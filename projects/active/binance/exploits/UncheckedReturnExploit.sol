// SPDX-License-Identifier: MIT
pragma solidity 0.8.17;

/**
 * â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
 * â•‘  ğŸŸª EXPLOIT: Unchecked Return Value - Fund Trapping                       â•‘
 * â•‘  ğŸŸª TARGET: BSC Genesis Contract - StakeHub.distributeReward()            â•‘
 * â•‘  ğŸŸª BOUNTY POTENTIAL: $10,000 - $50,000                                   â•‘
 * â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 *
 * VULNERABILITY EXPLANATION:
 * --------------------------
 * In StakeHub.sol line 656:
 *   SYSTEM_REWARD_ADDR.call{ value: msg.value }("");
 *
 * The return value is NOT checked. If this call fails:
 * - Funds remain trapped in StakeHub
 * - No error is thrown
 * - Event says "INVALID_VALIDATOR" but funds are lost
 *
 * This can happen if:
 * 1. SYSTEM_REWARD_ADDR is a contract that reverts
 * 2. SYSTEM_REWARD_ADDR runs out of gas
 * 3. SYSTEM_REWARD_ADDR has receive() that reverts under certain conditions
 *
 * WHY IT'S DANGEROUS:
 * - Staking rewards can be permanently lost
 * - Validators lose income
 * - Economic damage to network participants
 */

interface IStakeHub {
    function distributeReward(address consensusAddress) external payable;
}

interface ISystemReward {
    function claimRewards(address to, uint256 amount) external returns (uint256);
}

/**
 * @title UncheckedReturnAnalyzer
 * @dev Analyzes the unchecked return value vulnerability
 */
contract UncheckedReturnAnalyzer {
    address public constant STAKE_HUB = 0x0000000000000000000000000000000000002002;
    address public constant SYSTEM_REWARD_ADDR = 0x0000000000000000000000000000000000001002;

    event AnalysisResult(
        bool systemRewardAcceptsFunds,
        uint256 systemRewardBalance,
        uint256 stakeHubBalance,
        bool potentialFundTrap
    );

    event SimulationResult(
        bool callSucceeded,
        uint256 amountSent,
        uint256 systemRewardBalanceBefore,
        uint256 systemRewardBalanceAfter
    );

    /**
     * @dev Analyze current state and potential for fund trapping
     */
    function analyzeVulnerability() external view returns (
        uint256 systemRewardBalance,
        uint256 stakeHubBalance,
        string memory riskAssessment
    ) {
        systemRewardBalance = SYSTEM_REWARD_ADDR.balance;
        stakeHubBalance = STAKE_HUB.balance;

        // The risk is that distributeReward sends to SYSTEM_REWARD_ADDR
        // without checking success
        riskAssessment = "MEDIUM: If SYSTEM_REWARD receive() fails, funds are trapped in StakeHub. "
                        "This could happen during network congestion or if SYSTEM_REWARD "
                        "contract is upgraded to a version with failing receive().";
    }

    /**
     * @dev Simulate what happens when the call fails
     */
    function simulateFailure() external payable returns (string memory result) {
        // In practice, we can't make SYSTEM_REWARD_ADDR fail
        // But we can demonstrate the pattern

        // The vulnerable code pattern is:
        // SYSTEM_REWARD_ADDR.call{ value: msg.value }("");
        //
        // Should be:
        // (bool success,) = SYSTEM_REWARD_ADDR.call{ value: msg.value }("");
        // require(success, "Transfer failed");

        return "The vulnerability is that if the call fails, the function continues "
               "as if nothing happened. Funds stay in StakeHub but are not tracked. "
               "They become 'ghost funds' that no one can claim.";
    }

    /**
     * @dev Calculate potential fund loss from this vulnerability
     * @param blocksPerDay Average blocks per day
     * @param avgRewardPerBlock Average reward per block
     * @param failureRate Estimated failure rate (1 = 0.01%)
     */
    function calculatePotentialLoss(
        uint256 blocksPerDay,
        uint256 avgRewardPerBlock,
        uint256 failureRate
    ) external pure returns (
        uint256 dailyLoss,
        uint256 monthlyLoss,
        uint256 yearlyLoss
    ) {
        uint256 dailyRewards = blocksPerDay * avgRewardPerBlock;
        dailyLoss = (dailyRewards * failureRate) / 10000;
        monthlyLoss = dailyLoss * 30;
        yearlyLoss = dailyLoss * 365;
    }
}

/**
 * @title ReceiveFailer
 * @dev Contract that fails to receive funds under certain conditions
 * Used to demonstrate how the vulnerability could be exploited
 */
contract ReceiveFailer {
    bool public shouldFail;
    uint256 public receivedAmount;

    event ReceiveCalled(uint256 amount, bool failed);

    function setShouldFail(bool _shouldFail) external {
        shouldFail = _shouldFail;
    }

    receive() external payable {
        if (shouldFail) {
            emit ReceiveCalled(msg.value, true);
            revert("Intentional failure");
        }
        receivedAmount += msg.value;
        emit ReceiveCalled(msg.value, false);
    }
}

/**
 * @title VulnerablePattern
 * @dev Demonstrates the vulnerable vs safe pattern
 */
contract VulnerablePattern {
    event TransferAttempted(bool success, uint256 amount);

    /**
     * @dev VULNERABLE: This is how StakeHub currently does it
     */
    function vulnerableTransfer(address target) external payable {
        // This line doesn't check success - funds can be lost!
        target.call{ value: msg.value }("");
        // Execution continues even if the transfer failed
    }

    /**
     * @dev SAFE: This is how it should be done
     */
    function safeTransfer(address target) external payable {
        (bool success,) = target.call{ value: msg.value }("");
        require(success, "Transfer failed");
        emit TransferAttempted(success, msg.value);
    }

    /**
     * @dev SAFEST: Use low-level call with explicit handling
     */
    function safestTransfer(address target) external payable {
        (bool success, bytes memory data) = target.call{ value: msg.value }("");
        if (!success) {
            // Refund the sender
            (bool refundSuccess,) = msg.sender.call{ value: msg.value }("");
            require(refundSuccess, "Refund failed");
            emit TransferAttempted(false, msg.value);
        } else {
            emit TransferAttempted(true, msg.value);
        }
    }
}
