#!/usr/bin/env python3
"""
Credential Finder
Find credentials and secrets in files and responses.

USAGE:
    python cred_finder.py <target> [--type file|url|text]

EXAMPLES:
    python cred_finder.py ./config/ --type file
    python cred_finder.py https://example.com --type url
    python cred_finder.py "api_key=abc123" --type text
    python cred_finder.py ./src/ --recursive --output creds.json
"""

import sys
import os
import argparse
import re
import json
from pathlib import Path
sys.path.insert(0, '/home/l0ve/Desktop/WD/Tools')
from lib import success, error, warning, info, banner, HTTPClient

# Credential patterns
PATTERNS = {
    # API Keys
    'aws_access_key': r'AKIA[0-9A-Z]{16}',
    'aws_secret_key': r'[A-Za-z0-9/+=]{40}',
    'google_api_key': r'AIza[0-9A-Za-z\-_]{35}',
    'google_oauth': r'[0-9]+-[0-9A-Za-z_]{32}\.apps\.googleusercontent\.com',
    'github_token': r'(ghp_[a-zA-Z0-9]{36}|github_pat_[a-zA-Z0-9]{22}_[a-zA-Z0-9]{59})',
    'github_oauth': r'gho_[a-zA-Z0-9]{36}',
    'gitlab_token': r'glpat-[a-zA-Z0-9\-]{20}',
    'slack_token': r'xox[baprs]-[0-9]{10,12}-[0-9]{10,12}[a-zA-Z0-9-]*',
    'slack_webhook': r'https://hooks\.slack\.com/services/T[a-zA-Z0-9_]{8}/B[a-zA-Z0-9_]{8,12}/[a-zA-Z0-9_]{24}',
    'stripe_api_key': r'sk_live_[0-9a-zA-Z]{24}',
    'stripe_restricted': r'rk_live_[0-9a-zA-Z]{24}',
    'square_access_token': r'sq0atp-[0-9A-Za-z\-_]{22}',
    'square_oauth': r'sq0csp-[0-9A-Za-z\-_]{43}',
    'twilio_api_key': r'SK[0-9a-fA-F]{32}',
    'sendgrid_api_key': r'SG\.[a-zA-Z0-9_-]{22}\.[a-zA-Z0-9_-]{43}',
    'mailchimp_api_key': r'[0-9a-f]{32}-us[0-9]{1,2}',
    'mailgun_api_key': r'key-[0-9a-zA-Z]{32}',
    'heroku_api_key': r'[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}',
    'firebase_key': r'AAAA[A-Za-z0-9_-]{7}:[A-Za-z0-9_-]{140}',
    'azure_storage': r'DefaultEndpointsProtocol=https;AccountName=[^;]+;AccountKey=[A-Za-z0-9+/=]{88};',

    # Tokens & Secrets
    'jwt_token': r'eyJ[A-Za-z0-9_-]*\.eyJ[A-Za-z0-9_-]*\.[A-Za-z0-9_-]*',
    'bearer_token': r'[Bb]earer\s+[a-zA-Z0-9_\-\.=]+',
    'basic_auth': r'[Bb]asic\s+[a-zA-Z0-9+/=]+',
    'private_key': r'-----BEGIN (RSA |EC |DSA |OPENSSH )?PRIVATE KEY-----',
    'ssh_key': r'ssh-(rsa|dss|ed25519)\s+[A-Za-z0-9+/=]+',

    # Credentials
    'password_field': r'["\']?password["\']?\s*[:=]\s*["\'][^"\']{4,}["\']',
    'passwd_field': r'["\']?passwd["\']?\s*[:=]\s*["\'][^"\']{4,}["\']',
    'secret_field': r'["\']?secret["\']?\s*[:=]\s*["\'][^"\']{4,}["\']',
    'api_key_field': r'["\']?api_?key["\']?\s*[:=]\s*["\'][^"\']{8,}["\']',
    'token_field': r'["\']?token["\']?\s*[:=]\s*["\'][^"\']{8,}["\']',
    'auth_field': r'["\']?auth["\']?\s*[:=]\s*["\'][^"\']{4,}["\']',

    # Database
    'mysql_conn': r'mysql://[^:]+:[^@]+@[^/]+/[^\s]+',
    'postgres_conn': r'postgres(ql)?://[^:]+:[^@]+@[^/]+/[^\s]+',
    'mongodb_conn': r'mongodb(\+srv)?://[^:]+:[^@]+@[^/]+',
    'redis_conn': r'redis://:[^@]+@[^:]+:\d+',

    # URLs with credentials
    'url_creds': r'https?://[^:]+:[^@]+@[^\s]+',
    'ftp_creds': r'ftp://[^:]+:[^@]+@[^\s]+',

    # Cloud
    'aws_mws_auth_token': r'amzn\.mws\.[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}',
    'facebook_access_token': r'EAACEdEose0cBA[0-9A-Za-z]+',
    'twitter_oauth': r'[0-9a-zA-Z]{35,44}',

    # Generic patterns
    'generic_api_key': r'["\']?[Aa][Pp][Ii][-_]?[Kk][Ee][Yy]["\']?\s*[:=]\s*["\'][a-zA-Z0-9_\-]{16,}["\']',
    'generic_secret': r'["\']?[Ss][Ee][Cc][Rr][Ee][Tt]["\']?\s*[:=]\s*["\'][a-zA-Z0-9_\-]{8,}["\']',
    'hex_secret': r'["\']?(?:key|secret|token|password)["\']?\s*[:=]\s*["\'][0-9a-fA-F]{32,}["\']',
}

# Sensitive files to look for
SENSITIVE_FILES = [
    '.env', '.env.local', '.env.production', '.env.development',
    'config.json', 'config.yaml', 'config.yml', 'config.ini',
    'settings.json', 'settings.py', 'settings.yaml',
    'credentials.json', 'credentials.xml',
    'secrets.json', 'secrets.yaml',
    '.git/config', '.gitconfig',
    '.npmrc', '.pypirc',
    'docker-compose.yml', 'docker-compose.yaml',
    'Dockerfile',
    'id_rsa', 'id_dsa', 'id_ed25519',
    '.htpasswd', '.htaccess',
    'wp-config.php',
    'database.yml', 'database.json',
    'appsettings.json', 'web.config',
]


class CredentialFinder:
    def __init__(self):
        self.findings = []
        self.client = HTTPClient()

    def scan_text(self, text: str, source: str = 'text') -> list:
        """Scan text for credentials."""
        findings = []

        for pattern_name, pattern in PATTERNS.items():
            matches = re.finditer(pattern, text, re.IGNORECASE | re.MULTILINE)
            for match in matches:
                finding = {
                    'type': pattern_name,
                    'value': match.group()[:100] + '...' if len(match.group()) > 100 else match.group(),
                    'source': source,
                    'position': match.start(),
                }

                # Avoid duplicates
                if not any(f['value'] == finding['value'] for f in findings):
                    findings.append(finding)

        return findings

    def scan_file(self, filepath: str) -> list:
        """Scan a file for credentials."""
        findings = []

        try:
            with open(filepath, 'r', errors='ignore') as f:
                content = f.read()
                findings = self.scan_text(content, filepath)

                # Add line numbers
                lines = content.split('\n')
                for finding in findings:
                    pos = finding['position']
                    line_num = content[:pos].count('\n') + 1
                    finding['line'] = line_num

        except Exception as e:
            warning(f"Could not read {filepath}: {e}")

        return findings

    def scan_directory(self, directory: str, recursive: bool = True,
                       extensions: list = None) -> list:
        """Scan directory for credentials."""
        all_findings = []

        default_extensions = ['.py', '.js', '.json', '.yaml', '.yml', '.xml',
                              '.env', '.ini', '.conf', '.config', '.php',
                              '.java', '.rb', '.go', '.sh', '.bash', '.txt',
                              '.sql', '.md', '.html', '.htm']

        if extensions is None:
            extensions = default_extensions

        path = Path(directory)

        if recursive:
            files = path.rglob('*')
        else:
            files = path.glob('*')

        for file in files:
            if file.is_file():
                # Check extension or sensitive filename
                if file.suffix.lower() in extensions or file.name in SENSITIVE_FILES:
                    findings = self.scan_file(str(file))
                    all_findings.extend(findings)

        return all_findings

    def scan_url(self, url: str) -> list:
        """Scan URL response for credentials."""
        try:
            resp = self.client.get(url)
            return self.scan_text(resp.text, url)
        except Exception as e:
            error(f"Could not fetch {url}: {e}")
            return []

    def check_sensitive_files(self, base_url: str) -> list:
        """Check for exposed sensitive files on web server."""
        findings = []

        for filename in SENSITIVE_FILES[:15]:  # Top sensitive files
            url = f"{base_url.rstrip('/')}/{filename}"
            try:
                resp = self.client.get(url)
                if resp.status_code == 200:
                    findings.append({
                        'type': 'exposed_file',
                        'filename': filename,
                        'url': url,
                        'size': len(resp.text),
                    })
                    warning(f"Exposed file: {url}")

                    # Scan content for credentials
                    creds = self.scan_text(resp.text, url)
                    findings.extend(creds)
            except:
                pass

        return findings


def main():
    parser = argparse.ArgumentParser(
        description='Credential Finder',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
EXAMPLES:
    %(prog)s ./config/ --type file
    %(prog)s https://example.com --type url
    %(prog)s "api_key=abc123" --type text
    %(prog)s ./src/ --recursive --output creds.json
    %(prog)s https://example.com --check-files
        """
    )
    parser.add_argument('target', help='Target (file, directory, URL, or text)')
    parser.add_argument('-t', '--type', choices=['file', 'dir', 'url', 'text', 'auto'], default='auto', help='Target type')
    parser.add_argument('-r', '--recursive', action='store_true', help='Recursive directory scan')
    parser.add_argument('--check-files', action='store_true', help='Check for exposed sensitive files')
    parser.add_argument('-o', '--output', help='Output file (JSON)')
    parser.add_argument('--list-patterns', action='store_true', help='List detection patterns')
    args = parser.parse_args()

    banner("Credential Finder")

    finder = CredentialFinder()

    if args.list_patterns:
        info("Detection patterns:")
        for name in sorted(PATTERNS.keys()):
            print(f"  - {name}")
        sys.exit(0)

    # Auto-detect target type
    if args.type == 'auto':
        if args.target.startswith(('http://', 'https://')):
            args.type = 'url'
        elif os.path.isdir(args.target):
            args.type = 'dir'
        elif os.path.isfile(args.target):
            args.type = 'file'
        else:
            args.type = 'text'

    info(f"Target: {args.target}")
    info(f"Type: {args.type}")

    findings = []

    if args.type == 'url':
        findings = finder.scan_url(args.target)

        if args.check_files:
            findings.extend(finder.check_sensitive_files(args.target))

    elif args.type == 'dir':
        findings = finder.scan_directory(args.target, recursive=args.recursive)

    elif args.type == 'file':
        findings = finder.scan_file(args.target)

    elif args.type == 'text':
        findings = finder.scan_text(args.target)

    # Display results
    if findings:
        print(f"\n[Found {len(findings)} potential credential(s)]")

        # Group by type
        by_type = {}
        for f in findings:
            t = f['type']
            if t not in by_type:
                by_type[t] = []
            by_type[t].append(f)

        for cred_type, items in sorted(by_type.items()):
            print(f"\n[{cred_type}]")
            for item in items[:10]:
                source = item.get('source', '')
                line = f":{item['line']}" if 'line' in item else ''
                print(f"  {source}{line}")
                print(f"    {item['value']}")

            if len(items) > 10:
                print(f"  ... and {len(items) - 10} more")

        success(f"\nTotal findings: {len(findings)}")
    else:
        warning("No credentials found")

    if args.output:
        with open(args.output, 'w') as f:
            json.dump({'target': args.target, 'findings': findings}, f, indent=2)
        success(f"Results saved to {args.output}")


if __name__ == '__main__':
    main()
