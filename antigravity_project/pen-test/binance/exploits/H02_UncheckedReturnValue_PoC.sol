// SPDX-License-Identifier: MIT
pragma solidity 0.8.17;

/**
 * ============================================================================
 *  CRITICAL VULNERABILITY: Unchecked Return Value in StakeHub.distributeReward()
 * ============================================================================
 *
 * Target: BSC Genesis Contract - StakeHub.sol:656
 * Severity: HIGH (Permanent Loss of Funds)
 * Bounty Potential: $50,000 - $100,000
 *
 * VULNERABILITY SUMMARY:
 * ----------------------
 * The distributeReward() function in StakeHub.sol does not check the return
 * value of an external .call() when sending funds to SYSTEM_REWARD_ADDR.
 * If this call fails, the BNB remains permanently trapped in StakeHub with
 * no recovery mechanism.
 *
 * VULNERABLE CODE (StakeHub.sol:650-665):
 *
 *     function distributeReward(address consensusAddress) external payable onlyValidatorContract {
 *         address operatorAddress = consensusToOperator[consensusAddress];
 *         Validator memory valInfo = _validators[operatorAddress];
 *         if (valInfo.creditContract == address(0) || valInfo.jailed) {
 *             SYSTEM_REWARD_ADDR.call{ value: msg.value }("");  // <-- NO RETURN CHECK!
 *             emit RewardDistributeFailed(operatorAddress, "INVALID_VALIDATOR");
 *             return;
 *         }
 *         // ... rest of function
 *     }
 *
 * ATTACK SCENARIOS:
 * -----------------
 * 1. Validator Migration Failure:
 *    - A validator fails to migrate properly, creditContract = address(0)
 *    - Rewards accumulate in BSCValidatorSet
 *    - distributeReward() attempts to forward to SYSTEM_REWARD_ADDR
 *    - If call fails, funds are lost forever
 *
 * 2. SystemReward Upgrade Risk:
 *    - Governance upgrades SystemReward contract
 *    - New implementation's receive() reverts under certain conditions
 *    - All rewards for invalid/jailed validators are permanently lost
 *
 * 3. Gas Manipulation:
 *    - Complex receive() function in future SystemReward upgrade
 *    - Out of gas during the call
 *    - Funds trapped with silent failure
 */

import "forge-std/Test.sol";

// Mock interfaces
interface IStakeHub {
    function distributeReward(address consensusAddress) external payable;
}

/**
 * @title MaliciousSystemReward
 * @dev Simulates a SystemReward contract that rejects transfers
 *      This demonstrates what happens if SystemReward is upgraded
 *      to a version that reverts on receive()
 */
contract MaliciousSystemReward {
    bool public shouldReject;

    constructor() {
        shouldReject = false;
    }

    function setReject(bool _reject) external {
        shouldReject = _reject;
    }

    // This receive function rejects transfers when shouldReject is true
    receive() external payable {
        if (shouldReject) {
            revert("Transfer rejected");
        }
    }
}

/**
 * @title VulnerableStakeHub
 * @dev Simplified version of StakeHub to demonstrate the vulnerability
 */
contract VulnerableStakeHub {
    address public SYSTEM_REWARD_ADDR;

    mapping(address => address) public consensusToOperator;
    mapping(address => bool) public isJailed;
    mapping(address => address) public creditContract;

    event RewardDistributeFailed(address indexed validator, string reason);
    event RewardDistributed(address indexed validator, uint256 amount);
    event FundsTrapped(uint256 amount);

    constructor(address _systemReward) {
        SYSTEM_REWARD_ADDR = _systemReward;
    }

    function setValidator(
        address consensus,
        address operator,
        address credit,
        bool jailed
    ) external {
        consensusToOperator[consensus] = operator;
        creditContract[operator] = credit;
        isJailed[operator] = jailed;
    }

    /**
     * @dev VULNERABLE FUNCTION - mirrors StakeHub.sol:650-665
     *      Note: No return value check on the .call()!
     */
    function distributeReward(address consensusAddress) external payable {
        address operatorAddress = consensusToOperator[consensusAddress];
        address credit = creditContract[operatorAddress];
        bool jailed = isJailed[operatorAddress];

        if (credit == address(0) || jailed) {
            // BUG: Return value not checked!
            // If this fails, msg.value is trapped in this contract forever
            SYSTEM_REWARD_ADDR.call{ value: msg.value }("");
            emit RewardDistributeFailed(operatorAddress, "INVALID_VALIDATOR");
            return;
        }

        // Normal distribution path (simplified)
        emit RewardDistributed(operatorAddress, msg.value);
    }

    /**
     * @dev FIXED VERSION - How it should be implemented
     */
    function distributeRewardFixed(address consensusAddress) external payable {
        address operatorAddress = consensusToOperator[consensusAddress];
        address credit = creditContract[operatorAddress];
        bool jailed = isJailed[operatorAddress];

        if (credit == address(0) || jailed) {
            // FIXED: Check return value!
            (bool success,) = SYSTEM_REWARD_ADDR.call{ value: msg.value }("");
            if (!success) {
                // Option 1: Revert (safest)
                revert("Transfer to SYSTEM_REWARD failed");

                // Option 2: Store for later recovery (if must not revert)
                // trappedFunds[operatorAddress] += msg.value;
            }
            emit RewardDistributeFailed(operatorAddress, "INVALID_VALIDATOR");
            return;
        }

        emit RewardDistributed(operatorAddress, msg.value);
    }

    // View function to check trapped funds
    function getTrappedFunds() external view returns (uint256) {
        return address(this).balance;
    }
}

/**
 * @title H02_UncheckedReturnValue_Test
 * @dev Foundry test demonstrating the vulnerability
 */
contract H02_UncheckedReturnValue_Test is Test {
    VulnerableStakeHub public stakeHub;
    MaliciousSystemReward public systemReward;

    address constant VALIDATOR_CONSENSUS = address(0x1);
    address constant VALIDATOR_OPERATOR = address(0x2);

    function setUp() public {
        // Deploy malicious SystemReward
        systemReward = new MaliciousSystemReward();

        // Deploy vulnerable StakeHub
        stakeHub = new VulnerableStakeHub(address(systemReward));

        // Setup a jailed validator (triggers the vulnerable code path)
        stakeHub.setValidator(
            VALIDATOR_CONSENSUS,
            VALIDATOR_OPERATOR,
            address(0),  // No credit contract
            true         // Jailed
        );
    }

    /**
     * @dev Test 1: Normal operation - funds reach SystemReward
     */
    function test_NormalOperation() public {
        uint256 rewardAmount = 1 ether;

        // SystemReward accepts transfers
        systemReward.setReject(false);

        uint256 systemRewardBalanceBefore = address(systemReward).balance;

        // Distribute reward
        stakeHub.distributeReward{value: rewardAmount}(VALIDATOR_CONSENSUS);

        // Verify funds reached SystemReward
        assertEq(
            address(systemReward).balance,
            systemRewardBalanceBefore + rewardAmount,
            "Funds should reach SystemReward"
        );
        assertEq(stakeHub.getTrappedFunds(), 0, "No funds should be trapped");
    }

    /**
     * @dev Test 2: EXPLOIT - SystemReward rejects, funds are trapped
     */
    function test_FundsTrapped_WhenSystemRewardRejects() public {
        uint256 rewardAmount = 1 ether;

        // SystemReward starts rejecting transfers (simulates upgrade)
        systemReward.setReject(true);

        uint256 stakeHubBalanceBefore = address(stakeHub).balance;

        // This should NOT revert (that's the bug!)
        // The function completes "successfully" but funds are trapped
        stakeHub.distributeReward{value: rewardAmount}(VALIDATOR_CONSENSUS);

        // CRITICAL: Funds are now trapped in StakeHub!
        assertEq(
            stakeHub.getTrappedFunds(),
            stakeHubBalanceBefore + rewardAmount,
            "VULNERABILITY: Funds trapped in StakeHub!"
        );

        // SystemReward received nothing
        assertEq(
            address(systemReward).balance,
            0,
            "SystemReward should have received nothing"
        );

        // Log the vulnerability
        emit log_string("====================================");
        emit log_string("VULNERABILITY CONFIRMED!");
        emit log_string("====================================");
        emit log_named_uint("Trapped funds (BNB)", stakeHub.getTrappedFunds());
        emit log_string("These funds are PERMANENTLY LOST");
        emit log_string("No recovery mechanism exists");
    }

    /**
     * @dev Test 3: Multiple failed distributions compound the loss
     */
    function test_CompoundedLoss_MultipleFails() public {
        systemReward.setReject(true);

        // Simulate multiple epochs of failed distributions
        for (uint256 i = 0; i < 10; i++) {
            stakeHub.distributeReward{value: 1 ether}(VALIDATOR_CONSENSUS);
        }

        // 10 ETH now permanently trapped
        assertEq(stakeHub.getTrappedFunds(), 10 ether);

        emit log_string("After 10 failed distributions:");
        emit log_named_uint("Total trapped (BNB)", stakeHub.getTrappedFunds());
    }
}

/**
 * REMEDIATION:
 * ============
 *
 * Option 1 - Require Success (Safest, but may break consensus):
 *
 *     (bool success,) = SYSTEM_REWARD_ADDR.call{ value: msg.value }("");
 *     require(success, "Transfer to SYSTEM_REWARD failed");
 *
 * Option 2 - Recovery Mechanism (Best for "should never revert" requirement):
 *
 *     (bool success,) = SYSTEM_REWARD_ADDR.call{ value: msg.value }("");
 *     if (!success) {
 *         unclaimedRewards[operatorAddress] += msg.value;
 *         emit RewardStoredForRecovery(operatorAddress, msg.value);
 *     }
 *
 *     function recoverTrappedRewards(address operator) external onlyGov {
 *         uint256 amount = unclaimedRewards[operator];
 *         unclaimedRewards[operator] = 0;
 *         (bool success,) = SYSTEM_REWARD_ADDR.call{ value: amount }("");
 *         require(success, "Recovery failed");
 *     }
 *
 * Option 3 - Fallback Storage (Simple):
 *
 *     (bool success,) = SYSTEM_REWARD_ADDR.call{ value: msg.value }("");
 *     if (!success) {
 *         // Store in contract for manual recovery by governance
 *         trappedBalance += msg.value;
 *         emit FundsTrapped(msg.value);
 *     }
 */
