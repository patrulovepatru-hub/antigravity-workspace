#!/usr/bin/env python3
"""
Payload Encoder
Encode payloads to bypass filters and WAF.

USAGE:
    python encoder.py <payload> [--encode type] [--iterations N]

EXAMPLES:
    python encoder.py "<script>alert(1)</script>" --encode url
    python encoder.py "' OR 1=1--" --encode double-url
    python encoder.py "cat /etc/passwd" --encode base64
    python encoder.py "<img src=x onerror=alert(1)>" --encode html --iterations 2
"""

import sys
import argparse
import base64
import html
import codecs
from urllib.parse import quote, quote_plus, unquote
sys.path.insert(0, '/home/l0ve/Desktop/WD/Tools')
from lib import success, error, warning, info, banner


class PayloadEncoder:
    def __init__(self):
        self.encoders = {
            'url': self.url_encode,
            'double-url': self.double_url_encode,
            'url-full': self.url_encode_full,
            'base64': self.base64_encode,
            'html': self.html_encode,
            'html-decimal': self.html_decimal_encode,
            'html-hex': self.html_hex_encode,
            'hex': self.hex_encode,
            'unicode': self.unicode_encode,
            'unicode-full': self.unicode_full_encode,
            'octal': self.octal_encode,
            'binary': self.binary_encode,
            'rot13': self.rot13_encode,
            'reverse': self.reverse,
            'uppercase': self.uppercase,
            'lowercase': self.lowercase,
            'mixed-case': self.mixed_case,
            'js-unicode': self.js_unicode_encode,
            'js-hex': self.js_hex_encode,
            'js-octal': self.js_octal_encode,
            'css-hex': self.css_hex_encode,
            'sql-char': self.sql_char_encode,
            'sql-hex': self.sql_hex_encode,
        }

        self.decoders = {
            'url': self.url_decode,
            'base64': self.base64_decode,
            'html': self.html_decode,
            'hex': self.hex_decode,
            'rot13': self.rot13_encode,  # ROT13 is symmetric
            'reverse': self.reverse,
        }

    # URL Encoding
    def url_encode(self, payload: str) -> str:
        return quote(payload, safe='')

    def double_url_encode(self, payload: str) -> str:
        return quote(quote(payload, safe=''), safe='')

    def url_encode_full(self, payload: str) -> str:
        return ''.join([f'%{ord(c):02X}' for c in payload])

    def url_decode(self, payload: str) -> str:
        return unquote(payload)

    # Base64
    def base64_encode(self, payload: str) -> str:
        return base64.b64encode(payload.encode()).decode()

    def base64_decode(self, payload: str) -> str:
        return base64.b64decode(payload).decode()

    # HTML Encoding
    def html_encode(self, payload: str) -> str:
        return html.escape(payload)

    def html_decimal_encode(self, payload: str) -> str:
        return ''.join([f'&#{ord(c)};' for c in payload])

    def html_hex_encode(self, payload: str) -> str:
        return ''.join([f'&#x{ord(c):x};' for c in payload])

    def html_decode(self, payload: str) -> str:
        return html.unescape(payload)

    # Hex Encoding
    def hex_encode(self, payload: str) -> str:
        return payload.encode().hex()

    def hex_decode(self, payload: str) -> str:
        return bytes.fromhex(payload).decode()

    # Unicode Encoding
    def unicode_encode(self, payload: str) -> str:
        result = ''
        for c in payload:
            if ord(c) > 127:
                result += f'\\u{ord(c):04x}'
            else:
                result += c
        return result

    def unicode_full_encode(self, payload: str) -> str:
        return ''.join([f'\\u{ord(c):04x}' for c in payload])

    # Octal Encoding
    def octal_encode(self, payload: str) -> str:
        return ''.join([f'\\{ord(c):03o}' for c in payload])

    # Binary Encoding
    def binary_encode(self, payload: str) -> str:
        return ' '.join([f'{ord(c):08b}' for c in payload])

    # ROT13
    def rot13_encode(self, payload: str) -> str:
        return codecs.encode(payload, 'rot_13')

    # Case Manipulation
    def reverse(self, payload: str) -> str:
        return payload[::-1]

    def uppercase(self, payload: str) -> str:
        return payload.upper()

    def lowercase(self, payload: str) -> str:
        return payload.lower()

    def mixed_case(self, payload: str) -> str:
        return ''.join([c.upper() if i % 2 == 0 else c.lower() for i, c in enumerate(payload)])

    # JavaScript Encoding
    def js_unicode_encode(self, payload: str) -> str:
        return ''.join([f'\\u{ord(c):04x}' for c in payload])

    def js_hex_encode(self, payload: str) -> str:
        return ''.join([f'\\x{ord(c):02x}' for c in payload])

    def js_octal_encode(self, payload: str) -> str:
        return ''.join([f'\\{ord(c):03o}' for c in payload])

    # CSS Encoding
    def css_hex_encode(self, payload: str) -> str:
        return ''.join([f'\\{ord(c):x} ' for c in payload])

    # SQL Encoding
    def sql_char_encode(self, payload: str) -> str:
        chars = ','.join([str(ord(c)) for c in payload])
        return f'CHAR({chars})'

    def sql_hex_encode(self, payload: str) -> str:
        return '0x' + payload.encode().hex()

    def encode(self, payload: str, encoding: str, iterations: int = 1) -> str:
        """Encode payload with specified encoding."""
        if encoding not in self.encoders:
            return payload

        result = payload
        for _ in range(iterations):
            result = self.encoders[encoding](result)
        return result

    def decode(self, payload: str, encoding: str) -> str:
        """Decode payload."""
        if encoding not in self.decoders:
            return payload
        return self.decoders[encoding](payload)

    def multi_encode(self, payload: str, encodings: list) -> str:
        """Apply multiple encodings in sequence."""
        result = payload
        for enc in encodings:
            if enc in self.encoders:
                result = self.encoders[enc](result)
        return result


def main():
    parser = argparse.ArgumentParser(
        description='Payload Encoder',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
ENCODINGS:
    url, double-url, url-full      - URL encoding variants
    base64                         - Base64 encoding
    html, html-decimal, html-hex   - HTML entity encoding
    hex                            - Hexadecimal encoding
    unicode, unicode-full          - Unicode encoding
    js-unicode, js-hex, js-octal   - JavaScript encoding
    css-hex                        - CSS hex encoding
    sql-char, sql-hex              - SQL encoding
    rot13                          - ROT13 cipher
    reverse, uppercase, lowercase  - String manipulation
    mixed-case                     - Alternating case

EXAMPLES:
    %(prog)s "<script>alert(1)</script>" --encode url
    %(prog)s "' OR 1=1--" --encode double-url
    %(prog)s "cat /etc/passwd" --encode base64
    %(prog)s "<img src=x>" --encode html-hex --iterations 2
    %(prog)s "alert(1)" --multi url,base64
        """
    )
    parser.add_argument('payload', help='Payload to encode')
    parser.add_argument('-e', '--encode', help='Encoding type')
    parser.add_argument('-d', '--decode', help='Decoding type')
    parser.add_argument('-i', '--iterations', type=int, default=1, help='Number of iterations (default: 1)')
    parser.add_argument('-m', '--multi', help='Multiple encodings (comma-separated)')
    parser.add_argument('--list', action='store_true', help='List available encodings')
    parser.add_argument('--all', action='store_true', help='Show all encodings')
    args = parser.parse_args()

    banner("Payload Encoder")

    encoder = PayloadEncoder()

    if args.list:
        info("Available encodings:")
        for enc in sorted(encoder.encoders.keys()):
            print(f"  - {enc}")
        sys.exit(0)

    if args.all:
        info(f"Original: {args.payload}\n")
        for enc in sorted(encoder.encoders.keys()):
            try:
                result = encoder.encode(args.payload, enc)
                print(f"[{enc}]")
                print(f"  {result}\n")
            except:
                pass
        sys.exit(0)

    if args.decode:
        result = encoder.decode(args.payload, args.decode)
        info(f"Decoded ({args.decode}):")
        print(result)

    elif args.multi:
        encodings = [e.strip() for e in args.multi.split(',')]
        result = encoder.multi_encode(args.payload, encodings)
        info(f"Multi-encoded ({' -> '.join(encodings)}):")
        print(result)

    elif args.encode:
        result = encoder.encode(args.payload, args.encode, args.iterations)
        info(f"Encoded ({args.encode} x{args.iterations}):")
        print(result)

    else:
        # Show common encodings
        common = ['url', 'double-url', 'base64', 'html-hex', 'js-unicode', 'hex']
        info(f"Original: {args.payload}\n")
        for enc in common:
            result = encoder.encode(args.payload, enc)
            print(f"[{enc}] {result}")


if __name__ == '__main__':
    main()
